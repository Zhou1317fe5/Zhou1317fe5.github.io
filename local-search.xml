<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>工业蒸汽预测-03特征工程</title>
    <link href="/2023/07/31/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-03%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    <url>/2023/07/31/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-03%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="导入数据分析工具包">1导入数据分析工具包</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)<br> <br>%matplotlib inline<br></code></pre></td></tr></table></figure><h1 id="数据读取">2数据读取</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data_file = <span class="hljs-string">&quot;./data/zhengqi_train.txt&quot;</span><br>test_data_file =  <span class="hljs-string">&quot;./data/zhengqi_test.txt&quot;</span><br><br>train_data = pd.read_csv(train_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>test_data = pd.read_csv(test_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="训练数据总览">3训练数据总览</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>...</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td></tr><tr><th>mean</th><td>0.123048</td><td>0.056068</td><td>0.289720</td><td>-0.067790</td><td>0.012921</td><td>-0.558565</td><td>0.182892</td><td>0.116155</td><td>0.177856</td><td>-0.169452</td><td>...</td><td>0.097648</td><td>0.055477</td><td>0.127791</td><td>0.020806</td><td>0.007801</td><td>0.006715</td><td>0.197764</td><td>0.030658</td><td>-0.130330</td><td>0.126353</td></tr><tr><th>std</th><td>0.928031</td><td>0.941515</td><td>0.911236</td><td>0.970298</td><td>0.888377</td><td>0.517957</td><td>0.918054</td><td>0.955116</td><td>0.895444</td><td>0.953813</td><td>...</td><td>1.061200</td><td>0.901934</td><td>0.873028</td><td>0.902584</td><td>1.006995</td><td>1.003291</td><td>0.985675</td><td>0.970812</td><td>1.017196</td><td>0.983966</td></tr><tr><th>min</th><td>-4.335000</td><td>-5.122000</td><td>-3.420000</td><td>-3.956000</td><td>-4.742000</td><td>-2.182000</td><td>-4.576000</td><td>-5.048000</td><td>-4.692000</td><td>-12.891000</td><td>...</td><td>-2.912000</td><td>-4.507000</td><td>-5.859000</td><td>-4.053000</td><td>-4.627000</td><td>-4.789000</td><td>-5.695000</td><td>-2.608000</td><td>-3.630000</td><td>-3.044000</td></tr><tr><th>25%</th><td>-0.297000</td><td>-0.226250</td><td>-0.313000</td><td>-0.652250</td><td>-0.385000</td><td>-0.853000</td><td>-0.310000</td><td>-0.295000</td><td>-0.159000</td><td>-0.390000</td><td>...</td><td>-0.664000</td><td>-0.283000</td><td>-0.170250</td><td>-0.407250</td><td>-0.499000</td><td>-0.290000</td><td>-0.202500</td><td>-0.413000</td><td>-0.798250</td><td>-0.350250</td></tr><tr><th>50%</th><td>0.359000</td><td>0.272500</td><td>0.386000</td><td>-0.044500</td><td>0.110000</td><td>-0.466000</td><td>0.388000</td><td>0.344000</td><td>0.362000</td><td>0.042000</td><td>...</td><td>-0.023000</td><td>0.053500</td><td>0.299500</td><td>0.039000</td><td>-0.040000</td><td>0.160000</td><td>0.364000</td><td>0.137000</td><td>-0.185500</td><td>0.313000</td></tr><tr><th>75%</th><td>0.726000</td><td>0.599000</td><td>0.918250</td><td>0.624000</td><td>0.550250</td><td>-0.154000</td><td>0.831250</td><td>0.782250</td><td>0.726000</td><td>0.042000</td><td>...</td><td>0.745250</td><td>0.488000</td><td>0.635000</td><td>0.557000</td><td>0.462000</td><td>0.273000</td><td>0.602000</td><td>0.644250</td><td>0.495250</td><td>0.793250</td></tr><tr><th>max</th><td>2.121000</td><td>1.918000</td><td>2.828000</td><td>2.457000</td><td>2.689000</td><td>0.489000</td><td>1.895000</td><td>1.918000</td><td>2.245000</td><td>1.335000</td><td>...</td><td>4.580000</td><td>2.689000</td><td>2.013000</td><td>2.395000</td><td>5.465000</td><td>5.110000</td><td>2.324000</td><td>5.238000</td><td>3.000000</td><td>2.538000</td></tr></tbody></table><p>8 rows × 39 columns</p></div><h1 id="特征工程">4特征工程</h1><h2 id="异常值分析箱型图">4.1异常值分析（箱型图）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">18</span>, <span class="hljs-number">10</span>))<br>plt.boxplot(x=train_data.values,labels=train_data.columns)<br>plt.hlines([-<span class="hljs-number">7.5</span>, <span class="hljs-number">7.5</span>], <span class="hljs-number">0</span>, <span class="hljs-number">40</span>, colors=<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-comment"># 0,40：水平线起始结束位置</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/img/工业蒸汽预测-03特征工程/output_8_0.png" /></p><p>从箱线图可以看出，有些特征存在明显的异常值、如V9变量。接下来分别把训练集和测试集中的异常值删除。</p><h4 id="代码详解">代码详解：</h4><ol type="1"><li><p><code>plt.boxplot(x=train_data.values,labels=train_data.columns)</code>：使用<code>boxplot</code>函数绘制箱线图。其中，<code>train_data.values</code>是要绘制箱线图的数据，<code>labels=train_data.columns</code>表示箱线图中每个箱子对应的标签是<code>train_data</code>数据集的列名。</p></li><li><p><code>plt.hlines([-7.5, 7.5], 0, 40, colors='r')</code>：使用<code>hlines</code>函数绘制水平线。<code>[-7.5, 7.5]</code>表示要绘制的水平线的位置，0和40分别表示水平线的起始和结束位置，<code>colors='r'</code>表示线条颜色为红色。</p></li></ol><p>该段代码使用matplotlib库绘制了一个箱线图，展示了<code>train_data</code>数据集中各个特征列的分布情况，并在图中添加了两条水平线（-7.5和7.5），用于标记异常值的阈值。</p><h3 id="删除异常值">4.1.1删除异常值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data = train_data[train_data[<span class="hljs-string">&#x27;V9&#x27;</span>]&gt;-<span class="hljs-number">7.5</span>] <span class="hljs-comment"># 保留大于-7.5的值</span><br>test_data = test_data[test_data[<span class="hljs-string">&#x27;V9&#x27;</span>]&gt;-<span class="hljs-number">7.5</span>]<br><br>display(train_data.describe())<br>display(test_data.describe())<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.00000</td><td>...</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td></tr><tr><th>mean</th><td>0.123725</td><td>0.056856</td><td>0.290340</td><td>-0.068364</td><td>0.012254</td><td>-0.558971</td><td>0.183273</td><td>0.116274</td><td>0.178138</td><td>-0.16213</td><td>...</td><td>0.097019</td><td>0.058619</td><td>0.127617</td><td>0.023626</td><td>0.008271</td><td>0.006959</td><td>0.198513</td><td>0.030099</td><td>-0.131957</td><td>0.127451</td></tr><tr><th>std</th><td>0.927984</td><td>0.941269</td><td>0.911231</td><td>0.970357</td><td>0.888037</td><td>0.517871</td><td>0.918211</td><td>0.955418</td><td>0.895552</td><td>0.91089</td><td>...</td><td>1.060824</td><td>0.894311</td><td>0.873300</td><td>0.896509</td><td>1.007175</td><td>1.003411</td><td>0.985058</td><td>0.970258</td><td>1.015666</td><td>0.983144</td></tr><tr><th>min</th><td>-4.335000</td><td>-5.122000</td><td>-3.420000</td><td>-3.956000</td><td>-4.742000</td><td>-2.182000</td><td>-4.576000</td><td>-5.048000</td><td>-4.692000</td><td>-7.07100</td><td>...</td><td>-2.912000</td><td>-4.507000</td><td>-5.859000</td><td>-4.053000</td><td>-4.627000</td><td>-4.789000</td><td>-5.695000</td><td>-2.608000</td><td>-3.630000</td><td>-3.044000</td></tr><tr><th>25%</th><td>-0.292000</td><td>-0.224250</td><td>-0.310000</td><td>-0.652750</td><td>-0.385000</td><td>-0.853000</td><td>-0.310000</td><td>-0.295000</td><td>-0.158750</td><td>-0.39000</td><td>...</td><td>-0.664000</td><td>-0.282000</td><td>-0.170750</td><td>-0.405000</td><td>-0.499000</td><td>-0.290000</td><td>-0.199750</td><td>-0.412750</td><td>-0.798750</td><td>-0.347500</td></tr><tr><th>50%</th><td>0.359500</td><td>0.273000</td><td>0.386000</td><td>-0.045000</td><td>0.109500</td><td>-0.466000</td><td>0.388500</td><td>0.345000</td><td>0.362000</td><td>0.04200</td><td>...</td><td>-0.023000</td><td>0.054500</td><td>0.299500</td><td>0.040000</td><td>-0.040000</td><td>0.160000</td><td>0.364000</td><td>0.137000</td><td>-0.186000</td><td>0.314000</td></tr><tr><th>75%</th><td>0.726000</td><td>0.599000</td><td>0.918750</td><td>0.623500</td><td>0.550000</td><td>-0.154000</td><td>0.831750</td><td>0.782750</td><td>0.726000</td><td>0.04200</td><td>...</td><td>0.745000</td><td>0.488000</td><td>0.635000</td><td>0.557000</td><td>0.462000</td><td>0.273000</td><td>0.602000</td><td>0.643750</td><td>0.493000</td><td>0.793750</td></tr><tr><th>max</th><td>2.121000</td><td>1.918000</td><td>2.828000</td><td>2.457000</td><td>2.689000</td><td>0.489000</td><td>1.895000</td><td>1.918000</td><td>2.245000</td><td>1.33500</td><td>...</td><td>4.580000</td><td>2.689000</td><td>2.013000</td><td>2.395000</td><td>5.465000</td><td>5.110000</td><td>2.324000</td><td>5.238000</td><td>3.000000</td><td>2.538000</td></tr></tbody></table><p>8 rows × 39 columns</p></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V28</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th></tr></thead><tbody><tr><th>count</th><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>...</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td></tr><tr><th>mean</th><td>-0.184404</td><td>-0.083912</td><td>-0.434762</td><td>0.101671</td><td>-0.019172</td><td>0.838049</td><td>-0.274092</td><td>-0.173971</td><td>-0.266709</td><td>0.255114</td><td>...</td><td>-0.206871</td><td>-0.146463</td><td>-0.083215</td><td>-0.191729</td><td>-0.030782</td><td>-0.011433</td><td>-0.009985</td><td>-0.296895</td><td>-0.046270</td><td>0.195735</td></tr><tr><th>std</th><td>1.073333</td><td>1.076670</td><td>0.969541</td><td>1.034925</td><td>1.147286</td><td>0.963043</td><td>1.054119</td><td>1.040101</td><td>1.085916</td><td>1.014394</td><td>...</td><td>1.064140</td><td>0.880593</td><td>1.126414</td><td>1.138454</td><td>1.130228</td><td>0.989732</td><td>0.995213</td><td>0.946896</td><td>1.040854</td><td>0.940599</td></tr><tr><th>min</th><td>-4.814000</td><td>-5.488000</td><td>-4.283000</td><td>-3.276000</td><td>-4.921000</td><td>-1.168000</td><td>-5.649000</td><td>-5.625000</td><td>-6.059000</td><td>-6.784000</td><td>...</td><td>-2.435000</td><td>-2.413000</td><td>-4.507000</td><td>-7.698000</td><td>-4.057000</td><td>-4.627000</td><td>-4.789000</td><td>-7.477000</td><td>-2.608000</td><td>-3.346000</td></tr><tr><th>25%</th><td>-0.664000</td><td>-0.451000</td><td>-0.978000</td><td>-0.644000</td><td>-0.497000</td><td>0.122000</td><td>-0.732000</td><td>-0.509000</td><td>-0.775000</td><td>-0.390000</td><td>...</td><td>-0.453000</td><td>-0.818000</td><td>-0.339000</td><td>-0.476000</td><td>-0.472000</td><td>-0.460000</td><td>-0.290000</td><td>-0.349000</td><td>-0.593000</td><td>-0.432000</td></tr><tr><th>50%</th><td>0.065000</td><td>0.195000</td><td>-0.267000</td><td>0.220000</td><td>0.118000</td><td>0.437000</td><td>-0.082000</td><td>0.018000</td><td>-0.004000</td><td>0.401000</td><td>...</td><td>-0.445000</td><td>-0.199000</td><td>0.010000</td><td>0.100000</td><td>0.155000</td><td>-0.040000</td><td>0.160000</td><td>-0.270000</td><td>0.083000</td><td>0.152000</td></tr><tr><th>75%</th><td>0.549000</td><td>0.589000</td><td>0.278000</td><td>0.793000</td><td>0.610000</td><td>1.928000</td><td>0.457000</td><td>0.515000</td><td>0.482000</td><td>0.904000</td><td>...</td><td>-0.434000</td><td>0.468000</td><td>0.447000</td><td>0.471000</td><td>0.627000</td><td>0.419000</td><td>0.273000</td><td>0.364000</td><td>0.651000</td><td>0.797000</td></tr><tr><th>max</th><td>2.100000</td><td>2.120000</td><td>1.946000</td><td>2.603000</td><td>4.475000</td><td>3.176000</td><td>1.528000</td><td>1.394000</td><td>2.408000</td><td>1.766000</td><td>...</td><td>4.656000</td><td>3.022000</td><td>3.139000</td><td>1.428000</td><td>2.299000</td><td>5.465000</td><td>5.110000</td><td>1.671000</td><td>2.861000</td><td>3.021000</td></tr></tbody></table><p>8 rows × 38 columns</p></div><h2 id="特征缩放最大最小值归一化">4.2特征缩放（最大最小值归一化）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> preprocessing <br><br>features_columns = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> train_data.columns <span class="hljs-keyword">if</span> col <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;target&#x27;</span>]]<br><br>min_max_scaler = preprocessing.MinMaxScaler()<br>min_max_scaler = min_max_scaler.fit(train_data[features_columns])<br><br>train_data_scaler = min_max_scaler.transform(train_data[features_columns])<br>test_data_scaler = min_max_scaler.transform(test_data[features_columns])<br><br>train_data_scaler = pd.DataFrame(train_data_scaler)<br>train_data_scaler.columns = features_columns<br><br>test_data_scaler = pd.DataFrame(test_data_scaler)<br>test_data_scaler.columns = features_columns<br><br>train_data_scaler[<span class="hljs-string">&#x27;target&#x27;</span>] = train_data[<span class="hljs-string">&#x27;target&#x27;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">display(train_data_scaler.describe())<br>display(test_data_scaler.describe())<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>...</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2884.000000</td></tr><tr><th>mean</th><td>0.690633</td><td>0.735633</td><td>0.593844</td><td>0.606212</td><td>0.639787</td><td>0.607649</td><td>0.735477</td><td>0.741354</td><td>0.702053</td><td>0.821897</td><td>...</td><td>0.401631</td><td>0.634466</td><td>0.760495</td><td>0.632231</td><td>0.459302</td><td>0.484489</td><td>0.734944</td><td>0.336235</td><td>0.527608</td><td>0.127274</td></tr><tr><th>std</th><td>0.143740</td><td>0.133703</td><td>0.145844</td><td>0.151311</td><td>0.119504</td><td>0.193887</td><td>0.141896</td><td>0.137154</td><td>0.129098</td><td>0.108362</td><td>...</td><td>0.141594</td><td>0.124279</td><td>0.110938</td><td>0.139037</td><td>0.099799</td><td>0.101365</td><td>0.122840</td><td>0.123663</td><td>0.153192</td><td>0.983462</td></tr><tr><th>min</th><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>...</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>-3.044000</td></tr><tr><th>25%</th><td>0.626239</td><td>0.695703</td><td>0.497759</td><td>0.515087</td><td>0.586328</td><td>0.497566</td><td>0.659249</td><td>0.682314</td><td>0.653489</td><td>0.794789</td><td>...</td><td>0.300053</td><td>0.587132</td><td>0.722593</td><td>0.565757</td><td>0.409037</td><td>0.454490</td><td>0.685279</td><td>0.279792</td><td>0.427036</td><td>-0.348500</td></tr><tr><th>50%</th><td>0.727153</td><td>0.766335</td><td>0.609155</td><td>0.609855</td><td>0.652873</td><td>0.642456</td><td>0.767192</td><td>0.774189</td><td>0.728557</td><td>0.846181</td><td>...</td><td>0.385611</td><td>0.633894</td><td>0.782330</td><td>0.634770</td><td>0.454518</td><td>0.499949</td><td>0.755580</td><td>0.349860</td><td>0.519457</td><td>0.313000</td></tr><tr><th>75%</th><td>0.783922</td><td>0.812642</td><td>0.694422</td><td>0.714096</td><td>0.712152</td><td>0.759266</td><td>0.835690</td><td>0.837030</td><td>0.781029</td><td>0.846181</td><td>...</td><td>0.488121</td><td>0.694136</td><td>0.824949</td><td>0.714950</td><td>0.504261</td><td>0.511365</td><td>0.785260</td><td>0.414447</td><td>0.621870</td><td>0.794250</td></tr><tr><th>max</th><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>...</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>2.538000</td></tr></tbody></table><p>8 rows × 39 columns</p></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V28</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th></tr></thead><tbody><tr><th>count</th><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>...</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td></tr><tr><th>mean</th><td>0.642905</td><td>0.715637</td><td>0.477791</td><td>0.632726</td><td>0.635558</td><td>1.130681</td><td>0.664798</td><td>0.699688</td><td>0.637926</td><td>0.871534</td><td>...</td><td>0.313556</td><td>0.369132</td><td>0.614756</td><td>0.719928</td><td>0.623793</td><td>0.457349</td><td>0.482778</td><td>0.673164</td><td>0.326501</td><td>0.577034</td></tr><tr><th>std</th><td>0.166253</td><td>0.152936</td><td>0.155176</td><td>0.161379</td><td>0.154392</td><td>0.360555</td><td>0.162899</td><td>0.149311</td><td>0.156540</td><td>0.120675</td><td>...</td><td>0.149752</td><td>0.117538</td><td>0.156533</td><td>0.144621</td><td>0.175284</td><td>0.098071</td><td>0.100537</td><td>0.118082</td><td>0.132661</td><td>0.141870</td></tr><tr><th>min</th><td>-0.074195</td><td>-0.051989</td><td>-0.138124</td><td>0.106035</td><td>-0.024088</td><td>0.379633</td><td>-0.165817</td><td>-0.082831</td><td>-0.197059</td><td>0.034142</td><td>...</td><td>0.000000</td><td>0.066604</td><td>0.000000</td><td>-0.233613</td><td>-0.000620</td><td>0.000000</td><td>0.000000</td><td>-0.222222</td><td>0.000000</td><td>0.042836</td></tr><tr><th>25%</th><td>0.568618</td><td>0.663494</td><td>0.390845</td><td>0.516451</td><td>0.571256</td><td>0.862598</td><td>0.594035</td><td>0.651593</td><td>0.564653</td><td>0.794789</td><td>...</td><td>0.278919</td><td>0.279498</td><td>0.579211</td><td>0.683816</td><td>0.555366</td><td>0.412901</td><td>0.454490</td><td>0.666667</td><td>0.256819</td><td>0.482353</td></tr><tr><th>50%</th><td>0.681537</td><td>0.755256</td><td>0.504641</td><td>0.651177</td><td>0.654017</td><td>0.980532</td><td>0.694483</td><td>0.727247</td><td>0.675796</td><td>0.888889</td><td>...</td><td>0.280045</td><td>0.362120</td><td>0.627710</td><td>0.756987</td><td>0.652605</td><td>0.454518</td><td>0.499949</td><td>0.676518</td><td>0.342977</td><td>0.570437</td></tr><tr><th>75%</th><td>0.756506</td><td>0.811222</td><td>0.591869</td><td>0.740527</td><td>0.720226</td><td>1.538750</td><td>0.777778</td><td>0.798593</td><td>0.745856</td><td>0.948727</td><td>...</td><td>0.281593</td><td>0.451148</td><td>0.688438</td><td>0.804116</td><td>0.725806</td><td>0.500000</td><td>0.511365</td><td>0.755580</td><td>0.415371</td><td>0.667722</td></tr><tr><th>max</th><td>0.996747</td><td>1.028693</td><td>0.858835</td><td>1.022766</td><td>1.240345</td><td>2.005990</td><td>0.943285</td><td>0.924777</td><td>1.023497</td><td>1.051273</td><td>...</td><td>0.997889</td><td>0.792045</td><td>1.062535</td><td>0.925686</td><td>0.985112</td><td>1.000000</td><td>1.000000</td><td>0.918568</td><td>0.697043</td><td>1.003167</td></tr></tbody></table><p>8 rows × 38 columns</p></div><h4 id="代码详解-1">代码详解：</h4><ol type="1"><li><p><code>features_columns = [col for col in train_data.columns if col not in ['target']]</code>：使用列表推导式创建一个列表<code>features_columns</code>，其中包含除了'target'列之外的所有训练数据的特征列。</p></li><li><p><code>min_max_scaler = preprocessing.MinMaxScaler()</code>：创建一个MinMaxScaler对象，用于进行特征缩放。</p></li><li><p><code>min_max_scaler = min_max_scaler.fit(train_data[features_columns])</code>：使用训练数据的特征列拟合（fit）MinMaxScaler对象，计算训练集中每个特征的最小值和最大值。</p></li><li><p><code>train_data_scaler = min_max_scaler.transform(train_data[features_columns])</code>：将训练数据的特征列使用MinMaxScaler进行缩放转换，得到缩放后的训练数据。</p></li><li><p><code>test_data_scaler = min_max_scaler.transform(test_data[features_columns])</code>：将测试数据的特征列使用相同的MinMaxScaler进行缩放转换，得到缩放后的测试数据。这里使用的是在训练数据上拟合的MinMaxScaler对象，保证了训练数据和测试数据的缩放方式一致。</p></li><li><p><code>train_data_scaler = pd.DataFrame(train_data_scaler)</code>：将缩放后的训练数据转换为DataFrame格式。</p></li><li><p><code>train_data_scaler.columns = features_columns</code>：将缩放后的训练数据的列名设置为原始特征列的列名，保持一致性。</p></li><li><p><code>test_data_scaler = pd.DataFrame(test_data_scaler)</code>：将缩放后的测试数据转换为DataFrame格式。</p></li><li><p><code>test_data_scaler.columns = features_columns</code>：将缩放后的测试数据的列名设置为原始特征列的列名，保持一致性。</p></li><li><p><code>train_data_scaler['target'] = train_data['target']</code>：将缩放后的训练数据中的'target'列设置为原始训练数据的'target'列，这样保留了目标变量。</p></li></ol><hr /><p><strong>fit与transform：</strong></p><ol type="1"><li>fit方法：<ul><li>fit方法用于从训练数据中学习模型的参数或数据转换所需的统计信息。</li><li>在fit方法中，模型会根据训练数据自动计算并确定转换所需的参数，例如均值、标准差等。</li><li>fit方法通常只针对训练数据集进行调用，以便使模型能够根据训练数据适应最佳的参数设置。</li></ul></li><li>transform方法：<ul><li>transform方法用于将原始数据转换为经过预处理后的数据。</li><li>在transform方法中，模型会根据之前学习到的参数或统计信息，对数据进行相应的转换操作。</li><li>transform方法通常在训练数据和测试数据上分别调用，以便将它们都转换为相同的预处理格式，保证数据的一致性。</li></ul></li></ol><p>fit和transform方法在不同的预处理类中具有相对应的方法名：</p><ul><li><p>MinMaxScaler类，fit方法用于计算每个特征的最小值和最大值，transform方法用于将数据缩放到给定的范围，默认为[0, 1]。</p></li><li><p>StandardScaler类，fit方法用于计算每个特征的均值和标准差，transform方法用于将数据进行标准化处理，使其均值为0，标准差为1。</p></li><li><p>OneHotEncoder类，fit方法用于确定类别特征的所有可能取值，并构建映射关系，transform方法用于将类别特征转换为二进制矩阵表示。</p></li></ul><p>fit方法用于从 ==训练数据== 中 ==学习== 模型的 ==参数== 或统计信息，transform方法用于将原始数据按照之前学习到的参数或统计信息进行转换。在实际应用中，通常先调用fit方法对模型进行训练，然后再调用transform方法对训练数据和测试数据进行相同的数据预处理操作。</p><p>使用MinMaxScaler对数据进行缩放时，通常将其fit在训练集上的原因是为了避免信息泄漏（information leakage）。</p><p>信息泄漏是指在数据预处理过程中，使用了不应该在当前步骤中可用的额外信息。这可能导致模型在实际应用中性能下降，因为会在测试集上产生过于乐观的估计。</p><p>将MinMaxScaler仅拟合（fit）于训练数据的优势有两个：</p><ul><li>模型只能使用训练集的信息进行训练和预测，这符合机器学习的基本原则。模型无法直接访问测试集的任何信息，以确保其在真实世界中的性能。</li><li>防止信息泄漏。如果将MinMaxScaler同时拟合于训练集和测试集，就相当于使用了测试集的信息来进行预处理，将测试集的信息引入到了训练过程中。这可能会导致过于乐观的结果。</li><li>测试集是用于评估模型性能的独立数据集。如果对测试集拟合（fit），则使用不同的预处理参数，那么测试集的数据范围和分布就会与训练集不一致，这可能导致模型在实际应用中表现不佳。</li></ul><hr /><p><strong><code>column = train_data.columns.tolist()[:39]</code>与 <code>columns = [col for col in train_data.columns]</code> 这两种获取列名的区别和优劣：</strong></p><ol type="1"><li><code>column = train_data.columns.tolist()[:39]</code>：<ul><li>这种方式将DataFrame的列名转换为一个Python列表。</li><li>优点：简单直接，获取指定数量的列名。</li><li>缺点：只能获取指定数量的列名，不适用于需要选择特定列或基于某些条件筛选列名的情况。</li></ul></li><li><code>columns = [col for col in train_data.columns]</code>：<ul><li>这种方式使用列表推导式将DataFrame的所有列名存储到一个列表中。</li><li>优点：可以获取DataFrame中的所有列名，提供了更大的灵活性。可以通过条件筛选、修改等方式来操作列名。</li><li>缺点：相对于第一种方式来说，代码稍微复杂一些。</li></ul></li></ol><p>所以，选择哪种方式取决于具体的需求：</p><ul><li>如果只需要获取特定数量的列名，且数量固定，可以使用<code>train_data.columns.tolist()[:39]</code>方式，简单且明确。</li><li>如果需要对列名进行更多的操作，如条件筛选、修改等，或者需要获取所有列名，例如<code>col for col in train_data.columns if col not in ['target']</code> 那么使用列表推导式会更灵活。</li></ul><h2 id="查看数据分布情况">4.3查看数据分布情况</h2><p>我们利用KDE分布对比特征变量在训练集和测试集中的分布情况。对比后发现：特征变量V5, V9, V11, V17, V22, V28在训练集和测试集中的分布差异较大，会影响模型的泛化能力，故删除这些特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># KDE分布</span><br>dist_cols = <span class="hljs-number">6</span><br>dist_rows = <span class="hljs-built_in">len</span>(test_data_scaler.columns)<br><br>plt.figure(figsize=(<span class="hljs-number">4</span>*dist_cols,<span class="hljs-number">4</span>*dist_rows))<br><br><br><span class="hljs-keyword">for</span> i, col <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(test_data_scaler.columns):<br>    ax=plt.subplot(dist_rows,dist_cols,i+<span class="hljs-number">1</span>)<br>    ax = sns.kdeplot(train_data_scaler[col], color=<span class="hljs-string">&quot;Red&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax = sns.kdeplot(test_data_scaler[col], color=<span class="hljs-string">&quot;Blue&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax.set_xlabel(col)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    ax = ax.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br> <br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-03特征工程/output_19_0.png" /> ​</p><h4 id="代码解释">代码解释：</h4><p><code>for i, col in enumerate(test_data_scaler.columns)</code>：迭代循环，遍历<code>test_data_scaler.columns</code>中的每一列，并使用<code>enumerate</code>函数同时将列的索引赋值给<code>i</code>，列名赋值给<code>col</code>。</p><p>查看特征'V5', 'V17', 'V28', 'V22', 'V11', 'V9'数据的数据分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">drop_col = <span class="hljs-number">6</span><br>drop_row = <span class="hljs-number">1</span><br><br>plt.figure(figsize=(<span class="hljs-number">5</span>*drop_col,<span class="hljs-number">5</span>*drop_row))<br><br><span class="hljs-keyword">for</span> i, col <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">&quot;V5&quot;</span>,<span class="hljs-string">&quot;V9&quot;</span>,<span class="hljs-string">&quot;V11&quot;</span>,<span class="hljs-string">&quot;V17&quot;</span>,<span class="hljs-string">&quot;V22&quot;</span>,<span class="hljs-string">&quot;V28&quot;</span>]):<br>    ax =plt.subplot(drop_row,drop_col,i+<span class="hljs-number">1</span>)<br>    ax = sns.kdeplot(train_data_scaler[col], color=<span class="hljs-string">&quot;Red&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax= sns.kdeplot(test_data_scaler[col], color=<span class="hljs-string">&quot;Blue&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax.set_xlabel(col)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    ax = ax.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-03特征工程/output_22_0.png" /> ​</p><p>这几个特征下，训练集的数据和测试集的数据分布不一致，会影响模型的泛化能力，故删除这些特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">data_train_scaler = train_data_scaler.drop([<span class="hljs-string">&#x27;V5&#x27;</span>,<span class="hljs-string">&#x27;V9&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>,<span class="hljs-string">&#x27;V17&#x27;</span>,<span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V28&#x27;</span>],axis=<span class="hljs-number">1</span>)<br>data_train_scaler.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V6</th><th>V7</th><th>V8</th><th>V10</th><th>V12</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>0</th><td>0.759139</td><td>0.729830</td><td>0.524488</td><td>0.680337</td><td>0.698964</td><td>0.427136</td><td>0.385874</td><td>0.613522</td><td>0.221743</td><td>0.698875</td><td>...</td><td>0.406834</td><td>0.641467</td><td>0.666159</td><td>0.679280</td><td>0.00000</td><td>0.000000</td><td>0.074074</td><td>0.000000</td><td>0.018401</td><td>0.175</td></tr><tr><th>1</th><td>0.821406</td><td>0.789631</td><td>0.557939</td><td>0.705130</td><td>0.664244</td><td>0.465152</td><td>0.385874</td><td>0.724232</td><td>0.373887</td><td>0.690502</td><td>...</td><td>0.371596</td><td>0.643552</td><td>0.748349</td><td>0.721619</td><td>0.37495</td><td>0.499949</td><td>0.755580</td><td>0.289702</td><td>0.437406</td><td>0.676</td></tr><tr><th>2</th><td>0.828377</td><td>0.808239</td><td>0.584987</td><td>0.674567</td><td>0.653210</td><td>0.495905</td><td>0.385874</td><td>0.733458</td><td>0.466415</td><td>0.699012</td><td>...</td><td>0.387480</td><td>0.676487</td><td>0.779472</td><td>0.610577</td><td>0.37495</td><td>0.499949</td><td>0.755580</td><td>0.429901</td><td>0.458673</td><td>0.633</td></tr><tr><th>3</th><td>0.785006</td><td>0.779830</td><td>0.592670</td><td>0.642601</td><td>0.718746</td><td>0.521712</td><td>0.425208</td><td>0.734467</td><td>0.350013</td><td>0.706972</td><td>...</td><td>0.390683</td><td>0.684269</td><td>0.779726</td><td>0.722084</td><td>0.37495</td><td>0.477220</td><td>0.755580</td><td>0.374841</td><td>0.530618</td><td>0.206</td></tr><tr><th>4</th><td>0.777416</td><td>0.818182</td><td>0.588988</td><td>0.649462</td><td>0.683488</td><td>0.541338</td><td>0.425208</td><td>0.721638</td><td>0.314675</td><td>0.736206</td><td>...</td><td>0.413107</td><td>0.776126</td><td>0.785950</td><td>0.693393</td><td>0.37495</td><td>0.462067</td><td>0.755580</td><td>0.296712</td><td>0.543288</td><td>0.384</td></tr></tbody></table><p>5 rows × 33 columns</p></div><h2 id="特征相关性">4.4特征相关性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">16</span>))  <br>column = train_data_scaler.columns.tolist()  <br>mcorr = train_data_scaler[column].corr(method=<span class="hljs-string">&quot;spearman&quot;</span>)  <br>mask = np.zeros_like(mcorr, dtype=np.<span class="hljs-built_in">bool</span>)  <br>mask[np.triu_indices_from(mask)] = <span class="hljs-literal">True</span>  <br>cmap = sns.diverging_palette(<span class="hljs-number">220</span>, <span class="hljs-number">10</span>, as_cmap=<span class="hljs-literal">True</span>)  <br>g = sns.heatmap(mcorr, mask=mask, cmap=cmap, square=<span class="hljs-literal">True</span>, annot=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">&#x27;0.2f&#x27;</span>)  <br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-03特征工程/output_26_0.png" /> ​</p><h2 id="特征降维">4.5特征降维</h2><h3 id="相关性初筛1">4.5.1相关性初筛1</h3><p>进行特征相关性初筛，计算相关性系数并筛选大于0.1的特征变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">mcorr=mcorr.<span class="hljs-built_in">abs</span>()<br>numerical_corr=mcorr[mcorr[<span class="hljs-string">&#x27;target&#x27;</span>]&gt;<span class="hljs-number">0.1</span>][<span class="hljs-string">&#x27;target&#x27;</span>]<br><span class="hljs-built_in">print</span>(numerical_corr.sort_values(ascending=<span class="hljs-literal">False</span>))<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">target    1.000000V0        0.712403V31       0.711636V1        0.682909V8        0.679469V27       0.657398V2        0.585850V16       0.545793V3        0.501622V4        0.478683V12       0.460300V10       0.448682V36       0.425991V37       0.376443V24       0.305526V5        0.286076V6        0.280195V20       0.278381V11       0.234551V15       0.221290V29       0.190109V7        0.185321V19       0.180111V18       0.149741V13       0.149199V17       0.126262V22       0.112743V30       0.101378Name: target, dtype: float64</code></pre><h4 id="代码详解-2">代码详解：</h4><ol type="1"><li><p>使用 <code>mcorr.abs()</code>对相关性矩阵 <code>mcorr</code> 中的各个元素取绝对值。</p></li><li><p><code>mcorr[mcorr['target']&gt;0.1]</code> 从 <code>mcorr</code> 中筛选出目标变量（<code>target</code>）相关性大于 0.1 的特征行，接着 <code>mcorr[mcorr['target']&gt;0.1]['target']</code>提取出 <code>target</code> 列。</p></li><li><p>对 <code>numerical_corr</code> 进行降序排序，<code>.sort_values(ascending=False)</code> 表示按照降序排列，即相关性系数较高的特征显示在前面。</p></li><li><p><code>numerical_corr.sort_values(ascending=False).index</code> 对 <code>numerical_corr</code> 进行降序排序，并提取排序后的索引，并将其赋值给 <code>index0</code>。</p></li><li><p>通过 <code>train_data_scaler[index0]</code> 获取 <code>train_data_scaler</code> 中与 <code>index0</code> 中特征名称索引对应的特征列，并使用 <code>.corr('spearman')</code> 计算这些特征之间的斯皮尔曼相关系数。</p></li></ol><h3 id="相关性初筛2">4.5.2相关性初筛2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">features_corr = numerical_corr.sort_values(ascending=<span class="hljs-literal">False</span>).reset_index()<br>features_corr.columns = [<span class="hljs-string">&#x27;features_and_target&#x27;</span>, <span class="hljs-string">&#x27;corr&#x27;</span>]<br>features_corr_select = features_corr[features_corr[<span class="hljs-string">&#x27;corr&#x27;</span>]&gt;<span class="hljs-number">0.3</span>] <span class="hljs-comment"># 筛选出大于相关性大于0.3的特征</span><br><span class="hljs-built_in">print</span>(features_corr_select)<br>select_features = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> features_corr_select[<span class="hljs-string">&#x27;features_and_target&#x27;</span>] <span class="hljs-keyword">if</span> col <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;target&#x27;</span>]]<br>new_train_data_corr_select = train_data_scaler[select_features+[<span class="hljs-string">&#x27;target&#x27;</span>]]<br>new_test_data_corr_select = test_data_scaler[select_features]<br></code></pre></td></tr></table></figure><pre><code class="hljs">   features_and_target      corr0               target  1.0000001                   V0  0.7124032                  V31  0.7116363                   V1  0.6829094                   V8  0.6794695                  V27  0.6573986                   V2  0.5858507                  V16  0.5457938                   V3  0.5016229                   V4  0.47868310                 V12  0.46030011                 V10  0.44868212                 V36  0.42599113                 V37  0.37644314                 V24  0.305526</code></pre><h2 id="多重共线性分析">4.6多重共线性分析</h2><p>多重共线性分析的原则是特征组之间的相关性系数较大，即每个特征变量与其他特征变量之间的相关性系数较大，故可能存在较大的共线性影响，这会导致模型估计不准确。因此，后续要使用PCA对数据进行处理，去除多重共线性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算多重共线性</span><br><span class="hljs-keyword">from</span> statsmodels.stats.outliers_influence <span class="hljs-keyword">import</span> variance_inflation_factor <span class="hljs-comment">#多重共线性方差膨胀因子</span><br><br><span class="hljs-comment">#多重共线性</span><br>new_numerical=[<span class="hljs-string">&#x27;V0&#x27;</span>, <span class="hljs-string">&#x27;V2&#x27;</span>, <span class="hljs-string">&#x27;V3&#x27;</span>, <span class="hljs-string">&#x27;V4&#x27;</span>, <span class="hljs-string">&#x27;V5&#x27;</span>, <span class="hljs-string">&#x27;V6&#x27;</span>, <span class="hljs-string">&#x27;V10&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>, <br>                         <span class="hljs-string">&#x27;V13&#x27;</span>, <span class="hljs-string">&#x27;V15&#x27;</span>, <span class="hljs-string">&#x27;V16&#x27;</span>, <span class="hljs-string">&#x27;V18&#x27;</span>, <span class="hljs-string">&#x27;V19&#x27;</span>, <span class="hljs-string">&#x27;V20&#x27;</span>, <span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V24&#x27;</span>,<span class="hljs-string">&#x27;V30&#x27;</span>, <span class="hljs-string">&#x27;V31&#x27;</span>, <span class="hljs-string">&#x27;V37&#x27;</span>]<br>X=np.matrix(train_data_scaler[new_numerical])<br>VIF_list=[variance_inflation_factor(X, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(X.shape[<span class="hljs-number">1</span>])]<br>VIF_list<br></code></pre></td></tr></table></figure><pre><code class="hljs">[216.73387180903222, 114.38118723828812, 27.863778129686356, 201.96436579080174, 78.93722825798903, 151.06983667656212, 14.519604941508451, 82.69750284665385, 28.479378440614585, 27.759176471505945, 526.6483470743831, 23.50166642638334, 19.920315849901424, 24.640481765008683, 11.816055964845381, 4.958208708452915, 37.09877416736591, 298.26442986612767, 47.854002539887034]</code></pre><p>说明：new_numerical的特征变量可以根据相关性矩阵看出并过滤筛选，剔除那些与其他特征高度相关的特征，然后，使用剩余的特征矩阵来计算每个特征的VIF值，以评估自变量之间的多重共线性程度。</p><h4 id="代码详解-3">代码详解：</h4><ol type="1"><li><p><code>new_numerical=[ ]</code>：定义了一个包含特征列名称的列表<code>new_numerical</code>，这些特征将被用于计算VIF。</p></li><li><p><code>X=np.matrix(train_data_scaler[new_numerical])</code>：将训练数据<code>train_data_scaler</code>中<code>new_numerical</code>列表中的特征列用 <code>np.matrix</code> 转换为二维矩阵<code>X</code>。该矩阵将作为VIF计算的输入。</p></li><li><p><code>VIF_list=[variance_inflation_factor(X, i) for i in range(X.shape[1])]</code>：使用列表推导式计算VIF列表。对于矩阵<code>X</code>的每一列（即特征），调用<code>variance_inflation_factor</code>函数来计算VIF，并将结果添加到<code>VIF_list</code>中。<code>range(X.shape[1])</code>生成了一个表示列索引的迭代器。（下方详解variance_inflation_factor）</p></li><li><p><code>VIF_list</code>：输出VIF列表，该列表包含了每个特征的方差膨胀因子。</p></li></ol><hr /><p><strong>variance_inflation_factor用法</strong></p><p><code>variance_inflation_factor</code> 是一个用于计算方差膨胀因子（Variance Inflation Factor，VIF）的函数。方差膨胀因子是用于检测多重共线性（multicollinearity）问题的一种统计指标。</p><p>多重共线性指的是在回归分析中，自变量之间存在高度线性相关性的情况。它会导致回归模型中的估计不稳定，使得对自变量的解释变得困难。方差膨胀因子通过衡量每个自变量对其他自变量的线性相关性来检测多重共线性。</p><p><code>variance_inflation_factor</code> 函数通常需要传入两个参数：</p><ol type="1"><li><code>X</code>：一个二维数组或数据帧，表示自变量矩阵。每一列代表一个自变量。</li><li><code>idx</code>：一个整数，表示要计算方差膨胀因子的自变量的索引。</li></ol><p>以下是 <code>variance_inflation_factor</code> 函数的用法示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> statsmodels.stats.outliers_influence <span class="hljs-keyword">import</span> variance_inflation_factor<br><br><span class="hljs-comment"># 假设 X 是自变量矩阵，其中每一列代表一个自变量</span><br>vif = variance_inflation_factor(X, idx)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Variance inflation factor for variable <span class="hljs-subst">&#123;idx&#125;</span>: <span class="hljs-subst">&#123;vif&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>这段代码计算自变量矩阵 <code>X</code> 中给定索引 <code>idx</code> 的自变量的方差膨胀因子，并将结果打印输出。</p><p>方差膨胀因子的常见阈值为 5 或 10。当方差膨胀因子超过这个阈值时，表示该自变量与其他自变量存在高度线性相关性，可能会导致多重共线性问题。一般而言，方差膨胀因子越大，说明自变量之间的相关性越高。</p><h2 id="pca处理">4.7PCA处理</h2><p>利用PCA方法去除数据的多重共线性，并进行降维。</p><p>在scikit-learn（sklearn）库中，PCA被实现<code>sklearn.decomposition.PCA</code>类，主要参数<code>n_components</code>指定降维后的特征数量或保留的信息量的比例。可以设置为一个整数来指定具体的特征数量，也可以设置为一个0到1之间的浮点数来表示保留的信息量比例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA   <span class="hljs-comment">#主成分分析法</span><br><br><span class="hljs-comment">#PCA方法降维</span><br><span class="hljs-comment">#保持90%的信息</span><br>pca = PCA(n_components=<span class="hljs-number">0.9</span>)<br>new_train_pca_90 = pca.fit_transform(train_data_scaler.iloc[:,<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>])<br>new_test_pca_90 = pca.transform(test_data_scaler)<br><br>new_train_pca_90 = pd.DataFrame(new_train_pca_90)<br>new_test_pca_90 = pd.DataFrame(new_test_pca_90)<br><br>new_train_pca_90[<span class="hljs-string">&#x27;target&#x27;</span>] = train_data_scaler[<span class="hljs-string">&#x27;target&#x27;</span>]<br><br><span class="hljs-comment"># 查看原数据信息并与PCA处理后的数据进行对比</span><br>display(new_train_pca_90.describe())<br>display(train_data_scaler.describe())<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2884.000000</td></tr><tr><th>mean</th><td>2.089242e-17</td><td>-1.012126e-16</td><td>1.057905e-17</td><td>-1.002894e-16</td><td>8.509402e-17</td><td>-5.249131e-17</td><td>5.271732e-17</td><td>6.668166e-17</td><td>-4.468205e-17</td><td>9.163379e-17</td><td>7.636149e-18</td><td>1.237075e-16</td><td>-5.053900e-18</td><td>-5.874257e-17</td><td>-2.122542e-17</td><td>1.230265e-16</td><td>0.127274</td></tr><tr><th>std</th><td>3.998976e-01</td><td>3.500240e-01</td><td>2.938631e-01</td><td>2.728023e-01</td><td>2.077128e-01</td><td>1.951842e-01</td><td>1.877104e-01</td><td>1.607670e-01</td><td>1.512707e-01</td><td>1.443772e-01</td><td>1.368790e-01</td><td>1.286192e-01</td><td>1.193301e-01</td><td>1.149758e-01</td><td>1.133507e-01</td><td>1.019259e-01</td><td>0.983462</td></tr><tr><th>min</th><td>-1.071795e+00</td><td>-9.429479e-01</td><td>-9.948314e-01</td><td>-7.103087e-01</td><td>-7.703987e-01</td><td>-5.340294e-01</td><td>-5.993766e-01</td><td>-5.870755e-01</td><td>-6.282818e-01</td><td>-4.902583e-01</td><td>-6.341045e-01</td><td>-5.906753e-01</td><td>-4.175153e-01</td><td>-4.310613e-01</td><td>-4.170535e-01</td><td>-3.601627e-01</td><td>-3.044000</td></tr><tr><th>25%</th><td>-2.804085e-01</td><td>-2.613727e-01</td><td>-2.090797e-01</td><td>-1.945196e-01</td><td>-1.315620e-01</td><td>-1.264097e-01</td><td>-1.236360e-01</td><td>-1.016452e-01</td><td>-9.662098e-02</td><td>-9.297088e-02</td><td>-8.202809e-02</td><td>-7.721868e-02</td><td>-7.139961e-02</td><td>-7.474073e-02</td><td>-7.709743e-02</td><td>-6.603914e-02</td><td>-0.348500</td></tr><tr><th>50%</th><td>-1.417104e-02</td><td>-1.277241e-02</td><td>2.112166e-02</td><td>-2.337401e-02</td><td>-5.122797e-03</td><td>-1.355336e-02</td><td>-1.747870e-04</td><td>-4.656359e-03</td><td>2.572054e-03</td><td>-1.479172e-03</td><td>7.286444e-03</td><td>-5.745946e-03</td><td>-4.140670e-03</td><td>1.054915e-03</td><td>-1.758387e-03</td><td>-7.533392e-04</td><td>0.313000</td></tr><tr><th>75%</th><td>2.287306e-01</td><td>2.317720e-01</td><td>2.069571e-01</td><td>1.657590e-01</td><td>1.281660e-01</td><td>9.993122e-02</td><td>1.272081e-01</td><td>9.657222e-02</td><td>1.002626e-01</td><td>9.059634e-02</td><td>8.833765e-02</td><td>7.148033e-02</td><td>6.786199e-02</td><td>7.574868e-02</td><td>7.116829e-02</td><td>6.357449e-02</td><td>0.794250</td></tr><tr><th>max</th><td>1.597730e+00</td><td>1.382802e+00</td><td>1.010250e+00</td><td>1.448007e+00</td><td>1.034061e+00</td><td>1.358962e+00</td><td>6.191589e-01</td><td>7.370089e-01</td><td>6.449125e-01</td><td>5.839586e-01</td><td>6.405187e-01</td><td>6.780732e-01</td><td>5.156118e-01</td><td>4.978126e-01</td><td>4.673189e-01</td><td>4.570870e-01</td><td>2.538000</td></tr></tbody></table></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>...</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2884.000000</td></tr><tr><th>mean</th><td>0.690633</td><td>0.735633</td><td>0.593844</td><td>0.606212</td><td>0.639787</td><td>0.607649</td><td>0.735477</td><td>0.741354</td><td>0.702053</td><td>0.821897</td><td>...</td><td>0.401631</td><td>0.634466</td><td>0.760495</td><td>0.632231</td><td>0.459302</td><td>0.484489</td><td>0.734944</td><td>0.336235</td><td>0.527608</td><td>0.127274</td></tr><tr><th>std</th><td>0.143740</td><td>0.133703</td><td>0.145844</td><td>0.151311</td><td>0.119504</td><td>0.193887</td><td>0.141896</td><td>0.137154</td><td>0.129098</td><td>0.108362</td><td>...</td><td>0.141594</td><td>0.124279</td><td>0.110938</td><td>0.139037</td><td>0.099799</td><td>0.101365</td><td>0.122840</td><td>0.123663</td><td>0.153192</td><td>0.983462</td></tr><tr><th>min</th><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>...</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>-3.044000</td></tr><tr><th>25%</th><td>0.626239</td><td>0.695703</td><td>0.497759</td><td>0.515087</td><td>0.586328</td><td>0.497566</td><td>0.659249</td><td>0.682314</td><td>0.653489</td><td>0.794789</td><td>...</td><td>0.300053</td><td>0.587132</td><td>0.722593</td><td>0.565757</td><td>0.409037</td><td>0.454490</td><td>0.685279</td><td>0.279792</td><td>0.427036</td><td>-0.348500</td></tr><tr><th>50%</th><td>0.727153</td><td>0.766335</td><td>0.609155</td><td>0.609855</td><td>0.652873</td><td>0.642456</td><td>0.767192</td><td>0.774189</td><td>0.728557</td><td>0.846181</td><td>...</td><td>0.385611</td><td>0.633894</td><td>0.782330</td><td>0.634770</td><td>0.454518</td><td>0.499949</td><td>0.755580</td><td>0.349860</td><td>0.519457</td><td>0.313000</td></tr><tr><th>75%</th><td>0.783922</td><td>0.812642</td><td>0.694422</td><td>0.714096</td><td>0.712152</td><td>0.759266</td><td>0.835690</td><td>0.837030</td><td>0.781029</td><td>0.846181</td><td>...</td><td>0.488121</td><td>0.694136</td><td>0.824949</td><td>0.714950</td><td>0.504261</td><td>0.511365</td><td>0.785260</td><td>0.414447</td><td>0.621870</td><td>0.794250</td></tr><tr><th>max</th><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>...</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>2.538000</td></tr></tbody></table><p>8 rows × 39 columns</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#PCA方法降维</span><br><span class="hljs-comment">#保留16个主成分</span><br>pca = PCA(n_components=<span class="hljs-number">16</span>)<br>new_train_pca_16 = pca.fit_transform(train_data_scaler.iloc[:,<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>])<br>new_test_pca_16 = pca.transform(test_data_scaler)<br>new_train_pca_16 = pd.DataFrame(new_train_pca_16)<br>new_test_pca_16 = pd.DataFrame(new_test_pca_16)<br>new_train_pca_16[<span class="hljs-string">&#x27;target&#x27;</span>] = train_data_scaler[<span class="hljs-string">&#x27;target&#x27;</span>]<br><br>display(new_train_pca_16.describe())<br>display(new_test_pca_16.describe())<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2884.000000</td></tr><tr><th>mean</th><td>-8.025530e-17</td><td>9.902951e-17</td><td>2.481268e-17</td><td>-9.296098e-17</td><td>6.399362e-17</td><td>-2.711122e-17</td><td>8.112207e-17</td><td>3.819036e-17</td><td>-6.028134e-17</td><td>7.289445e-17</td><td>1.754800e-17</td><td>1.437164e-16</td><td>-1.772471e-17</td><td>-4.583132e-17</td><td>-4.687240e-18</td><td>1.133413e-16</td><td>0.127274</td></tr><tr><th>std</th><td>3.998976e-01</td><td>3.500240e-01</td><td>2.938631e-01</td><td>2.728023e-01</td><td>2.077128e-01</td><td>1.951842e-01</td><td>1.877104e-01</td><td>1.607670e-01</td><td>1.512707e-01</td><td>1.443772e-01</td><td>1.368790e-01</td><td>1.286192e-01</td><td>1.193301e-01</td><td>1.149758e-01</td><td>1.133504e-01</td><td>1.019258e-01</td><td>0.983462</td></tr><tr><th>min</th><td>-1.071795e+00</td><td>-9.429479e-01</td><td>-9.948314e-01</td><td>-7.103086e-01</td><td>-7.703992e-01</td><td>-5.340298e-01</td><td>-5.993763e-01</td><td>-5.870643e-01</td><td>-6.282915e-01</td><td>-4.902772e-01</td><td>-6.340438e-01</td><td>-5.906787e-01</td><td>-4.175381e-01</td><td>-4.310506e-01</td><td>-4.168836e-01</td><td>-3.602406e-01</td><td>-3.044000</td></tr><tr><th>25%</th><td>-2.804085e-01</td><td>-2.613727e-01</td><td>-2.090798e-01</td><td>-1.945196e-01</td><td>-1.315621e-01</td><td>-1.264102e-01</td><td>-1.236360e-01</td><td>-1.016531e-01</td><td>-9.661879e-02</td><td>-9.296451e-02</td><td>-8.202614e-02</td><td>-7.723983e-02</td><td>-7.137032e-02</td><td>-7.476121e-02</td><td>-7.689358e-02</td><td>-6.605108e-02</td><td>-0.348500</td></tr><tr><th>50%</th><td>-1.417105e-02</td><td>-1.277241e-02</td><td>2.112167e-02</td><td>-2.337400e-02</td><td>-5.122561e-03</td><td>-1.355336e-02</td><td>-1.746698e-04</td><td>-4.655969e-03</td><td>2.574279e-03</td><td>-1.483695e-03</td><td>7.272187e-03</td><td>-5.778147e-03</td><td>-4.141567e-03</td><td>1.056716e-03</td><td>-1.924285e-03</td><td>-7.935672e-04</td><td>0.313000</td></tr><tr><th>75%</th><td>2.287306e-01</td><td>2.317720e-01</td><td>2.069571e-01</td><td>1.657590e-01</td><td>1.281662e-01</td><td>9.993117e-02</td><td>1.272076e-01</td><td>9.657352e-02</td><td>1.002620e-01</td><td>9.059130e-02</td><td>8.833726e-02</td><td>7.147819e-02</td><td>6.780737e-02</td><td>7.573818e-02</td><td>7.113472e-02</td><td>6.362983e-02</td><td>0.794250</td></tr><tr><th>max</th><td>1.597730e+00</td><td>1.382802e+00</td><td>1.010250e+00</td><td>1.448007e+00</td><td>1.034058e+00</td><td>1.358961e+00</td><td>6.191591e-01</td><td>7.370478e-01</td><td>6.449824e-01</td><td>5.839721e-01</td><td>6.405928e-01</td><td>6.781944e-01</td><td>5.156549e-01</td><td>4.978232e-01</td><td>4.677552e-01</td><td>4.569075e-01</td><td>2.538000</td></tr></tbody></table></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><th>count</th><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td></tr><tr><th>mean</th><td>0.381177</td><td>0.081992</td><td>0.281879</td><td>-0.197930</td><td>-0.100701</td><td>-0.142780</td><td>0.004071</td><td>-0.060480</td><td>-0.154322</td><td>0.086993</td><td>-0.100815</td><td>0.046543</td><td>0.019935</td><td>0.165712</td><td>-0.091402</td><td>0.098503</td></tr><tr><th>std</th><td>0.476428</td><td>0.401721</td><td>0.286971</td><td>0.469295</td><td>0.247697</td><td>0.240629</td><td>0.181197</td><td>0.182679</td><td>0.205765</td><td>0.194124</td><td>0.169021</td><td>0.150554</td><td>0.186972</td><td>0.133136</td><td>0.113115</td><td>0.156939</td></tr><tr><th>min</th><td>-0.669864</td><td>-0.811128</td><td>-0.867655</td><td>-1.464873</td><td>-0.835855</td><td>-0.885696</td><td>-0.598268</td><td>-1.178334</td><td>-1.263819</td><td>-0.551279</td><td>-0.907768</td><td>-0.552060</td><td>-0.647384</td><td>-0.249090</td><td>-0.530208</td><td>-0.404869</td></tr><tr><th>25%</th><td>0.038180</td><td>-0.212454</td><td>0.115846</td><td>-0.574960</td><td>-0.255649</td><td>-0.276799</td><td>-0.115316</td><td>-0.174018</td><td>-0.310445</td><td>-0.047362</td><td>-0.204719</td><td>-0.060321</td><td>-0.107933</td><td>0.071293</td><td>-0.168086</td><td>-0.011253</td></tr><tr><th>50%</th><td>0.287710</td><td>0.014673</td><td>0.282676</td><td>-0.087425</td><td>-0.125262</td><td>-0.150075</td><td>0.003478</td><td>-0.053806</td><td>-0.175642</td><td>0.107260</td><td>-0.107033</td><td>0.036827</td><td>0.034512</td><td>0.148576</td><td>-0.087650</td><td>0.084981</td></tr><tr><th>75%</th><td>0.684349</td><td>0.348803</td><td>0.478167</td><td>0.170079</td><td>0.031784</td><td>-0.028064</td><td>0.116061</td><td>0.062062</td><td>-0.015697</td><td>0.235243</td><td>0.002403</td><td>0.142344</td><td>0.149126</td><td>0.261064</td><td>-0.018204</td><td>0.207740</td></tr><tr><th>max</th><td>2.265144</td><td>1.727923</td><td>1.228726</td><td>1.300934</td><td>0.893993</td><td>1.232575</td><td>0.635610</td><td>0.468097</td><td>0.639576</td><td>0.758273</td><td>0.691010</td><td>0.793413</td><td>0.627588</td><td>0.665948</td><td>0.301437</td><td>0.631095</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>机器学习实战入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工业蒸汽预测-02数据探索</title>
    <link href="/2023/07/29/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-02%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/"/>
    <url>/2023/07/29/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-02%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="导入数据探索的工具包">1导入数据探索的工具包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns <span class="hljs-comment"># 数据可视化。其中boxplot用于绘制箱形图</span><br><br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)<br> <br>%matplotlib inline<br></code></pre></td></tr></table></figure><h2 id="读取数据">2读取数据</h2><p>使用Pandas库<code>read_csv()</code>函数进行数据读取，由于读取的是文本文件(.txt)，需要设置分割符为‘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data_file = <span class="hljs-string">&quot;./data/zhengqi_train.txt&quot;</span><br>test_data_file =  <span class="hljs-string">&quot;./data/zhengqi_test.txt&quot;</span><br><br>train_data = pd.read_csv(train_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>test_data = pd.read_csv(test_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="查看数据信息">3查看数据信息</h2><h3 id="查看数据基本信息">3.1查看数据基本信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练集</span><br>train_data.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 2888 entries, 0 to 2887Data columns (total 39 columns): #   Column  Non-Null Count  Dtype  ---  ------  --------------  -----   0   V0      2888 non-null   float64 1   V1      2888 non-null   float64 2   V2      2888 non-null   float64 3   V3      2888 non-null   float64 4   V4      2888 non-null   float64 5   V5      2888 non-null   float64 6   V6      2888 non-null   float64 7   V7      2888 non-null   float64 8   V8      2888 non-null   float64 9   V9      2888 non-null   float64 10  V10     2888 non-null   float64 11  V11     2888 non-null   float64 12  V12     2888 non-null   float64 13  V13     2888 non-null   float64 14  V14     2888 non-null   float64 15  V15     2888 non-null   float64 16  V16     2888 non-null   float64 17  V17     2888 non-null   float64 18  V18     2888 non-null   float64 19  V19     2888 non-null   float64 20  V20     2888 non-null   float64 21  V21     2888 non-null   float64 22  V22     2888 non-null   float64 23  V23     2888 non-null   float64 24  V24     2888 non-null   float64 25  V25     2888 non-null   float64 26  V26     2888 non-null   float64 27  V27     2888 non-null   float64 28  V28     2888 non-null   float64 29  V29     2888 non-null   float64 30  V30     2888 non-null   float64 31  V31     2888 non-null   float64 32  V32     2888 non-null   float64 33  V33     2888 non-null   float64 34  V34     2888 non-null   float64 35  V35     2888 non-null   float64 36  V36     2888 non-null   float64 37  V37     2888 non-null   float64 38  target  2888 non-null   float64dtypes: float64(39)memory usage: 880.1 KB</code></pre><ol type="1"><li>此训练集数据共有2888个样本，数据中有V0-V37共计38个特征变量，变量类型都为数值类型，所有数据特征没有缺失值数据；</li><li>数据字段由于采用了脱敏处理，删除了特征数据的具体含义；</li><li>target字段为标签变量</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试集</span><br>test_data.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 1925 entries, 0 to 1924Data columns (total 38 columns): #   Column  Non-Null Count  Dtype  ---  ------  --------------  -----   0   V0      1925 non-null   float64 1   V1      1925 non-null   float64 2   V2      1925 non-null   float64 3   V3      1925 non-null   float64 4   V4      1925 non-null   float64 5   V5      1925 non-null   float64 6   V6      1925 non-null   float64 7   V7      1925 non-null   float64 8   V8      1925 non-null   float64 9   V9      1925 non-null   float64 10  V10     1925 non-null   float64 11  V11     1925 non-null   float64 12  V12     1925 non-null   float64 13  V13     1925 non-null   float64 14  V14     1925 non-null   float64 15  V15     1925 non-null   float64 16  V16     1925 non-null   float64 17  V17     1925 non-null   float64 18  V18     1925 non-null   float64 19  V19     1925 non-null   float64 20  V20     1925 non-null   float64 21  V21     1925 non-null   float64 22  V22     1925 non-null   float64 23  V23     1925 non-null   float64 24  V24     1925 non-null   float64 25  V25     1925 non-null   float64 26  V26     1925 non-null   float64 27  V27     1925 non-null   float64 28  V28     1925 non-null   float64 29  V29     1925 non-null   float64 30  V30     1925 non-null   float64 31  V31     1925 non-null   float64 32  V32     1925 non-null   float64 33  V33     1925 non-null   float64 34  V34     1925 non-null   float64 35  V35     1925 non-null   float64 36  V36     1925 non-null   float64 37  V37     1925 non-null   float64dtypes: float64(38)memory usage: 571.6 KB</code></pre><ol type="1"><li>测试集数据共有1925个样本，数据中有V0-V37共计38个特征变量，变量类型都为数值类型，无缺失值。</li><li>测试集中没有target字段（标签变量），需要我们预测并提交。</li></ol><h3 id="查看数据统计信息">3.2查看数据统计信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练集</span><br>train_data.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>...</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td></tr><tr><th>mean</th><td>0.123048</td><td>0.056068</td><td>0.289720</td><td>-0.067790</td><td>0.012921</td><td>-0.558565</td><td>0.182892</td><td>0.116155</td><td>0.177856</td><td>-0.169452</td><td>...</td><td>0.097648</td><td>0.055477</td><td>0.127791</td><td>0.020806</td><td>0.007801</td><td>0.006715</td><td>0.197764</td><td>0.030658</td><td>-0.130330</td><td>0.126353</td></tr><tr><th>std</th><td>0.928031</td><td>0.941515</td><td>0.911236</td><td>0.970298</td><td>0.888377</td><td>0.517957</td><td>0.918054</td><td>0.955116</td><td>0.895444</td><td>0.953813</td><td>...</td><td>1.061200</td><td>0.901934</td><td>0.873028</td><td>0.902584</td><td>1.006995</td><td>1.003291</td><td>0.985675</td><td>0.970812</td><td>1.017196</td><td>0.983966</td></tr><tr><th>min</th><td>-4.335000</td><td>-5.122000</td><td>-3.420000</td><td>-3.956000</td><td>-4.742000</td><td>-2.182000</td><td>-4.576000</td><td>-5.048000</td><td>-4.692000</td><td>-12.891000</td><td>...</td><td>-2.912000</td><td>-4.507000</td><td>-5.859000</td><td>-4.053000</td><td>-4.627000</td><td>-4.789000</td><td>-5.695000</td><td>-2.608000</td><td>-3.630000</td><td>-3.044000</td></tr><tr><th>25%</th><td>-0.297000</td><td>-0.226250</td><td>-0.313000</td><td>-0.652250</td><td>-0.385000</td><td>-0.853000</td><td>-0.310000</td><td>-0.295000</td><td>-0.159000</td><td>-0.390000</td><td>...</td><td>-0.664000</td><td>-0.283000</td><td>-0.170250</td><td>-0.407250</td><td>-0.499000</td><td>-0.290000</td><td>-0.202500</td><td>-0.413000</td><td>-0.798250</td><td>-0.350250</td></tr><tr><th>50%</th><td>0.359000</td><td>0.272500</td><td>0.386000</td><td>-0.044500</td><td>0.110000</td><td>-0.466000</td><td>0.388000</td><td>0.344000</td><td>0.362000</td><td>0.042000</td><td>...</td><td>-0.023000</td><td>0.053500</td><td>0.299500</td><td>0.039000</td><td>-0.040000</td><td>0.160000</td><td>0.364000</td><td>0.137000</td><td>-0.185500</td><td>0.313000</td></tr><tr><th>75%</th><td>0.726000</td><td>0.599000</td><td>0.918250</td><td>0.624000</td><td>0.550250</td><td>-0.154000</td><td>0.831250</td><td>0.782250</td><td>0.726000</td><td>0.042000</td><td>...</td><td>0.745250</td><td>0.488000</td><td>0.635000</td><td>0.557000</td><td>0.462000</td><td>0.273000</td><td>0.602000</td><td>0.644250</td><td>0.495250</td><td>0.793250</td></tr><tr><th>max</th><td>2.121000</td><td>1.918000</td><td>2.828000</td><td>2.457000</td><td>2.689000</td><td>0.489000</td><td>1.895000</td><td>1.918000</td><td>2.245000</td><td>1.335000</td><td>...</td><td>4.580000</td><td>2.689000</td><td>2.013000</td><td>2.395000</td><td>5.465000</td><td>5.110000</td><td>2.324000</td><td>5.238000</td><td>3.000000</td><td>2.538000</td></tr></tbody></table><p>8 rows × 39 columns</p></div><p>上面数据显示了数据的统计信息，例如样本数count，数据的平均值mean，标准差std，最小值min，最大值max等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试集</span><br>test_data.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V28</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th></tr></thead><tbody><tr><th>count</th><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>...</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td></tr><tr><th>mean</th><td>-0.184404</td><td>-0.083912</td><td>-0.434762</td><td>0.101671</td><td>-0.019172</td><td>0.838049</td><td>-0.274092</td><td>-0.173971</td><td>-0.266709</td><td>0.255114</td><td>...</td><td>-0.206871</td><td>-0.146463</td><td>-0.083215</td><td>-0.191729</td><td>-0.030782</td><td>-0.011433</td><td>-0.009985</td><td>-0.296895</td><td>-0.046270</td><td>0.195735</td></tr><tr><th>std</th><td>1.073333</td><td>1.076670</td><td>0.969541</td><td>1.034925</td><td>1.147286</td><td>0.963043</td><td>1.054119</td><td>1.040101</td><td>1.085916</td><td>1.014394</td><td>...</td><td>1.064140</td><td>0.880593</td><td>1.126414</td><td>1.138454</td><td>1.130228</td><td>0.989732</td><td>0.995213</td><td>0.946896</td><td>1.040854</td><td>0.940599</td></tr><tr><th>min</th><td>-4.814000</td><td>-5.488000</td><td>-4.283000</td><td>-3.276000</td><td>-4.921000</td><td>-1.168000</td><td>-5.649000</td><td>-5.625000</td><td>-6.059000</td><td>-6.784000</td><td>...</td><td>-2.435000</td><td>-2.413000</td><td>-4.507000</td><td>-7.698000</td><td>-4.057000</td><td>-4.627000</td><td>-4.789000</td><td>-7.477000</td><td>-2.608000</td><td>-3.346000</td></tr><tr><th>25%</th><td>-0.664000</td><td>-0.451000</td><td>-0.978000</td><td>-0.644000</td><td>-0.497000</td><td>0.122000</td><td>-0.732000</td><td>-0.509000</td><td>-0.775000</td><td>-0.390000</td><td>...</td><td>-0.453000</td><td>-0.818000</td><td>-0.339000</td><td>-0.476000</td><td>-0.472000</td><td>-0.460000</td><td>-0.290000</td><td>-0.349000</td><td>-0.593000</td><td>-0.432000</td></tr><tr><th>50%</th><td>0.065000</td><td>0.195000</td><td>-0.267000</td><td>0.220000</td><td>0.118000</td><td>0.437000</td><td>-0.082000</td><td>0.018000</td><td>-0.004000</td><td>0.401000</td><td>...</td><td>-0.445000</td><td>-0.199000</td><td>0.010000</td><td>0.100000</td><td>0.155000</td><td>-0.040000</td><td>0.160000</td><td>-0.270000</td><td>0.083000</td><td>0.152000</td></tr><tr><th>75%</th><td>0.549000</td><td>0.589000</td><td>0.278000</td><td>0.793000</td><td>0.610000</td><td>1.928000</td><td>0.457000</td><td>0.515000</td><td>0.482000</td><td>0.904000</td><td>...</td><td>-0.434000</td><td>0.468000</td><td>0.447000</td><td>0.471000</td><td>0.627000</td><td>0.419000</td><td>0.273000</td><td>0.364000</td><td>0.651000</td><td>0.797000</td></tr><tr><th>max</th><td>2.100000</td><td>2.120000</td><td>1.946000</td><td>2.603000</td><td>4.475000</td><td>3.176000</td><td>1.528000</td><td>1.394000</td><td>2.408000</td><td>1.766000</td><td>...</td><td>4.656000</td><td>3.022000</td><td>3.139000</td><td>1.428000</td><td>2.299000</td><td>5.465000</td><td>5.110000</td><td>1.671000</td><td>2.861000</td><td>3.021000</td></tr></tbody></table><p>8 rows × 38 columns</p></div><h3 id="查看数据字段信息">3.3查看数据字段信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>0</th><td>0.566</td><td>0.016</td><td>-0.143</td><td>0.407</td><td>0.452</td><td>-0.901</td><td>-1.812</td><td>-2.360</td><td>-0.436</td><td>-2.114</td><td>...</td><td>0.136</td><td>0.109</td><td>-0.615</td><td>0.327</td><td>-4.627</td><td>-4.789</td><td>-5.101</td><td>-2.608</td><td>-3.508</td><td>0.175</td></tr><tr><th>1</th><td>0.968</td><td>0.437</td><td>0.066</td><td>0.566</td><td>0.194</td><td>-0.893</td><td>-1.566</td><td>-2.360</td><td>0.332</td><td>-2.114</td><td>...</td><td>-0.128</td><td>0.124</td><td>0.032</td><td>0.600</td><td>-0.843</td><td>0.160</td><td>0.364</td><td>-0.335</td><td>-0.730</td><td>0.676</td></tr><tr><th>2</th><td>1.013</td><td>0.568</td><td>0.235</td><td>0.370</td><td>0.112</td><td>-0.797</td><td>-1.367</td><td>-2.360</td><td>0.396</td><td>-2.114</td><td>...</td><td>-0.009</td><td>0.361</td><td>0.277</td><td>-0.116</td><td>-0.843</td><td>0.160</td><td>0.364</td><td>0.765</td><td>-0.589</td><td>0.633</td></tr><tr><th>3</th><td>0.733</td><td>0.368</td><td>0.283</td><td>0.165</td><td>0.599</td><td>-0.679</td><td>-1.200</td><td>-2.086</td><td>0.403</td><td>-2.114</td><td>...</td><td>0.015</td><td>0.417</td><td>0.279</td><td>0.603</td><td>-0.843</td><td>-0.065</td><td>0.364</td><td>0.333</td><td>-0.112</td><td>0.206</td></tr><tr><th>4</th><td>0.684</td><td>0.638</td><td>0.260</td><td>0.209</td><td>0.337</td><td>-0.454</td><td>-1.073</td><td>-2.086</td><td>0.314</td><td>-2.114</td><td>...</td><td>0.183</td><td>1.078</td><td>0.328</td><td>0.418</td><td>-0.843</td><td>-0.215</td><td>0.364</td><td>-0.280</td><td>-0.028</td><td>0.384</td></tr></tbody></table><p>5 rows × 39 columns</p></div><p>上面显示训练集前5条数据的基本信息，可以看到数据都是浮点型数据，数据都是数值型连续型特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">test_data.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V28</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th></tr></thead><tbody><tr><th>0</th><td>0.368</td><td>0.380</td><td>-0.225</td><td>-0.049</td><td>0.379</td><td>0.092</td><td>0.550</td><td>0.551</td><td>0.244</td><td>0.904</td><td>...</td><td>-0.449</td><td>0.047</td><td>0.057</td><td>-0.042</td><td>0.847</td><td>0.534</td><td>-0.009</td><td>-0.190</td><td>-0.567</td><td>0.388</td></tr><tr><th>1</th><td>0.148</td><td>0.489</td><td>-0.247</td><td>-0.049</td><td>0.122</td><td>-0.201</td><td>0.487</td><td>0.493</td><td>-0.127</td><td>0.904</td><td>...</td><td>-0.443</td><td>0.047</td><td>0.560</td><td>0.176</td><td>0.551</td><td>0.046</td><td>-0.220</td><td>0.008</td><td>-0.294</td><td>0.104</td></tr><tr><th>2</th><td>-0.166</td><td>-0.062</td><td>-0.311</td><td>0.046</td><td>-0.055</td><td>0.063</td><td>0.485</td><td>0.493</td><td>-0.227</td><td>0.904</td><td>...</td><td>-0.458</td><td>-0.398</td><td>0.101</td><td>0.199</td><td>0.634</td><td>0.017</td><td>-0.234</td><td>0.008</td><td>0.373</td><td>0.569</td></tr><tr><th>3</th><td>0.102</td><td>0.294</td><td>-0.259</td><td>0.051</td><td>-0.183</td><td>0.148</td><td>0.474</td><td>0.504</td><td>0.010</td><td>0.904</td><td>...</td><td>-0.456</td><td>-0.398</td><td>1.007</td><td>0.137</td><td>1.042</td><td>-0.040</td><td>-0.290</td><td>0.008</td><td>-0.666</td><td>0.391</td></tr><tr><th>4</th><td>0.300</td><td>0.428</td><td>0.208</td><td>0.051</td><td>-0.033</td><td>0.116</td><td>0.408</td><td>0.497</td><td>0.155</td><td>0.904</td><td>...</td><td>-0.458</td><td>-0.776</td><td>0.291</td><td>0.370</td><td>0.181</td><td>-0.040</td><td>-0.290</td><td>0.008</td><td>-0.140</td><td>-0.497</td></tr></tbody></table><p>5 rows × 38 columns</p></div><h2 id="可视化数据分布">4可视化数据分布</h2><h3 id="箱形图">4.1箱形图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先绘制训练集中特征变量V0的箱形图：</span><br>fig = plt.figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>))  <span class="hljs-comment"># 指定绘图对象宽度和高度</span><br>sns.boxplot(train_data[<span class="hljs-string">&#x27;V0&#x27;</span>],orient=<span class="hljs-string">&quot;v&quot;</span>, width=<span class="hljs-number">0.5</span>) <br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;AxesSubplot:&gt;</code></pre><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_20_1.png" /> ​</p><p>从图中可以看出有偏离值，许多数据点位于下四分位点以下。</p><h4 id="代码详解">代码详解：</h4><ol type="1"><li><p><code>fig = plt.figure(figsize=(4, 6))</code> 创建一个画布，并指定宽度为4，高度为6。<code>plt</code> 是 matplotlib 库的一个模块，用于绘制数据可视化图形。</p></li><li><p><code>sns.boxplot(train_data['V0'],orient="v", width=0.5)</code> 绘制箱形图。<code>sns</code> 是 seaborn 库的一个模块，用于数据可视化。<code>boxplot</code> 是用于绘制箱形图的函数。<code>train_data['V0']</code> 表示从训练集中获取特征变量 V0 的数据进行绘制。<code>orient="v"</code> 表示将箱形图垂直绘制，即以竖直方向为主轴。<code>width=0.5</code> 表示箱形图的宽度为0.5。</p></li></ol><p>箱形图是一种用于展示数据分布和离群值的图形。它由一个矩形框和两条线（即“须”上限、下限）组成。矩形框表示数据的四分位数范围（上下四分位数之间的距离），中间的线表示中位数，须表示数据的整体分布情况。箱形图可以帮助我们观察数据的偏态、集中趋势以及离群值等信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># V0-V37的箱形图：</span><br>column = train_data.columns.tolist()[:<span class="hljs-number">39</span>]  <span class="hljs-comment"># 列表头,共39列，V0-target</span><br>fig = plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">40</span>))  <span class="hljs-comment"># 指定绘图对象宽度和高度</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">38</span>):<br>    plt.subplot(<span class="hljs-number">13</span>, <span class="hljs-number">3</span>, i + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 13行3列子图</span><br>    sns.boxplot(train_data[column[i]], orient=<span class="hljs-string">&quot;h&quot;</span>, width=<span class="hljs-number">0.5</span>)  <span class="hljs-comment"># 箱式图</span><br>    plt.ylabel(column[i], fontsize=<span class="hljs-number">8</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_23_0.png" /> ​</p><p>从图中发现数据存在许多偏离较大的异常值，可以考虑移除。</p><h4 id="代码详解-1">代码详解：</h4><ol type="1"><li><p><code>column = train_data.columns.tolist()[:39]</code> 获取训练集数据中前39（包含）列（即V0到target）的列名，并将其存储在列表 <code>column</code> 中。<code>train_data.columns</code> 返回数据集的所有列名，<code>tolist()</code> 将其转换为列表，<code>[:39]</code> 表示取列表中的前39个元素。</p></li><li><p><code>fig = plt.figure(figsize=(20, 40))</code> 创建一个画布，并指定宽度为20，高度为40。</p></li><li><p><code>for i in range(38):</code> 循环遍历从0到37的整数，对应特征变量 V0 到 V37。</p></li><li><p><code>plt.subplot(13, 3, i + 1)</code> 创建一个子图，将画布分为13行3列的网格，选中当前子图(i+1)进行绘制。<code>i + 1</code> 表示子图的编号，从1开始。</p></li><li><p><code>sns.boxplot(train_data[column[i]], orient="h", width=0.5)</code> 绘制箱形图。<code>train_data[column[i]]</code> 表示从训练集中获取第i个特征变量的数据进行绘制。<code>orient="h"</code> 表示将箱形图水平绘制，即以水平方向为主轴。<code>width=0.5</code> 表示箱形图的宽度为0.5。</p></li><li><p><code>plt.ylabel(column[i], fontsize=8)</code> 在每个子图上添加y轴标签，标签内容为对应的特征变量名称 <code>column[i]</code>，并设置字体大小为8。</p></li><li><p><code>plt.show()</code> 展示绘制的箱形图。</p></li></ol><h3 id="直方图和q-q图">4.2直方图和Q-Q图</h3><p>Q-Q图是指数据的分位数和正态分布的分位数对比参照的图，如果数据符合正态分布，则所有的点都会落在直线上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看特征变量‘V0’的数据分布直方图，并绘制Q-Q图查看数据是否近似于正态分布</span><br><br>plt.figure(figsize=(<span class="hljs-number">5</span>,<span class="hljs-number">2.5</span>))<br><br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>sns.distplot(train_data[<span class="hljs-string">&#x27;V0&#x27;</span>],fit=stats.norm)<br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>res = stats.probplot(train_data[<span class="hljs-string">&#x27;V0&#x27;</span>], plot=plt)<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_28_0.png" /> ​</p><p>可以看到，训练集中特征变量V0的分布不是正态分布。</p><h4 id="代码详解-2">代码详解：</h4><ol type="1"><li><p><code>plt.figure(figsize=(10,5))</code> 创建一个宽度为10，高度为5的画布对象。<code>figsize=(10,5)</code> 指定了画布的尺寸。</p></li><li><p><code>ax=plt.subplot(1,2,1)</code> 创建一个子图对象，并指定它位于画布的第1行，第2列中。这里的 <code>(1,2,1)</code> 表示将画布分为1行2列的网格，并选中第1个位置的子图。</p></li><li><p><code>sns.distplot(train_data['V0'],fit=stats.norm)</code> 在第一个子图中绘制特征变量 'V0' 的直方图。<code>train_data['V0']</code> 表示从训练集中获取 'V0' 特征变量的数据进行绘制。<code>sns.distplot()</code> 是 seaborn 库中的函数，用于绘制直方图并拟合参数化的概率密度函数（默认为正态分布，通过 <code>fit=stats.norm</code> 指定，表示使用正态分布拟合）。</p></li><li><p><code>ax=plt.subplot(1,2,2)</code> 创建第二个子图，并指定它位于画布的第1行，第2列中。这里的 <code>(1,2,2)</code> 表示将画布分为1行2列的网格，并选中第2个位置的子图。</p></li><li><p><code>res = stats.probplot(train_data['V0'], plot=plt)</code> 在第二个子图中绘制特征变量 'V0' 的概率图。<code>stats.probplot()</code> 是 scipy 库（科学计算库）中的函数，用于绘制概率图。它可以判断数据是否符合某种理论分布（这里使用了默认的正态分布）。<code>plot=plt</code> 表示将概率图绘制在指定的子图上。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看所有数据的直方图和Q-Q图</span><br>train_cols = <span class="hljs-number">6</span> <span class="hljs-comment"># 画布列数</span><br>train_rows = <span class="hljs-built_in">len</span>(train_data.columns) <span class="hljs-comment"># 画布行数</span><br>plt.figure(figsize=(<span class="hljs-number">5</span>*train_cols,<span class="hljs-number">5</span>*train_rows))<br><br>i=<span class="hljs-number">0</span> <span class="hljs-comment"># 一次循环两个自增，所以初始为0</span><br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> train_data.columns:<br>    i+=<span class="hljs-number">1</span><br>    ax=plt.subplot(train_rows,train_cols,i)<br>    sns.distplot(train_data[col],fit=stats.norm)<br>    <br>    i+=<span class="hljs-number">1</span><br>    ax=plt.subplot(train_rows,train_cols,i)<br>    res = stats.probplot(train_data[col], plot=plt)<br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_31_0.png" /> ​</p><p>由上面的数据分布图信息可以看出，很多特征变量（如'V1','V9','V24','V28'等）的数据分布不是正态的，数据并不跟随对角线，后续可以使用数据变换对数据进行转换。</p><h4 id="代码解释">代码解释：</h4><p>简单的图可以通过<code>plt.figure(figsize=(10, 5))</code>直接指定画布的大小。</p><p>在展示多个子图时，直接指定画布大小可能会导致子图之间的重叠或缺乏足够的空间来显示所有子图。从而导致布局混乱或信息重叠。</p><p>使用<code>plt.figure(figsize=(5*train_cols, 5*train_rows))</code>的方式更加灵活，它会自动根据数据集中的特征变量数量来计算所需的行数和列数，并相应地调整画布的大小。这样可以确保每个子图都有足够的空间进行展示，并且整体布局更加均衡和清晰。</p><h3 id="kde图">4.3KDE图</h3><p>KDE(Kernel Density Estimation,核密度估计)可以理解为是对直方图的加窗平滑。可以查看并对比训练集和测试集中特征变量的分布情况，发现两个数据集中分布不一致的特征变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对比同一特征变量‘V0’下，训练集数据和测试集数据的分布情况，查看数据分布是否一致</span><br>plt.figure(figsize=(<span class="hljs-number">5</span>,<span class="hljs-number">2.5</span>),dpi=<span class="hljs-number">150</span>)<br>ax = sns.kdeplot(train_data[<span class="hljs-string">&#x27;V0&#x27;</span>], color=<span class="hljs-string">&quot;Red&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>ax = sns.kdeplot(test_data[<span class="hljs-string">&#x27;V0&#x27;</span>], color=<span class="hljs-string">&quot;Blue&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>ax.set_xlabel(<span class="hljs-string">&#x27;V0&#x27;</span>)<br>ax.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>ax = ax.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_35_0.png" /> ​</p><p>可以看到，V0在两个数据集中的分布基本一致。</p><h4 id="代码详解-3">代码详解：</h4><ol type="1"><li><p><code>plt.figure(figsize=(8,4), dpi=150)</code>：创建一个画布，指定尺寸为宽度8英寸，高度4英寸，dpi（每英寸像素点数）为150，数值越高质量越好，不指定有默认。</p></li><li><p><code>ax = sns.kdeplot(train_data['V0'], color="Red", shade=True)</code>：使用 Seaborn 库的 <code>kdeplot</code> 函数绘制训练数据集中特征变量 <code>'V0'</code> 的核密度估计曲线。<code>color="Red"</code> 指定曲线的颜色为红色，<code>shade=True</code> 表示曲线下方填充阴影以突出密度分布。</p></li><li><p><code>ax = sns.kdeplot(test_data['V0'], color="Blue", shade=True)</code>：类似地，使用 <code>kdeplot</code> 函数在同一图形上绘制测试数据集中特征变量 <code>'V0'</code> 的核密度估计曲线。这里设置曲线颜色为蓝色。</p></li><li><p><code>ax.set_xlabel('V0')</code>：设置 x 轴的标签为 <code>'V0'</code>。</p></li><li><p><code>ax.set_ylabel("Frequency")</code>：设置 y 轴的标签为 <code>'Frequency'</code>。</p></li><li><p><code>ax = ax.legend(["train","test"])</code>：添加图例。该语句首先通过 <code>ax.legend()</code> 方法在当前的轴对象 <code>ax</code> 上添加图例，然后使用 <code>["train", "test"]</code> 指定图例的标签。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看所有变量在训练集和测试集的KDE分布情况，分析并寻找出数据分布不一致的特征变量。</span><br>dist_cols = <span class="hljs-number">6</span><br>dist_rows = <span class="hljs-built_in">len</span>(test_data.columns)<br>plt.figure(figsize=(<span class="hljs-number">4</span>*dist_cols,<span class="hljs-number">4</span>*dist_rows))<br><br>i=<span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> test_data.columns:<br>    ax=plt.subplot(dist_rows,dist_cols,i)<br>    ax = sns.kdeplot(train_data[col], color=<span class="hljs-string">&quot;Red&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax = sns.kdeplot(test_data[col], color=<span class="hljs-string">&quot;Blue&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax.set_xlabel(col)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    ax = ax.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br>    <br>    i+=<span class="hljs-number">1</span><br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_38_0.png" /> ​</p><p>可以发现，特征变量V5,V9,V11,V17,V22,V28在训练集与测试集中的分布不一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看特征V5,V9,V11,V17,V22,V28数据的数据分布</span><br>drop_col = <span class="hljs-number">6</span><br>drop_row = <span class="hljs-number">1</span><br><br>plt.figure(figsize=(<span class="hljs-number">5</span>*drop_col,<span class="hljs-number">5</span>*drop_row))<br><br>i=<span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;V5&quot;</span>,<span class="hljs-string">&quot;V9&quot;</span>,<span class="hljs-string">&quot;V11&quot;</span>,<span class="hljs-string">&quot;V17&quot;</span>,<span class="hljs-string">&quot;V22&quot;</span>,<span class="hljs-string">&quot;V28&quot;</span>]:<br>    ax =plt.subplot(drop_row,drop_col,i)<br>    ax = sns.kdeplot(train_data[col], color=<span class="hljs-string">&quot;Red&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax = sns.kdeplot(test_data[col], color=<span class="hljs-string">&quot;Blue&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax.set_xlabel(col)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    ax = ax.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br>    <br>    i+=<span class="hljs-number">1</span><br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_40_0.png" /> ​</p><p>由上图的数据分布可以看到特征'V5','V9','V11','V17','V22','V28' 训练集数据与测试集数据分布不一致，会导致模型泛化能力差，采用删除此类特征方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">drop_columns = [<span class="hljs-string">&#x27;V5&#x27;</span>,<span class="hljs-string">&#x27;V9&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>,<span class="hljs-string">&#x27;V17&#x27;</span>,<span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V28&#x27;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#合并训练集和测试集数据，并可视化训练集和测试集数据特征分布图</span><br></code></pre></td></tr></table></figure><h3 id="线性回归关系图">4.4线性回归关系图</h3><p>线性回归关系图主要用于分析变量之间的线性回归关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看‘V0’与&#x27;target&#x27;变量的线性回归关系</span><br>fcols = <span class="hljs-number">2</span><br>frows = <span class="hljs-number">1</span><br>plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))<br><br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>sns.regplot(x=<span class="hljs-string">&#x27;V0&#x27;</span>, y=<span class="hljs-string">&#x27;target&#x27;</span>, data=train_data, ax=ax, <br>            scatter_kws=&#123;<span class="hljs-string">&#x27;marker&#x27;</span>:<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;alpha&#x27;</span>:<span class="hljs-number">0.3</span>&#125;,<br>            line_kws=&#123;<span class="hljs-string">&#x27;color&#x27;</span>:<span class="hljs-string">&#x27;k&#x27;</span>&#125;);<br>plt.xlabel(<span class="hljs-string">&#x27;V0&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;target&#x27;</span>)<br><br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>sns.distplot(train_data[<span class="hljs-string">&#x27;V0&#x27;</span>].dropna())<br>plt.xlabel(<span class="hljs-string">&#x27;V0&#x27;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_45_0.png" /> ​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看所有特征变量与&#x27;target&#x27;变量的线性回归关系</span><br>fcols = <span class="hljs-number">6</span><br>frows = <span class="hljs-built_in">len</span>(test_data.columns)<br>plt.figure(figsize=(<span class="hljs-number">5</span>*fcols,<span class="hljs-number">4</span>*frows))<br><br>i=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> test_data.columns:<br>    i+=<span class="hljs-number">1</span><br>    ax=plt.subplot(frows,fcols,i)<br>    sns.regplot(x=col, y=<span class="hljs-string">&#x27;target&#x27;</span>, data=train_data, ax=ax, <br>                scatter_kws=&#123;<span class="hljs-string">&#x27;marker&#x27;</span>:<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;alpha&#x27;</span>:<span class="hljs-number">0.3</span>&#125;,<br>                line_kws=&#123;<span class="hljs-string">&#x27;color&#x27;</span>:<span class="hljs-string">&#x27;k&#x27;</span>&#125;);<br>    plt.xlabel(col)<br>    plt.ylabel(<span class="hljs-string">&#x27;target&#x27;</span>)<br>    <br>    i+=<span class="hljs-number">1</span><br>    ax=plt.subplot(frows,fcols,i)<br>    sns.distplot(train_data[col].dropna())<br>    plt.xlabel(col)<br>    <br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_46_0.png" /> ​</p><h4 id="代码解释-1">代码解释：</h4><p>散点图： 使用 Seaborn 库中的 <code>regplot</code> 函数来绘制自变量 <code>col</code> 与因变量 <code>'target'</code> 之间的散点图，并拟合一条线性回归线。</p><ul><li><code>x=col</code> 表示自变量的数据是 <code>col</code>，即当前循环遍历到的特征变量。</li><li><code>y='target'</code> 表示因变量的数据是 <code>'target'</code>，即目标变量。</li><li><code>data=train_data</code> 表示数据集是 <code>train_data</code>，即训练数据集。</li><li><code>ax=ax</code> 表示将子图对象 <code>ax</code> 分配给 <code>regplot</code> 函数来绘制子图。</li><li><code>scatter_kws=&#123;'marker':'.','s':3,'alpha':0.3&#125;</code> 设置散点图的样式参数。这里使用了小圆点作为散点图的标记，设置了透明度（<code>alpha</code>）、大小（<code>s</code>）和颜色（默认颜色）。</li><li><code>line_kws=&#123;'color':'k'&#125;</code> 设置回归线的样式参数。这里将回归线的颜色设置为黑色（<code>'k'</code> 是黑色的简写）。</li></ul><p>直方图： <code>sns.distplot(train_data[col].dropna())</code>绘制特征变量 <code>col</code>的直方图和核密度估计曲线。<code>dropna()</code>函数用于移除其中的缺失值（NaN值）。</p><h2 id="查看特征变量的相关性">5查看特征变量的相关性</h2><p>对特征变量的相关性进行分析，可以发现特征变量和目标变量及特征变量之间的关系，为在特征工程中提取特征做准备。</p><h3 id="计算相关性系数">5.1计算相关性系数</h3><p>在删除训练集和测试集中分布不一致的特征变量，如V5,V9,V11,V17,V22,V28之后，计算剩余特征变量及taret变量的相关性系数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pd.set_option (&#x27;display.max_columns&#x27;,10) # 显示最大列数，为10列，其他折叠起来</span><br><span class="hljs-comment"># pd.set_option(&#x27;display.max_rows&#x27;,10) # 显示最大行数，为10行，其他折叠起来</span><br><br>data_train1 = train_data.drop([<span class="hljs-string">&#x27;V5&#x27;</span>,<span class="hljs-string">&#x27;V9&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>,<span class="hljs-string">&#x27;V17&#x27;</span>,<span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V28&#x27;</span>],axis=<span class="hljs-number">1</span>)<br><br>train_corr = data_train1.corr()<br>train_corr<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V6</th><th>V7</th><th>V8</th><th>V10</th><th>V12</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>V0</th><td>1.000000</td><td>0.908607</td><td>0.463643</td><td>0.409576</td><td>0.781212</td><td>0.189267</td><td>0.141294</td><td>0.794013</td><td>0.298443</td><td>0.751830</td><td>...</td><td>0.302145</td><td>0.156968</td><td>0.675003</td><td>0.050951</td><td>0.056439</td><td>-0.019342</td><td>0.138933</td><td>0.231417</td><td>-0.494076</td><td>0.873212</td></tr><tr><th>V1</th><td>0.908607</td><td>1.000000</td><td>0.506514</td><td>0.383924</td><td>0.657790</td><td>0.276805</td><td>0.205023</td><td>0.874650</td><td>0.310120</td><td>0.656186</td><td>...</td><td>0.147096</td><td>0.175997</td><td>0.769745</td><td>0.085604</td><td>0.035129</td><td>-0.029115</td><td>0.146329</td><td>0.235299</td><td>-0.494043</td><td>0.871846</td></tr><tr><th>V2</th><td>0.463643</td><td>0.506514</td><td>1.000000</td><td>0.410148</td><td>0.057697</td><td>0.615938</td><td>0.477114</td><td>0.703431</td><td>0.346006</td><td>0.059941</td><td>...</td><td>-0.275764</td><td>0.175943</td><td>0.653764</td><td>0.033942</td><td>0.050309</td><td>-0.025620</td><td>0.043648</td><td>0.316462</td><td>-0.734956</td><td>0.638878</td></tr><tr><th>V3</th><td>0.409576</td><td>0.383924</td><td>0.410148</td><td>1.000000</td><td>0.315046</td><td>0.233896</td><td>0.197836</td><td>0.411946</td><td>0.321262</td><td>0.306397</td><td>...</td><td>0.117610</td><td>0.043966</td><td>0.421954</td><td>-0.092423</td><td>-0.007159</td><td>-0.031898</td><td>0.080034</td><td>0.324475</td><td>-0.229613</td><td>0.512074</td></tr><tr><th>V4</th><td>0.781212</td><td>0.657790</td><td>0.057697</td><td>0.315046</td><td>1.000000</td><td>-0.117529</td><td>-0.052370</td><td>0.449542</td><td>0.141129</td><td>0.927685</td><td>...</td><td>0.659093</td><td>0.022807</td><td>0.447016</td><td>-0.026186</td><td>0.062367</td><td>0.028659</td><td>0.100010</td><td>0.113609</td><td>-0.031054</td><td>0.603984</td></tr><tr><th>V6</th><td>0.189267</td><td>0.276805</td><td>0.615938</td><td>0.233896</td><td>-0.117529</td><td>1.000000</td><td>0.917502</td><td>0.468233</td><td>0.415660</td><td>-0.087312</td><td>...</td><td>-0.467980</td><td>0.188907</td><td>0.546535</td><td>0.144550</td><td>0.054210</td><td>-0.002914</td><td>0.044992</td><td>0.433804</td><td>-0.404817</td><td>0.370037</td></tr><tr><th>V7</th><td>0.141294</td><td>0.205023</td><td>0.477114</td><td>0.197836</td><td>-0.052370</td><td>0.917502</td><td>1.000000</td><td>0.389987</td><td>0.310982</td><td>-0.036791</td><td>...</td><td>-0.311363</td><td>0.170113</td><td>0.475254</td><td>0.122707</td><td>0.034508</td><td>-0.019103</td><td>0.111166</td><td>0.340479</td><td>-0.292285</td><td>0.287815</td></tr><tr><th>V8</th><td>0.794013</td><td>0.874650</td><td>0.703431</td><td>0.411946</td><td>0.449542</td><td>0.468233</td><td>0.389987</td><td>1.000000</td><td>0.419703</td><td>0.420557</td><td>...</td><td>-0.011091</td><td>0.150258</td><td>0.878072</td><td>0.038430</td><td>0.026843</td><td>-0.036297</td><td>0.179167</td><td>0.326586</td><td>-0.553121</td><td>0.831904</td></tr><tr><th>V10</th><td>0.298443</td><td>0.310120</td><td>0.346006</td><td>0.321262</td><td>0.141129</td><td>0.415660</td><td>0.310982</td><td>0.419703</td><td>1.000000</td><td>0.140462</td><td>...</td><td>-0.105042</td><td>-0.036705</td><td>0.560213</td><td>-0.093213</td><td>0.016739</td><td>-0.026994</td><td>0.026846</td><td>0.922190</td><td>-0.045851</td><td>0.394767</td></tr><tr><th>V12</th><td>0.751830</td><td>0.656186</td><td>0.059941</td><td>0.306397</td><td>0.927685</td><td>-0.087312</td><td>-0.036791</td><td>0.420557</td><td>0.140462</td><td>1.000000</td><td>...</td><td>0.666775</td><td>0.028866</td><td>0.441963</td><td>-0.007658</td><td>0.046674</td><td>0.010122</td><td>0.081963</td><td>0.112150</td><td>-0.054827</td><td>0.594189</td></tr><tr><th>V13</th><td>0.185144</td><td>0.157518</td><td>0.204762</td><td>-0.003636</td><td>0.075993</td><td>0.138367</td><td>0.110973</td><td>0.153299</td><td>-0.059553</td><td>0.098771</td><td>...</td><td>0.008235</td><td>0.027328</td><td>0.113743</td><td>0.130598</td><td>0.157513</td><td>0.116944</td><td>0.219906</td><td>-0.024751</td><td>-0.379714</td><td>0.203373</td></tr><tr><th>V14</th><td>-0.004144</td><td>-0.006268</td><td>-0.106282</td><td>-0.232677</td><td>0.023853</td><td>0.072911</td><td>0.163931</td><td>0.008138</td><td>-0.077543</td><td>0.020069</td><td>...</td><td>0.056814</td><td>-0.004057</td><td>0.010989</td><td>0.106581</td><td>0.073535</td><td>0.043218</td><td>0.233523</td><td>-0.086217</td><td>0.010553</td><td>0.008424</td></tr><tr><th>V15</th><td>0.314520</td><td>0.164702</td><td>-0.224573</td><td>0.143457</td><td>0.615704</td><td>-0.431542</td><td>-0.291272</td><td>0.018366</td><td>-0.046737</td><td>0.642081</td><td>...</td><td>0.951314</td><td>-0.111311</td><td>0.011768</td><td>-0.104618</td><td>0.050254</td><td>0.048602</td><td>0.100817</td><td>-0.051861</td><td>0.245635</td><td>0.154020</td></tr><tr><th>V16</th><td>0.347357</td><td>0.435606</td><td>0.782474</td><td>0.394517</td><td>0.023818</td><td>0.847119</td><td>0.752683</td><td>0.680031</td><td>0.546975</td><td>0.025736</td><td>...</td><td>-0.342210</td><td>0.154794</td><td>0.778538</td><td>0.041474</td><td>0.028878</td><td>-0.054775</td><td>0.082293</td><td>0.551880</td><td>-0.420053</td><td>0.536748</td></tr><tr><th>V18</th><td>0.148622</td><td>0.123862</td><td>0.132105</td><td>0.022868</td><td>0.136022</td><td>0.110570</td><td>0.098691</td><td>0.093682</td><td>-0.024693</td><td>0.119833</td><td>...</td><td>0.053958</td><td>0.470341</td><td>0.079718</td><td>0.411967</td><td>0.512139</td><td>0.365410</td><td>0.152088</td><td>0.019603</td><td>-0.181937</td><td>0.170721</td></tr><tr><th>V19</th><td>-0.100294</td><td>-0.092673</td><td>-0.161802</td><td>-0.246008</td><td>-0.205729</td><td>0.215290</td><td>0.158371</td><td>-0.144693</td><td>0.074903</td><td>-0.148319</td><td>...</td><td>-0.205409</td><td>0.100133</td><td>-0.131542</td><td>0.144018</td><td>-0.021517</td><td>-0.079753</td><td>-0.220737</td><td>0.087605</td><td>0.012115</td><td>-0.114976</td></tr><tr><th>V20</th><td>0.462493</td><td>0.459795</td><td>0.298385</td><td>0.289594</td><td>0.291309</td><td>0.136091</td><td>0.089399</td><td>0.412868</td><td>0.207612</td><td>0.271559</td><td>...</td><td>0.016233</td><td>0.086165</td><td>0.326863</td><td>0.050699</td><td>0.009358</td><td>-0.000979</td><td>0.048981</td><td>0.161315</td><td>-0.322006</td><td>0.444965</td></tr><tr><th>V21</th><td>-0.029285</td><td>-0.012911</td><td>-0.030932</td><td>0.114373</td><td>0.174025</td><td>-0.051806</td><td>-0.065300</td><td>-0.047839</td><td>0.082288</td><td>0.144371</td><td>...</td><td>0.157097</td><td>-0.077945</td><td>0.053025</td><td>-0.159128</td><td>-0.087561</td><td>-0.053707</td><td>-0.199398</td><td>0.047340</td><td>0.315470</td><td>-0.010063</td></tr><tr><th>V23</th><td>0.231136</td><td>0.222574</td><td>0.065509</td><td>0.081374</td><td>0.196530</td><td>0.069901</td><td>0.125180</td><td>0.174124</td><td>-0.066537</td><td>0.180049</td><td>...</td><td>0.116122</td><td>0.363963</td><td>0.129783</td><td>0.367086</td><td>0.183666</td><td>0.196681</td><td>0.635252</td><td>-0.035949</td><td>-0.187582</td><td>0.226331</td></tr><tr><th>V24</th><td>-0.324959</td><td>-0.233556</td><td>0.010225</td><td>-0.237326</td><td>-0.529866</td><td>0.072418</td><td>-0.030292</td><td>-0.136898</td><td>-0.029420</td><td>-0.550881</td><td>...</td><td>-0.642370</td><td>0.033532</td><td>-0.202097</td><td>0.060608</td><td>-0.134320</td><td>-0.095588</td><td>-0.243738</td><td>-0.041325</td><td>-0.137614</td><td>-0.264815</td></tr><tr><th>V25</th><td>-0.200706</td><td>-0.070627</td><td>0.481785</td><td>-0.100569</td><td>-0.444375</td><td>0.438610</td><td>0.316744</td><td>0.173320</td><td>0.079805</td><td>-0.448877</td><td>...</td><td>-0.575154</td><td>0.088238</td><td>0.201243</td><td>0.065501</td><td>-0.013312</td><td>-0.030747</td><td>-0.093948</td><td>0.069302</td><td>-0.246742</td><td>-0.019373</td></tr><tr><th>V26</th><td>-0.125140</td><td>-0.043012</td><td>0.035370</td><td>-0.027685</td><td>-0.080487</td><td>0.106055</td><td>0.160566</td><td>0.015724</td><td>0.072366</td><td>-0.124111</td><td>...</td><td>-0.133694</td><td>-0.057247</td><td>0.062879</td><td>-0.004545</td><td>-0.034596</td><td>0.051294</td><td>0.085576</td><td>0.064963</td><td>0.010880</td><td>-0.046724</td></tr><tr><th>V27</th><td>0.733198</td><td>0.824198</td><td>0.726250</td><td>0.392006</td><td>0.412083</td><td>0.474441</td><td>0.424185</td><td>0.901100</td><td>0.246085</td><td>0.374380</td><td>...</td><td>-0.032772</td><td>0.208074</td><td>0.790239</td><td>0.095127</td><td>0.030135</td><td>-0.036123</td><td>0.159884</td><td>0.226713</td><td>-0.617771</td><td>0.812585</td></tr><tr><th>V29</th><td>0.302145</td><td>0.147096</td><td>-0.275764</td><td>0.117610</td><td>0.659093</td><td>-0.467980</td><td>-0.311363</td><td>-0.011091</td><td>-0.105042</td><td>0.666775</td><td>...</td><td>1.000000</td><td>-0.122817</td><td>-0.004364</td><td>-0.110699</td><td>0.035272</td><td>0.035392</td><td>0.078588</td><td>-0.099309</td><td>0.285581</td><td>0.123329</td></tr><tr><th>V30</th><td>0.156968</td><td>0.175997</td><td>0.175943</td><td>0.043966</td><td>0.022807</td><td>0.188907</td><td>0.170113</td><td>0.150258</td><td>-0.036705</td><td>0.028866</td><td>...</td><td>-0.122817</td><td>1.000000</td><td>0.114318</td><td>0.695725</td><td>0.083693</td><td>-0.028573</td><td>-0.027987</td><td>0.006961</td><td>-0.256814</td><td>0.187311</td></tr><tr><th>V31</th><td>0.675003</td><td>0.769745</td><td>0.653764</td><td>0.421954</td><td>0.447016</td><td>0.546535</td><td>0.475254</td><td>0.878072</td><td>0.560213</td><td>0.441963</td><td>...</td><td>-0.004364</td><td>0.114318</td><td>1.000000</td><td>0.016782</td><td>0.016733</td><td>-0.047273</td><td>0.152314</td><td>0.510851</td><td>-0.357785</td><td>0.750297</td></tr><tr><th>V32</th><td>0.050951</td><td>0.085604</td><td>0.033942</td><td>-0.092423</td><td>-0.026186</td><td>0.144550</td><td>0.122707</td><td>0.038430</td><td>-0.093213</td><td>-0.007658</td><td>...</td><td>-0.110699</td><td>0.695725</td><td>0.016782</td><td>1.000000</td><td>0.105255</td><td>0.069300</td><td>0.016901</td><td>-0.054411</td><td>-0.162417</td><td>0.066606</td></tr><tr><th>V33</th><td>0.056439</td><td>0.035129</td><td>0.050309</td><td>-0.007159</td><td>0.062367</td><td>0.054210</td><td>0.034508</td><td>0.026843</td><td>0.016739</td><td>0.046674</td><td>...</td><td>0.035272</td><td>0.083693</td><td>0.016733</td><td>0.105255</td><td>1.000000</td><td>0.719126</td><td>0.167597</td><td>0.031586</td><td>-0.062715</td><td>0.077273</td></tr><tr><th>V34</th><td>-0.019342</td><td>-0.029115</td><td>-0.025620</td><td>-0.031898</td><td>0.028659</td><td>-0.002914</td><td>-0.019103</td><td>-0.036297</td><td>-0.026994</td><td>0.010122</td><td>...</td><td>0.035392</td><td>-0.028573</td><td>-0.047273</td><td>0.069300</td><td>0.719126</td><td>1.000000</td><td>0.233616</td><td>-0.019032</td><td>-0.006854</td><td>-0.006034</td></tr><tr><th>V35</th><td>0.138933</td><td>0.146329</td><td>0.043648</td><td>0.080034</td><td>0.100010</td><td>0.044992</td><td>0.111166</td><td>0.179167</td><td>0.026846</td><td>0.081963</td><td>...</td><td>0.078588</td><td>-0.027987</td><td>0.152314</td><td>0.016901</td><td>0.167597</td><td>0.233616</td><td>1.000000</td><td>0.025401</td><td>-0.077991</td><td>0.140294</td></tr><tr><th>V36</th><td>0.231417</td><td>0.235299</td><td>0.316462</td><td>0.324475</td><td>0.113609</td><td>0.433804</td><td>0.340479</td><td>0.326586</td><td>0.922190</td><td>0.112150</td><td>...</td><td>-0.099309</td><td>0.006961</td><td>0.510851</td><td>-0.054411</td><td>0.031586</td><td>-0.019032</td><td>0.025401</td><td>1.000000</td><td>-0.039478</td><td>0.319309</td></tr><tr><th>V37</th><td>-0.494076</td><td>-0.494043</td><td>-0.734956</td><td>-0.229613</td><td>-0.031054</td><td>-0.404817</td><td>-0.292285</td><td>-0.553121</td><td>-0.045851</td><td>-0.054827</td><td>...</td><td>0.285581</td><td>-0.256814</td><td>-0.357785</td><td>-0.162417</td><td>-0.062715</td><td>-0.006854</td><td>-0.077991</td><td>-0.039478</td><td>1.000000</td><td>-0.565795</td></tr><tr><th>target</th><td>0.873212</td><td>0.871846</td><td>0.638878</td><td>0.512074</td><td>0.603984</td><td>0.370037</td><td>0.287815</td><td>0.831904</td><td>0.394767</td><td>0.594189</td><td>...</td><td>0.123329</td><td>0.187311</td><td>0.750297</td><td>0.066606</td><td>0.077273</td><td>-0.006034</td><td>0.140294</td><td>0.319309</td><td>-0.565795</td><td>1.000000</td></tr></tbody></table><p>33 rows × 33 columns</p></div><h3 id="相关性热力图">5.2相关性热力图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画出相关性热力图</span><br>ax = plt.subplots(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">16</span>))<span class="hljs-comment">#调整画布大小</span><br><br>ax = sns.heatmap(train_corr, vmax=<span class="hljs-number">.8</span>, square=<span class="hljs-literal">True</span>, annot=<span class="hljs-literal">True</span>)<span class="hljs-comment">#画热力图   annot=True 显示系数</span><br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_52_0.png" /> ​</p><h4 id="代码解释-2">代码解释：</h4><p>使用Seaborn库中的<code>heatmap()</code>函数来绘制相关性热力图。</p><ul><li><code>ax = sns.heatmap(train_corr, vmax=.8, square=True, annot=True)</code> 在当前图像对象中绘制热力图。<code>train_corr</code>先前计算的相关系数矩阵。<code>vmax</code>参数用于设置颜色映射的最大值，即相关系数的范围。<code>square=True</code>将使得热力图的每个方块为正方形。<code>annot=True</code>表示在热力图中显示相关系数的数值。</li></ul><p><code>vmax</code>参数用于设置颜色映射的最大值，即相关系数的上限。通过将<code>vmax</code>设置为0.8，意味着相关系数的范围将被限制在0到0.8之间。任何具有相关系数大于0.8的值都将被映射为最浅的颜色。</p><p>通常，颜色映射是根据相关系数的值来定义的，例如，浅色可能表示正相关，深色可能表示负相关，中间色调可能表示无相关性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找出相关程度</span><br>data_train1 = train_data.drop([<span class="hljs-string">&#x27;V5&#x27;</span>,<span class="hljs-string">&#x27;V9&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>,<span class="hljs-string">&#x27;V17&#x27;</span>,<span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V28&#x27;</span>],axis=<span class="hljs-number">1</span>)<br><br>plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">16</span>))  <span class="hljs-comment"># 指定绘图对象宽度和高度</span><br>colnm = data_train1.columns.tolist()  <span class="hljs-comment"># 列表头</span><br>mcorr = data_train1[colnm].corr(method=<span class="hljs-string">&quot;spearman&quot;</span>)  <span class="hljs-comment"># 相关系数矩阵，即给出了任意两个变量之间的相关系数</span><br>mask = np.zeros_like(mcorr, dtype=np.<span class="hljs-built_in">bool</span>)  <span class="hljs-comment"># 构造与mcorr同维数矩阵 为bool型</span><br>mask[np.triu_indices_from(mask)] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 角分线右侧为True</span><br>cmap = sns.diverging_palette(<span class="hljs-number">220</span>, <span class="hljs-number">10</span>, as_cmap=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 返回matplotlib colormap对象</span><br>g = sns.heatmap(mcorr, mask=mask, cmap=cmap, square=<span class="hljs-literal">True</span>, annot=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">&#x27;0.2f&#x27;</span>)  <span class="hljs-comment"># 热力图（看两两相似度）</span><br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_54_0.png" /> ​</p><p>上图为所有特征变量和target变量两两之间的相关系数，由此可以看出各个特征变量V0-V37之间的相关性以及特征变量V0-V37与target的相关性。</p><h4 id="代码详解-4">代码详解：</h4><ol type="1"><li><p><code>mcorr = data_train1[colnm].corr(method="spearman")</code>计算了给定变量列表<code>[colnm]</code>中两两变量之间的相关系数矩阵，使用Spearman秩相关系数方法，该方法更适用于非线性关系的数据，而且对异常值的影响较小。</p></li><li><p><code>np.zeros_like(mcorr, dtype=np.bool)</code>构建了一个与相关系数矩阵 <code>mcorr</code> 维度相同的布尔型矩阵 <code>mask</code>，并将其所有元素初始化为False。这个矩阵 <code>mask</code> 将用于在热力图中标记需要遮挡的区域。<code>np.zeros_like</code>用于创建一个与给定数组（或者与给定数组形状相同）具有相同形状的全零数组。</p></li><li><p><code>mask[np.triu_indices_from(mask)] = True</code>将对角线右上方的元素设为True，在热力图中这些区域将被遮挡起来，只显示对角线左下方的相关系数。</p></li></ol><ul><li><code>np.triu_indices_from()</code> 函数用于获取一个上三角矩阵的索引。</li><li><code>np.triu_indices_from(mask)</code>我们可以获取 mask 矩阵中上三角区域的所有元素的索引。然后，将这些索引对应的位置在 mask 矩阵中设置为 <code>True</code>，表示需要将相关系数矩阵中对应的元素掩盖起来。</li></ul><ol start="4" type="1"><li><code>cmap = sns.diverging_palette(220, 10, as_cmap=True)</code>利用Seaborn库中的<code>diverging_palette</code>函数创建了一个颜色映射(color map)对象 <code>cmap</code>，用于渲染热力图的颜色。</li></ol><ul><li><code>sns.diverging_palette()</code> 函数用于生成一个离散的、具有对比度的颜色调色板。它接受三个参数：<code>start</code>、<code>end</code> 和 <code>as_cmap</code>。</li><li><code>start</code> 和 <code>end</code> 是起始颜色和结束颜色的色调值（hue），取值范围为 [0, 360]。在这里，起始颜色的色调值为 220，结束颜色的色调值为 10。这意味着生成的调色板将从蓝绿色渐变到橙红色。</li><li><code>as_cmap=True</code> 表示将调色板转换为 colormap 对象，以便在绘图时使用。</li></ul><ol start="5" type="1"><li><code>g = sns.heatmap(mcorr, mask=mask, cmap=cmap, square=True, annot=True, fmt='0.2f')</code>生成热力图。其中，<code>mcorr</code>为相关系数矩阵，<code>mask</code>用于指定需要遮挡的区域，<code>cmap</code>为颜色映射对象，<code>square=True</code>表示将热力图显示为正方形，<code>annot=True</code>表示在热力图中显示相关系数的数值，<code>fmt='0.2f'</code>指定数值显示格式为保留两位小数。</li></ol><h3 id="根据相关系数筛选特征变量">5.3根据相关系数筛选特征变量</h3><p>以方便我们后续做特征工程及模型分析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先寻找K个与target变量最相关的特征变量</span><br>k = <span class="hljs-number">10</span> <span class="hljs-comment"># number of variables for heatmap</span><br>cols = train_corr.nlargest(k, <span class="hljs-string">&#x27;target&#x27;</span>)[<span class="hljs-string">&#x27;target&#x27;</span>].index <span class="hljs-comment"># 返回特征名</span><br><br>cm = np.corrcoef(train_data[cols].values.T)<br>hm = plt.subplots(figsize=(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>))<span class="hljs-comment">#调整画布大小</span><br><span class="hljs-comment">#hm1 = sns.heatmap(cm, cbar=True, annot=True, square=True) # 与hm结果相同，只是无标签.cbar=True 是在绘制相关性热力图时，添加了一个颜色条（color bar）来表示相关系数的范围。</span><br><span class="hljs-comment">#g = sns.heatmap(train_data[cols].corr(),annot=True,square=True,cmap=&quot;RdYlGn&quot;) # 与hm结果相同，只是配色不同. cmap=&quot;RdYlGn&quot; 指定颜色映射为 &quot;RdYlGn&quot;。</span><br>hm = sns.heatmap(train_data[cols].corr(),annot=<span class="hljs-literal">True</span>,square=<span class="hljs-literal">True</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_58_0.png" /> ​</p><h4 id="代码详解-5">代码详解：</h4><ol type="1"><li><code>train_corr.nlargest(k, 'target')['target'].index</code> 用于找到与目标变量相关性最高的k个特征变量，从<code>train_corr</code>中找到与<code>target</code>相关性最高的10个变量。</li></ol><ul><li><p><code>nlargest(n, columns, keep='first')</code>:<code>n</code>：要获取的最大值的数量。<code>columns</code>：指定要比较大小的列或列的列表。<code>keep</code>：（可选参数）设置用于处理重复值的策略。默认值为 'first'，表示保留第一个出现的最大值。还可以选择 'last'，表示保留最后一个出现的最大值。</p></li><li><p><code>train_corr.nlargest(k, 'target')</code> 返回了一个 DataFrame，其中包含了与目标变量 'target' 最相关的 K 个特征变量,返回整行。 <img src="C:/Users/Admin/Desktop/%25E5%25B7%25A5%25E4%25B8%259A%25E8%2592%25B8%25E6%25B1%25BD%252002%25E6%2595%25B0%25E6%258D%25AE%25E6%258E%25A2%25E7%25B4%25A2/img/1.png" /></p></li><li><p><code>['target']</code> 从这个 DataFrame 中选择了名为 'target' 的列，并返回一个 Series 对象。 <img src="C:/Users/Admin/Desktop/%25E5%25B7%25A5%25E4%25B8%259A%25E8%2592%25B8%25E6%25B1%25BD%252002%25E6%2595%25B0%25E6%258D%25AE%25E6%258E%25A2%25E7%25B4%25A2/img/2.png" /></p></li><li><p><code>.index</code> 调用了 Series 对象的 index 属性，用于获取该 Series 的索引。在这个上下文中，.index 返回了与目标变量最相关的 K 个特征变量所对应的列的索引。 <img src="C:/Users/Admin/Desktop/%25E5%25B7%25A5%25E4%25B8%259A%25E8%2592%25B8%25E6%25B1%25BD%252002%25E6%2595%25B0%25E6%258D%25AE%25E6%258E%25A2%25E7%25B4%25A2/img/3.png" /></p></li></ul><ol start="2" type="1"><li><code>np.corrcoef(train_data[cols].values.T)</code> 计算<code>train_data</code>中<code>cols</code>所对应的特征变量之间的相关系数。</li></ol><ul><li><p><code>corrcoef(x, y=None, rowvar=True, bias=np._NoValue, ddof=np._NoValue)</code> 函数常用的是前三个参数，x和y分别是需要计算相关系数的两个随机变量，当rowvar为True(默认情况)时，每一行代表一个随机变量，否则每一列代表一个随机变量。所以需要用<code>.T</code>进行转置。</p></li><li><p><code>np.corrcoef(train_data[cols].values.T)</code>和<code>train_data[cols].corr()</code> 返回的数值都是一样的。最主要的区别是前者返回的类型是NumPy 数组，后者为 Pandas DataFrame</p></li></ul><ol start="3" type="1"><li><p><code>hm1 = sns.heatmap(cm, cbar=True, annot=True, square=True)</code> # cbar=True 添加颜色条（color bar）来表示相关系数的范围。</p></li><li><p><code>g = sns.heatmap(train_data[cols].corr(),annot=True,square=True,cmap="RdYlGn")</code> cmap="RdYlGn" 指定颜色映射为 "RdYlGn"。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 然后找出与arget变量的相关系数大于0.5的特征变量：</span><br>threshold = <span class="hljs-number">0.5</span><br><br>corrmat = train_data.corr()<br>top_corr_features = corrmat.index[<span class="hljs-built_in">abs</span>(corrmat[<span class="hljs-string">&quot;target&quot;</span>])&gt;threshold]<br>plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>))<br>g = sns.heatmap(train_data[top_corr_features].corr(),annot=<span class="hljs-literal">True</span>,cmap=<span class="hljs-string">&quot;RdYlGn&quot;</span>)<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_60_0.png" /> ​</p><h4 id="代码解释-3">代码解释：</h4><ol type="1"><li><p><code>corrmat["target"]</code>：从相关性矩阵 <code>corrmat</code> 中选择名为 "target" 的列，得到一个包含所有特征与目标变量的相关系数的 Series 对象。</p></li><li><p><code>abs(corrmat["target"]) &gt; threshold</code>：计算相关系数的绝对值，并将结果与阈值 <code>threshold</code> 进行比较，得到一个布尔类型的 Series 对象，表示哪些特征与目标变量的相关系数大于阈值。</p></li><li><p><code>corrmat.index[abs(corrmat["target"])&gt;threshold]</code>：根据上述布尔索引，从相关性矩阵的索引中选择相应的特征名。这将得到一个包含与目标变量的相关系数大于阈值的特征名的索引对象。<code>.index[]</code> 返回索引值。</p></li></ol><p>可以发现，与target变量的相关系数大于0.5的特征变量被直观地筛选出来。这一方法可以简单、直观地判断哪些特征变量线性相关，相关系数越大，就认为这些特征变量对target变量的线性影响越大。</p><p>说明：相关性选择主要用于判别线性相关对于target变量如果存在更复杂的函数形式的影响则建议使用树模型的特征重要性去选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用相关系数阈值移除相关特征：</span><br>threshold = <span class="hljs-number">0.5</span><br><br><span class="hljs-comment"># Absolute value correlation matrix</span><br>corr_matrix = data_train1.corr().<span class="hljs-built_in">abs</span>()<br>drop_col=corr_matrix[corr_matrix[<span class="hljs-string">&quot;target&quot;</span>]&lt;threshold].index<br><span class="hljs-comment">#data_all.drop(drop_col, axis=1, inplace=True)</span><br></code></pre></td></tr></table></figure><p>由于'V14', 'V21', 'V25', 'V26', 'V32', 'V33', 'V34'特征的相关系数值小于0.5，故认为这些特征与最终的预测target值不相关，删除这些特征变量；其可以发现一些不重要的特征并快速删除，方便快速分析重要特征。这里先不删除这些特征（注释的代码行用于删除特征），因为后续分析还会用到。</p><h3 id="box-cox变换">5.4Box-Cox变换</h3><p>由于线性回归是基于正态分布的，因此在进行统计分析时，需要转换数据使其符合正态分布。</p><p>Box-Cox 变换是一种常见的数据转换技术，用于将非正态分布的数据<strong>转换为近似正态分布</strong>的数据。这一变换可以使线性回归模型在满足线性、正态性、独立性及方差齐性的同时，又不丢失信息。在对数据做Box-Cox变换之后，可以在一定程度上减小不可观测的误差和预测变量的相关性，这有<strong>利于线性模型的拟合及分析出特征的相关性</strong>。</p><p>在做Box-Cox变换之前，需要对数据做归一化预处理。在归一化时，对数据进行合并操作可以使训练数据和测试数据一致。这种方式可以在线下分析建模中使用，而线上部署只需采用训练数据的归一化即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">drop_columns.clear()  <span class="hljs-comment"># 用于清空列表中的所有元素。</span><br>drop_columns = [<span class="hljs-string">&#x27;V5&#x27;</span>,<span class="hljs-string">&#x27;V9&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>,<span class="hljs-string">&#x27;V17&#x27;</span>,<span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V28&#x27;</span>]<br><br><span class="hljs-comment"># 合并训练集和测试集的数据</span><br>train_x =  train_data.drop([<span class="hljs-string">&#x27;target&#x27;</span>], axis=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">#data_all=pd.concat([train_data,test_data],axis=0,ignore_index=True)</span><br>data_all = pd.concat([train_x,test_data]) <br><br><br>data_all.drop(drop_columns,axis=<span class="hljs-number">1</span>,inplace=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">#View data</span><br>data_all.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V6</th><th>V7</th><th>V8</th><th>V10</th><th>V12</th><th>...</th><th>V27</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th></tr></thead><tbody><tr><th>0</th><td>0.566</td><td>0.016</td><td>-0.143</td><td>0.407</td><td>0.452</td><td>-1.812</td><td>-2.360</td><td>-0.436</td><td>-0.940</td><td>-0.073</td><td>...</td><td>0.168</td><td>0.136</td><td>0.109</td><td>-0.615</td><td>0.327</td><td>-4.627</td><td>-4.789</td><td>-5.101</td><td>-2.608</td><td>-3.508</td></tr><tr><th>1</th><td>0.968</td><td>0.437</td><td>0.066</td><td>0.566</td><td>0.194</td><td>-1.566</td><td>-2.360</td><td>0.332</td><td>0.188</td><td>-0.134</td><td>...</td><td>0.338</td><td>-0.128</td><td>0.124</td><td>0.032</td><td>0.600</td><td>-0.843</td><td>0.160</td><td>0.364</td><td>-0.335</td><td>-0.730</td></tr><tr><th>2</th><td>1.013</td><td>0.568</td><td>0.235</td><td>0.370</td><td>0.112</td><td>-1.367</td><td>-2.360</td><td>0.396</td><td>0.874</td><td>-0.072</td><td>...</td><td>0.326</td><td>-0.009</td><td>0.361</td><td>0.277</td><td>-0.116</td><td>-0.843</td><td>0.160</td><td>0.364</td><td>0.765</td><td>-0.589</td></tr><tr><th>3</th><td>0.733</td><td>0.368</td><td>0.283</td><td>0.165</td><td>0.599</td><td>-1.200</td><td>-2.086</td><td>0.403</td><td>0.011</td><td>-0.014</td><td>...</td><td>0.277</td><td>0.015</td><td>0.417</td><td>0.279</td><td>0.603</td><td>-0.843</td><td>-0.065</td><td>0.364</td><td>0.333</td><td>-0.112</td></tr><tr><th>4</th><td>0.684</td><td>0.638</td><td>0.260</td><td>0.209</td><td>0.337</td><td>-1.073</td><td>-2.086</td><td>0.314</td><td>-0.251</td><td>0.199</td><td>...</td><td>0.332</td><td>0.183</td><td>1.078</td><td>0.328</td><td>0.418</td><td>-0.843</td><td>-0.215</td><td>0.364</td><td>-0.280</td><td>-0.028</td></tr></tbody></table><p>5 rows × 32 columns</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对合并后的每列数据进行归一化：</span><br>cols_numeric=<span class="hljs-built_in">list</span>(data_all.columns)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">scale_minmax</span>(<span class="hljs-params">col</span>):<br>    <span class="hljs-keyword">return</span> (col-col.<span class="hljs-built_in">min</span>())/(col.<span class="hljs-built_in">max</span>()-col.<span class="hljs-built_in">min</span>())<br><br>data_all[cols_numeric] = data_all[cols_numeric].apply(scale_minmax,axis=<span class="hljs-number">0</span>)<br>data_all[cols_numeric].describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V6</th><th>V7</th><th>V8</th><th>V10</th><th>V12</th><th>...</th><th>V27</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th></tr></thead><tbody><tr><th>count</th><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>...</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td></tr><tr><th>mean</th><td>0.694172</td><td>0.721357</td><td>0.602300</td><td>0.603139</td><td>0.523743</td><td>0.748823</td><td>0.745740</td><td>0.715607</td><td>0.348518</td><td>0.578507</td><td>...</td><td>0.881401</td><td>0.388683</td><td>0.589459</td><td>0.792709</td><td>0.628824</td><td>0.458493</td><td>0.483790</td><td>0.762873</td><td>0.332385</td><td>0.545795</td></tr><tr><th>std</th><td>0.144198</td><td>0.131443</td><td>0.140628</td><td>0.152462</td><td>0.106430</td><td>0.132560</td><td>0.132577</td><td>0.118105</td><td>0.134882</td><td>0.105088</td><td>...</td><td>0.128221</td><td>0.133475</td><td>0.130786</td><td>0.102976</td><td>0.155003</td><td>0.099095</td><td>0.101020</td><td>0.102037</td><td>0.127456</td><td>0.150356</td></tr><tr><th>min</th><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>...</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td></tr><tr><th>25%</th><td>0.626676</td><td>0.679416</td><td>0.514414</td><td>0.503888</td><td>0.478182</td><td>0.683324</td><td>0.696938</td><td>0.664934</td><td>0.284327</td><td>0.532892</td><td>...</td><td>0.888575</td><td>0.292445</td><td>0.550092</td><td>0.761816</td><td>0.562461</td><td>0.409037</td><td>0.454490</td><td>0.727273</td><td>0.270584</td><td>0.445647</td></tr><tr><th>50%</th><td>0.729488</td><td>0.752497</td><td>0.617072</td><td>0.614270</td><td>0.535866</td><td>0.774125</td><td>0.771974</td><td>0.742884</td><td>0.366469</td><td>0.591635</td><td>...</td><td>0.916015</td><td>0.375734</td><td>0.594428</td><td>0.815055</td><td>0.643056</td><td>0.454518</td><td>0.499949</td><td>0.800020</td><td>0.347056</td><td>0.539317</td></tr><tr><th>75%</th><td>0.790195</td><td>0.799553</td><td>0.700464</td><td>0.710474</td><td>0.585036</td><td>0.842259</td><td>0.836405</td><td>0.790835</td><td>0.432965</td><td>0.641971</td><td>...</td><td>0.932555</td><td>0.471837</td><td>0.650798</td><td>0.852229</td><td>0.719777</td><td>0.500000</td><td>0.511365</td><td>0.800020</td><td>0.414861</td><td>0.643061</td></tr><tr><th>max</th><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>...</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td></tr></tbody></table><p>8 rows × 32 columns</p></div><h4 id="代码解释-4">代码解释：</h4><ol type="1"><li><code>cols_numeric=list(data_all.columns)</code><ul><li>将<code>data_all</code>中的所有列名保存在<code>cols_numeric</code>列表中。</li></ul></li><li><code>def scale_minmax(col):</code><ul><li>定义<code>scale_minmax</code>的函数，输入参数<code>col</code>表示数据的某一列。即使传入的是整个列，Pandas库的向量化操作会自动将这些操作应用到列中的每个元素上，从而实现对每个元素的归一化处理。</li></ul></li><li><code>return (col-col.min())/(col.max()-col.min())</code><ul><li>计算数据列<code>col</code>的归一化值。它用数据列中每个元素减去该列的最小值，然后除以该列的最大值与最小值之差，从而实现归一化处理。</li></ul></li><li><code>data_all[cols_numeric] = data_all[cols_numeric].apply(scale_minmax,axis=0)</code><ul><li>进行广播，将归一化处理的结果应用到<code>data_all</code>数据框的所有数值型列上。</li><li><code>data_all[cols_numeric]</code>表示选择<code>data_all</code>数据框中<code>cols_numeric</code>列表中的列。</li><li><code>.apply(scale_minmax, axis=0)</code>将<code>scale_minmax</code>函数应用到每列数据上，并指定<code>axis=0</code>以逐列进行操作。</li></ul></li></ol><p>也可以<strong>分开</strong>对训练数据和测试数据进行归一化处理，不过这种方式需要建立在训练数据和测试数据分布一致的前提下，建议在<strong>数据量大</strong>的情况下使用（数据量大，一般分布比较一致)，能加快归一化的速度。而数据量较小会存在分布差异较大的情况，此时，在数据分析和线下建模中应该将数据统一归一化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练集测试集分开归一化</span><br>train_data_process = train_data[cols_numeric]<br>train_data_process = train_data_process[cols_numeric].apply(scale_minmax,axis=<span class="hljs-number">0</span>)<br><br>test_data_process = test_data[cols_numeric]<br>test_data_process = test_data_process[cols_numeric].apply(scale_minmax,axis=<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Box-Cox变换（特征太多，分左右两部分绘制）</span><br>cols_numeric_left = cols_numeric[<span class="hljs-number">0</span>:<span class="hljs-number">13</span>]<br>cols_numeric_right = cols_numeric[<span class="hljs-number">13</span>:]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Check effect of Box-Cox transforms on distributions of continuous variables</span><br><br>train_data_process = pd.concat([train_data_process, train_data[<span class="hljs-string">&#x27;target&#x27;</span>]], axis=<span class="hljs-number">1</span>)<span class="hljs-comment"># 合并训练集</span><br><br>fcols = <span class="hljs-number">6</span><br>frows = <span class="hljs-built_in">len</span>(cols_numeric_left)<br>plt.figure(figsize=(<span class="hljs-number">4</span>*fcols,<span class="hljs-number">4</span>*frows)) <br>i=<span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> cols_numeric_left:<br>    dat = train_data_process[[var, <span class="hljs-string">&#x27;target&#x27;</span>]].dropna()<br>        <br>    <span class="hljs-comment">### 原数据直方图、Q-Q图、散点图    </span><br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    sns.distplot(dat[var] , fit=stats.norm);<br>    plt.title(var+<span class="hljs-string">&#x27; Original&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    _=stats.probplot(dat[var], plot=plt)<br>    plt.title(<span class="hljs-string">&#x27;skew=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stats.skew(dat[var]))) <span class="hljs-comment"># 下方有用法详解</span><br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    plt.plot(dat[var], dat[<span class="hljs-string">&#x27;target&#x27;</span>],<span class="hljs-string">&#x27;.&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    plt.title(<span class="hljs-string">&#x27;corr=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(dat[var], dat[<span class="hljs-string">&#x27;target&#x27;</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])) <span class="hljs-comment"># 下方有用法详解</span><br> <br>    <span class="hljs-comment">### Box-Cox变换，并绘制直方图、Q-Q图、散点图</span><br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    trans_var, lambda_var = stats.boxcox(dat[var].dropna()+<span class="hljs-number">1</span>)<br>    trans_var = scale_minmax(trans_var)      <br>    sns.distplot(trans_var , fit=stats.norm);<br>    plt.title(var+<span class="hljs-string">&#x27; Tramsformed&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    _=stats.probplot(trans_var, plot=plt)<br>    plt.title(<span class="hljs-string">&#x27;skew=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stats.skew(trans_var)))<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    plt.plot(trans_var, dat[<span class="hljs-string">&#x27;target&#x27;</span>],<span class="hljs-string">&#x27;.&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    plt.title(<span class="hljs-string">&#x27;corr=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(trans_var,dat[<span class="hljs-string">&#x27;target&#x27;</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_73_0.png" /> ​</p><h4 id="代码详解-6">代码详解：</h4><ul><li><p><code>plt.title()</code>：这是Matplotlib库中的一个函数，用于设置当前子图的标题。它接受一个字符串作为参数，表示要设置的标题内容。</p></li><li><p><code>'skew=' + '&#123;:.4f&#125;'.format(stats.skew(dat[var]))</code>：这是一个字符串格式化操作，用于构造标题内容。其中包含了以下几个部分：</p><ul><li><code>'skew='</code>：这是一个固定的字符串，用于标识标题内容中的部分。</li><li><code>'&#123;:.4f&#125;'</code>：这是一个格式化字符串，表示将要显示的数值（即偏度值）的格式。<code>&#123;:.4f&#125;</code>中的<code>4</code>表示小数点后四位，<code>.f</code>表示浮点数。</li><li><code>format(stats.skew(dat[var]))</code>：这是一个格式化操作，用于将实际的数值（<code>stats.skew(dat[var])</code>）应用到格式化字符串中。</li></ul></li><li><p><code>stats.skew(dat[var])</code>：这是SciPy库中的<code>stats.skew()</code>函数，用于计算给定数据集（<code>dat[var]</code>）的偏度值。偏度是衡量数据分布偏斜程度的统计量，负值表示左偏（左侧的尾部更长），正值表示右偏（右侧的尾部更长），0表示对称分布。</p></li></ul><p><code>&#123;:.4f&#125;</code>是一种格式化字符串的方法，用于将浮点数进行格式化输出。</p><ol type="1"><li>具体用法：<ul><li><code>&#123;&#125;</code>：花括号内放置要格式化的值的占位符。</li><li><code>:</code> ：表示格式说明符的开始。</li><li><code>.4f</code>：表示使用浮点数格式化，并保留小数点后四位。</li></ul></li><li><code>:</code> 的用处：<ul><li>在格式说明符中，冒号（<code>:</code>）用来分隔格式说明符的各个部分。</li><li>在 <code>&#123;&#125;</code> 内的冒号后面，可以添加格式说明符，对应要格式化的值按照指定的格式输出。</li></ul></li><li>中间可以填哪些参数，表示什么：<ul><li>宽度参数：如 <code>&#123;:&lt;10&#125;</code> 表示左对齐并占用 10 个字符的宽度。</li><li>对齐参数：如 <code>&#123;:&gt;10&#125;</code> 表示右对齐并占用 10 个字符的宽度。</li><li>精度参数：如 <code>&#123;:.2f&#125;</code> 表示保留两位小数。</li><li>类型参数：如 <code>&#123;:s&#125;</code> 表示字符串类型，<code>&#123;:d&#125;</code> 表示整数类型，<code>&#123;:f&#125;</code> 表示浮点数类型等。</li></ul></li></ol><p>总结起来，冒号（<code>:</code>）在格式化字符串中的作用是分隔格式说明符的各个部分。精度参数和类型参数是冒号后面的部分，用于指定格式化的精度和类型。</p><p><code>[0][1]</code> 是用于获取 <code>np.corrcoef(dat[var],dat['target'])</code> 返回的相关系数矩阵中的特定元素的索引表示方式。</p><p><code>np.corrcoef(dat[var], dat['target'])</code> 用于计算 <code>dat[var]</code> 和 <code>dat['target']</code> 之间的相关系数矩阵。</p><ul><li>相关系数矩阵是一个二维矩阵，其中每个元素是两个变量之间的相关系数。例如： <img src="C:/Users/Admin/Desktop/%25E5%25B7%25A5%25E4%25B8%259A%25E8%2592%25B8%25E6%25B1%25BD%252002%25E6%2595%25B0%25E6%258D%25AE%25E6%258E%25A2%25E7%25B4%25A2/img/4.png" /></li><li>在这种情况下，<code>[0][1]</code> 表示相关系数矩阵的第一行第二列的元素。其中，第一行对应于 <code>dat[var]</code> 与 <code>dat[var]</code>自身的相关系数，而第二列对应于 <code>dat[var]</code> 与 <code>dat['target']</code> 的相关系数。</li></ul><p>因此，<code>plt.title('corr='+'&#123;:.2f&#125;'.format(np.corrcoef(dat[var],dat['target'])[0][1]))</code> 中的 <code>[0][1]</code> 表示提取相关系数矩阵中与 <code>dat[var]</code> 与 <code>dat['target']</code> 相关系数对应的值，并将其格式化为小数点后两位的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Check effect of Box-Cox transforms on distributions of continuous variables</span><br><br>fcols = <span class="hljs-number">6</span><br>frows = <span class="hljs-built_in">len</span>(cols_numeric_right)<br>plt.figure(figsize=(<span class="hljs-number">4</span>*fcols,<span class="hljs-number">4</span>*frows))<br>i=<span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> cols_numeric_right:<br>    dat = train_data_process[[var, <span class="hljs-string">&#x27;target&#x27;</span>]].dropna() <br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    sns.distplot(dat[var] , fit=stats.norm);<br>    plt.title(var+<span class="hljs-string">&#x27; Original&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    _=stats.probplot(dat[var], plot=plt)<br>    plt.title(<span class="hljs-string">&#x27;skew=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stats.skew(dat[var])))<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    plt.plot(dat[var], dat[<span class="hljs-string">&#x27;target&#x27;</span>],<span class="hljs-string">&#x27;.&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    plt.title(<span class="hljs-string">&#x27;corr=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(dat[var], dat[<span class="hljs-string">&#x27;target&#x27;</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))<br> <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    trans_var, lambda_var = stats.boxcox(dat[var].dropna()+<span class="hljs-number">1</span>)<br>    trans_var = scale_minmax(trans_var)      <br>    sns.distplot(trans_var , fit=stats.norm);<br>    plt.title(var+<span class="hljs-string">&#x27; Tramsformed&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    _=stats.probplot(trans_var, plot=plt)<br>    plt.title(<span class="hljs-string">&#x27;skew=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stats.skew(trans_var)))<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    plt.plot(trans_var, dat[<span class="hljs-string">&#x27;target&#x27;</span>],<span class="hljs-string">&#x27;.&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    plt.title(<span class="hljs-string">&#x27;corr=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(trans_var,dat[<span class="hljs-string">&#x27;target&#x27;</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><p><img src="/img/工业蒸汽预测-02数据探索/output_77_0.png" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习实战入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习07-强化学习</title>
    <link href="/2023/07/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A007-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A007-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="强化学习">强化学习</h1><p>强化学习是一种机器学习方法，它通过代理与环境的交互来学习如何做出最优决策。代理在不断尝试中获得奖励信号，并通过调整策略来最大化累积奖励。这种学习方式类似于人类通过试错来学习，帮助机器代理逐步提高在特定任务上的表现能力。</p><p>强化学习算法的思路非常简单，以游戏为例，如果在游戏中采取某种策略可以取得较高的得分，那么就进一步“强化”这种策略，以期继续取得较好的结果。这种策略与日常生活中的各种“绩效奖励”非常类似。</p><h1 id="离散状态空间">离散状态空间</h1><h2 id="示例火星探测器">示例：火星探测器</h2><p>探测器在火星执行探测任务，共有6个位置。在强化学习中，探测器的位置被称为状态，初始时，探测器位于状态4。 现在，位置1和位置6都有一些有趣的表面。科学家希望探测器对位置1进行采样，因为它比位置6更重要。但是位置1很远，所以我们通过奖励函数来反映状态的价值，在每个状态可以获得对应的奖励。状态1的奖励是100，状态6的奖励是40，其他状态的奖励都是0。在每一步中，探测器可以选择向左或向右移动。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721182005.png" /> 在每个位置，机器人都处于某种状态s，它可以选择一个动作a，并从而得到奖励R(s)，状态随动作变为新的状态s'。注意，奖励R(s)是与状态s相关，而不是下一个状态s'相关。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721182247.png" /> 例如，当探测器处于状态4，并采取了向左走的动作，状态4奖励为0，变为新的状态3。</p><p>强化学习四要素：<strong>状态、动作、奖励、下一个状态</strong></p><p>探测器在不同的位置可以走不同的路线，起点为位置4可以走4-3-2-1，也可以走4-5-6。较远的位置虽然奖励多，但是它所花费的时间和路程值得这些奖励吗？怎么知道一组特定的奖励比另一组不同的奖励更好还是更差?</p><p>我们用强化学习中的<strong>回报（Return）</strong> 来解决这件事。</p><h2 id="回报">回报</h2><p>基于折扣因子和奖励值，计算一系列动作下所获得的总效用值。折扣因子 <span class="math inline">\(\gamma\)</span> (Gamma)：取值范围在0到1之间，一般是一个非常接近1的数值。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721184441.png" /></p><p>得到的回报取决于奖励，而奖励取决于你采取的行动，因此回报取决于你采取的行动。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721185214.png" /></p><h2 id="策略">策略</h2><p>策略（policy）是指代理在特定状态下选择动作的方式或规则。策略定义了代理对于给定状态所做出的行为，就是一个从状态到行为的映射。我们可以通过策略来确定每个状态下的行为。</p><p>强化学习的目标是训练出一个策略函数，它以任意状态s为输入，并将其映射到采取的某个动作a。</p><p>例如可以有4种策略，以最后一种策略为例，右边是策略函数 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721194933.png" /></p><p>强化学习的目标是找到一个策略 <span class="math inline">\(\pi\)</span> ，告诉你在每个状态下采取什么行动以最大化回报。</p><h2 id="马尔可夫决策过程">马尔可夫决策过程</h2><p><strong>马尔可夫决策过程</strong>（Markov Decision Process, MDP），指未来仅取决于当前状态，而不取决于当前状态之前发生的任何事情。换句话说，在马尔可夫决策过程中，未来只取决于你现在所处的位置，而不取决于你是如何到达这里的。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721202150.png" /></p><p>根据目标当前状态 s，基于策略选择动作a，世界或环境会发生变化，然后观察基于世界状态，目标的状态s及得到的奖励R</p><h2 id="状态动作价值函数qsa">状态动作价值函数Q(s,a)</h2><p>状态动作价值函数 Q(s, a)（也称为 Q-value 函数）是在强化学习中用于评估在给定状态 s 下采取动作 a 的价值的函数。它表示了代理在特定状态下采取某个动作所能获得的预期累积回报。</p><p>具体而言，对于给定的状态动作对 (s, a)，Q(s, a) 表示从状态 s 开始，采取某一行动，之后一直按照最佳的策略行动，最终获得的预期累积回报。这个预期累积回报通常是通过累加未来奖励的折扣值来计算的。（至于为何能在获得最优策略前计算Q，后面会讲，会基于循环）。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721224150.png" /></p><p>例如： 计算Q（2，→），则为以状态2开始，采取向右的行动，到状态3，那后面最优策略是一直向左走，行动轨迹为2-3-2-1，所以计算Q为12.5。 Q（2，←）则为以状态2开始，采取某一行动为向左，行动轨迹为2-1，此时Q为50。</p><p>对每个状态，每个动作，都可计算得到Q。而且我们可以发现，Q(s,a)的最大值即为从状态s获得的最佳可能回报。因此当我们可以计算Q(s,a)，即可知道最佳的动作。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721224959.png" /></p><p>如果你可以计算每一个状态每一个动作的Q(s,a)，然后找出最大的Q(s,a)，这个Q(s,a)中的a即为最佳的行动，所以该状态s的 <span class="math inline">\(\pi(s)=a\)</span> 。</p><p>因此，Q计算和策略相对应，如果能基于s和a计算Q函数，就能得到策略。</p><h2 id="贝尔曼方程">贝尔曼方程</h2><p>贝尔曼方程（Bellman equation）是强化学习中的关键方程，用来描述状态值函数或者状态动作值函数之间的递归关系。 <strong>贝尔曼方程</strong>：<span class="math inline">\(Q(s,a)=R(s)+\gamma\max_{a^{\prime}}Q(s^{\prime},a^{\prime})\)</span></p><p>贝尔曼方程通过将<strong>当前</strong>状态和动作的价值与<strong>下一个</strong>状态的价值联系起来，帮助我们计算最优策略。也就是说，贝尔曼方程告诉我们一个状态的价值如何与其后续状态的价值相关联。</p><p>贝尔曼方程的本质是，当前状态s的总回报包含两部分，一部分是马上得到的奖励R(s)，第二部分是 <span class="math inline">\(\gamma\)</span> 乘以下一状态s'的最佳总回报 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722101410.png" /> 例如从状态4开始，向左走： <span class="math display">\[\begin{aligned}&amp;Q(4,\leftarrow)\\&amp;=0+(0.5)0+(0.5)^20+(0.5)^3100\\&amp;=R(4)+(0.5)\begin{bmatrix}0+(0.5)0+(0.5)^2100\end{bmatrix}\\&amp;=R(4)+(0.5)\max_{a^{\prime}}Q(3,a^{\prime})\end{aligned}\]</span></p><p>实际上，贝尔曼方程告诉我们，在当前状态下采取某个动作的价值与下一个状态的价值之间存在一个关系。通过不断迭代更新这个关系，最终将能够找到最佳策略，即在每个状态下都选择可以获得最大预期回报的动作。 ## 随机马尔可夫决策</p><p>在随机马尔可夫过程中，执行动作a时，存在一定概率无法按照预期进行。以一个随机环境为例，我们向一个探测器发送左转指令，但由于未知的环境因素，左侧地面可能很滑，导致探测器滑向相反的方向，无法按照我们的指令执行。因此，我们获得的奖励也是随机的。</p><p>在随机强化学习问题中，目标的不是最大化回报，而是折扣奖励总和的平均值，即期望回报 <span class="math display">\[\begin{aligned}\text{Expected Return}&amp;=\text{Average}(R_1+\gamma R_2+\gamma^2R_3+\gamma^3R_4+\cdots)\\&amp;=\text{E}[R_1+\gamma R_2+\gamma^2R_3+\gamma^3R_4+\cdots]\end{aligned}\]</span></p><p>随机马尔可夫决策中，贝尔曼方程改为： <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722110235.png" /> 前面TensorFlow实例中，misstep_prob参数就表示失误概率。</p><h1 id="连续状态空间应用">连续状态空间应用</h1><p>例如在自动控制汽车、飞机中，状态s都是连续状态空间，包含x,y,z轴坐标，及各轴方向上速度、角速度等，这都是连续状态空间</p><h2 id="示例登月器">示例：登月器</h2><p>登月器的任务是在适当的时候启动火力推进，将其安全降落到着陆台上。</p><p><strong>状态：</strong> <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722112131.png" /> <span class="math inline">\(x\)</span> ：水平位置 <span class="math inline">\(y\)</span> ：垂直高度 <span class="math inline">\(\dot{x}\)</span> ：水平方向速度 <span class="math inline">\(\dot{y}\)</span> ：垂直方向速度 <span class="math inline">\(\theta\)</span> ：倾斜角，向左/右倾斜多少 <span class="math inline">\(\dot{\theta}\)</span> ：角速度 <span class="math inline">\(l\)</span> ：左脚落地 <span class="math inline">\(r\)</span> ：右脚落地</p><p><strong>动作：</strong> 什么都不做，向下加速，向左加速，向右加速</p><p><strong>奖励函数：</strong> <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722113031.png" /> 到达着陆台：100-140 靠近/远离着陆台的额外奖励 坠毁：-100 软着陆：+100 腿着陆：+10 启动主推进器：-0.3 启动侧推进器：-0.03</p><p><strong>目标</strong>是找到策略函数： <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722113530.png" /></p><h2 id="学习状态值函数强化学习中使用神经网络">学习状态值函数（强化学习中使用神经网络）</h2><p>关键思想是我们要训练一个神经网络来计算或近似S,a的状态动作值函数Q,然后上我们洗择好的动作</p><p>学习算法的核心是我们将训练一个神经网络，该网络输入当前状态和当前动作并计算或近似的Q 。 我们将状态和动作放在一起作为输入，这个12个数字的列表，8个数字用于状态，然后是个数字是动作的单热编码。这是我们对神经网络的输入，称之为X。神经网络的工作就是输出Q。</p><p>因为我们稍后会使用神经网络训练算法，所以我还将Q作为训练神经网络逼近的目标值Y。强化学习与监督学习不同，但我们要做的不是输入状态并让它来输出动作。我们要做的是输入一个状态动作对，让它尝试输出Q,并在强化学习算法中使用神经网络。</p><p><img src="/img/机器学习07-强化学习/Pasted%20image%2020230722183834.png" /> 如果您可以在隐藏层和上层中选择适当的参数来训练神经网络，以便为您提供对Q的良好估计，那么每当您在月球着陆器处于某种状态s时，您就可以使用神经网络计算Q。对于所有四个动作，都可以计算Q，Q(s,nothing),Q(s,left),Q(s,main),Q(s,right)，最后，哪个具有最高值，就选择那个相应的动作。 例如，如果在这四个值中，Q(s,main)最大，那么将启动着陆器的主推进器。</p><p>所以问题就变成了，如何训练一个神经网络来输出Q?</p><p>方法是使用贝尔曼方程来创建包含大量示例×和y的训练集，然后我们使用监督学习，就像神经网络时所学的一样。使用监督学习，利用神经网络学习从x到y的映射，即从状态动作对到目标值Q的映射。</p><p>但是，如何获得具有x和y值的训练集，可以在其上训练神经网络？</p><p>这是贝尔曼方程：<span class="math inline">\(Q(s,a)=R(s)+\gamma\max_{a^{\prime}}Q(s^{\prime},a^{\prime})\)</span> 。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722185112.png" />我们将等式右边的值为神经网络的输出y，等式左边即为输入x。神经网络的工作是输入x，即输入状态动作对，并尝试准确预测右边的值。</p><p>在监督学习中，我们训练一个神经网络来学习一个函数f，它取决于参数W和B（神经网络各个层的参数），神经网络的最左端输入X，最右端放一些接近目标值y的东西。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722185443.png" /> 问题是，我们如何才能为新网络提供一个具有x和y的训练集来学习？</p><p>我们将使用着陆器，并尝试在其中随机执行不同的操作。通过在月球着陆器中尝试做不同的动作，我们将会得到很多例子，这些例子说明我们何时处于哪种状态并采取了哪些动作，可能是一个好的动作，也可能是一个坏的动作。然后，由于处于该状态，我们获得了一些奖励R(s)，接着，我们进入了某个新状态S'。<span class="math inline">\((s,a,R(s),s^{\prime})\)</span> 我们称为元组。</p><p><img src="/img/机器学习07-强化学习/Pasted%20image%2020230722190456.png" /></p><p>例如，也许有一次处于某个状态 <span class="math inline">\(S^{(1)}\)</span>，采取了动作 <span class="math inline">\(a^{(1)}\)</span> ，得到了奖励 <span class="math inline">\(R(S^{(1)})\)</span> ，达到了个新状态 <span class="math inline">\(S^{\prime(1)}\)</span> ； 也许在不同的时间处于某个状态 <span class="math inline">\(S^{(2)}\)</span>，采取了动作 <span class="math inline">\(a^{(2)}\)</span> ，得到了奖励 <span class="math inline">\(R(S^{(2)})\)</span> ，达到了个新状态 <span class="math inline">\(S^{\prime(2)}\)</span> ；以此类推 。 也许你已经这样做了10,000次甚至超过10,000次。这10,000个元组都是训练示例x，y。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722191729.png" /> 元组中的前两个将用于计算x，后两个将用于计算y。 例如，<span class="math inline">\(x^1\)</span> 就是 <span class="math inline">\(x^{(1)}=(s^{(1)},a^{(1)})\)</span> ；<span class="math inline">\(y^1\)</span> 将使用贝尔曼方程的右侧计算。 贝尔曼方程表示，当您输入 <span class="math inline">\(s^{(1)},a^{(1)}\)</span> 时，希望 <span class="math inline">\(Q(s^{(1)},a^{(1)})=R(s^{(1)})+\gamma\max_{a^{\prime}}Q(s^{\prime(1)},a^{\prime})\)</span> 。<span class="math inline">\(y^1\)</span> 即等于 <span class="math inline">\(R(s^{(1)})+\gamma\max_{a^{\prime}}Q(s^{\prime(1)},a^{\prime})\)</span> 。注意，元组最后的两个元素提供了足够的信息来计算右侧，计算后这将是数字，比如12.5或17。 我们将数字保存为 <span class="math inline">\(y^1\)</span> 。这对 <span class="math inline">\(x^1,y^1\)</span> 成为了第一个训练示例。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722193800.png" /> 现在你可能想要知道 <span class="math inline">\(Q(s^{\prime(1)},a^{\prime})\)</span> 从哪里来，其实我们最初并不知道 <span class="math inline">\(Q(s^{\prime(1)},a^{\prime})\)</span> 是什么，但是当不知道Q函数是什么时，可以随机猜测一个初始值。刚开始这里的每一步Q都只是一些猜测，随着时间的推移，他们会变得更好，慢慢的逼近实际的Q函数值。</p><p>依此类推，直到你最终得到10,000个包含这些x,y对的训练示例。稍后，我们将采用这个训练集，其中x是具有12个特征的输入，而y只是数字。 我们将使用均方误差损失来训练一个新网络，以尝试将y预测为输入x的函数。</p><p>以上描述的只是我们将使用的算法的一部分，接下来看看它们是如何组合成一个学习Q函数的完整算法的。</p><p>首先，我们将采用我们的神经网络并随机初始化神经网络的所有参数。最初我们不知道Q函数是什么，我们只是完全随机的赋值。我们假设这个神经网络是我们对Q函数的初始随机猜测。这有点像你在训川练线性回归时随机初始化所有参数，然后使用梯度下降来改进参数。现在随机初始化没关系。重要的是算法是否可以慢慢改进参数以获得更好的估计。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722203836.png" /> 接下来，我们将重复执行以下操作；我们将对着陆器中采取动作，然后得到众多元组 <span class="math inline">\((s,a,R(s),s^{\prime})\)</span> ， 我们要做的是存储这些元组的10,000个最新示例。当你运行这个算法时，你会看到着陆器有很多步骤，可能有几十万个步骤。为了确保我们最终不会使用过多的计算机内存，通常的做法是只记住我们在 MDP中看到的10,000个最近的此类元组。这种仅存储最近示例的技术在强化学习算法中称为回放缓冲区。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722203905.png" /> 日前，我们只是让月球着陆器随机飞行，有时会坠毁，有时不会坠毁，并根据学习算法经验获取这些元组。</p><p>有时我们会训练神经网络，为了训练神经网络，下面是我们要做的。</p><p>我们将查看我们保存的这10,000个最近的元组，并创建一个包含10,000个示例的训练集。 训练集需要很多对x和y。对于我们的训练示例，x将是s来自元组的 <span class="math inline">\((s,a)\)</span> 这一部分。我们希望神经网络尝试预测的目标值是 <span class="math inline">\(\mathbf{y}=R(s)+\:\gamma\max_{a^{\prime}}Q(s^{\prime},a^{\prime})\)</span> 。我们如何获得Q的这个值？最初是我们随机初始化的这个神经网络，是一个猜测值。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722204559.png" /> 创建这10,000个训练示例后，我们将拥有训练示例 <span class="math inline">\(x^1\)</span> 、<span class="math inline">\(y^1\)</span> 到 <span class="math inline">\(x^{10,000}\)</span> 、<span class="math inline">\(y^{10,000}\)</span> 。我们将训练一个神经网络，我将把新的神经网络称为Qnew,这样 <span class="math inline">\(Q_{new}(s,a)\approx y\)</span> 。这正是训练那个神经网络 <span class="math inline">\(f_{W,B}(x)\approx y\)</span> 。现在，这个神经网络应该稍微更好地估计Q函数是什么，接着我们要做的是将Q设置为我们刚刚学习的新神经网络 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722210052.png" /> 事实证明，如果您从真正随机猜测Q函数开始运行此算法，然后使用Bellman方 Set-new.程反复尝试改进Q函数的估计值。,9然后通过反复执行此操作，采取大量操作，训川练模型，这将改进您对Q函数的猜 Set-new. Jw,BX)XU测.,9对于您训川练的下一个模型，您现在对什么是Q函数有了更好的估计。那么你训练的下一个模型会更好当您更新Q等于Qnew时。然后下次训练 <span class="math inline">\(Q(s^{\prime},a^{\prime})\)</span> 时，将是一个更好的估计值。</p><p>当你在每次迭代中运行这个算法时，<span class="math inline">\(Q(s^{\prime},a^{\prime})\)</span> 有望成为Q函数的更好估计，这样当你运行算法足够长的时间时，这个估计值会越来越接近真实值，这样你就可以用它来挑选，希望是好的动作或 MDP。</p><p>这个算法称为DQN算法（Deep Q-Network），因为使用深度学习和神经网络训练模型来学习Q函数。</p><h2 id="算法改进改进的神经网络架构">算法改进：改进的神经网络架构</h2><p>改进前，神将网络只能输出一个值，要分别计算4次Q，Q(s,nothing),Q(s,left),Q(s,main),Q(s,right)各一次 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722213200.png" /></p><p>改进后，神经网络可以同时输出四个值，会更加有效，且更方便选择最大值，可直接用于贝尔曼方程计算 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722213230.png" /></p><h2 id="算法改进epsilon-greedy-策略">算法改进：Epsilon Greedy 策略</h2><p>ε-greedy策略是一种在强化学习中常用的策略，用于在探索（exploration）和利用（exploitation）之间进行权衡。该策略基于一个参数ε，用来决定代理在<strong>选择动作时</strong>是进行<strong>随机探索</strong>还是根据当前已学习的知识做出<strong>最优动作</strong>的利用。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722215349.png" /></p><p>在强化学习中，ε-贪婪策略（方法2）是更常用的方法。在大多数情况下，我们选择使当前的Q(s, a)（神经网络训练出来的）最大化的动作a，即贪婪行动。只有在极少数情况下（偶尔）会随机选择动作，即探索行动。</p><p>方法1容易出现问题，因为由于随机初始化的原因，可能始终不会尝试一些动作，而这些动作可能会效果很好。为了解决这个问题，我们采用方法2，即使用ε-贪婪策略，对所有动作进行尝试。</p><p>当ε=0.05时，贪婪动作占95%，探索动作占5%。</p><p>通常，在学习刚开始时，我们将ε设置得较大，这样代理会频繁地选择随机动作，然后逐渐减小ε的值，因此随着时间的推移，代理不太可能随机采取行动，而更有可能根据Q函数来选择最优的动作。</p><p>在强化学习中，参数的选择非常关键，不合适的参数选择可能导致训练时间非常非常慢。</p><h2 id="算法改进小批量和软更新">算法改进：小批量和软更新</h2><p>小批量（mini-batches）可以提高算法运行速度，同样适用于监督学习，例如训练神经网络，或训练线性回归或逻辑回归模型。 软更新（soft updates）可以使强化学习更好的收敛</p><h3 id="小批量">小批量</h3><p>小批量是指在训练模型时，将训练数据划分为多个较小的批次进行模型参数的更新。相比于使用完整的训练集进行参数更新，小批量更新可以提高计算效率，并且有助于减少参数更新的方差。</p><p>当样本数量非常大时，例如有一亿个样本，如果梯度下降的每一步都需用全部样本计算平均值，那么算法会运行的很慢。使用小批量是每次梯度下降时，只关注一个batch的数据。使用小批量梯度下降的思想是不用再每次迭代中使用1亿个示例，而是选择一个较小的数，如1000，这将花费较少的时间。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722221956.png" /></p><p>小批量梯度下降很容易在迭代时向着错误的方向前进，不可靠且有点嘈杂。但会趋向于全局最小值，每次迭代的计算成本要低得多，因此小批量梯度下降可以提高算法运行速度。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722222116.png" /></p><p>在强化学习中同样可以应用mini-batch，如虽然缓冲存储区中有10000个样本元组，但每次训练神经网络模型时可以只选取1000个（一个batch）来进行训练</p><p><img src="/img/机器学习07-强化学习/Pasted%20image%2020230722223649.png" /></p><h3 id="软更新">软更新</h3><p>软更新是指在深度强化学习的策略网络和目标网络之间进行参数更新时，采用一种平滑的更新方式。</p><p>在软更新中，每次更新时只更新一小部分的策略网络参数，而不是完全替换目标网络的参数。这样可以缓解训练过程中目标网络参数的剧烈变化，使得网络更新更加稳定，更好的收敛。</p><p>软更新通常使用一个超参数τ来控制更新的幅度，即通过对新参数和旧参数进行加权平均来更新目标网络的参数。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722223002.png" /></p><h1 id="强化学习发展现状">强化学习发展现状</h1><ul><li>强化学习在模拟状态实现要比真实状态实现容易很多</li><li>应用要比监督学习和无监督学习少很多</li><li>前景很大，是机器学习的支柱之一</li></ul><p><img src="/img/机器学习07-强化学习/Pasted%20image%2020230722223249.png" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习06-推荐系统</title>
    <link href="/2023/07/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A006-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/07/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A006-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="基于内容的推荐算法">基于内容的推荐算法</h1><p>假设您经营一家大型电影流媒体网站，用户使用一到五颗星对电影进行评级，请预测用户未看过的电影可能给出的评分。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230717185300.png" /> <span class="math inline">\(n_u\)</span> ：用户数量 <span class="math inline">\(n_m\)</span> ：电影数量 <span class="math inline">\(r(i,j)\)</span> = 1 ：第j个用户对 第i个电影做出评价 <span class="math inline">\(y^{(i,j)}\)</span> ：当 <span class="math inline">\(r(i,j)\)</span> = 1时，第j个用户对第i个电影的评分</p><p>假设每一部电影都有一个特征集X，n表示特征数量，<span class="math inline">\(x_1\)</span> 衡量一部电影为爱情片的程度，<span class="math inline">\(x_2\)</span> 衡量一部电影为动作片的程度，例如 <span class="math inline">\(x^{(1)}=\begin{bmatrix}0.9\\0\end{bmatrix}\)</span> <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230717202336.png" /> 我们可以把每一个用户的预测评价值当做线性回归问题。对于每个用户 j，需要学习参数 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> , 之后便可用 <span class="math inline">\(w · x^{(i)} + b\)</span> 预测用户 j 对电影 i 的评分。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230717202958.png" /></p><p>例如，预测用户 1 对电影 3 的评分，假设模型各参数为<span class="math inline">\(\mathbf{w}^{(1)}=\begin{bmatrix}5\\0\end{bmatrix} \quad b^{(1)}=0\quad\mathbf{x}^{(3)}=\begin{bmatrix}0.9\\0\end{bmatrix}\)</span> ，则有 <span class="math inline">\(\mathbf{w}^{(1)}\cdot\mathbf{x}^{(3)}+\mathbf{b}^{(1)}=4.95\)</span></p><p>一般的，用户j对电影i的评分为：<span class="math inline">\(\mathbf{w^{(j)}\cdot x^{(i)}+b^{(j)}}\)</span></p><h2 id="成本函数">成本函数</h2><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230717204317.png" /> 其中，<span class="math inline">\(\sum_{i:r(i,j)=1}\)</span> 表示仅对<span class="math inline">\(r(i,j)\)</span> = 1 的值求和。使用正则化后的代价函数为： <span class="math display">\[\min_{w^{(j)}b^{(j)}}{J}(w^{(j)},b^{(j)})=\frac{1}{2m^{(j)}}\sum_{i:r(i,j)=1}(w^{(j)}\cdot x^{(i)}+b^{(j)}-y^{(i,j)})^{2} +\frac{\lambda}{2m^{(j)}}\sum_{k=1}^{n}\left(w_{k}^{(j)}\right)^{2}\]</span> 为了使式子更简单，可以去掉 <span class="math inline">\(\frac{1}{2m^{(j)}}\)</span> 中的 <span class="math inline">\(m^{(j)}\)</span> ，去掉后值不变。</p><p>对所有的用户： <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230717210141.png" /></p><h1 id="预测电影特征">预测电影特征</h1><p>基于内容的推荐算法要求取得每部电影的特征值，然而这是很难的。对此，有另外一种算法无需取得特征值，而只要根据用户的爱好矩阵 便可预测出用户对电影的评分。</p><p>在之前的基于内容的推荐系统中，对于每一部电影，我们都掌握了可用的特征，比如衡量一部电影为爱情片的程度、动作片的程度，使用这些特征训练来出每一个用户的参数。相反地，如果我们拥有用户的参数，我们可以学习得出电影的特征。</p><p>假设拥有所有四个用户的参数，如下，进而我们可以求出电影的特征 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719165153.png" /></p><h2 id="成本函数-1">成本函数</h2><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719165851.png" /> 一部电影特征的成本函数： <span class="math display">\[J(x^{i})=\frac{1}{2}\sum_{j:r(i,j)=1}(w^{(j)}\cdot x^{(i)}+b^{(j)}-y^{(i,j)})^2+\frac{\lambda}{2}\sum_{k=1}^{n}\left(x_k^{(i)}\right)^2\]</span> 所有电影特征的成本函数： <span class="math display">\[J\left(x^{(1)},x^{(2)},...,x^{(n_m)}\right)=\frac12\sum_{i=1}^{n_m}\sum_{j:r(i,j)=1}\left(w^{(j)}\cdot x^{(j)}+b^{(j)}-y^{(i,j)}\right)^2+\frac\lambda2\sum_{i=1}^{n_m}\sum_{k=1}^n\left(x_k^{(i)}\right)^2\]</span></p><h1 id="协同过滤算法">协同过滤算法</h1><p>目前我们都是在假设已有用户参数的基础上来预测电影特征的，但是这些参数从哪里得到呢？我们将基于内容的推荐算法（学习w和b）和预测电影特征算法（学习x）结合在一起，这就是协同过滤算法 。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719171626.png" /></p><p>上面是逐列遍历矩阵中非零元素，下面试逐行遍历矩阵中非零元素 ## 成本函数 <span class="math display">\[\min_{b^{(1)},...,b^{(n_{u})}}J(w,b,x)=\frac{1}{2}\sum_{(i,j):r(i,j)=1}\left(w^{(j)}\cdot x^{(j)}+b^{(j)}-y^{(i,j)}\right)^{2}+\frac{\lambda}{2}\sum_{j=1}^{n_{u}}\sum_{k=1}^{n}\left(w_{k}^{(j)}\right)^{2}+\frac{\lambda}{2}\sum_{i=1}^{n_{m}}\sum_{k=1}^{n}\left(x_{k}^{(j)}\right)^{2}\]</span></p><h2 id="梯度下降">梯度下降</h2><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719173253.png" /></p><p>在协同过滤中，是因为有多个用户评价同一部电影，了解这部电影可能是什么样子，所以可以预测出电影特征。</p><h2 id="推广至二进制标签收藏喜欢和点击">推广至二进制标签：收藏、喜欢和点击</h2><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719181259.png" /></p><h1 id="均值归一化">均值归一化</h1><p>让我们来看下面的用户评分数据： <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719183211.png" /> 如果我们新增一个用户 <strong>Eve</strong>，并且 <strong>Eve</strong> 没有为任何电影评分，那么我们以什么为依据为<strong>Eve</strong>推荐电影呢？ 如果这个数据集上运行算法，会得到Eve的参数为<span class="math inline">\(w^{(5)}=\begin{bmatrix}0\\0\end{bmatrix}\quad b^{(5)}=0\)</span> ，预测结果都为0。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719183617.png" /> 因此，如果有一个尚未对任何内容进行评分的新用户，算法会认为他们会对所有电影都是零星评分，这样的预测并不是非常合理的。</p><p>因此，我们将使用<strong>均值归一化</strong>帮助该算法为尚未对任何电影进行评级的新用户更好地预测电影评级。</p><p>我们首先需要对结果矩阵进行均值归一化处理，将每一个用户对某一部电影的评分减去所有用户对该电影评分的平均值： <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719184019.png" /> 然后我们利用这个新的 矩阵来训练算法。 如果我们要用新训练出的算法来预测评分，则需要将平均值重新加回去，预测<span class="math inline">\(w^{(j)}\cdot x^{(i)}+b^{(j)}+\mu_i\)</span> 对于<strong>Eve</strong>，我们的新模型会认为她给每部电影的评分都是该电影的平均分。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719184250.png" /></p><p>均值归一化使算法更快，更重要的是，当用户评价的电影很少甚至根本没有电影时，它可以让算法给出更好、更合理的预测。</p><h1 id="寻找相关特征">寻找相关特征</h1><p>当你浏览一些电影时，平台会给你推荐一些相似的电影，这是如何做到的？</p><p>使用算法学习出电影的特征 <span class="math inline">\(X^i\)</span> ，要是想要找出其他与 <span class="math inline">\(X^i\)</span> 相似的电影，即尝试找到具有特征 <span class="math inline">\(X^k\)</span> 的电影，并且 <span class="math inline">\(X^k\)</span> 类似于 <span class="math inline">\(X^i\)</span> 。我们用以下方法确定电影特征之间的相似程度： <span class="math display">\[\sum_{l=1}^n\left(x_l^{(k)}-x_l^{(i)}\right)^2\]</span> <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230720175911.png" /> # 协同过滤的局限性 1. 冷启动问题。如何解决 - 对很少有用户评价的新项目进行排名？ - 向对很少项目进行评分的新用户显示一些合理的内容？</p><ol start="2" type="1"><li>使用有关电影或用户的辅助信息：<ul><li>电影：类型、电影明星、工作室 ...</li><li>用户：人口统计数据（年龄、性别、地点）、偏好 ...</li></ul></li></ol><h1 id="基于内容的协同过滤">基于内容的协同过滤</h1><h2 id="协同过滤vs基于内容的协同过滤">协同过滤VS基于内容的协同过滤</h2><p>协同过滤： - 根据与你评分相近的用户的评分向你推荐商品</p><p>基于内容的协同过滤： - 根据用户和物品的特征向您推荐物品，找到合适的匹配</p><h2 id="用户和项目特性示例">用户和项目特性示例</h2><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230720183819.png" /></p><p>用户特征和电影特征的大小可能会有很大的差距。例如，用户特征可能会有1500个，而电影特征可能只会有50个。</p><h2 id="匹配用户和电影">匹配用户和电影</h2><p>之前我们用 <span class="math inline">\(w^{(j)}\cdot x^{(i)}+b^{(j)}\)</span> 来预测用户j对电影i的评分，在此，我们用 <span class="math inline">\(V_u^J\cdot V_m^i\)</span> 来预测用户j对电影i的评分。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230720184516.png" /> <span class="math inline">\(b\)</span> ：去掉b不会影响算法性能 <span class="math inline">\(V_u^J\)</span> ：代表向量，是根据用户j的特征 <span class="math inline">\(X_u^j\)</span> 计算的数字列表，下标u代表用户 <span class="math inline">\(V_m^i\)</span> ：代表向量，是根据电影i的特征 <span class="math inline">\(X_m^i\)</span> 计算的数字列表，下标m代表电影</p><p>例如，<span class="math inline">\(\mathbf{V_u}=\begin{bmatrix}4.9\\0.1\\\vdots\\3.0\end{bmatrix}\)</span> ，第一个数字代表用户对爱情电影的喜爱程度，第二个代表对动作电影的喜爱程度；<span class="math inline">\(\mathrm{Vm}=\begin{bmatrix}4.5\\0.2\\\vdots\\3.5\end{bmatrix}\)</span> ，第一个数字表示电影包含爱情片元素的程度，第二个表示包含动作片元素的程度。<span class="math inline">\(V_u\cdot V_m\)</span> 进行点积即可了解用户对该电影的喜爱程度。</p><p>点积需要<span class="math inline">\(V_u\)</span> 和 <span class="math inline">\(V_m\)</span> 有相同的维度，比如都需要有32个数字。但是，<span class="math inline">\(V_u\)</span> 和 <span class="math inline">\(V_m\)</span> 是根据用户特征<span class="math inline">\(X_u^j\)</span> 和电影特征<span class="math inline">\(X_m^i\)</span> 计算来的，用户特征和电影特征不一定有相同大小。</p><p>总而言之，在协同过滤中，我们有许多用户对不同的项目进行评分。在基于内容的过滤中，我们有用户的特征和项目的特征，我们想找到一种方法来找到用户和项目之间的良好匹配。</p><h2 id="基于内容过滤的深度学习方法">基于内容过滤的深度学习方法</h2><p>我们给定用户特征<span class="math inline">\(X_u^j\)</span> 和电影特征<span class="math inline">\(X_m^i\)</span> ，计算向量<span class="math inline">\(V_u\)</span> 和 <span class="math inline">\(V_m\)</span> 最好的办法是利用神经网络。</p><p>我们将用户特征<span class="math inline">\(X_u^j\)</span> 和电影特征<span class="math inline">\(X_m^i\)</span> 作为输入，将<span class="math inline">\(V_u\)</span> 和 <span class="math inline">\(V_m\)</span> 作为输出，最后计算<span class="math inline">\(V_u\cdot V_m\)</span> 。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230720201025.png" /> 需要注意的是，用户网络和电影网络输出层的神经元个数需要相同，中间的隐藏层可以不同。</p><p><span class="math inline">\(V_u\cdot V_m\)</span> 最终计算出的是1-5或0-5星的电影评级，如果我们有二进制标签，y表示用户喜欢或不喜欢某个项目，可以将sigmod函数应用于<span class="math inline">\(V_u\cdot V_m\)</span> 得出标签为1的概率。<span class="math inline">\(g(v_u\cdot v_m)\mathrm{~to~predict~the~probability~that~y^{(i,j)}~is~1}\)</span></p><p>我们也可以将用户网络和电影网络合成一个神经网路，最终直接计算出预测值： <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230720202033.png" /></p><p>现在，这个模型有很多参数，神经网络的每一层都有一组神经网络参数。那么如何训练用户网络和电影网络的所有参数？我们要做的是构建一个成本函数J。 <span class="math display">\[J=\sum_{(i,j):r(i,j)=1}\left(v_{u}^{(j)}\cdot v_{m}^{(i)}-y^{(i,j)}\right)^2+\text{NN regularization term}\]</span> 我们将神经网路算出来的参数 <span class="math inline">\(V_u\)</span> 和 <span class="math inline">\(V_m\)</span> 带入成本函数中的 <span class="math inline">\(v_{u}^{(j)}\)</span> 和<span class="math inline">\(v_{m}^{(i)}\)</span> ，来评价该模型的好坏，进而用梯度下降或其他优化算法来调整神经网络的参数，还可以添加神经网络的正则化项 <code>NN regularization term</code> 来防止过拟合。</p><p>当训练完这个神经网络后，也可以用它来寻找相似的电影：</p><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230720203458.png" /></p><p>目前该算法的一个局限性是，如果您有大量可能想要推荐的不同电影的大目录，那么运行它的计算成本可能非常高。</p><h2 id="从大型目录中推荐">从大型目录中推荐</h2><p>如果要推荐数百万、数千万甚至更多的电影时，如何使算法运行的更高效。 实现为两个步骤，称为检索和排名步骤。 在检索步骤中生成大量可能的项目候选列表，试图涵盖可能向用户推荐的许多可能的东西。如果候选列表中包含很多用户可能不太喜欢的项目，那么在排名步骤中将微调并选择最好的项目推荐给用户。</p><h3 id="检索">检索</h3><ul><li><p>生成大量可能的候选项目列表 （1）对于用户最近观看的 10 部电影中的每一部电影，查找 10 部最相似的电影 （2）对于观看次数最多的 3 个类型，查找排名前 10 的电影 （3）国内排名前20的电影</p></li><li><p>将检索到的项目合并到列表中，删除重复项和已观看/购买的项目</p></li></ul><p>检索步骤的目标是确保广泛的覆盖范围，以便有足够的电影至少有很多好电影</p><h3 id="排名">排名</h3><ul><li>获取检索到的列表，并使用模型进行排名（把用户特征向量和电影特征向量输入到神经网络中）</li><li>向用户显示排名的项目</li></ul><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230721105951.png" /> <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230721110025.png" /></p><p>检索更多项目会带来更好的性能，但推荐速度会更慢。 要分析/优化权衡，请进行离线实验，看看检索其他项目是否会产生更相关的推荐。</p><p>但是通过单独的检索步骤和排名步骤，能使许多推荐系统能够提供快速和准确的结果。因为检索步骤试图剪掉很多不值得做的更详细的项目，然后排名步骤对用户实际可能喜欢的项目进行更仔细的预测。否则需要对所有的项目进行非常详细的预测。</p><h2 id="基于内容过滤的tensorflow实现">基于内容过滤的TensorFlow实现</h2><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230721102308.png" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习05-无监督学习</title>
    <link href="/2023/07/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A005-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A005-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="聚类clustering">聚类（Clustering）</h1><p>聚类算法查看大量数据点并自动找到彼此相关或相似的数据点。</p><h2 id="k-means">K-means</h2><p>首先做的是随机初始化集群中心的位置，集群中心称为簇质心（Cluster centroids）。 <img src="/img/5无监督学习/Pasted%20image%2020230716102103.png" /></p><p>接着，重复做两件事，第一个是将点分配给簇质心，第二个是移动簇质心</p><p>第一步：遍历这些点中的每一个，并查看它是更接近红十字还是更接近蓝十字。然后把这些点分配给它更接近的簇质心。 <img src="/img/5无监督学习/Pasted%20image%2020230716102808.png" /></p><p>第二步：查看所有的红点并取它们的平均值。并将红十字移动到红点的平均位置，称为新的簇质心位置。蓝色同理。 <img src="/img/5无监督学习/Pasted%20image%2020230716102923.png" /></p><p>重复第一步：遍历每一个点并分配。 <img src="/img/5无监督学习/Pasted%20image%2020230716103250.png" /></p><p>接着重复第二步：移动簇质心。 <img src="/img/5无监督学习/Pasted%20image%2020230716103433.png" /></p><p>一直重复这两个步骤，直到簇质心的位置没有变化，此时K均值聚类算法已经收敛。 <img src="/img/5无监督学习/Pasted%20image%2020230716103559.png" /></p><h2 id="k-means算法">K-means算法</h2><p><strong>第一步：将点分配给簇质心</strong> <img src="/img/5无监督学习/Pasted%20image%2020230716123812.png" /> K:共K个聚类中心 <span class="math inline">\(\mu_{1},\mu_{2},\ldots,\mu_{K}\)</span> <span class="math inline">\(c^{(i)}\)</span> = 最接近<span class="math inline">\(x^{(i)}\)</span>的聚类中心点的索引(从1到K) 例如：点<span class="math inline">\(x^{(1)}\)</span> 离聚类中心 <span class="math inline">\(\mu_{1}\)</span> 最近，则<span class="math inline">\(c^{(i)}\)</span> = 1</p><p><strong>第二步：移动簇质心</strong> <img src="/img/5无监督学习/Pasted%20image%2020230716124031.png" /></p><p><span class="math inline">\(\mu_k\)</span> = 分配给群组k的点的平均值</p><h2 id="k-means的成本函数">K-means的成本函数</h2><p><span class="math inline">\(\mu_{C^{(i)}}\)</span> = 示例<span class="math inline">\(x^{(i)}\)</span>所在群组的聚类中心点 <span class="math display">\[J\big(c^{(1)},...,c^{(m)},\mu_1,...,\mu_K\big)=\frac{1}{m}\sum_{i=1}^{m}\big\Vert x^{(i)}-\mu_{c^{(i)}}\big\Vert^2\]</span> m表示训练样本的数量。</p><p><strong><span class="math inline">\(\mu_k\)</span> 和<span class="math inline">\(\mu_{C^{(i)}}\)</span> 区别：</strong> <span class="math inline">\(\mu_k\)</span>表示第k个群组的聚类中心点，即将该群组中所有分配给该群组的点<span class="math inline">\(x^{(i)}\)</span>的平均值作为新的聚类中心点。<span class="math inline">\(\mu_k\)</span>的计算方式是通过对属于第k个群组的所有数据点的均值来获得。</p><p>而<span class="math inline">\(\mu_{C^{(i)}}\)</span>表示示例<span class="math inline">\(x^{(i)}\)</span>所在群组的聚类中心点，是通过将<span class="math inline">\(x^{(i)}\)</span>分配给最近的聚类中心点得到的。<span class="math inline">\(\mu_{C^{(i)}}\)</span>和<span class="math inline">\(\mu_k\)</span>具有相同的含义，只是对应于不同的数据点。<span class="math inline">\(\mu_{C^{(i)}}\)</span>是根据每个数据点<span class="math inline">\(x^{(i)}\)</span>的分配结果得到的，而<span class="math inline">\(\mu_k\)</span>是根据整个群组的数据点求取均值得到的。</p><p>因此，<span class="math inline">\(\mu_{C^{(i)}}\)</span>和<span class="math inline">\(\mu_k\)</span>在K-means算法中都用于表示聚类中心点，只是对应于不同的数据点和群组。<span class="math inline">\(\mu_{C^{(i)}}\)</span>表示一个特定的数据点的聚类中心点，而<span class="math inline">\(\mu_k\)</span>表示整个群组的聚类中心点。</p><h2 id="如何初始化簇质心">如何初始化簇质心</h2><p>随机选择样本点作为初始簇质心 <img src="/img/5无监督学习/Pasted%20image%2020230716165659.png" /></p><p>只选择一次的话容易陷入局部最优 <img src="/img/5无监督学习/Pasted%20image%2020230716165753.png" /></p><p>多次选择样本点作 为簇质心，最终选择出成本函数最小的那一个 <img src="/img/5无监督学习/Pasted%20image%2020230716170122.png" /></p><h2 id="选择聚类数量k">选择聚类数量K</h2><p>Elbow method: <img src="/img/5无监督学习/Pasted%20image%2020230716171545.png" /></p><p>对于将T恤分成三个尺码，还是五个尺码，需要考虑成本和利润之间的关系，五个尺码可能挣得更多，但是成本更大。 <img src="/img/5无监督学习/Pasted%20image%2020230716171828.png" /></p><h1 id="异常检测anomaly-detection">异常检测（Anomaly detection）</h1><p>异常检测（Anomaly Detection）是一种用于识别和监测数据中异常、异常行为或异常模式的技术。它可以帮助我们在大量数据中自动发现那些与正常行为或模式不同的数据点。</p><p>检测制造的飞机发动机是否存在问题，为了简化问题，我们以发动机运行的温度、震动频率作为特征。当新引擎的参数落在中间一堆时，发动机正常，当落在外围时有很大概率存在问题。 <img src="/img/5无监督学习/Pasted%20image%2020230716173246.png" /></p><p>执行异常检测的最常见方法是通过密度估计的技术。 <img src="/img/5无监督学习/Pasted%20image%2020230716174016.png" /></p><h2 id="高斯分布">高斯分布</h2><p><img src="/img/5无监督学习/Pasted%20image%2020230716174647.png" /></p><p>对于只有一个特征时，将其应用于异常检测，就是要找到参数 <span class="math inline">\(\mu\)</span> 和 <span class="math inline">\(\sigma^2\)</span> 的合适取值 <img src="/img/5无监督学习/Pasted%20image%2020230716175138.png" /></p><h2 id="异常检测算法">异常检测算法</h2><p><img src="/img/5无监督学习/Pasted%20image%2020230716193942.png" /></p><p>共有m个样本，n个特征，对每一个特征求平均值 <span class="math inline">\(\mu\)</span> 和方差 <span class="math inline">\(\sigma^2\)</span> 。</p><p><span class="math inline">\(\mu_j\)</span> : 第j个特征的平均值 <span class="math inline">\(\sigma_j^2\)</span> : 第j个特征的方差 <span class="math inline">\(p(x)\)</span> : 假定每一个特征 <span class="math inline">\(x_{1}\)</span> 到 <span class="math inline">\(x_{n}\)</span> 均服从正态分布，则其模型的概率为： <span class="math display">\[\begin{aligned}p(x)&amp; =p(x_{1};\mu_{1},\sigma_{1}^{2})p(x_{2};\mu_{2},\sigma_{2}^{2})\cdotp\cdotp\cdotp p(x_{n};\mu_{n},\sigma_{n}^{2})  \\&amp;=\prod_{j=1}^{n}p(x_{j};\mu_{j},\sigma_{j}^{2}) \\&amp;=\prod_{j=1}^{n}\frac{1}{\sqrt{2\pi}\sigma_{j}}exp(-\frac{(x_{j}-\mu_{j})^{2}}{2\sigma_{j}^{2}})\end{aligned}\]</span></p><p>举例： 假定我们有两个特征，它们都服从于高斯分布，并且通过参数估计，我们知道了分布参数： <img src="/img/5无监督学习/Pasted%20image%2020230716202208.png" /> 将 <span class="math inline">\(p(x_1;\mu_1,\sigma_1^2)\)</span> 和 <span class="math inline">\(p(x_2;\mu_2,\sigma_2^2)\)</span> 相乘后会得到上图左下角的三维曲面图 <span class="math inline">\(p(x)\)</span>。当 <span class="math inline">\(p\left(x_{test}^{(1)}\right)\)</span> 小于 <span class="math inline">\(\mathbf{\varepsilon}\)</span> 时，有异常。</p><h2 id="算法评估">算法评估</h2><h3 id="实数计算">实数计算</h3><p><img src="/img/5无监督学习/Pasted%20image%2020230716221302.png" /></p><p>飞机发动机监测实例： 根据以往的数据，我们选择10000个正常的样本，20个异常样本。 <img src="/img/5无监督学习/Pasted%20image%2020230716220237.png" /></p><p>在训练集中用6000个正常样本训练模型； 交叉验证集中有2000个正常数据和10个异常数据，并把它们标记为0和1。在交叉验证集中评估模型准确率。</p><p>接着，改变超参数，训练集中训练模型，交叉验证集中评估模型。</p><p>最后选出一个最好的模型用在预测集中评估最终模型。</p><h3 id="算法评估-1">算法评估</h3><p>如果负面样本非常少，也可以不用预测集，只用训练集和交叉验证集。但这样的弊端是，模型可能在未知的数据上效果并不好。</p><p>由于异常样本是非常少的，所以整个数据集是非常偏斜的，我们不能单纯的用预测准确率来评估算法优劣，所以用我们之前的查准率（Precision）和召回率（Recall）计算出 F 值进行衡量异常检测算法了。</p><ul><li>真阳性、假阳性、真阴性、假阴性</li><li>查准率（Precision）与 召回率（Recall）</li><li>F1 Score</li></ul><h2 id="异常检测vs监督学习">异常检测VS监督学习</h2><p><img src="/img/5无监督学习/Pasted%20image%2020230716224601.png" /></p><p>异常检测，任何偏离正常的情况都被标记为异常，包括这在您的数据集中从未见过的一种全新的飞机发动机故障方式。</p><p>无监督适用于可能会出现从来没见过的例子的事情，而监督学习就适用于不会出现和以前完全不一样的例子的数据集</p><p>异常检测试图找到全新的正面示例，这些示例可能与您以前见过的任何东西都不一样。监督学习会查看您的正面示例并尝试确定未来示例是否与您已经看到的正面示例相似，</p><p>例子 <img src="/img/5无监督学习/Pasted%20image%2020230716224929.png" /></p><h2 id="选择特征">选择特征</h2><ol type="1"><li>将不符合高斯分布的特征转换成符合高斯分布的特征 <img src="/img/5无监督学习/Pasted%20image%2020230716230532.png" /></li><li>查看未能检测出来的异常，然后看看能否寻找出新的特征 <img src="/img/5无监督学习/Pasted%20image%2020230716230651.png" /></li></ol><h1 id="pca算法">PCA算法</h1><h2 id="降低特征数量">降低特征数量</h2><p>PCA是一种降维算法，用于获取具有大量特征、大量维度或高维度的数据，并将其简化为两个或三个特征，变成二维或三维数据，以便可以对其进行绘图和可视化，并更好地理解数据中有什么。</p><h3 id="示例">示例</h3><p>如果你有来自汽车的数据，并且汽车可以有很多特征。例如汽车的长度，汽车的宽度，汽车的高度，车轮的直径，以及其他特征。如果想要减少特征的数量以便将其可视化，如何使用PCA来做到这一点？</p><p><strong>示例1：</strong> 假设您有一个具有两个特征的数据集。特征 <span class="math inline">\(x_1\)</span> 是汽车的长度，特征<span class="math inline">\(x_2\)</span> 是汽车的宽度。 在大多数国家/地区，由于对汽车行驶道路宽度的限制，汽车宽度往往变化不大。你会发现数据集 <span class="math inline">\(x_1\)</span> 变化很大，而 <span class="math inline">\(x_2\)</span> 变化相对较小。 <img src="/img/5无监督学习/Pasted%20image%2020230721114957.png" /> 如果你想减少特征的数量，那么，你可以做的一件事就是只取 <span class="math inline">\(x_1\)</span> ，忽略 <span class="math inline">\(x_2\)</span> 。</p><p><strong>示例2：</strong> 假设我们有两个特征，即汽车的长度 <span class="math inline">\(x_1\)</span> 和高度 <span class="math inline">\(x_2\)</span>。这两个特征的变化范围都比较大。如果我们绘制这些数据点，可能会得到一个这样散点图。 <img src="/img/5无监督学习/Pasted%20image%2020230721120204.png" /></p><p>现在，如果我们想要减少特征的数量，我们应该选择什么呢？</p><p>我们不希望只选择长度 <span class="math inline">\(x_1\)</span> 而忽略高度 <span class="math inline">\(x_2\)</span>，也不希望只选择高度 <span class="math inline">\(x_2\)</span> 而忽略长度 <span class="math inline">\(x_1\)</span>。为了解决这个问题，PCA算法提出了一个思想：寻找一个新的轴，我们可以将其称为Z轴。请注意，这里的Z轴并不是在三维空间中突出显示的Z轴，而是长度和高度的组合，也是在这个二维平面中的。 <img src="/img/5无监督学习/Pasted%20image%2020230721120803.png" /></p><p>Z轴能够获得关于长度和高度的信息。Z轴上的值可以映射到 <span class="math inline">\(x_1\)</span> 轴和 <span class="math inline">\(x_2\)</span> 轴， <span class="math inline">\(x_1\)</span> 轴上的这个距离是多少，可以告诉我们汽车的长度是多少；<span class="math inline">\(x_2\)</span> 轴上的这个距离是多少，告诉我们汽车的高度是多少。</p><p><img src="/img/5无监督学习/Pasted%20image%2020230721121015.png" /></p><p>现在，我们只需要一个数字即可反映出汽车的长度和高度的特征。 重建可以知道原来的特征数据（近似的）是多少。这些新轴即为主成分。</p><p>通过PCA算法，我们能够将原始高维数据映射到低维空间，将数据的维度减少到我们所选择的新轴上，同时保留了关键的信息。这样做有助于简化问题、减少计算复杂性，并且仍然能够提供有关汽车尺寸的重要特征。</p><h2 id="pca代码实现scikit-learn">PCA代码实现(scikit-learn)</h2><p>2D to 1D <img src="/img/5无监督学习/Pasted%20image%2020230721131231.png" /></p><p>2D to 2D <img src="/img/5无监督学习/Pasted%20image%2020230721131323.png" /></p><h2 id="线性回归和pca区别">线性回归和PCA区别</h2><p>线性回归是求绿色线最小值 PCA求黄色线最小值 <img src="/img/5无监督学习/Pasted%20image%2020230721123113.png" /></p><h2 id="应用pca的建议">应用PCA的建议</h2><p><img src="/img/5无监督学习/Pasted%20image%2020230721131635.png" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习04-树模型</title>
    <link href="/2023/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A004-%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A004-%E6%A0%91%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="分类决策树">分类决策树</h1><p><img src="/img/4树模型/Pasted%20image%2020230715193726.png" /></p><ol type="1"><li>在每个节点上如何选择特征进行拆分？</li></ol><ul><li>选择要拆分的特征以尝试最大化纯度 <img src="/img/4树模型/Pasted%20image%2020230715170822.png" /></li></ul><ol start="2" type="1"><li>何时停止分支？ <img src="/img/4树模型/Pasted%20image%2020230715171547.png" /></li></ol><ul><li>分出类别</li><li>达到最大深度</li><li>当纯度低于阈值</li><li>节点的示例数量低于阈值</li></ul><h1 id="纯度">纯度</h1><p>熵（entropy）的定义，它是衡量一组数据不纯度（混乱程度）的指标。 熵越小，纯度越高</p><p><img src="/img/4树模型/Pasted%20image%2020230715172451.png" /></p><p>熵函数 <img src="/img/4树模型/Pasted%20image%2020230715172601.png" /> 在决策树构建的过程中，我们希望通过选择特征使得熵最小化，即寻找能够最大程度减少数据集的纯度。通过计算每个特征的熵，并对其进行比较，我们可以选择最佳的划分特征来构建决策树的节点。</p><h1 id="选择拆分信息增益">选择拆分信息增益</h1><p>在决策树中，熵的减少称为信息增益（information gain） 信息增益是决策树算法中用于选择最佳划分特征的指标之一。它表示通过使用某个特征对数据集进行划分所能获得的整体熵减少量。</p><p>在计算信息增益时，首先需要计算划分前的数据集的熵（也称为初始熵）。然后，对于每个候选划分特征，并计算每个划分子集的熵。最后，通过计算划分前的熵与所有划分子集熵的加权平均来计算信息增益。</p><p><img src="/img/4树模型/Pasted%20image%2020230715183454.png" /> 其中，初始熵是对整个数据集进行计算得到的熵，子集熵是对每个划分子集进行计算得到的熵，子集样本数是每个划分子集中的样本数量，总样本数是整个数据集的样本总数。</p><p>未分支前有5个猫，5个狗，因此初始熵熵 <span class="math inline">\(H(0.5)=1\)</span> 。 分支后加权平均的熵为上图红色方框，未分支前的熵减去分支后加权平均的熵即为信息增益。</p><p>具体计算公式如下：</p><p>信息增益 = 初始熵 - ∑(子集熵 * 子集样本数 / 总样本数) <img src="/img/4树模型/Pasted%20image%2020230715191714.png" /></p><p>信息增益表示通过使用某个特征划分数据集，分支后，<strong>整体熵相对于初始熵的减少量</strong>。我们希望选择具有<strong>最大</strong>信息增益的特征作为划分依据，因为它能够最大程度地<strong>减少数据集的不确定性（混乱程度）</strong>，提供更多有用的信息。</p><p>总结：熵代表混乱程度，熵越高，混乱程度越高；信息增益越大，熵减少的越大，说明从高熵减低到低熵，进而说明从高混乱程度到低混乱程度的变化。</p><h1 id="决策树步骤">决策树步骤</h1><p><img src="/img/4树模型/Pasted%20image%2020230715193336.png" /> 从根节点开始，将所有的示例放置在根节点上。 计算所有可能特征的信息增益，并选择具有最高信息增益的特征。 根据所选特征划分数据集，并创建决策树的左右分支。 不断重复划分过程，直到满足停止准则为止： - 当一个节点是100%属于某一类别时 - 当划分一个节点会导致树超过最大深度时 - 额外划分带来的信息增益低于阈值时。</p><h1 id="如何处理连续值特征">如何处理连续值特征</h1><p>在决策树中处理连续性数值的特征通常有两种方法：二元切分和多元切分。</p><ol type="1"><li><p>二元切分（Binary Splitting）：通过选择一个阈值来将连续性数值特征进行二元切分。对于给定的连续性特征，可以选择一个合适的阈值将数据集划分为两个子集。例如，如果特征是年龄，可以选择一个年龄阈值，将数据分为小于等于阈值和大于阈值的两个子集。然后，根据这个划分继续构建决策树。</p></li><li><p>多元切分（Multi-way Splitting）：与二元切分不同，多元切分将连续性数值特征划分为多个范围或区间。通过指定多个阈值或范围，将连续性特征划分为多个子集。例如，对于年龄特征，可以指定年龄范围(0-10岁, 11-20岁, 21-30岁, 等等)作为划分依据。然后，根据这个划分继续构建决策树。</p></li></ol><p>无论是二元切分还是多元切分，决策树都会根据划分结果计算信息增益或其他评估指标，选择最佳的划分。</p><p>在示例中增加一列体重特征： <img src="/img/4树模型/Pasted%20image%2020230715195850.png" /> 对于体重，我们选取不同的阈值来分割，然后计算对应的信息增益 <img src="/img/4树模型/Pasted%20image%2020230715200031.png" /> 当选择9时，信息增益最大，因此我们用是否大于9磅进行分支。</p><h1 id="回归决策树">回归决策树</h1><p>预测体重： <img src="/img/4树模型/Pasted%20image%2020230715201645.png" /></p><p><img src="/img/4树模型/Pasted%20image%2020230715201734.png" /></p><p><img src="/img/4树模型/Pasted%20image%2020230715201805.png" /> 方差 方差减小最大</p><h1 id="有放回抽样样本">有放回抽样样本</h1><p>共十个样本，五个猫 五个狗，有放回的抽取10次，组成一个新的训练集。 <img src="/img/4树模型/Pasted%20image%2020230715212515.png" /></p><h1 id="装袋决策树">装袋决策树</h1><p>有一个大小为m的训练集。</p><p>b等于1到B，我们将训练集放入袋子中，利用有放回抽样选出B次大小为m的新的训练集，我们在这些新的训练集中训练一个个决策树。 <img src="/img/4树模型/Pasted%20image%2020230715222743.png" /> 选出一个新的训练集，训练一个决策树；选出另外一个新的训练集，在训练一个决策树，就这样选出B个训练集，训练出B个决策树。 B则代表决策树的数量， 已经构建了一个包含B棵不同树的集合，然后让这些树对预测的结果进行投票。</p><p>当B远大于100时，算法的性能并不会有显著的增加，只会降低计算速度。</p><p>这种从袋子中选出新的训练集创建的决策树称为装袋决策时，所以B代表的是bag。</p><p>弊端是，这种抽取训练集的方法，会使许多树在根节点或者根节点附近的某些节点使用相同的特征进行分支。因此对算法进行改进，尝试随机化每个节点的特征选择，使数之间变得更加不同这就是随机森林。 # 随机森林</p><p>在每个节点上，在选择用于划分的特征时，如果有n个可用特征，则从中随机选择一个大小为k（k &lt; n）的特征子集，并只允许算法从该特征子集中进行选择，从中选择出具有最高信息增益的特征进行分支。 当n很大时，K值的典型选择是它的平方根 <span class="math inline">\({\mathrm{k=\sqrt{n}}}\)</span> 。</p><p>因此，这意味着训练集的任何微小变化都不太可能对整个随机森林算法的整体输出产生巨大影响。</p><h1 id="xgboost">XGBoost</h1><p>依然使用有放回的抽样方式，创建一个大小为m的新训练集。但不是以相等的（1/m）概率从所有示例中抽取，而是更有可能抽取那些先前训练树分类错误的示例。</p><p><strong>优势：</strong> 助推树的开源实现 快速高效的实现 可选择良好的默认拆分标准和何时停止拆分的标准 内置正则化，防止过拟合 机器学习竞赛（如Kaggle竞赛）中极具竞争力的算法 # 决策树VS神经网络 <img src="/img/4树模型/Pasted%20image%2020230716093526.png" /></p><ol type="1"><li><p>数据集的特征：决策树在处理具有离散特征和类别特征的数据集时表现较好，而神经网络在处理具有连续特征和大量样本的数据集时通常更有效。</p></li><li><p>数据集的大小：如果数据集非常大，神经网络通常能够通过深层次的学习来发现复杂的模式和关联，因此神经网络可能更适合用于大规模数据集。</p></li><li><p>解释性要求：决策树提供了较好的可解释性，可以根据节点分裂规则和特征重要性进行解释。而神经网络通常被认为是“黑盒”模型，其内部权重和参数难以解释。</p></li><li><p>预测性能需求：神经网络在某些高度复杂的问题上可能具有更强的预测性能，尤其是当数据集具有深层次的非线性关系时。集成树模型如随机森林和梯度提升树则在处理噪声和异常值方面表现较好。</p></li><li><p>训练效率：决策树通常更容易训练和调优，而神经网络需要更多的计算资源和时间来训练和优化。</p></li><li><p>预测速度：决策树是一种基于规则的模型，可以快速进行预测。相比之下，神经网络需要通过多层次的计算才能进行预测，因此在实时性要求较高的场景中可能不太适用。</p></li></ol><p>最终的选择应该根据具体问题的需求和数据集特征来决定。在某些情况下，使用决策树和集成树（如随机森林、梯度提升树）能够提供较好的性能和解释性；而在其他情况下，神经网络可能会更适合。还可以尝试将两种算法结合起来，如使用神经网络进行特征提取，然后使用决策树进行分类或回归。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习03-模型评估</title>
    <link href="/2023/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A003-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/"/>
    <url>/2023/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A003-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="模型选择">模型选择</h1><p>如何评估学习算法，自动选择模型？</p><p>模型选择&amp;交叉验证测试集的训练方法</p><p>因为d也是一个需要学习的参数，不断选择d的过程本质上和学习模型内参数w,b是一致的，而超参数d本就是靠在test集上测试找到的，而test集在这里就成为参数d的“训练集”，所以这样得出的d是过拟合的</p><p>简而言之 Training set 用来 选 w&amp;b, cross validation用来选 d , Test set 用来评估 模型 最终的 泛化误差 - 就是这个模型好不好</p><p>训练集：得到模型，得到每个模型的w，b 验证集:挑选模型，挑选某一个模型 测试集：评估挑选的模型的泛化能力</p><p>只有在你想出一个模型作为你的最终模型之后，才可以在测试集上对其进行评估，并且因为你没有使用测试集做出任何决定，这可以确保你的测试集是公平的而不是过度的对您的模型对新数据的泛化能力的乐观估计</p><p>选择几个模型进行训练，然后用交叉验证集对几个模型进行损失值评估，以此选出最好的模型，再通过测试集新数据评估该模型泛化误差</p><h1 id="偏差与方差">偏差与方差</h1><p>高偏差（欠拟合） 高方差（过拟合）</p><p>多项式最高次数与代价函数值图： <img src="/img/3模型评估/Pasted%20image%2020230713190145.png" /></p><p>多项式次数低，欠拟合，训练集成本函数值（<span class="math inline">\(J_{train}\)</span>）高，交叉验证集成本函数值（<span class="math inline">\(J_{cv}\)</span>）高。</p><p>多项式次数高，过拟合，<span class="math inline">\(J_{train}\)</span> 低，<span class="math inline">\(J_{cv}\)</span> 高。</p><p>一般在神经网路中才同时具有高偏差和高方差。</p><p>高偏差意味着在训练集上做的不好。高方差意味着在训练集和交叉验证集都不好。</p><h1 id="正则化如何影响方差和偏差">正则化如何影响方差和偏差</h1><p><img src="/img/3模型评估/Pasted%20image%2020230713203458.png" /></p><h1 id="正则化中-lambda-评估">正则化中 <span class="math inline">\(\lambda\)</span> 评估</h1><p><span class="math inline">\(\lambda\)</span> 与代价函数值图： <img src="/img/3模型评估/Pasted%20image%2020230713204607.png" /> <span class="math inline">\(\lambda\)</span> 小，过拟合，<span class="math inline">\(J_{train}\)</span> 低，<span class="math inline">\(J_{cv}\)</span> 高。 <span class="math inline">\(\lambda\)</span> 大，欠拟合，<span class="math inline">\(J_{train}\)</span> 高，<span class="math inline">\(J_{cv}\)</span> 高。</p><h1 id="性能评估的基准">性能评估的基准</h1><p><img src="/img/3模型评估/Pasted%20image%2020230714164315.png" /></p><p>评估基准：你希望算法能达到的性能是多少 - 人类水平的表现 - 竞争对手的算法，其他人以前已经实现的算法 - 以往的经验</p><h2 id="是否具有高方差偏差">是否具有高方差/偏差</h2><p><img src="/img/3模型评估/Pasted%20image%2020230714164706.png" /> 相互比较</p><h2 id="高偏差的学习曲线">高偏差的学习曲线</h2><p><img src="/img/3模型评估/Pasted%20image%2020230714170245.png" /> 具有高偏差欠拟合的模型，加训练数据量没法改善，从模型选择就有问题； 欠拟合对新数据不敏感</p><h2 id="高方差的学习曲线">高方差的学习曲线</h2><p><img src="/img/3模型评估/Pasted%20image%2020230714171220.png" /> 高方差过拟合加训练数据量可以改善； 过拟合对新数据特别敏感。</p><p>缺点是，使用训练集的不同大小的子集来训练这么多不同的模型在计算上非常昂贵，在实践中，并没有这样做。虽然如此，在脑海中形成训练集的视觉图像，有时可帮助思考学习算法在做什么，是否具有高偏差或高方差</p><h1 id="调试学习算法">调试学习算法</h1><p><img src="/img/3模型评估/Pasted%20image%2020230714173338.png" /></p><p>高方差：增加训练数据，简化模型（减少特征、增加<span class="math inline">\(\lambda\)</span>） 高偏差：强化模型（增加特征、增加多项式、降低<span class="math inline">\(\lambda\)</span>）</p><h1 id="误差分析">误差分析</h1><p>算法错误分类了100个样本，我们手动分析这一百个样本，并试图深入了解算法出错的地方，将它们分组为共同的主题或共同的属性或共同的特征。 <img src="/img/3模型评估/Pasted%20image%2020230714185413.png" /> 分析发现： 药品垃圾邮件21件 故意拼写错误3件 邮件路由错误7件 钓鱼邮件18件 图片5件 那我们将重心放在识别药品垃圾邮件和钓鱼邮件，而不是放在识别拼写错误这种净影响实际上非常小的问题上。</p><p>例如对于药品垃圾邮件，可以收集更多的关于药物垃圾邮件数据，而不是收集更多的所有数据，以便学习算法可以更好地识别这些药物垃圾邮件。</p><p>但是现在错误分析的一个局限性是它更容易解决人类擅长的问题。比如人们可以直接的分辨出是否为垃圾邮件，对于连人类都不擅长的任务，错误分析可能会更难一些，例如，如果试图预测人们会点击网站上的哪些链接。对于这种主观性较大的事件，可能无法预测人会点击什么。</p><h1 id="添加有帮助的数据">添加有帮助的数据</h1><p>采用现有的训练示例并对其进行修改、扭曲以创建另一个训练示例。 例如，计算机视觉常用合成数据进行增加训练样本。 <img src="/img/3模型评估/Pasted%20image%2020230714203623.png" /> 有时花更多时间采用以数据为中心的方法会更有成效，在这种方法中，专注于设计算法使用的数据，数据可以来源于收集、数据增强、数据合成。</p><p>可以用迁移学习的方法获取数据，关键在于从几乎不相关的任务中获取数据。</p><h1 id="迁移学习">迁移学习</h1><p>迁移学习可以使用其他任务中的数据应用于程序，核心思想是从一个任务学到的知识或模型应用于另一个相关任务上。通过迁移学习，可以在目标任务上利用源任务的经验和模型参数，从而加快目标任务的训练速度、提高预测性能。</p><p>迁移学习的基本假设是：不同的任务之间存在某种共享的特征表示或知识，这些特征和知识对于解决其他任务也是有用的。通过迁移学习，可以利用源任务的经验来帮助目标任务的学习，尤其在目标任务的数据较少或难以获取的情况下，迁移学习可以发挥重要作用。</p><p>假设要识别从0-9的手写识别，但是没有这么多用于训练的数据。 可以这样做， 假设您找到了一个非常大的数据集，其中包含一百万张猫、狗、汽车等一千个类别的图片，然后，您可以用这一百万张图片训练一个识别个个类别的神经网络，即训练算法将一百万张图像X作为输入，将1,000个不同的类别作为输出。 <img src="/img/3模型评估/Pasted%20image%2020230715085908.png" /> 这个神经网路共五层，四个隐藏层和一个输出层。各层的参数分别为<span class="math inline">\(\mathbf{W}^{[1]},\vec{\boldsymbol{b}}^{[1]}\)</span>、<span class="math inline">\(\mathbf{W}^{[2]},\vec{\boldsymbol{b}}^{[2]}\)</span>、<span class="math inline">\(\mathbf{W}^{[3]},\vec{\boldsymbol{b}}^{[3]}\)</span>、<span class="math inline">\(\mathbf{W}^{[4]},\vec{\boldsymbol{b}}^{[4]}\)</span>、<span class="math inline">\(\mathbf{W}^{[5]},\vec{\boldsymbol{b}}^{[5]}\)</span> 要应用迁移学习，您要做的是复制此神经网络，在其中插入参数<span class="math inline">\(\mathbf{W}^{[1]},\vec{\boldsymbol{b}}^{[1]}\)</span>、<span class="math inline">\(\mathbf{W}^{[2]},\vec{\boldsymbol{b}}^{[2]}\)</span>、<span class="math inline">\(\mathbf{W}^{[3]},\vec{\boldsymbol{b}}^{[3]}\)</span>、<span class="math inline">\(\mathbf{W}^{[4]},\vec{\boldsymbol{b}}^{[4]}\)</span> 但对于最后一层输出层，用0-9代替原来的一千个分类，然后用优化 算法，例如梯度下降或Adma算法仅更新 <span class="math inline">\(\mathbf{W}^{[5]},\vec{\boldsymbol{b}}^{[5]}\)</span> ；对于<span class="math inline">\(\mathbf{W}^{[1]},\vec{\boldsymbol{b}}^{[1]}\)</span>-<span class="math inline">\(\mathbf{W}^{[4]},\vec{\boldsymbol{b}}^{[4]}\)</span> 用原来的值 不更新。</p><p><img src="/img/3模型评估/Pasted%20image%2020230715091903.png" /></p><p>另一种策略是，更新所有的参数，但是<span class="math inline">\(\mathbf{W}^{[1]},\vec{\boldsymbol{b}}^{[1]}\)</span>、<span class="math inline">\(\mathbf{W}^{[2]},\vec{\boldsymbol{b}}^{[2]}\)</span>、<span class="math inline">\(\mathbf{W}^{[3]},\vec{\boldsymbol{b}}^{[3]}\)</span>、<span class="math inline">\(\mathbf{W}^{[4]},\vec{\boldsymbol{b}}^{[4]}\)</span> 使用上面训练过的值作为初始值，在此基础上进行更新。</p><p>如果有一个非常小的训练集，前一种策略较好，如果训练集稍微大一点，后一种策略较好。</p><p>迁移学习的两个步骤，首先在大型数据集上进行训练，即预训练；然后在较小的数据集上进一步调整参数，即微调。</p><p>我的理解： 预训练是用预训练的数据集找出一个大致的工作模板，第一步该干什么，第二步该干什么什么，最后得出结论。 微调是在已有的工作模板上直接按部就班，但是需要进行一些改动、优化，使之变得符合本项目的工作流程。</p><p>GPT: 预训练的目标是通过大规模数据集，使模型学习到一些通用的特征表示或知识。这个过程可以被看作是为模型提供一个“大致的工作模板”，其中包含了一些普遍适用的信息。预训练可以使用无监督学习方法，如自编码器或生成对抗网络，也可以使用有监督学习方法。预训练后的模型通常具有更好的初始特征表示能力。</p><p>微调则是在预训练模型的基础上，通过在目标领域的较小数据集上进行进一步训练来调整模型参数。微调过程中，可以根据具体任务的需求进行一些改动、优化或修正，以使模型更符合目标任务的工作流程。微调的目的是将预训练模型适应特定任务的特征和表现能力，提高模型在目标领域上的性能。</p><p>总结来说，预训练提供了一个初始的模板或特征表示，微调则是在此基础上进行调整和优化，以适应具体的任务需求和数据分布。这样的迁移学习方法可以减少对大量标注数据的依赖，提高模型的泛化性能。</p><h1 id="倾斜数据集的误差指标">倾斜数据集的误差指标</h1><p>如果正例与负例比例偏差很大，那么像准确度这种错误指标效果不佳。</p><p>假设正在训练一个二分类模型，检测患者是否患罕见疾病，在人群中只有0.5%发病率。</p><p>对于这种倾斜数据集的衡量常用准确率（Precisionn）和召回率（Recall）</p><p><img src="/img/3模型评估/Pasted%20image%2020230715114140.png" /> 高精度意味着如果患者被诊断患有这种罕见疾病，那么该患者可能确实患有这种疾病，并且这是一个准确的诊断。 高召回率意味着如果有患者患有这种罕见疾病，算法可能会正确识别出他们确实患有这种疾病。</p><p>预测的准确性和漏判的概率 Precision很高：说话靠谱；Recall很高：遗漏率很低。 当两者都较高时模型才有较好的效果。</p><p>因此，当有偏斜类或想要检测稀有类时，精确率和召回率可以判断算法是否做出了良好的预测或有用的预测。</p><h1 id="精确率与召回率的权衡">精确率与召回率的权衡</h1><p>当使用逻辑回归模型时，可更改阈值来权衡精确率和召回率 <img src="/img/3模型评估/Pasted%20image%2020230715120340.png" /> 当阈值提高到0.7，则说明当算法有70%及以上的信心认为样本患病时，才把该样本标记为患病。如果只有69%的信心时，则不标记患病，划分为未患病。</p><p>因此，通过提高阈值，可以提高精确度，但是会降低召回率。</p><p>如果治疗花费非常高、对患者伤害很大，则可能需要高精确度。反之，如果花费不是很高，伤害也小，但是不治疗会带来更糟糕的后果，则可能需要高召回率。</p><p>F1 Score，用于自动结合精确度和召回率，以帮助你选择最佳算法或最佳权衡两者。更强调的是这些值中较低的那个。数值较大的算法较好 <img src="/img/3模型评估/Pasted%20image%2020230715122058.png" /> 种结合P和R精度和召回率的方法，但它更强调这些值中较低的那个</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习02-多分类问题</title>
    <link href="/2023/07/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A002-%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    <url>/2023/07/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A002-%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="多分类问题">多分类问题</h1><h3 id="softmax回归">Softmax回归</h3><p>当有四种分类时： <img src="/img/2多分类问题/Pasted%20image%2020230712183238.png" /></p><p>普试： <img src="/img/2多分类问题/Pasted%20image%2020230712183725.png" /> <span class="math inline">\(a_{j}\)</span>被解释为给定输入特征x时模型对y等于j的概率。</p><h3 id="softmax回归的损失函数">Softmax回归的损失函数</h3><p><img src="/img/2多分类问题/Pasted%20image%2020230712185008.png" /> 损失函数衡量的是在一个训练样例上的表现如何，所以对于一个特定的训练样本，y只能取一个值。因此最终只能针对 <span class="math inline">\({a}_j\)</span> 的一个值计算 <span class="math inline">\({a}_j\)</span> 的负对数，即在该特定训练样本中y的实际值等于j的任何值。例如，当y等于2时，损失函数只计算 <span class="math inline">\(-\log a_{2}\)</span></p><h3 id="神经网络的softmax输出">神经网络的Softmax输出</h3><p><img src="/img/2多分类问题/Pasted%20image%2020230712191305.png" /> sigmod激活函数，激活值 <span class="math inline">\({a}_1\)</span> 仅是 <span class="math inline">\({z}_1\)</span> 的函数 ，<span class="math inline">\({a}_2\)</span> 也只是 <span class="math inline">\({z}_2\)</span> 的函数。但是对于softmax函数，每一个激活值都取决于Z的所有值。</p><h3 id="tensorflow实现">Tensorflow实现</h3><p>基本实现： <img src="/img/2多分类问题/Pasted%20image%2020230712192259.png" /></p><p>更好的实现：（P68） <img src="/img/2多分类问题/Pasted%20image%2020230712194825.png" /></p><p>目的在于减小计算误差。计算机是将数字转换为二进制计算数值的，会有误差。原来是先计算出a，再将a带入到损失函数中计算损失函数，这种利用中间值计算的损失函数具有误差。</p><p>现在softmax不再单独计算，在计算cost时将a嵌入损失韩素内部一起算了。并且输出层为 liner，这样输出层只会直接输出Z的值，不再带入softmax计算了。 完整代码： <img src="/img/2多分类问题/Pasted%20image%2020230712195606.png" alt="多分类优化代码" /></p><p>逻辑回归优化代码： <img src="/img/2多分类问题/Pasted%20image%2020230712195739.png" alt="逻辑回归优化代码" /></p><p>epochs 迭代次数。</p><h1 id="多标签分类问题">多标签分类问题</h1><p><img src="/img/2多分类问题/Pasted%20image%2020230712203304.png" /> 多标签分类问题是指对一个样本进行多个类别的分类，而不是将样本分到唯一的类别中。在多标签分类问题中，每个样本可以属于多个类别，类别之间是相互独立的。</p><p>举个例子，假设我们有一个图像识别任务，需要对图像进行多个标签的分类，比如识别图像中的汽车、公交车、行人。一张图像可能同时包含多个标签，比如既有人又有汽车。</p><p>训练三个单独的模型，分别识别有没有汽车、公交车、行人。 训练一个模型一次识别完。输出层有三个sigmod神经元，因此我们解决的是三个二分类问题。</p><p><img src="/img/2多分类问题/Pasted%20image%2020230712204335.png" /></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习01-神经网络</title>
    <link href="/2023/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A001-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A001-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="神经网路">神经网路</h2><p>什么是神经网络（Neural Networks）？最开始科学家想用算法去模拟大脑达到人工智能。通过一系列的实验发现，大脑是通过神经元进行工作的，神经元之间通过电信号传递信息。于是他们就开始模拟神经元的工作过程，用算法去模拟神经元，这就形成了神经网络。神经网络可以用来学习复杂的<strong>非线性假设模型</strong>。</p><p>为了构建神经网络模型，我们需要首先思考大脑中的神经网络是怎样的？</p><p>大脑中的神经元接受许多输入的信息，并进行一些计算和处理，计算后通过电脉冲发送给其他的神经元。上层神经元的输出又成为下层神经元的输入，下层神经元再次聚合来自其他神经元的输出作为该神经元的输入，然后将自己的输出发到其他神经元。这便是大脑中神经网络的工作原理。</p><p><img src="/img/1深度学习神经网络/Neurons_big1.jpg" /></p><p>我们将神经元简化如下：</p><p><img src="/img/1深度学习神经网络/Snipaste_2023-06-29_10-54-00.png" /> 每一个生物神经元都可以被认为是一个处理单元/神经核（<strong>processing unit</strong>/<strong>Nucleus</strong>），它含有许多输入/树突（<strong>input</strong>/<strong>Dendrite</strong>），并且有一个输出/轴突（<strong>output</strong>/<strong>Axon</strong>)。生物神经元会发送电脉冲，成为另一个神经元的输入。神经网络是大量神经元相互链接并通过电脉冲来交流的一个网络。</p><p>所有<strong>人工神经网络</strong>使用的是非常简化的生物神经元的数学模型。</p><p>我们用圆圈表示一个神经元，神经元所做的就是接受一个或多个输入，这些输入为数字，它进行一些计算后，输出一些数字，这些数字又作为下一层神经元的输入。我们构建人工神经网路时，通常同时模拟多个这样的神经元，而不是构建一个。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230708182836.png" /></p><h2 id="神经网络如何工作的">神经网络如何工作的？</h2><h3 id="案例一">案例一</h3><p>我们用需求案例来了解神经网路时如何工作的，这个案例中目标是想知道那些短袖可能成为畅销品，以来规划更好的库存水平和营销活动。收集的数据有：不同短袖的价格，以及是否是畅销品。</p><p><img src="/img/1深度学习神经网络/Pasted%20image%2020230709190636.png" /> 在此示例中，输入特征X是短袖的价格，如果应用逻辑回归sigmoid函数来拟合这些数据，那么预测输出则为<span class="math inline">\(\frac1{1+e^{-(wx+b)}}\)</span> <img src="assets/Pasted%20image%2020230709192135.png" /></p><p>在神经网络中，我们用a来表示算法的输出，a代表激活（activation），来源于神经科学的一个术语，指的是一个神经元向下游其他神经元发送多少高输出。</p><p>这个逻辑回归单元可看作大脑中单个神经元非常简化的数学模型。这个人工神经元所要做的就是，将价格X输入，然后利用sigmoid函数公式 <span class="math inline">\(\frac1{1+e^{-(wx+b)}}\)</span> 计算出输出值a，输出的则为这件短袖可能成为畅销品的概率。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709193702.png" /> 鉴于对单个神经元的描述，构建神经网络只需要将这些神经元并在一起，并将他们连接起来。</p><h3 id="案例二">案例二</h3><p>接下来我们看一个更复杂的需求预测案例，在该案例中我们用四个特征来预测短袖是否为畅销品。四个特征为价格（price）、运费（shipping cost）、营销手段（marketing）、材料质量（material）。我们假设短袖是否能成为畅销品取决于以下几个因素： 1. affordability - 对这件短袖人们是否<strong>可负担</strong>的起?支付能力 2. awareness - 潜在买家对这件短袖的<strong>认识程度</strong>如何？短袖是否知名 3. perceived quality - <strong>感知质量</strong>，人们是否有偏见或潜在偏见说这是一件高质量的短袖？ <img src="/img/1深度学习神经网络/Pasted%20image%2020230709200233.png" /></p><p><strong>首先</strong>，我们要创建一个人工神经元来估计这件短袖被人们认为是可负担的起的概率。支付能力主要是价格和运费的函数，因为一件短袖的支付总额是价格加上运费。所以在这里我们使用一个神经元，一个逻辑回归单元来输入价格和运费，并预测人们是否负担的起。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709212521.png" /></p><p><strong>接着</strong>，创建一个人工神经元来预测潜在买家对这件T恤衫的认识程度。短袖知名程度归因于营销手段。<strong>最后</strong>，要创建另一个神经元来估计人们是否认为这是高质量的短袖。这可能是短袖价格和材料质量的函数。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709213442.png" /></p><p>鉴于对可负担性（affordability）、认识程度（awareness）、感知质量（perceived quality）的预测，我们将这三个神经元的输出连接到右侧另一个神经元，然后该神经元输入这三个数字并输出可能成为畅销品的概率。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709213627.png" /> ==神经网络可看作逻辑回归，但是这个逻辑回归可以学习自身更好的特征，不需要手动设计，从而进行更准确的预测（神经网络=自动化特征工程+逻辑/线性回归)==</p><p>在神经网络术语中我们把，我们将把这三个神经元组合在一起，形成谓的<strong>层（layer）</strong>，层是一组神经元，它们将相同或相似的特征作为输入，然后一起输出一些数字，右边神经元也为层，所以层可以有一个或多个神经元。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709215546.png" /> 右边这一层也叫做<strong>输出层</strong>（output layer），因为最后一层输出的是整个神经网络的预测值。最左边输入的四个特征也叫<strong>输入层</strong>（input layer)。在输入层和输出层中间的所有层都叫<strong>隐藏层</strong>，在神经网络中输入层和输出层都有明确的数值，而中间的层并没有告诉确切的数值，是未知的。</p><p>我们还将 affordability、awareness、perceived quality 叫做激活（activations）。激活源于生物神经元，它指的是生物神经元向下游其他神经元发送的高输出值或发送许多电脉冲的程度。这些关于affordability、awareness和perceived quality的数字是该层中这三个神经元的激活。同样输出概率是右侧这个神经元的激活。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709220948.png" /></p><p>至此，我们手动选择了那个神经元需要那几个特征作为输入，但神经网络在实践中层中的每一个神经元都可以访问上一层的每一个特征，从输入层访问每个值。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709222537.png" /></p><p>你可以想象，如果试图预测短袖的可负担性，并且它知道价格、运费、营销和材料，你可能会忽略营销和材料，只注重于价格和运费。我们就可以通过适当地设置参数来找出那些特征与负担能力最相关，比如价格和运费权重较大，而营销和材料的权重较小。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习00-监督学习</title>
    <link href="/2023/07/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A000-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A000-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="线性回归模型linear-regression">线性回归模型（Linear Regression）</h1><h2 id="假设函数">假设函数</h2><p><span class="math display">\[f_{w,b}(x)=w_{1}x_{1}+w_{2}x_{2}+...+w_{n}x_{n}+b\]</span></p><p>如何确定模型中的参数取什么值? 用代价函数</p><h2 id="代价函数">代价函数</h2><p><a href="如何最简单、通俗地理解代价函数？.md">代价函数</a>（Cost Function）是用来衡量预测值与实际值之间的误差。它的目的是找到一组参数，使得预测值与实际值之间的误差最小（确定最优参数）。评价模型是否拟合的准确，值越小，拟合的越准确。</p><p><strong>线性回归的代价函数</strong>：最小二乘法。所谓“二乘”就是平方的意思。</p><p><span class="math display">\[J(w,b)=\frac{1}{2m}\sum_{i=1}^m\bigl(f_{w,b}\bigl(x^{(i)}\bigr)-y^{(i)}\bigr)^2\]</span></p><pre><code class="hljs">此处1/2m中的2仅为了后续求导计算时，简化计算步骤</code></pre><p><strong>注意：</strong></p><p>代价函数中的 <span class="math display">\[(f_{w,b}\bigl(x^{(i)}\bigr)-y^{(i)}\bigr)^2\]</span> 部分叫损失函数（Loss Function）用L表示 <span class="math display">\[L=(f_{w,b}\bigl(x^{(i)}\bigr)-y^{(i)}\bigr)^2\]</span> 损失函数衡量的是你在一个训练样例上的表现如何，它是通过总结你随后获得的所有训练样列的损失；而代价函数衡量你在整个训练集上的表现。</p><p>因此，代价函数值是在损失函数值求和后除以训练量。</p><p>线性回归代价函数图：</p><p><img src="/img/机器学习/Snipaste_2023-06-09_11-22-50.png" /></p><p>代价函数图自变量为参数，因变量为代价函数值。有代价函数图了，如何自动到达代价函数图的最小值点，即模型拟合最优的点？</p><h2 id="梯度下降gradient-descent">梯度下降（Gradient descent ）</h2><p>从代价函数图中找到最小值所在的点。有没有一种算法可以自动地、快速求出使得代价函数最小的点呢？有，那就是<strong>梯度下降</strong></p><ul><li><p>梯度下降的工作是找到希望最小化代价函数J的参数w和b</p></li><li><p>如何快速到达最优点：从山顶一步一步走到山谷，先在原地转一圈，选最陡的地方走一步，在转一圈，在选最陡的一步。这一步一步就是多个梯度下降的步骤。</p></li><li><p>不同的w，b值决定你在那个位置</p></li><li><p>梯度下降算法 <span class="math display">\[\begin{aligned}w &amp;= w - \alpha \frac{\partial}{d\omega}J(\omega.b) \\b &amp;= b - \alpha \frac{\partial}{d\omega}J(\omega.b)\end{aligned}\]</span></p></li><li><p>梯度下降（Gradient descent ）同时更新w，b。同时更新目的在于，能够确保是在原点寻找最陡方向。赋值就像迈出了一步，先迈出左脚寻找最陡的地方和在原地寻找最陡的地方不一样。</p></li><li><p>α学习率决定你迈出的一步有多大</p></li><li><p>导数决定梯度下降方向，学习率决定步长</p></li></ul><p><img src="/img/机器学习/Snipaste_2023-06-12_19-02-10.png" /></p><p><strong>线性回归的梯度下降：</strong> <span class="math display">\[\begin{aligned}w&amp;=w-\alpha\frac{1}{m}\sum_{i=1}^{m}(f_{w,b}\big(x^{(i)}\big)-y^{(i)})x^{(i)}\\b &amp;=b-\alpha\frac{1}{m}\sum_{i=1}^{m}(f_{w,b}(x^{(i)})-y^{(i)})\end{aligned}\]</span></p><h2 id="多维特征">多维特征</h2><ul><li>矢量化使代码更简短 运行更高效</li></ul><h2 id="特征缩放feature-scaling">特征缩放（<strong>Feature Scaling</strong>）</h2><p>房价</p><p><span class="math display">\[pr i c e=w_{1}x_{1}+w_{2}x_{2}+b\]</span> <span class="math inline">\(x_{1}\)</span> : size（feet^2）range :300-2000 <span class="math inline">\(x_{2}\)</span> : # bedrooms range :0-5</p><p>当特征的可能值较大时，如房间大小(<span class="math inline">\(x_{1}\)</span>)，则其参数(<span class="math inline">\(w_{1}\)</span>)的合理值将相对较小 当特征的可能值较小时，如卧室数量(<span class="math inline">\(x_{2}\)</span>)，则其参数(<span class="math inline">\(w_{2}\)</span>)的合理值将相对较大</p><p><img src="/img/机器学习/Snipaste_2023-05-27_11-58-53.png" /></p><p>特征散点图如左上时，其代价函数在等高线图中的样子如右上所示，为椭圆形，梯度下降可能会在它最终找到全局最小值之前来回弹跳很长的时间。</p><p>所以当你有不同的特征，它们的取值范围非常不同时，它可能会导致梯度下降运行缓慢，但重新缩放不同的特征，使它们都具有可比较的取值范围，让梯度下降法运行得更快。</p><h3 id="如何实现特征缩放">如何实现特征缩放？</h3><p>将数据标准化、归一化</p><p><strong>平均值归一化方法（Mean normalization）</strong></p><p>如果要将该值映射到[-1,1]区间内，则需要计算特征的平均值<span class="math inline">\(X_{Mean}\)</span>，使用平均值归一化方法公式为</p><p><span class="math display">\[x=\frac{X-X_{Mean}}{X_{Max}-X_{Min}}\]</span></p><p><strong>Z-score标准化方法（Z-score Normalization）</strong></p><p>标准化法需要提前计算特征的均值<span class="math inline">\(X_{Mean}\)</span>和标准差<span class="math inline">\(\sigma\)</span>，标准化后的变量值围绕0上下波动，大于0说明高于平均水平，小于0说明低于平均水平。 <span class="math display">\[x={\frac{X-X_{M e a n}}{\sigma}}\]</span></p><h3 id="缩放的范围是否有固定的要求">缩放的范围是否有固定的要求？</h3><p><img src="/img/机器学习/Snipaste_2023-06-08_16-08-53.png" /></p><p>最好是-1到1，实在不行，最大是-3到3，最小是-0.3到0.3，都能接受。</p><p>基本意思是，保证各个特征的数量级一致，通过缩放尽量让所有特征的取值在差不多范围，在一个数量级以内的特征可以不考虑缩放，这样它们的变化对预测值的影响都是接近的。</p><h2 id="判断梯度下降是否收敛">判断梯度下降是否收敛？</h2><p>在运行梯度下降时，怎样才能知道梯度下降是否有效，是否正在找到全局最小值或接近它的值？为了能够选择更好的学习率。</p><p>判断梯度下降运行是否良好，用<strong>学习曲线</strong>（learning curve），横轴为梯度下降迭代次数，纵轴为代价函数J。</p><p><img src="/img/机器学习/Snipaste_2023-06-08_17-32-14.png" /> 当运行良好时，学习曲线是一直下降的，直到变平（即收敛)；当出现先下降后又上升的情况时，可能是学习率错误，或者程序错误。查看此学习曲线，您可以尝试发现梯度下降是否收敛。</p><p>另一种方法是<strong>自动收敛测试</strong>（Automatic convergence test） 令<span class="math inline">\(\epsilon\)</span> ”epsilon“等于一个非常小的数，如果代价J在一次迭代中减少的幅度小于这个数字epsilon,那么很可能位于学习曲线的平坦部分，可以宣布收敛。但是选择正确的阈值epsilon非常困难。</p><h2 id="如何设置学习率">如何设置学习率？</h2><p>当梯度下降函数运行有错误时，可能是学习率太大了或者程序有错误。</p><ul><li>学习率过大，调小学习率</li><li>程序有错误，查看公式是否写错，比如把减号写成加号</li></ul><p><strong>尝试不同的学习率并画对应的学习曲线</strong></p><p>……0.001，0.003，0.01，0.03，0.1，0.3，1 ……</p><p><img src="/img/机器学习/Snipaste_2023-06-08_17-54-18.png" /></p><p>在太小，太大的学习率之间调试。</p><h2 id="特征工程feature-engineering">特征工程（feature engineering）</h2><p>利用领域知识和现有数据，创造出新的特征，用于机器学习算法；可以手动（manual）或自动（automated）。</p><p>如果新特征是原始特征的次方，那么特征缩放会非常重要</p><p><img src="/img/机器学习/Snipaste_2023-06-08_18-10-02.png" /></p><h1 id="分类classification">分类（Classification）</h1><h2 id="逻辑回归logistic-regression">逻辑回归（logistic regression）</h2><h3 id="假设函数-1">假设函数</h3><p>首先介绍sigmoid函数，又称logistic函数</p><p><img src="/img/机器学习/Snipaste_2023-06-09_08-48-39.png" /></p><p><span class="math display">\[g(z)=\frac{1}{1+e^{-z}}\quad0&lt;g(z)&lt;1\]</span></p><p>当z取无限大时，函数趋向于1；当取无限小时，趋向于0。该函数表示结果输出为1的概率。</p><p>令 <span class="math display">\[\text{Z}=\overrightarrow{W}\cdot\overrightarrow{X}+b\]</span> 则逻辑回归的假设函数为 <span class="math display">\[f_{\overrightarrow{W},b}(\overrightarrow{X})=g(\vec{W}\cdot\vec{X}+b)=\frac{1}{1+e^{-(\overrightarrow{W}\cdot\overrightarrow{X}+b)}}\]</span></p><h3 id="代价函数-1">代价函数</h3><p>首先我们回顾一下之前学过的一个代价函数，线性回归的代价函数： <span class="math display">\[J(w,b)=\frac{1}{2m}\sum_{i=1}^m\bigl(f_{w,b}\bigl(x^{(i)}\bigr)-y^{(i)}\bigr)^2\]</span> 如果把此代价函数用在逻辑回归中会怎么样？我们看一下应用该代价函数的代价函数图：</p><p><img src="/img/机器学习/Snipaste_2023-06-12_17-13-32.png" /></p><p>我们发现，，此函数不是凸函数，如果用梯度下降的话，找到的是局部最优，不是整体最优。</p><pre><code class="hljs">凸函数有个很好的性质，只要能证明是凸函数，最终解一定是全局最优解，即局部最小值是全局最小值。</code></pre><p>因此，最小二乘法代价函数不适合逻辑回归。</p><p>我们定义<strong>逻辑回归的损失函数</strong>如下（后续说明为何定义该函数）:  $$L\left(f_{\overrightarrow{{{w}}},b}\left(\overrightarrow{{{x}}}^{(i)}\right),y^{(i)}\right)=\left\{\begin{array}{rl}{{-\log\left(f_{\overrightarrow{{{w}}},b}\left(\overrightarrow{{{x}}}^{(i)}\right)\right)}}&{{\mathrm{if~}y^{(i)}=1}}\\ {{-\log\left(1-f_{\overrightarrow{{{w}}},b}\left(\overrightarrow{{{x}}}^{(i)}\right)\right)}}&{{\mathrm{if~}y^{(i)}=0}}\end{array}\right. $$</p><p>因此，逻辑回归的代价函数如下：</p><p><span class="math display">\[J(\overrightarrow{W},b)=\frac{1}{m}\sum_{i=1}^{m}L\bigl(f_{\overrightarrow{W},b}\bigl(\overrightarrow{x}^{(i)}\bigr),y^{(i)}\bigr)\]</span></p><p>由于y的取值只能是0或1，所以<strong>简化</strong>后的损失函数及代价函数如下：  $$\begin{aligned}&L{\big(}f_{\overrightarrow{{{w}}},b}{\big(}\overrightarrow{{{x}}}^{(i)}{\big)},y^{(i)}{\big)}=-y^{(i)}\mathrm{log}{\Big(}f_{\overrightarrow{{{w}}},b}{\big(}\overrightarrow{{{x}}}^{(i)}{\big)}{\Big)}-{\big(}1-y^{(i)}\big){\mathrm{log}}{\Big(}1-f_{\overrightarrow{{{w}}},b}{\big(}\overrightarrow{{{x}}}^{(i)}{\big)}{\Big)} \\&J(\overrightarrow{w},b)=\frac{1}{m}\sum_{i=1}^{m}[L\big(f_{\overrightarrow{w},b}\big(\overrightarrow{x}^{(i)}\big),y^{(i)}\big)]\end{aligned}$$</p><p>那么为什么选择了这个函数作为代价函数呢？</p><p>这个特定的代价函数是使用称为最大似然估计的统计原理从统计中推导出来的。最大似然估计是一种常用的参数估计方法，它基于样本数据，通过寻找最有可能产生这些数据的参数值，来确定模型的参数。</p><h3 id="梯度下降">梯度下降</h3><p><strong>==逻辑回归的梯度下降==</strong> <span class="math display">\[\begin{aligned}w_{j}&amp;=w_{j}-\alpha\frac{1}{m}\sum_{i=1}^{m}(f_{w,b}\big(x^{(i)}\big)-y^{(i)})x_{j}^{(i)}\\b &amp;=b-\alpha\frac{1}{m}\sum_{i=1}^{m}(f_{w,b}(x^{(i)})-y^{(i)})\end{aligned}\]</span></p><p>注意：形式与线性回归一样，但是<span class="math inline">\(f_{w,b}(x)\)</span> 表达式不同。</p><h1 id="过拟合">过拟合</h1><h2 id="欠拟合过拟合">欠拟合、过拟合</h2><p><img src="/img/机器学习/Snipaste_2023-06-13_16-57-47.png" /></p><p>左图，欠拟合（underfit），也称作高偏差（High-bias），即对于当前数据集的拟合程度不够，欠拟合的特征是在训练集和测试集上的准确率都不好；</p><p>中图，拟合刚好的状态，具有泛化能力；</p><p>右图，过拟合（overfit），也称作高方差（High variance），过拟合对于当前训练数据拟合得太好了，以至于模型只在当前的训练集上表现很好，而在其他数据集上表现就不是那么好，所以过拟合的特征是在训练集上准确率很高而在测试集上表现一般。</p><h2 id="解决过拟合">解决过拟合</h2><p>方法： 1. 收集更多的数据 2. 减少特征数量 3. 正则化</p><h3 id="特征工程">特征工程</h3><h3 id="正则化">正则化</h3><p>将正则化应用在代价函数中，使用正则化来减小参数的大小</p><p><img src="/img/机器学习/Snipaste_2023-06-14_09-11-09.png" /></p><p>如何理解上式？</p><p>因为<span class="math inline">\(w_3^2\)</span>和<span class="math inline">\(w_4^2\)</span>前的系数非常大，要想使整个式子最小化，只能令<span class="math inline">\(w_3^2\)</span>和<span class="math inline">\(w_4^2\)</span> 非常小（<span class="math inline">\(\approx0\)</span>），<span class="math inline">\(w_3\)</span>和<span class="math inline">\(w_4\)</span> 即为惩罚项。 对于右图过拟合状态，此时<span class="math inline">\(w_3\)</span>和<span class="math inline">\(w_4\)</span> 权重衰减，这样就会降低高阶项对整个函数的影响，使得拟合的函数变得比较平滑。</p><p>如果有很多的特征，那如何选择惩罚项呢？</p><p>如果有非常多的特征，你可能不知道那些特征重要，以及需要惩罚的特征。通常实现正则化的方式是惩罚<strong>所有</strong>的特征。（==为什么惩罚有利特征==）</p><p>对于预测房价实例，比如有100个特征，正则化后的代价函数如下： <span class="math display">\[J(\vec{w},b)=\frac{1}{2m}\sum_{i=1}^{m}(f_{\vec{w},b}\big(\vec{x}^{(i)}\big)-y^{(i)}\big)^2+\frac{\lambda}{2m}\sum_{j=1}^{n}\omega_{j}^2\]</span> 把上式分为两部分，左边部分即为原始的代价函数，右边部分为正则化项。λ为超参数，通常会取一个较大的数。</p><p>为了最小化整个代价函数，当λ是固定的，那么就要减小<span class="math inline">\(w_1\)</span>到<span class="math inline">\(w_n\)</span>的值。加入正则项后，<span class="math inline">\(w_1\)</span>到<span class="math inline">\(w_n\)</span>均会减小，也就是使得权重衰减，这样就会降低高阶项对于整个函数的影响，使得估计函数变得比较平滑。</p><p>我们还将λ除以2m,这样这里的第一项和第二项都在2m上按比例缩放，会更改容易选择λ的值。按照惯例我们不会因为参数b太大而惩罚它，在实践中，做与不做几乎没有什么区别。</p><p>因此，总结一下这个修改后的代价函数： <img src="/img/机器学习/Snipaste_2023-06-14_09-37-48.png" /></p><p>我们想要最小化[原始代价函数即均方误差项+第二项即正则化项]</p><p>λ : 可以控制两个不同目标之间的取舍。</p><p>此函数有两个目的，目的一：最小化预测值与真实值之间的误差，更好的拟合训练集。目的二：试图减小<span class="math inline">\(w_j\)</span> ，使假设函数变得“简单”，防止过度拟合。</p><p><strong>两者相互平衡，从而达到一种相互制约的关系，最终找到一个平衡点，从而更好地拟合训练集并且具有良好的泛化能力。</strong></p><p>不同的λ值有什么影响？</p><p>使用线性回归的房价预测示例。</p><p>如果，λ等于0，那么正则项等于零，即根本没有使用正则化，会过度拟合。 <img src="/img/机器学习/Snipaste_2023-06-14_09-59-48.png" /></p><p>当λ非常非常大时，例如<span class="math inline">\(\lambda=10^{10}\)</span>,那么<span class="math inline">\(w_1到w_4\)</span>几乎等于0，只剩常数b项，此时会欠拟合。</p><p><img src="/img/机器学习/Snipaste_2023-06-14_10-00-42.png" /></p><p>线性回归的正则化方法： <img src="/img/机器学习/Snipaste_2023-06-14_10-13-49.png" /></p><p> $$\begin{aligned}& w_{j}=w_{j}-\alpha\left[\frac{1}{m}\sum_{i=1}^{m}\left[(f_{\vec{{{w}}},b}\big(\vec{x}^{(i)}\big)-y^{(i)}\big)x_{j}^{(i)}\right]+\frac{\lambda}{m}w_{j}\right]  \\&b=b-\alpha\frac{1}{m}\sum_{i=1}^m(f_{\vec{\mathbf{w}},b}(\vec{\mathbf{x}}^{(i)})-y^{(i)})\end{aligned}$$</p><p>逻辑回归的正则化方法： <img src="/img/机器学习/Snipaste_2023-06-14_10-18-04.png" /></p><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/75364861">吴恩达机器学习笔记（三）正则化</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识C语言02-字符串、转义字符、注释</title>
    <link href="/2023/06/29/%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%8002-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E3%80%81%E6%B3%A8%E9%87%8A/"/>
    <url>/2023/06/29/%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%8002-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E3%80%81%E6%B3%A8%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串">1 字符串</h2><ul><li><code>"abcdef"</code> 这种由双引号引起来的一串字符，称为字符串字面值，或者简称字符串。</li><li>字符串就是字符数组，好多个字符串起来的一组数据。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;c&#x27;</span>;<span class="hljs-comment">//定义了一个字符数据类型c</span><br><br><span class="hljs-string">&quot;abcdef&quot;</span> ;<span class="hljs-comment">// 这种由双引号引起来的一串字符称为字符串字面值，或者简称字符串。</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注：</strong> c语言中有字符类型没有字符串类型，若想存储需要放入字符数组中。</p><p>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;abcdef&quot;</span>; <span class="hljs-comment">// 存储字符串</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然字符串存储在字符数组中，那么数组中存储了哪些东西呢？</p><ol type="1"><li>在VS中按F10对代码进行调试，页面左端会显示黄色的小三角（如下图所示），三角号到哪行代码即运行到哪行，按一次F10 运行一行，直到运行到最后一行。</li></ol><p><img src="/img/002初识C语言/f453c9805a024185be201d1f098a6c07.jpeg" /></p><ol start="2" type="1"><li>调试后，点击 <code>调试-&gt;窗口-&gt;监视-&gt;监视(1)</code></li></ol><p><img src="/img/002初识C语言/425536e2d0d047b7b1139f9c9cc5bf94.jpeg" /></p><ol start="3" type="1"><li>输入监视的对象，此文中为<code>arr</code> , 并展开。</li></ol><p><img src="/img/002初识C语言/99556e579bc2425eb1919c9cddee0893.jpeg" /></p><p>我们发现数组<code>arr</code>大小为7并不是6，除了所要存储的 <code>abcdef</code> 外还另外放入了 <code>\0</code> ，说明还默认存储了一个 <code>\0</code> ，这个 <code>\0</code> 即为字符串的<strong>结束标志</strong>。</p><p><strong><code>\0</code> 作为字符串的结束标志非常重要</strong></p><p>为什么重要呢？</p><p>思考以下代码输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> arr1[] = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">char</span> arr2[] = &#123; <span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span> &#125;;<br><span class="hljs-type">char</span> arr3[] = &#123; <span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, arr1); <span class="hljs-comment">// %s 为输出字符串</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, arr2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, arr3);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby">abc<span class="hljs-keyword">def</span><br><span class="hljs-title function_">abcdef</span>烫烫烫烫烫abc<span class="hljs-keyword">def</span><br><span class="hljs-title function_">abcdef</span><br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol type="1"><li>首先查看一下 arr1 和 arr2 存储的内容</li></ol><p><img src="/img/002初识C语言/9e700bb13fc3453b994493134185317f.png" /></p><p>arr1用字符串初始化，编译系统会自动加入 <code>\0</code> ，所以arr1中有 <code>\0</code> ; 当我们主动给arr2中放入 <code>abcdef</code> ，数组中并没有 <code>\0</code> 。</p><ol start="2" type="1"><li>当我们用 <code>%s</code> 输出字符串时，输出结果为：</li></ol><p><img src="/img/002初识C语言/faf13d3caa964b8d9ad6c81d9d5bbb40.png" /></p><p>字符串作为一维数组存放在内存中，当程序遇到 <code>\0</code> 时判断字符串结束，如果没遇到，编译器自动向后打印直到遇见 <code>\0</code> 结束 。</p><p><strong>对于arr1</strong> <img src="/img/002初识C语言/cb7fb4c36ca04894bdf571fc8c3e5f5e.png" /></p><p>数组 arr1 从 <code>a</code> 开始输出，遇到 <code>\0</code> 结束，arr1是以字符串初始化，所以编译系统会默认加入 <code>\0</code> 。 在计算字符串长度的时候<code>\0</code> 是结束<strong>标志</strong>，不算作字符串内容，不打印。所以arr1打印结果为 <code>abcdef</code></p><p><strong>对于arr2</strong> <img src="/img/002初识C语言/d46fd8254348483a836ce3f8c1bbeaef.png" /></p><p>当我们主动给arr2中放入 <code>abcdef</code> ，编译系统并不会自动加入 <code>\0</code>。 数组arr2也是从 <code>a</code> 开始打印，但是不同的是 arr2 中并没有 <code>\0</code> ，而且arr2后面还有内存，内存中存储了其他内容，所以程序继续往后打印，直到遇到了一个 <code>\0</code> 结束打印，这就是为什么arr2会打印我们指定外的内容。</p><p><strong>对于arr3</strong> <img src="/img/002初识C语言/260317c64cc94a22911860369670d575.png" /></p><p>arr3中主动添加 <code>\0</code> 和arr1效果相同。</p><p>==总结：==</p><ul><li>c语言中没有字符串类型，若想存储需要放入字符数组中。</li><li>字符串的结束标志是一个 \0的转义字符。在计算字符串长度的时候 \0是结束标志，不算作字符串内容。</li></ul><h2 id="转义字符">2 转义字符</h2><h3 id="概念">2.1 概念</h3><p>C中定义了一些字母前加""来表示常见的那些不能显示的ASCII字符，如\0,，就称为转义字符。 | 转义字符 | 释义 | | -------- | -------------------------------------------------- | | \? | 在书写连续多个问号时使用，防止他们被解析成三字母词 | | \` | 用于表示字符常量` | | \" | 用于表示一个字符产内部的双引号 | | \\ | 用于表示一个反斜杠，防止它被解释为一个转义序列符 | | \a | 警告字符，蜂鸣 | | \b | 退格符 | | \f | 进纸符 | | \n | 换行 | | \r | 回车 | | \t | 水平制表符 | | \v | 垂直制表符 | | \ddd | ddd表示1~3个八进制的数字。如：\130 | | \xdd | dd表示2个十六进制数字。如:\x30 |</p><h3 id="详解">2.2 详解</h3><h4 id="section">2.2.1 <code>\?</code></h4><p>早期编译器会把三字母词 <code>??)</code> 解析成 <code>]</code> ；把三字母词 <code>??(</code> 解析成 <code>[</code> 。若不想这样解析，在问号前面加上 <code>\</code> ,此时的 <code>?</code> 不再是三字母词里的问号。目前编译器不在支持三字母词。</p><h4 id="section-1">2.2.2 <code>\'</code></h4><p>当想打印字符 <code>'</code> 时，按如下编写会报错。</p><p><img src="/img/002初识C语言/77293b40842c4393a0f44c8bb286cbf6.png" /></p><p>因为编译器把前两个单引号看成了一对，认为前两个单引号中间括了一个字符，最后一个单引号落单了，编译器无法解析。</p><p>在中间单引号前加 <code>\</code> 转义即可，让它单纯的就是一个单引号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="section-2">2.2.3 <code>\"</code></h4><p>当想打印字符 <code>"</code> 时，用 <code>\"</code>，与 <code>\'</code> 道理相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;\&quot;&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="section-3">2.2.4 <code>\\</code></h4><p>将 <code>\</code> 转义成单纯的斜杠。</p><p>当打印字符串 <code>abcd\0ef</code> 时只会输出 <code>abcd</code> ,因为遇到了字符串的结束标志\0，此时在 <code>\</code> 前在加一个 <code>\</code> ，把斜杠转移成普通的斜杠，不让<code>\0</code> 组成转义字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;abcd\\0ef&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 结果</span><br><span class="hljs-comment">// abcd\0ef</span><br></code></pre></td></tr></table></figure><h4 id="n-和r">2.2.5 <code>\n</code> 和<code>\r</code></h4><p>\n : 对输出进行换行</p><p>\r : 对输出进行回车</p><h4 id="t">2.2.6 <code>\t</code></h4><p>和电脑的Tab键效果相同。</p><h4 id="ddd">2.2.7 <code>\ddd</code></h4><p>ddd表示1~3个八进制的数字。如：\130。130为八进制的数字（幺叄零），不是一百三。</p><p>当打印 \130 时打印出来的是大写的X</p><p><img src="/img/002初识C语言/be1e59b60e00448cb477e276d25642cb.png" /></p><p>因为 \ddd 表示的是8进制的ddd转换成10进制的数字，即8进制的130，转换成10进制的88， 而88在ASCII码上对应的即为大写的X，所以打印字符88，即打印88在ASCII码上对应的值X。</p><p><img src="/img/002初识C语言/c9c60f5a589242bf961fbc201e346a03.png" /></p><h4 id="xdd">2.2.8 <code>\xdd</code></h4><p>dd表示2个十六进制数字。如:\x60 。<code>\x60</code> 是将60这个十六进制的数字转换成十进制的96。然后打印出96对应的ASCII码的值。</p><p>==总结：==</p><p>只需知道 <code>\?</code> <code>\'</code> <code>\"</code> <code>\\</code> <code>\n</code> <code>\r</code> <code>\t</code> <code>\ddd</code> <code>\xdd</code> 即可。</p><h2 id="注释">3 注释</h2><p>注释是对代码的解释和说明文字。</p><p>C语言中的注释分为两种：</p><h3 id="c风格的注释">3.1 C++风格的注释</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这是单行注释文字</span><br></code></pre></td></tr></table></figure><h3 id="c语言风格的注释">3.2 C语言风格的注释</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="使用的技巧">3.3 使用的技巧</h3><p>如果我们要对代码进行解释，那么就可以使用注释。</p><p>当注释的内容比较少，一行就写完了，可以用C++风格的注释。</p><p>如果注释的内容比较多，需要写在多行，那么可以使用C风格的注释。</p><h3 id="注意">3.4 注意</h3><p>注释的内容不会参与编译和运行的，仅仅是对代码的解释说明而已。</p><p>所以，不管在注释当中写什么内容，都不会影响代码运行的结果。</p><p>C语言风格的注释不能嵌套注释</p><p>C++风格的注释可以注释一行也可以注释多行</p>]]></content>
    
    
    <categories>
      
      <category>C语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识C语言01-数据类型、变量、常量</title>
    <link href="/2023/06/29/%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%8001-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E9%87%8F/"/>
    <url>/2023/06/29/%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%8001-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="c语言基础---数据类型变量常量">C语言基础 - 数据类型、变量、常量</h1><p>本章重点 - 第一个C语言程序 - 数据类型 - 变量、常量</p><h1 id="第一个c语言程序">1. 第一个C语言程序</h1><h2 id="打开vs">1. 打开VS</h2><h2 id="创建项目">2. 创建项目</h2><p><img src="/img/001初识C语言/157927af10eb4719a09117eb96b99dc2.png" /> ## 3. 创建源文件 <img src="/img/001初识C语言/8a363c30b1974b4c843695a85a1b3efc.png" /> <img src="/img/001初识C语言/f250956ab5964b4a9cb20d73e86ebddc.png" /></p><h2 id="打印-hello-word">4. 打印 hello word</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello word\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1、主函数</span><br><span class="hljs-comment">// c语言代码中一定要有main函数，主函数</span><br><span class="hljs-comment">// 主函数写法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 2、#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">// printf是一个库函数，专门用来打印数据的</span><br><span class="hljs-comment">// 不能直接用,需要包含&lt;stdio.h&gt;头文件，即：#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">// std - 标准</span><br><span class="hljs-comment">// i - input</span><br><span class="hljs-comment">// o - output</span><br><br><span class="hljs-comment">// 3、/n 换行 打印完换行</span><br><br><span class="hljs-comment">// 4、return 0;</span><br><span class="hljs-comment">// 代码正常运行，返回0，异常返回非0.</span><br><br><br></code></pre></td></tr></table></figure><h1 id="数据类型">2. 数据类型</h1><table><thead><tr class="header"><th>数据类型</th><th style="text-align: left;">说明</th><th>字节</th></tr></thead><tbody><tr class="odd"><td>char</td><td style="text-align: left;">字符数据类型</td><td>1</td></tr><tr class="even"><td>short</td><td style="text-align: left;">短整型</td><td>2</td></tr><tr class="odd"><td>int</td><td style="text-align: left;">整形</td><td>4</td></tr><tr class="even"><td>long</td><td style="text-align: left;">长整型</td><td>4</td></tr><tr class="odd"><td>long long</td><td style="text-align: left;">更长的整形</td><td>8</td></tr><tr class="even"><td>float</td><td style="text-align: left;">单精度浮点数</td><td>4</td></tr><tr class="odd"><td>double</td><td style="text-align: left;">双精度浮点数</td><td>8</td></tr></tbody></table><h1 id="变量常量">3. 变量、常量</h1><p>生活中的有些值是不变的（比如：圆周率，性别，身份证号码，血型等等） 有些值是可变的（比如：年龄，体重，薪资。 不变的值，C语言中用<strong>常量</strong>的概念来表示，变得值C语言中用<strong>变量</strong>来表示。</p><h2 id="变量定义方法">3.1 变量定义方法</h2><p>数据类型 变量名 = 值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> age = <span class="hljs-number">150</span>;<br></code></pre></td></tr></table></figure><h2 id="变量的使用">3.2 变量的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">// 1.初始化</span><br><span class="hljs-type">int</span> num1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> num2 = <span class="hljs-number">0</span>;<br> <br><span class="hljs-comment">// 输入两个整数</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;num1,&amp;num2); <span class="hljs-comment">// 按两个整型数值读取，读取后放入到num1 num2中，</span><br><span class="hljs-comment">// %d 占位符，两个整数。&amp;num，取地址，scanf需要地址，&amp;取地址。</span><br><span class="hljs-comment">// scanf安全问题解决,首行加入：#define _CRT_SECURE_NO_WARNINGS</span><br><br><span class="hljs-comment">// 2.求和</span><br><span class="hljs-type">int</span> sum = num1+num2;<br><br><span class="hljs-comment">// 3.输出</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变量的作用域和生命周期">3.3 变量的作用域和生命周期</h2><p><strong>作用域</strong></p><p>作用域（scope）是程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的,而限定这个名字的可用性的代码范围就是这个名字的作用域。</p><ol type="1"><li><p>局部变量的作用域是变量所在的局部范围。</p></li><li><p>全局变量的作用域是整个工程。</p></li></ol><p><strong>生命周期</strong></p><p>变量的生命周期指的是变量的创建到变量的销毁之间的一个时间段</p><ol type="1"><li><p>局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束。</p></li><li><p>全局变量的生命周期是：整个程序的生命周期。</p></li></ol><h2 id="常量">3.3 常量</h2><p>C语言中的常量和变量的定义的形式有所差异。</p><p>C语言中的常量分为以下四种：</p><ol type="1"><li>字面常量，自身就是常量，字面意义的常量</li><li>由 <code>const</code> 修饰的常变量</li><li>由 <code>#define</code> 定义的标识符常量</li><li>枚举常量</li></ol><h2 id="字面常量">3.1 字面常量</h2><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>  <br>&#123;  <br>    <span class="hljs-number">30</span>;<span class="hljs-comment">//数字常量  </span><br>    <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//字符常量  </span><br>    <span class="hljs-string">&#x27;abcd&#x27;</span>;<span class="hljs-comment">//字符串常量  </span><br>    <span class="hljs-comment">//以上常量可以直接输出  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;30,&#x27;a&#x27;,&#x27;abcd&#x27;&quot;</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="由-const-修饰的常变量">3.2 由 <code>const</code> 修饰的常变量</h2><p>定义常量方式：<code>const 数据类型 常量名 = 值;</code></p><p>由const定义的常变量本质上依旧为变量，但其具有==不可变==的属性 ;</p><p>首先变量可以修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n1=%d\n&quot;</span>,n);<br>n = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n2=%d\n&quot;</span>,n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用const定义后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n1=%d\n&quot;</span>, n);<br>n = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n2=%d\n&quot;</span>, n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>报错：</p><p><img src="/img/001初识C语言/4ae51c9edbab4b108a6eabc605d9a200.jpeg" /></p><p><strong>解释：</strong> 变量 n 的值是可以后续赋值改变的，但用const定义之后，编译器不允许修改其值，其值不可再改变，如果再次被赋值就会被报错。</p><p>在c语言中，const修饰的 n ,<strong>本质</strong>是变量，但是不能被修改，有常量的属性，同样因为是变量也不可用于数组的定义。</p><h2 id="由-define-定义的标识符常量">3.3 由 <code>#define</code> 定义的标识符常量</h2><p>定义方式：`<code>#define 常量名 值</code></p><p>由 <code>#define</code> 定义的标识符常量，可视为一般的字面常量，不可修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STR <span class="hljs-string">&quot;str&quot;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,MAX);<br><span class="hljs-type">int</span> a = MAX;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d&quot;</span>,a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,STR);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：<code>#define</code> 定义的不一定是整数类型的。</p><h2 id="枚举常量">3.4 枚举常量</h2><p>生活中有些值可以一 一列举出来的，比如性别（男、女），三原色（红、绿、蓝）等，将这些可能的取值枚举出来，未来可能的取值即为枚举常量。</p><p>看以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> // 声明变量(三原色)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">//未来可能的取值,即枚举常量</span><br>RED,<br>GERRN,<br>BLUE<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> <span class="hljs-title">c</span> =</span> RED;<br><span class="hljs-comment">// RED = 10; // 报错，枚举常量不可修改</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java13-面向对象进阶-抽象类&amp;接口&amp;内部类</title>
    <link href="/2023/06/29/Java13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E6%8A%BD%E8%B1%A1%E7%B1%BB&amp;%E6%8E%A5%E5%8F%A3&amp;%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2023/06/29/Java13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E6%8A%BD%E8%B1%A1%E7%B1%BB&amp;%E6%8E%A5%E5%8F%A3&amp;%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-抽象类">第一章 抽象类</h1><h2 id="概述">1.1 概述</h2><h3 id="抽象类引入">1.1.1 抽象类引入</h3><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的定义即可，具体实现交给子类自己去实现。<strong>我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类</strong>。</p><ul><li><strong>抽象方法</strong> ： 没有方法体的方法。</li><li><strong>抽象类</strong>：包含抽象方法的类。</li></ul><h2 id="abstract使用格式">1.2 abstract使用格式</h2><p><strong>abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。</strong></p><h3 id="抽象方法定义格式">1.2.1 抽象方法定义格式</h3><p>使用<code>abstract</code> 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">abstract</span> 返回值类型 方法名 (参数列表);<br></code></pre></td></tr></table></figure><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h3 id="抽象类定义格式">1.2.2 抽象类定义格式</h3><p>如果一个类包含抽象方法，那么该类必须是抽象类。<strong>注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。</strong></p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> class 类名字 &#123; <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>；<br>&#125;<br></code></pre></td></tr></table></figure><p><em>抽象类不一定有抽象方法：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>    System.out.printin(<span class="hljs-string">&quot;跑步&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象类的使用">1.2.3 抽象类的使用</h3><p><strong>抽象类和抽象方法的注意事项</strong></p><ul><li>抽象类不能实例化</li><li>可以有构造方法</li><li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类 要么重写抽象类中的所有抽象方法 要么是抽象类</li></ul><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父类,抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br><span class="hljs-keyword">private</span> String id;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary)</span> &#123;<br><span class="hljs-built_in">this</span>.id = id;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.salary = salary;<br>&#125;<br><br><span class="hljs-comment">// 抽象方法</span><br><span class="hljs-comment">// 抽象方法必须要放在抽象类中</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义一个子类继承抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Manager</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Manager</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary)</span> &#123;<br><span class="hljs-built_in">super</span>(id, name, salary);<br>&#125;<br><span class="hljs-comment">// 2.重写父类的抽象方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;管理其他人&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个子类继承抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Cook</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Cook</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary)</span> &#123;<br><span class="hljs-built_in">super</span>(id, name, salary);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;厨师炒菜&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo10</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 创建抽象类,抽象类不能创建对象</span><br><span class="hljs-comment">// 假设抽象类让我们创建对象,里面的抽象方法没有方法体,无法执行.所以不让我们创建对象</span><br><span class="hljs-comment">//Employee e = new Employee();</span><br><span class="hljs-comment">//e.work();</span><br><br><span class="hljs-comment">// 3.创建子类</span><br><span class="hljs-type">Manager</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>();<br>m.work();<br><br><span class="hljs-type">Cook</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cook</span>(<span class="hljs-string">&quot;ap002&quot;</span>, <span class="hljs-string">&quot;库克&quot;</span>, <span class="hljs-number">1</span>);<br>c.work();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p><h2 id="抽象类的细节">1.3 抽象类的细节</h2><p>不需要背，只要当idea报错之后，知道如何修改即可。</p><ol type="1"><li><p>抽象类<strong>不能实例化（创建对象）</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p><blockquote><p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></blockquote></li><li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p><blockquote><p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p></blockquote></li><li><p>抽象类中，不一定有抽象方法，但是有抽象方法的类必定是抽象类。</p><blockquote><p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p></blockquote></li><li><p>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。</p><blockquote><p>理解：假设子类不重写所有抽象方法，则子类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p></blockquote></li><li><p>抽象类存在的意义是为了被子类继承。</p><blockquote><p>理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。</p></blockquote></li></ol><h2 id="抽象类存在的意义">1.4 抽象类存在的意义</h2><pre><code class="hljs">抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义。抽象类可以强制让子类，一定要按照规定的格式进行重写。</code></pre><h1 id="第二章-接口">第二章 接口</h1><h2 id="概述-1">2.1 概述</h2><p>[[接口.mp4]]</p><h2 id="接口的定义">2.2 接口的定义</h2><p>接口用关键字<code>interface</code>来定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口的定义格式：</span><br>interface 接口名称&#123;<br>    <span class="hljs-comment">// 抽象方法</span><br>&#125;<br><br><span class="hljs-comment">// 接口的声明：interface</span><br><span class="hljs-comment">// 接口名称：首字母大写，满足“驼峰模式”</span><br></code></pre></td></tr></table></figure><h2 id="接口的的实现">2.3 接口的的实现</h2><h3 id="实现接口的概述">2.3.1 实现接口的概述</h3><p>在Java中接口是被实现的，类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code>implements</code>关键字。</p><h3 id="实现接口的格式">2.3.2 实现接口的格式</h3><ul><li>接口和类的实现关系，可以单实现，也可以多实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名 implements 接口<span class="hljs-number">1</span>,接口<span class="hljs-number">2</span>,接口<span class="hljs-number">3.</span>..&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现类还可以在继承一个类的同时实现多个接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名 extends 父类 implements 接口<span class="hljs-number">1</span>,接口<span class="hljs-number">2</span>,接口<span class="hljs-number">3.</span>..&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类实现接口的要求和意义">2.3.3 类实现接口的要求和意义</h3><ol type="1"><li>必须重写实现的全部接口中所有抽象方法。</li><li>如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。</li><li><strong>意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。</strong></li></ol><h3 id="实例">2.3.4 实例</h3><p>编写带有接口和抽象类的标准劁avabean类</p><p>青蛙 属性：名字，年龄 行为：吃虫子，蛙泳 狗 属性：名字，年龄 行为：吃骨头，狗刨 兔子 属性：名字，年龄 行为：吃胡萝卜</p><p><strong>父类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;  <br>  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swim</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>青蛙：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Frog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Swim</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Frog</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Frog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(name, age);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;青蛙吃虫子&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;蛙泳&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>狗：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Swim</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(name, age);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;狗吃骨头&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;狗刨&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>兔子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rabbit</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rabbit</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(name, age);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃胡萝卜&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Frog</span> <span class="hljs-variable">frog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Frog</span>();  <br>  <br>        frog.eat();  <br>        frog.swim();  <br>        &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口成员特点">2.4 接口成员特点</h2><h3 id="成员变量">2.4.1 成员变量</h3><ul><li>只能是常量</li><li>默认修饰符：public static final</li></ul><h3 id="构造方法">2.4.2 构造方法</h3><ul><li>接口中无构造方法</li></ul><h3 id="成员方法">2.4.3 成员方法</h3><ul><li>只能是抽象方法</li><li>默认修饰符：public abstract</li></ul><blockquote><p>JDK7以前：接口中只能定义抽象方法。 JDK8的新特性：接口中可以定义有方法体的方法。 JDK9的新特性：接口中可以定义私有方法。</p></blockquote><h2 id="类和接口之间的关系">2.5 类和接口之间的关系</h2><h3 id="类和类的关系">2.5.1 类和类的关系</h3><p>继承关系，只能单继承，不能多继承，但是可以多层继承</p><h3 id="类和接口的关系">2.5.2 类和接口的关系</h3><p><strong>接口与类是实现关系</strong>，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p><p><strong>若多个接口中方法重名，只需要重写一次</strong></p><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter1</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter2</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method4</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntrImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Inter1</span>,Inter2&#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method1&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method2&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method3&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method4</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method4&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口和接口的关系">2.5.3 接口和接口的关系</h3><p><strong>接口与接口是继承关系</strong>，可以单继承，也可以多继承</p><p>接口继承接口就是把其他接口的抽象方法与本接口进行了合并，如果实现类实现了最下面的子接口，那么就需要重写所有的抽象方法。</p><p>代码举例：</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter1</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter2</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Inter1</span>,Inter2 &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntrImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Inter3</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method1&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method2&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method3&quot;</span>);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩展接口的细节">2.6 扩展：接口的细节</h2><ol type="1"><li>当两个接口中存在相同抽象方法的时候，该怎么办？</li></ol><blockquote><p>只要重写一次即可。此时重写的方法，既表示重写1接口的，也表示重写2接口的。</p></blockquote><ol start="2" type="1"><li>实现类能不能继承A类的时候，同时实现其他接口呢？</li></ol><blockquote><p>继承的父类，就好比是亲爸爸一样 实现的接口，就好比是干爹一样 可以继承一个类的同时，再实现多个接口，只不过，要把接口里面所有的抽象方法，全部实现。</p></blockquote><ol start="3" type="1"><li>实现类能不能继承一个抽象类的时候，同时实现其他接口呢？</li></ol><blockquote><p>实现类可以继承一个抽象类的同时，再实现其他多个接口，只不过要把里面所有的抽象方法全部重写。</p></blockquote><ol start="4" type="1"><li>实现类Zi，实现了一个接口，还继承了一个Fu类。假设在接口中有一个方法，父类中也有一个相同的方法。子类如何操作呢？</li></ol><blockquote><p>处理办法一：如果父类中的方法体，能满足当前业务的需求，在子类中可以不用重写。 处理办法二：如果父类中的方法体，不能满足当前业务的需求，需要在子类中重写。</p></blockquote><ol start="5" type="1"><li>如果一个接口中，有10个抽象方法，但是我在实现类中，只需要用其中一个，该怎么办?</li></ol><blockquote><p>可以在接口跟实现类中间，新建一个中间类（适配器类） 让这个适配器类去实现接口，对接口里面的所有的方法做空重写。 让子类继承这个适配器类，想要用到哪个方法，就重写哪个方法。 因为中间类没有什么实际的意义，所以一般会把中间类定义为抽象的，不让外界创建对象</p></blockquote><h1 id="第三章-内部类">第三章 内部类</h1><h2 id="概述-2">3.1 概述</h2><h3 id="什么是内部类">3.1.1 什么是内部类</h3><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<strong>内部类</strong>，B则称为<strong>外部类</strong>。可以把内部类理解成寄生，外部类理解成宿主。</p><h3 id="什么时候使用内部类">3.1.2 什么时候使用内部类</h3><p>一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用</p><ol type="1"><li>人里面有一颗心脏。</li><li>汽车内部有一个发动机。</li><li>为了实现更好的封装性。</li></ol><h2 id="内部类的分类">3.2 内部类的分类</h2><p>按定义的位置来分</p><ol type="1"><li><strong>成员内部内</strong>，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)</li><li><strong>静态内部类</strong>，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)</li><li><strong>局部内部类</strong>，类定义在方法内</li><li><strong>匿名内部类</strong>，没有名字的内部类，可以在方法中，也可以在类中方法外。</li></ol><h2 id="成员内部类">3.3 成员内部类</h2><p><strong>成员内部类特点</strong>：</p><ul><li>无static修饰的内部类，属于外部类对象的。</li><li>宿主：外部类对象。</li></ul><p><strong>内部类的使用格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.内部类。 <span class="hljs-comment">// 访问内部类的类型都是用 外部类.内部类</span><br></code></pre></td></tr></table></figure><p><strong>获取成员内部类对象的两种方式</strong>：</p><p>方式一：外部直接创建成员内部类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.内部类 变量 = <span class="hljs-keyword">new</span> 外部类（）.new 内部类（）;<br></code></pre></td></tr></table></figure><p>方式二：在外部类中定义一个方法提供内部类的对象</p><p><strong>案例演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式一：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//  宿主：外部类对象。</span><br>       <span class="hljs-comment">// Outer out = new Outer();</span><br>        <span class="hljs-comment">// 创建内部类对象。</span><br>        Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        oi.method();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-comment">// 成员内部类，属于外部类对象的。</span><br>    <span class="hljs-comment">// 拓展：成员内部类不能定义静态成员。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-comment">// 这里面的东西与类是完全一样的。</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;内部类中的方法被调用了&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//方式二：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>        System.out.println(o.getInstance());<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="成员内部类的细节">3.4 成员内部类的细节</h2><p>编写成员内部类的注意点：</p><ol type="1"><li>成员内部类可以被一些修饰符所修饰，比如： private，默认，protected，public，static等</li><li>在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。</li><li>创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。（请参见3.6节的内存图）</li></ol><p>详解：</p><pre><code class="hljs">内部类被private修饰，外界无法直接获取内部类的对象，只能通过3.3节中的方式二获取内部类的对象被其他权限修饰符修饰的内部类一般用3.3节中的方式一直接获取内部类的对象内部类被static修饰是成员内部类中的特殊情况，叫做静态内部类下面单独学习。内部类如果想要访问外部类的成员变量，外部类的变量必须用final修饰，JDK8以前必须手动写final，JDK8之后不需要手动写，JDK默认加上。</code></pre><h2 id="成员内部类面试题">3.5 成员内部类面试题</h2><p>请在?地方向上相应代码,以达到输出的内容</p><p>注意：内部类访问外部类对象的格式是：<strong>外部类名.this</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Outer.<span class="hljs-type">inner</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">inner</span>();<br>        oi.method();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<span class="hljs-comment">// 外部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><br>    <span class="hljs-comment">// 在成员位置定义一个类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">inner</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>            System.out.println(???);<span class="hljs-comment">// 10   答案：a</span><br>            System.out.println(???);<span class="hljs-comment">// 20答案：this.a</span><br>            System.out.println(???);<span class="hljs-comment">// 30答案：Outer.this.a</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="成员内部类内存图">3.6 成员内部类内存图</h2><p><img src="/img/13-Java面向对象进阶/1e1b693f95744a3482f23182edf90ac5.png" /></p><h2 id="静态内部类">3.7 静态内部类</h2><p><strong>静态内部类特点</strong>：</p><ul><li><p>静态内部类是一种特殊的成员内部类。</p></li><li><p>有static修饰，属于外部类本身的。</p></li><li><p>总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。</p></li><li><p><strong>拓展1</strong>:静态内部类可以直接访问外部类的静态成员。</p></li><li><p><strong>拓展2</strong>:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象。</p></li><li><p><strong>拓展3</strong>:静态内部类中没有银行的Outer.this。</p></li></ul><p><strong>内部类的使用格式</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">外部类.内部类。<br></code></pre></td></tr></table></figure><p><strong>静态内部类对象的创建格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.内部类  变量 = <span class="hljs-keyword">new</span>  外部类.内部类构造器;<br></code></pre></td></tr></table></figure><p><strong>调用方法的格式：</strong></p><ul><li>调用非静态方法的格式：先创建对象，用对象调用</li><li>调用静态方法的格式：外部类名.内部类名.方法名();</li></ul><p><strong>案例演示</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 外部类：Outer01</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer01</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-type">String</span> <span class="hljs-variable">sc_name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;程序员&quot;</span>;<br>    <span class="hljs-comment">// 内部类: Inner01</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner01</span>&#123;<br>        <span class="hljs-comment">// 这里面的东西与类是完全一样的。</span><br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Inner01</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showName</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-built_in">this</span>.name);<br>            <span class="hljs-comment">// 拓展:静态内部类可以直接访问外部类的静态成员。</span><br>            System.out.println(sc_name);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClassDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建静态内部类对象。</span><br>        <span class="hljs-comment">// 外部类.内部类  变量 = new  外部类.内部类构造器;</span><br>        Outer01.<span class="hljs-type">Inner01</span> <span class="hljs-variable">in</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer01</span>.Inner01(<span class="hljs-string">&quot;张三&quot;</span>);<br>        in.showName();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="局部内部类">3.8 局部内部类</h2><ul><li><strong>局部内部类</strong> ：定义在<strong>方法中</strong>的类。</li></ul><p>定义格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">class 外部类名 &#123;<br>数据类型 变量名;<br><br>修饰符 返回值类型 方法名(参数列表) &#123;<br><span class="hljs-comment">// …</span><br>class 内部类 &#123;<br><span class="hljs-comment">// 成员变量</span><br><span class="hljs-comment">// 成员方法</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匿名内部类">3.9 匿名内部类</h2><h3 id="概述-3">3.9.1 概述</h3><p><strong>匿名内部类</strong> ：是内部类的简化写法。他是一个隐含了名字的内部类。开发中，最常用到的内部类就是匿名内部类了。</p><h3 id="格式">3.9.2 格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名或者接口名() &#123;<br>     重写方法;<br>&#125;;<br></code></pre></td></tr></table></figure><p>包含了：</p><ul><li><p>继承或者实现关系</p></li><li><p>方法重写</p></li><li><p>创建对象</p></li></ul><p>所以从语法上来讲，这个整体其实是匿名内部类对象</p><h3 id="什么时候用到匿名内部类">3.9.2 什么时候用到匿名内部类</h3><p><strong>实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用</strong></p><p><strong>是为了简化代码</strong>。</p><p>之前我们使用接口时，似乎得做如下几步操作：</p><ol type="1"><li>定义子类</li><li>重写接口中的方法</li><li>创建子类对象</li><li>调用重写后的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swim</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 1. 定义接口的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Swim</span> &#123;<br>    <span class="hljs-comment">// 2. 重写抽象方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;狗刨式...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3. 创建实现类对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-comment">// 4. 调用方法</span><br>        s.swimming();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。</p><h3 id="匿名内部类前提和格式">3.9.3 匿名内部类前提和格式</h3><p>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p><p><strong>匿名内部类格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 父类名或者接口名()&#123;<br>    <span class="hljs-comment">// 方法重写</span><br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使用方式">3.9.4 使用方式</h3><p>以接口为例，匿名内部类的使用，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swim</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用匿名内部类</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;自由泳...&quot;</span>);<br>&#125;<br>&#125;.swimming();<br><br>        <span class="hljs-comment">// 接口 变量 = new 实现类(); // 多态,走子类的重写方法</span><br>        <span class="hljs-type">Swim</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;蛙泳...&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        s2.swimming();<br>        s2.swimming();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名内部类的特点">3.9.5 匿名内部类的特点</h3><ol type="1"><li>定义一个没有名字的内部类</li><li>这个类实现了父类，或者父类接口</li><li>匿名内部类会创建这个没有名字的类的对象</li></ol><h3 id="匿名内部类的使用场景">3.9.6 匿名内部类的使用场景</h3><p>通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swim</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 普通方式传入对象</span><br>        <span class="hljs-comment">// 创建实现类对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <br>        goSwimming(s);<br>        <span class="hljs-comment">// 匿名内部类使用场景:作为方法参数传递</span><br>        <span class="hljs-type">Swim</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;蝶泳...&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">// 传入匿名内部类</span><br>        goSwimming(s3);<br><br>        <span class="hljs-comment">// 完美方案: 一步到位</span><br>        goSwimming(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;大学生, 蛙泳...&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        goSwimming(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;小学生, 自由泳...&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义一个方法,模拟请一些人去游泳</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goSwimming</span><span class="hljs-params">(Swim s)</span> &#123;<br>        s.swimming();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java12-面向对象进阶-多态&amp;包&amp;final&amp;权限修饰符</title>
    <link href="/2023/06/29/Java12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E5%A4%9A%E6%80%81&amp;%E5%8C%85&amp;final&amp;%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2023/06/29/Java12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E5%A4%9A%E6%80%81&amp;%E5%8C%85&amp;final&amp;%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-多态">第一章 多态</h1><h2 id="多态的形式">1.1 多态的形式</h2><p><strong>多态是继封装、继承之后，面向对象的第三大特性。</strong></p><p><strong>多态是出现在继承或者实现关系中的</strong>。</p><p><strong>多态体现的格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型 对象名称 = 子类对象;<br></code></pre></td></tr></table></figure><p><strong>多态的前提</strong>： - 有继承或实现关系 - 有父类引用指向子类对象 - 有方法重写</p><p>有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。</p><p>有父类引用指向子类对象 , <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Fu f = new Zi ();<br>Fu : 父类引用<br><span class="hljs-section">=  ：指向</span><br>new Zi：子类对象<br></code></pre></td></tr></table></figure></p><h2 id="多态的使用场景">1.2 多态的使用场景</h2><p>如果没有多态，在下图中register方法只能传递学生对象，其他的Teacher和administrator对象是无法传递给register方法方法的，在这种情况下，只能定义三个不同的register方法分别接收学生，老师和管理员。</p><p><img src="/img/12-Java面向对象进阶/f2052316dfd544de8072059c376fc270.png" /></p><p>有了多态之后，方法的形参就可以定义为共同的父类Person。</p><p><strong>要注意的是：</strong></p><ul><li>当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。</li><li>当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象。</li><li>而且多态还可以根据传递的不同对象来调用不同类中的方法。</li></ul><p><img src="/img/12-Java面向对象进阶/ad501eaacded4b6b85bf109877e008d9.png" /></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">父类：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 空参构造</span><br>    <span class="hljs-comment">// 带全部参数的构造</span><br>    <span class="hljs-comment">// get和set方法</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;, &quot;</span> + age);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">子类<span class="hljs-number">1</span>：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Administrator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;管理员的信息为：&quot;</span> + getName() + <span class="hljs-string">&quot;, &quot;</span> + getAge());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">子类<span class="hljs-number">2</span>：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;学生的信息为：&quot;</span> + getName() + <span class="hljs-string">&quot;, &quot;</span> + getAge());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">子类<span class="hljs-number">3</span>：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;老师的信息为：&quot;</span> + getName() + <span class="hljs-string">&quot;, &quot;</span> + getAge());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">测试类：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建三个对象，并调用register方法</span><br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>        s.setAge(<span class="hljs-number">18</span>);<br><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        t.setName(<span class="hljs-string">&quot;王建国&quot;</span>);<br>        t.setAge(<span class="hljs-number">30</span>);<br><br>        <span class="hljs-type">Administrator</span> <span class="hljs-variable">admin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Administrator</span>();<br>        admin.setName(<span class="hljs-string">&quot;管理员&quot;</span>);<br>        admin.setAge(<span class="hljs-number">35</span>);<br><br>        register(s);<br>        register(t);<br>        register(admin);<br><br>    &#125;<br><br>    <span class="hljs-comment">//这个方法既能接收老师，又能接收学生，还能接收管理员</span><br>    <span class="hljs-comment">//只能把参数写成这三个类型的父类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Person p)</span>&#123;<br>        p.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多态的定义和前提">1.3 多态的定义和前提</h2><p><strong>多态</strong>： 同类型的对象，表现出的不同形态。</p><p>Student、Teacher、Administrator都是Person表现出的不同形态。</p><p><strong>前提【重点】</strong></p><ol type="1"><li><p>有继承或者实现关系</p></li><li><p>方法的重写【意义体现：不重写，无意义】</p></li><li><p>父类引用指向子类对象【格式体现】</p><blockquote><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p></blockquote></li></ol><h2 id="多态调用成员的特点">1.4 多态调用成员的特点</h2><p>调用成员变量时：编译看左边，运行看左边</p><p>调用成员方法时：编译看左边，运行看右边</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java">  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-comment">//创建对象（多态方式）  </span><br>        <span class="hljs-comment">//Fu f = new Zi();  </span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();  <br>        <span class="hljs-comment">//调用成员变量：编译看左边，运行也看左边  </span><br>        <span class="hljs-comment">//编译看左边：javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。  </span><br>        <span class="hljs-comment">//运行也看左边：java运行代码的时候，实际获取的就是左边父类中成员变量的值  </span><br>        System.out.println(a.name);<span class="hljs-comment">//动物  </span><br>  <br>        <span class="hljs-comment">//调用成员方法：编译看左边，运行看右边  </span><br>        <span class="hljs-comment">//编译看左边：javac编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，如果没有编译失败。  </span><br>        <span class="hljs-comment">//运行看右边：java运行代码的时候，实际上运行的是子类中的方法。  </span><br>        a.show();<span class="hljs-comment">///Dog --- show方法  </span><br>  <br>        <span class="hljs-comment">//理解：  </span><br>        <span class="hljs-comment">//Animal a = new Dog();  </span><br>        <span class="hljs-comment">//现在用a去调用变量和方法的？是的  </span><br>        <span class="hljs-comment">//而a是Animal类型的，所以默认都会从Animal这个类中去找  </span><br>  <br>        <span class="hljs-comment">//成员变量：在子类的对象中，会把父类的成员变量也继承下的。对象中存在两个name 一个父name  一个子name， Animal a = new Dog();现在是的a是父类类型，所以用父类的name</span><br>        <span class="hljs-comment">//成员方法：如果子类对方法进行了重写，那么在虚方法表中是会把父类的方法进行覆盖的，所以调用的是子类的方法。  </span><br>    &#125;  <br>&#125;  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;动物&quot;</span>;  <br>  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;Animal --- show方法&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;狗&quot;</span>;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Dog --- show方法&quot;</span>);  <br>    &#125;  <br>  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;猫&quot;</span>;  <br>  <br>   <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Cat --- show方法&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多态的弊端">1.5 多态的弊端</h2><p>我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时<strong>多态的写法就无法访问子类独有功能了</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>｛<br>        System.out.println(<span class="hljs-string">&quot;动物吃东西！&quot;</span>)<br>    ｝<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);  <br>    &#125;  <br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;抓老鼠&quot;</span>);  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        a.eat();<br>        a.catchMouse();<span class="hljs-comment">//编译报错，编译看左边，Animal没有这个方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用类型转换">1.6 引用类型转换</h2><h3 id="为什么要转型">1.6.1 为什么要转型</h3><p><strong>多态的写法就无法访问子类独有功能了。</strong></p><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做向下转型。</p><p>回顾基本数据类型转换</p><ul><li><p>自动转换: 范围小的赋值给范围大的.自动完成:double d = 5;</p></li><li><p>强制转换: 范围大的赋值给范围小的,强制转换:int i = (int)3.14</p><p>多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。</p></li></ul><h3 id="向上转型自动转换">1.6.2 向上转型（自动转换）</h3><ul><li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。 当父类引用指向一个子类对象时，便是向上转型。 使用格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型  变量名 = <span class="hljs-keyword">new</span> 子类类型();<br>如：<span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure><p>原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。所以子类范围小可以直接自动转型给父类类型的变量。</p><h3 id="向下转型强制转换">1.6.3 向下转型（强制转换）</h3><ul><li><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。 一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</li></ul><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 子类类型 变量名 = (子类类型) 父类变量名; 如:</span><br><span class="hljs-type">Aniaml</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>   <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span>(Cat) a;  <br></code></pre></td></tr></table></figure><h3 id="案例演示">1.6.4 案例演示</h3><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做向下转型。</p><p>转型演示，代码如下：</p><p>定义类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;  <br>&#125;  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;抓老鼠&quot;</span>);  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">watchHouse</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;看家&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>定义测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 向上转型  </span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();  <br>        a.eat(); <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br><br>        <span class="hljs-comment">// 向下转型  </span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a;       <br>        c.catchMouse(); <span class="hljs-comment">// 调用的是 Cat 的 catchMouse</span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="转型的异常">1.6.5 转型的异常</h3><p>转型的过程中，一不小心就会遇到这样的问题，请看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 向上转型  </span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();  <br>        a.eat();               <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br><br>        <span class="hljs-comment">// 向下转型  </span><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a;       <br>        d.watchHouse();        <span class="hljs-comment">// 调用的是 Dog 的 watchHouse 【运行报错】</span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码可以通过编译，但是运行时，却报出了 <code>ClassCastException</code> ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。</p><h3 id="instanceof关键字">1.6.6 instanceof关键字</h3><p>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">变量名 <span class="hljs-keyword">instanceof</span> 数据类型 <br>如果变量属于该数据类型或者其子类类型，返回<span class="hljs-literal">true</span>。<br>如果变量不属于该数据类型或者其子类类型，返回<span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p>所以，转换前，我们最好先做一个判断，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 向上转型  </span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();  <br>        a.eat();               <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br><br>        <span class="hljs-comment">// 向下转型  </span><br>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Cat)&#123;<br>            <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a;       <br>            c.catchMouse();        <span class="hljs-comment">// 调用的是 Cat 的 catchMouse</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Dog)&#123;<br>            <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a;       <br>            d.watchHouse();       <span class="hljs-comment">// 调用的是 Dog 的 watchHouse</span><br>        &#125;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="instanceof新特性">1.6.7 instanceof新特性</h3><p>JDK14的时候提出了新特性，把判断和强转合并成了一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//新特性</span><br><span class="hljs-comment">//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d</span><br><span class="hljs-comment">//如果不是，则不强转，结果直接是false</span><br><span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Dog d)&#123;<br>    d.lookHome();<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Cat c)&#123;<br>    c.catchMouse();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;没有这个类型，无法转换&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="综合练习">1.7 综合练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">需求：根据需求完成代码:<br><span class="hljs-number">1.</span>定义狗类<br>属性：<br>年龄，颜色<br>行为:<br>eat(String something)(something表示吃的东西)<br>看家lookHome方法(无参数)<br><span class="hljs-number">2.</span>定义猫类<br>属性：<br>年龄，颜色<br>行为:<br>eat(String something)方法(something表示吃的东西)<br>逮老鼠catchMouse方法(无参数)<br><span class="hljs-number">3.</span>定义Person类<span class="hljs-comment">//饲养员</span><br>属性：<br>姓名，年龄<br>行为：<br>keepPet(Dog dog,String something)方法<br>功能：喂养宠物狗，something表示喂养的东西<br>行为：<br>keepPet(Cat cat,String something)方法<br>功能：喂养宠物猫，something表示喂养的东西<br>生成空参有参构造，set和get方法  <br><span class="hljs-number">4.</span>定义测试类(完成以下打印效果):<br>keepPet(Dog dog,String somethind)方法打印内容如下：<br>年龄为<span class="hljs-number">30</span>岁的老王养了一只黑颜色的<span class="hljs-number">2</span>岁的狗<br><span class="hljs-number">2</span>岁的黑颜色的狗两只前腿死死的抱住骨头猛吃<br>keepPet(Cat cat,String somethind)方法打印内容如下：<br>年龄为<span class="hljs-number">25</span>岁的老李养了一只灰颜色的<span class="hljs-number">3</span>岁的猫<br><span class="hljs-number">3</span>岁的灰颜色的猫眯着眼睛侧着头吃鱼<br><span class="hljs-number">5.</span>思考：<br><span class="hljs-number">1.</span>Dog和Cat都是Animal的子类，以上案例中针对不同的动物，定义了不同的keepPet方法，过于繁琐，能否简化，并体会简化后的好处？<br><span class="hljs-number">2.</span>Dog和Cat虽然都是Animal的子类，但是都有其特有方法，能否想办法在keepPet中调用特有方法？<br></code></pre></td></tr></table></figure><p>画图分析：</p><p><img src="/img/12-Java面向对象进阶/c69b99aeed55418c8b6b81d6010e95cf.png" /></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动物类（父类）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String color;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String something)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;动物在吃&quot;</span> + something);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//猫类（子类）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String color)</span> &#123;<br>        <span class="hljs-built_in">super</span>(age, color);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String something)</span> &#123;<br>        System.out.println(getAge() + <span class="hljs-string">&quot;岁的&quot;</span> + getColor() + <span class="hljs-string">&quot;颜色的猫眯着眼睛侧着头吃&quot;</span> + something);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;猫抓老鼠&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//狗类（子类）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String color)</span> &#123;<br>        <span class="hljs-built_in">super</span>(age, color);<br>    &#125;<br><br>    <span class="hljs-comment">//行为</span><br>    <span class="hljs-comment">//eat(String something)(something表示吃的东西)</span><br>    <span class="hljs-comment">//看家lookHome方法(无参数)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String something)</span> &#123;<br>        System.out.println(getAge() + <span class="hljs-string">&quot;岁的&quot;</span> + getColor() + <span class="hljs-string">&quot;颜色的狗两只前腿死死的抱住&quot;</span> + something + <span class="hljs-string">&quot;猛吃&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lookHome</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狗在看家&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//饲养员类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">//饲养狗</span><br>   <span class="hljs-comment">/* public void keepPet(Dog dog, String something) &#123;</span><br><span class="hljs-comment">        System.out.println(&quot;年龄为&quot; + age + &quot;岁的&quot; + name + &quot;养了一只&quot; + dog.getColor() + &quot;颜色的&quot; + dog.getAge() + &quot;岁的狗&quot;);</span><br><span class="hljs-comment">        dog.eat(something);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    //饲养猫</span><br><span class="hljs-comment">    public void keepPet(Cat cat, String something) &#123;</span><br><span class="hljs-comment">        System.out.println(&quot;年龄为&quot; + age + &quot;岁的&quot; + name + &quot;养了一只&quot; + cat.getColor() + &quot;颜色的&quot; + cat.getAge() + &quot;岁的猫&quot;);</span><br><span class="hljs-comment">        cat.eat(something);</span><br><span class="hljs-comment">    &#125;*/</span><br><br><br>    <span class="hljs-comment">//想要一个方法，能接收所有的动物，包括猫，包括狗</span><br>    <span class="hljs-comment">//方法的形参：可以写这些类的父类 Animal</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keepPet</span><span class="hljs-params">(Animal a, String something)</span> &#123;<br>        <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Dog d)&#123;<br>            System.out.println(<span class="hljs-string">&quot;年龄为&quot;</span> + age + <span class="hljs-string">&quot;岁的&quot;</span> + name + <span class="hljs-string">&quot;养了一只&quot;</span> + a.getColor() + <span class="hljs-string">&quot;颜色的&quot;</span> + a.getAge() + <span class="hljs-string">&quot;岁的狗&quot;</span>);<br>            d.eat(something);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Cat c)&#123;<br>            System.out.println(<span class="hljs-string">&quot;年龄为&quot;</span> + age + <span class="hljs-string">&quot;岁的&quot;</span> + name + <span class="hljs-string">&quot;养了一只&quot;</span> + c.getColor() + <span class="hljs-string">&quot;颜色的&quot;</span> + c.getAge() + <span class="hljs-string">&quot;岁的猫&quot;</span>);<br>            c.eat(something);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;没有这种动物&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建对象并调用方法</span><br>       <span class="hljs-comment">/* Person p1 = new Person(&quot;老王&quot;,30);</span><br><span class="hljs-comment">        Dog d = new Dog(2,&quot;黑&quot;);</span><br><span class="hljs-comment">        p1.keepPet(d,&quot;骨头&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        Person p2 = new Person(&quot;老李&quot;,25);</span><br><span class="hljs-comment">        Cat c = new Cat(3,&quot;灰&quot;);</span><br><span class="hljs-comment">        p2.keepPet(c,&quot;鱼&quot;);*/</span><br><br><br>        <span class="hljs-comment">//创建饲养员的对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;老王&quot;</span>,<span class="hljs-number">30</span>);<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;黑&quot;</span>);<br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;灰&quot;</span>);<br>        p.keepPet(d,<span class="hljs-string">&quot;骨头&quot;</span>);<br>        p.keepPet(c,<span class="hljs-string">&quot;鱼&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二章-包">第二章 包</h1><h2 id="包">2.1 包</h2><pre><code class="hljs">包在操作系统中其实就是一个文件夹。**包是用来分门别类的管理技术，不同的技术类放在不同的包下**，方便管理和维护。</code></pre><p>在IDEA项目中，建包的操作如下：</p><p><img src="/img/12-Java面向对象进阶/f2295f3a8bac40e983c65f20604595b9.jpeg" /></p><p><strong>包名的命名规范</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">路径名.路径名.xxx.xxx<br><span class="hljs-comment">// 例如：com.itheima.oa</span><br></code></pre></td></tr></table></figure><ul><li>包名一般是公司域名的倒写。</li><li>包名必须用”.“连接。</li><li>包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。</li></ul><h2 id="导包">2.2 导包</h2><p>什么时候需要导包？</p><pre><code class="hljs">情况一：在使用Java中提供的非核心包中的类时情况二：使用自己写的其他包中的类时</code></pre><p>什么时候不需要导包？</p><pre><code class="hljs">情况一：在使用Java核心包（java.lang）中的类时情况二：在使用同一个包中的其他类时</code></pre><h2 id="使用不同包下的同名类怎么办">2.3 使用不同包下的同名类怎么办？</h2><p>假设demo1和demo2中都有一个Student该如何使用？ - 使用全类名的形式</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用全类名的形式即可。</span><br><span class="hljs-comment">//全类名：包名 + 类名</span><br><span class="hljs-comment">//拷贝全类名的快捷键：选中类名crtl + shift + alt + c 或者用鼠标点copy，再点击copy Reference</span><br>work.demo1.<span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">work</span>.demo1.Student();<br>work.demo2.<span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">work</span>.demo2.Student();<br></code></pre></td></tr></table></figure><h1 id="第三章-权限修饰符">第三章 权限修饰符</h1><h2 id="权限修饰符">3.1 权限修饰符</h2><p>权限修饰符：是用来控制一个成员能够被访问的范围的。 可以修饰成员变量，方法，构造方法，内部类。</p><pre><code class="hljs">在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和默认修饰符的作用。</code></pre><ul><li><p>public：公共的，所有地方都可以访问。</p></li><li><p>protected：本类 ，本包，其他包中的子类都可以访问。</p></li><li><p>默认（没有修饰符）：本类 ，本包可以访问。（注意：默认是空着不写，不是default）</p></li><li><p>private：私有的，当前类可以访问。</p></li></ul><p><code>public &gt; protected &gt; 默认 &gt; private</code></p><h2 id="不同权限的访问能力">3.2 不同权限的访问能力</h2><table><thead><tr class="header"><th></th><th>public</th><th>protected</th><th>默认</th><th>private</th></tr></thead><tbody><tr class="odd"><td>同一类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr class="even"><td>同一包中的类</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr class="odd"><td>不同包的子类</td><td>√</td><td>√</td><td></td><td></td></tr><tr class="even"><td>不同包中的无关类</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><p>可见，public具有最大权限。private则是最小权限。</p><p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p><ul><li>成员变量使用<code>private</code> ，隐藏细节。</li><li>构造方法使用<code>public</code> ，方便创建对象。</li><li>成员方法使用<code>public</code> ，方便调用方法。</li></ul><h1 id="第四章-final关键字">第四章 final关键字</h1><h2 id="概述">4.1 概述</h2><pre><code class="hljs">学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。</code></pre><p>如果有一个方法我不想别人去改写里面内容，该怎么办呢？</p><p>Java提供了<code>final</code> 关键字，表示修饰的内容不可变。</p><ul><li><strong>final</strong>： 不可改变，最终的含义。可以用于修饰类、方法和变量。<ul><li>类：被修饰的类，不能被继承。</li><li>方法：被修饰的方法，不能被重写。</li><li>变量：被修饰的变量，有且仅能被赋值一次。</li></ul></li></ul><h2 id="使用方式">4.2 使用方式</h2><h3 id="修饰类">4.2.1 修饰类</h3><p>final修饰的类，不能被继承。</p><p>格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> class 类名 &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br>&#125;<br><span class="hljs-comment">// class Zi extends Fu &#123;&#125; // 报错,不能继承final的类</span><br></code></pre></td></tr></table></figure><h3 id="修饰方法">4.2.2 修饰方法</h3><p>final修饰的方法，不能被重写。 格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">final</span> 返回值类型 方法名(参数列表)&#123;<br>    <span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show1</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Fu show1&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Fu show2&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-comment">//@Override</span><br><span class="hljs-comment">//public void show1() &#123;</span><br><span class="hljs-comment">//System.out.println(&quot;Zi show1&quot;);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Zi show2&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰变量">4.2.3 修饰变量</h3><p>实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性。</p><p>常量的命名规范： - 单个单词：全部大写 - 多个单词：全部大写，单词之间用下划线隔开</p><h4 id="局部变量">4.2.3.1 局部变量</h4><ol type="1"><li><p><strong>局部变量——基本类型</strong></p><p>基本类型的局部变量，被final修饰后，只能赋值一次，变量存储的==数据值==不能再更改。</p><p>代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 声明变量，使用final修饰</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> A;<br>        <span class="hljs-comment">// 第一次赋值 </span><br>        A = <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">// 第二次赋值</span><br>        A = <span class="hljs-number">20</span>; <span class="hljs-comment">// 报错,不可重新赋值</span><br><br>        <span class="hljs-comment">// 声明变量，直接赋值，使用final修饰</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">// 第二次赋值</span><br>        B = <span class="hljs-number">20</span>; <span class="hljs-comment">// 报错,不可重新赋值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意下面两种写法，哪种可以通过编译？</p><p>写法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">C</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    C = i;<br>    System.out.println(C);<br>&#125;<br></code></pre></td></tr></table></figure><p>写法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">C</span> <span class="hljs-operator">=</span> i;<br>    System.out.println(C);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据 <code>final</code> 的定义，写法1报错！写法2通过编译呢。因为每次循环，都是一次新的变量c。</p><ol start="2" type="1"><li><p><strong>局部变量——引用类型</strong></p><p>变量存储的==地址值==不能再更改，对象内部的属性值可以改变。</p><p>代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//创建对象 </span><br><span class="hljs-keyword">final</span> Student s <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(name:<span class="hljs-string">&quot;张三&quot;</span>,age:<span class="hljs-number">23</span>);<br><span class="hljs-comment">//S = new Student(); // 报错，地址值不能再更改</span><br>S.setName(<span class="hljs-string">&quot;李四&quot;</span>); <br>S.setAge(<span class="hljs-number">24</span>); <br>System.out.println(S.getName()+<span class="hljs-string">&quot;,&quot;</span>+S.getAge());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="成员变量">4.2.3.2 成员变量</h4><p>成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个：</p><ul><li>显示初始化(在定义成员变量的时候立马赋值)（常用）；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>构造方法初始化(在构造方法中赋值一次)（不常用）。</p><p><strong>注意：每个构造方法中都要赋值一次！</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> num2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.num2 = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//     this.num2 = 20;</span><br>    &#125;<br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.num2 = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//     this.num2 = 20;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第五章-代码块">第五章 代码块</h1><h2 id="代码块的分类">5.1 代码块的分类</h2><p>局部代码块，构造代码块，静态代码块</p><h2 id="局部代码块">5.2 局部代码块</h2><p>局部代码块的作用 提前结束变量的生命周期（已淘汰）</p><h2 id="构造代码块">5.3 构造代码块</h2><p>构造代码块的作用 抽取构造方法中的重复代码（不够灵活）</p><h2 id="静态代码块">5.4 静态代码块</h2><p>随着类的加载而加载的，并且只执行一次。</p><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span>&#123;<br> 语句<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>应用场景</strong></p><p>在程序刚开始时进行数据初始化</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java11-面向对象进阶-static-继承</title>
    <link href="/2023/06/29/Java11-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-static-%E7%BB%A7%E6%89%BF/"/>
    <url>/2023/06/29/Java11-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-static-%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-复习回顾">第一章 复习回顾</h1><h2 id="如何定义类">1.1 如何定义类</h2><p>类的定义格式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 class 类名 &#123;<br>    <span class="hljs-comment">// 1.成员变量（属性）</span><br>    <span class="hljs-comment">// 2.成员方法 (行为) </span><br>    <span class="hljs-comment">// 3.构造方法 （初始化类的对象数据的）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 1.成员变量</span><br>    <span class="hljs-keyword">public</span> String name ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> sex ; <span class="hljs-comment">// &#x27;男&#x27;  &#x27;女&#x27;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何通过类创建对象">1.2 如何通过类创建对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类名 对象名称 = <span class="hljs-keyword">new</span> 类名();<br></code></pre></td></tr></table></figure><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br></code></pre></td></tr></table></figure><h2 id="封装">1.3 封装</h2><h4 id="封装的步骤">1.3.1 封装的步骤</h4><p>1.使用 <code>private</code> 关键字来修饰成员变量。</p><p>2.使用<code>public</code>修饰getter和setter方法。</p><h2 id="构造方法">1.4 构造方法</h2><h3 id="构造方法的作用">1.4.1 构造方法的作用</h3><p>在创建对象的时候，给成员变量进行初始化。</p><p>初始化即赋值的意思。</p><h3 id="构造方法的格式">1.4.2 构造方法的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 类名(形参列表) &#123;<br>    <span class="hljs-comment">// 构造体代码，执行代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="this关键字的作用">1.5 this关键字的作用</h2><h3 id="this关键字的作用-1">1.5.1 this关键字的作用</h3><p>this代表所在类的当前对象的引用（地址值），即代表当前对象。</p><h3 id="this关键字的应用">1.5.2 this关键字的应用</h3><h4 id="用于普通的gettter与setter方法">1.5.2.1 用于普通的gettter与setter方法</h4><p>this出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>      <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">0</span> &amp;&amp; age &lt; <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;年龄非法！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="用于构造方法中">1.5.2.2 用于构造方法中</h4><p>this出现在构造方法中，代表构造方法正在初始化的那个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-comment">// 无参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;&#125; <br>    <br>    <span class="hljs-comment">// 有参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二章-static关键字">第二章 static关键字</h1><h2 id="概述">2.1 概述</h2><p>以前我们定义过如下类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> sex; <span class="hljs-comment">// &#x27;男&#x27;  &#x27;女&#x27;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 无参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">// 有参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String  a)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们已经知道面向对象中，存在类和对象的概念，我们在类中定义了一些成员变量，例如name,age,sex ,结果发现这些成员变量，每个对象都存在（因为每个对象都可以访问）。</p><p>而像name ,age , sex确实是每个学生对象都应该有的属性，应该属于每个对象。</p><p>所以Java中成员（变量和方法）等是存在所属性的，Java是通过static关键字来区分的。static关键字在Java开发非常的重要，对于理解面向对象非常关键。</p><p>关于 <code>static</code> 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是<strong>属于类</strong>的是放在静态区中，没有static修饰的成员变量和方法则是<strong>属于对象</strong>的。我们上面案例中的成员变量都是没有static修饰的，所以属于每个对象。</p><h2 id="定义格式和使用">2.2 定义格式和使用</h2><p>static是静态的意思。 static可以修饰成员变量或者修饰方法。</p><h3 id="静态变量及其访问">2.2.1 静态变量及其访问</h3><p>被static修饰的成员变量，叫做静态变量（也称为类变量）。</p><p><strong>特点：</strong> - 被所有的对象共享 - 不属于对象属于类 - 随着类的加载而加载的，优先于对象出现的</p><p><strong>定义格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">static</span> 数据类型 变量名 = 初始值；    <br></code></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">schoolName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A大学&quot;</span>； <span class="hljs-comment">// 属于类，只有一份。</span><br>    <span class="hljs-comment">// .....</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>静态变量的访问:</strong> <strong>调用方式：</strong> - 类名调用 - 对象名调用</p><p><strong>格式：类名.静态变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    System.out.println(Student.schoolName); <span class="hljs-comment">// A大学</span><br>    Student.schoolName = <span class="hljs-string">&quot;B大学&quot;</span>;<br>    System.out.println(Student.schoolName); <span class="hljs-comment">// B大学</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>static内存：</strong> 因为类只有一个，所以静态成员变量在内存区域中也只存在一份。</p><h3 id="实例变量及其访问">2.2.2 实例变量及其访问</h3><p>无static修饰的成员变量属于每个对象的， 这个成员变量叫<strong>实例变量</strong>，之前我们写成员变量就是实例成员变量。</p><p><strong>需要注意的是</strong>：实例成员变量属于每个对象，必须创建类的对象才可以访问。</p><p><strong>格式：对象.实例成员变量</strong></p><h3 id="静态方法及其访问">2.2.3 静态方法及其访问</h3><p>有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为<strong>类方法或者</strong>静态方法**。 直接用 类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。</p><p>与静态成员变量一样，静态方法也是直接通过<strong>类名.方法名称</strong>即可访问。</p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">schoolName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A大学&quot;</span>； <span class="hljs-comment">// 属于类，只有一份。</span><br>    <span class="hljs-comment">// .....</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我们都学习&quot;</span>);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong> - 多用在测试类和工具类中 - Javabean类中很少会用</p><p><strong>静态成员变量的访问:</strong> - 类名调用 - 对象名调用</p><p><strong>格式：类名.静态方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    Student.study();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例方法及其访问">2.2.4 实例方法及其访问</h3><p>无static修饰的成员方法属于每个对象的，这个成员方法也叫做<strong>实例方法</strong>。</p><p><strong>需要注意的是</strong>：实例方法是属于每个对象，必须创建类的对象才可以访问。</p><p><strong>格式：对象.实例方法</strong></p><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 实例变量</span><br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-comment">// 2.方法：行为</span><br>    <span class="hljs-comment">// 无 static修饰，实例方法。属于每个对象，必须创建对象调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;学生可以跑步&quot;</span>);<br>    &#125;<br><span class="hljs-comment">// 无 static修饰，实例方法</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;学生睡觉&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-comment">// 创建对象 </span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> ;<br>    stu.name = <span class="hljs-string">&quot;徐干&quot;</span>;<br>    <span class="hljs-comment">// Student.sleep();// 报错，必须用对象访问。</span><br>    stu.sleep();<br>    stu.run();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结">2.3 小结</h2><p>1.当 <code>static</code> 修饰成员变量或者成员方法时，该变量称为<strong>静态变量</strong>，该方法称为<strong>静态方法</strong>。该类的每个对象都<strong>共享</strong>同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。</p><p>2.无static修饰的成员变量或者成员方法，称为<strong>实例变量，实例方法</strong>，实例变量和实例方法必须创建类的对象，然后通过对象来访问。</p><p>3.static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。</p><p>4.无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。</p><ul><li>静态方法中没有this关键字</li><li>==静态方法中只能调用静态==。</li><li>非静态方法可以访问所有。</li><li>静态属于类（共享），非静态属于具体对象（私有） # 第三章 继承</li></ul><h2 id="概述-1">3.1 概述</h2><h3 id="引入">3.1.1 引入</h3><p>假如我们要定义如下类: 学生类和老师类，如下。</p><p><img src="/img/11-Java面向对象进阶-static-继承/216f22f2cf044d18b22fb6ad98bbd930.png" /></p><p>假如多个类中存在相同属性和行为时，我们可以将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要<strong>继承</strong>那一个类即可。如图所示：</p><p><img src="/img/11-Java面向对象进阶-static-继承/7cbf1824bb8a4c638cdf79d539357928.png" /> <img src="/img/11-Java面向对象进阶-static-继承/07480fc3765e4a5880abfebd7f00cb5f.png" /></p><p>其中，多个类可以称为<strong>子类</strong>，单独被继承的那一个类称为<strong>父类</strong>、<strong>超类（superclass)</strong> 或者<strong>基类</strong>。</p><p>子类可以直接用父类中的东西，继承就是类与类之间的父子关系。</p><h3 id="继承的含义">3.1.2 继承的含义</h3><p><strong>继承</strong>：就是子类继承父类的<strong>属性</strong>和<strong>行为</strong>，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的<strong>非私有</strong>的属性和行为。</p><h3 id="继承的好处">3.1.3 继承的好处</h3><ol type="1"><li>提高<strong>代码的复用性</strong>（减少代码冗余，相同代码重复利用）。</li><li>使类与类之间产生了关系。</li><li>子类可以在父类的基础上，增加其他的功能，使子类更强大。</li></ol><h3 id="什么时候用继承">3.1.3 什么时候用继承</h3><p>当类与类之间，存在<strong>相同</strong>（共性）的内容，并满足子类是父类中的<strong>一种</strong>，就可以考虑使用继承，来优化代码</p><h2 id="继承的格式">3.2 继承的格式</h2><p>通过 <code>extends</code> 关键字，可以声明一个子类继承另外一个父类，定义格式如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">class 父类 &#123;<br>...<br>&#125;<br><br>class 子类 extends 父类 &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>继承的特点:</strong> Java只支持<strong>单继承</strong>，不支持<strong>多继承</strong>，但支持<strong>多层继承</strong>。 单继承: 一个类只能继承一个父类，但是Java中的子类是更加强大的。 不支持多继承: 子类不能同时继承多个父类 多层继承：子类A继承父类B,父类B可以继承父类C。 每一个类都直接或者间接的继承于Object</p><p><img src="/img/11-Java面向对象进阶-static-继承/dd9132251212437c87da4f196f38718e.png" /></p><h2 id="继承案例">3.3 继承案例</h2><h3 id="案例">3.3.1 案例</h3><p>现在有四种动物：布偶猫、中国狸花猫、哈士奇、泰迪。 暂时不考虑属性，只要考虑行为。 请按照继承的思想特点进行继承体系的设计。</p><p>四种动物分别有以下的行为： 布偶猫：吃饭、喝水、抓老鼠 中国狸花猫：吃饭、喝水、抓老鼠 。 哈士奇：吃饭、喝水、看家、拆家 泰迪：吃饭、喝水、看家、蹭一蹭</p><h3 id="案例图解分析">3.3.2 案例图解分析</h3><p><img src="/img/11-Java面向对象进阶-static-继承/d4c5fcac3a3047278bb9d34d88fa35fd.png" /></p><h3 id="案例代码实现">3.3.3 案例代码实现</h3><p><strong>1.父类Animal类</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃饭&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;喝水&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>2.子类Cat类</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;抓老鼠&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>3.子类Dog类</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">watchHome</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;看家&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>4.子类布偶猫类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ragdoll</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cat</span>&#123;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5.狸花猫类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LiHua</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cat</span>&#123;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>6.哈士奇类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Husky</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dog</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breakHome</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;拆家&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>7.泰迪类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teddy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dog</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">touch</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;蹭一蹭&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>8.测试类</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Ragdoll</span> <span class="hljs-variable">rd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ragdoll</span>();  <br>        rd.eat();  <br>        rd.drink();  <br>        rd.catchMouse();  <br>  <br>        <span class="hljs-type">Husky</span> <span class="hljs-variable">husky</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Husky</span>();  <br>        husky.eat();  <br>        husky.drink();  <br>        husky.watchHome();  <br>        husky.breakHome();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="小结-1">3.3.4 小结</h3><p>继承实际上是子类相同的属性和行为可以定义在父类中，子类特有的属性和行为由自己定义，这样就实现了相同属性和行为的重复利用，从而提高了代码复用。</p><h2 id="子类不能继承的内容">3.4 子类不能继承的内容</h2><h3 id="结论">3.4.1 结论</h3><p><img src="/img/11-Java面向对象进阶-static-继承/622d554279034a4f8990c2e2c3f7302b.png" /></p><p><strong>子类不能继承父类的构造方法。</strong> <strong>值得注意的是子类可以继承父类的私有成员（成员变量，方法)，只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。</strong></p><h2 id="继承后的特点成员变量">3.5 继承后的特点—成员变量</h2><h3 id="成员变量不重名">3.5.1 成员变量不重名</h3><p>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<strong>没有影响的</strong>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-comment">// Fu中的成员变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-comment">// Zi中的成员变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>  <br><span class="hljs-comment">// Zi中的成员方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 访问父类中的num</span><br>System.out.println(<span class="hljs-string">&quot;Fu num=&quot;</span>+num); <span class="hljs-comment">// 继承而来，所以直接访问。</span><br><span class="hljs-comment">// 访问子类中的num2</span><br>System.out.println(<span class="hljs-string">&quot;Zi num2=&quot;</span>+num2);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建子类对象</span><br><span class="hljs-type">Zi</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>(); <br>      <span class="hljs-comment">// 调用子类中的show方法</span><br>z.show();  <br>&#125;<br>&#125;<br><br>结果：<br><span class="hljs-type">Fu</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br><span class="hljs-type">Zi</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="成员变量重名">3.5.2 成员变量重名</h3><p>如果子类父类中出现<strong>重名</strong>的成员变量，这时的访问是<strong>有影响的</strong>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu1</span> &#123;<br><span class="hljs-comment">// Fu中的成员变量。</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu1</span> &#123;<br><span class="hljs-comment">// Zi中的成员变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;<br><br>System.out.println(<span class="hljs-string">&quot;num=&quot;</span> + num);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 创建子类对象</span><br><span class="hljs-type">Zi1</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi1</span>(); <br>      <span class="hljs-comment">// 调用子类中的show方法</span><br>z1.show(); <br>&#125;<br>&#125;<br>演示结果：<br>num = <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>就近原则</strong>，先在局部变量中寻找（int num = 7），没有去本类中寻找（int num = 6），最后去父类中寻找（int num = 5），逐级往上。</p><p>如果此时想访问父类成员变量，我们可以使用super关键字。</p><h3 id="super访问父类成员变量">3.5.3 super访问父类成员变量</h3><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用<code>super</code> 关键字，修饰父类成员变量，类似于 <code>this</code> 关键字。</p><p>需要注意的是：<strong>super代表的是父类对象的引用，this代表的是当前对象的引用(当前类中的成员变量，不在方法里 非局部)。</strong></p><p><img src="/img/11-Java面向对象进阶-static-继承/b4c9ec19b8794608aac6f0b16fc22baa.png" /></p><p><strong>使用格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">super</span>.父类成员变量名<br></code></pre></td></tr></table></figure><p>子类方法需要修改，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-comment">// Fu中的成员变量。</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-comment">// Zi中的成员变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <br>        <span class="hljs-comment">// 访问方法中的num</span><br>        System.out.println(<span class="hljs-string">&quot;method num=&quot;</span> + num);<br>        <span class="hljs-comment">// 访问子类中的num</span><br>        System.out.println(<span class="hljs-string">&quot;Zi num=&quot;</span> + <span class="hljs-built_in">this</span>.num);<br>        <span class="hljs-comment">// 访问父类中的num</span><br>        System.out.println(<span class="hljs-string">&quot;Fu num=&quot;</span> + <span class="hljs-built_in">super</span>.num);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 创建子类对象</span><br><span class="hljs-type">Zi1</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi1</span>(); <br>      <span class="hljs-comment">// 调用子类中的show方法</span><br>z1.show(); <br>&#125;<br>&#125;<br><br>演示结果：<br>method num=<span class="hljs-number">1</span><br>Zi num=<span class="hljs-number">6</span><br>Fu num=<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><blockquote><p>小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？可以在父类中提供公共的getXxx方法和setXxx方法。</p></blockquote><h2 id="继承后的特点成员方法">3.6 继承后的特点—成员方法</h2><p>当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？</p><h3 id="成员方法不重名">3.6.1 成员方法不重名</h3><p>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响的</strong>，<strong>就近原则</strong>。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Fu类中的show方法执行&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Zi类中的show2方法执行&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Zi</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();<br>     <span class="hljs-comment">//子类中没有show方法，但是可以找到父类方法去执行</span><br>z.show(); <br>z.show2();<br>&#125;<br>&#125;<br><br><br>结果：<br>Fu类中的show方法执行<br>Zi类中的show2方法执行<br></code></pre></td></tr></table></figure><h3 id="成员方法重名">3.6.2 成员方法重名</h3><p>如果子类父类中出现<strong>重名</strong>的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Fu show&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-comment">//子类重写了父类的show方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Zi show&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendsDemo05</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Zi</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();<br>     <span class="hljs-comment">// 子类中有show方法，只执行重写后的show方法</span><br>z.show();  <span class="hljs-comment">// Zi show</span><br><br>&#125;<br>&#125;<br><br>结果：<br>Zi show<br></code></pre></td></tr></table></figure><h2 id="方法重写">3.7 方法重写</h2><h3 id="概念">3.7.1 概念</h3><p><strong>方法重写</strong> ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>建立在子父类关系上，同个方法名同但是内容不同就是重写</strong>。</p><h3 id="使用场景与案例">3.7.2 使用场景与案例</h3><p>当父类的方法不能满足子类现在的需求，需要进行方法重写</p><p>子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方法（覆盖虚方法表中的方法）。</p><p>例如：我们定义了一个动物类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>  &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;动物跑的很快！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;动物都可以叫~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后定义一个猫类，猫可能认为父类cry()方法不能满足自己的需求</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;猫喵喵叫&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 创建子类对象</span><br>      <span class="hljs-type">Cat</span> <span class="hljs-variable">ddm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        <span class="hljs-comment">// 调用父类继承而来的方法</span><br>        ddm.run();<br>      <span class="hljs-comment">// 调用子类重写的方法</span><br>      ddm.cry();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="override重写注解">3.7.2 <span class="citation" data-cites="Override重写注解">@Override重写注解</span></h3><ul><li><p><span class="citation" data-cites="Override:注解">@Override:注解</span>，重写注解校验！</p></li><li><p>这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。</p></li><li><p>建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！</p><p>加上后的子类代码形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>     <span class="hljs-comment">// 声明不变，重新实现</span><br>    <span class="hljs-comment">// 方法名称与父类全部一样，只是方法体中的功能重写写了！</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;猫咪没有在叫&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="方法重写的本质">3.7.3 方法重写的本质</h3><p>如果发生了重写，则会覆盖，覆盖虚方法表中的方法。</p><p>B类继承C类方法： <img src="/img/11-Java面向对象进阶-static-继承/64667a9e3a924fbeb9f11ef31bfc589c.png" /></p><p>B类重写method2： <img src="/img/11-Java面向对象进阶-static-继承/0ba51ed75f0b4e90aedd47614d59a0f6.png" /></p><p>A类再次重写method2：</p><p><img src="/img/11-Java面向对象进阶-static-继承/c69ef5a5ee5f413ea782ca8d307a410a.png" /></p><h3 id="注意事项">3.7.4 注意事项</h3><ol type="1"><li>方法重写是发生在子父类之间的关系。</li><li>重写方法的名称、形参列表必须与父类中的一致。</li><li>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li><li>子类重写父类方法时，返回值类型子类必须小于等于父类</li><li>只有被添加到虚方法表中的方法才能被重写</li></ol><h2 id="继承后的特点构造方法">3.8 继承后的特点—构造方法</h2><h3 id="特点">3.8.1 特点</h3><ul><li>构造方法的名字是与类名一致的。所以子类无法继承父类构造方法的。</li><li>子类中所有的构造方法默认先访问父类中的无参构造，再执行自己。</li></ul><p><strong>为什么？</strong> - 构造方法的作用是初始化对象成员变量数据的。子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。 - ==子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化。==</p><p><strong>如何调用父类构造方法的？</strong> - 子类构造方法的第一行语句默认都是<code>super();</code>==不写也存在，且必须在第一行==。 - 如果想调用父类有参构造，必须手动写super进行调用</p><p><strong>继承后子类构方法器特点:子类所有构造方法的第一行都会默认先调用父类的无参构造方法</strong></p><h3 id="案例演示">3.8.2 案例演示</h3><p>按如下需求定义类:</p><ol type="1"><li>人类 成员变量: 姓名,年龄</li><li>学生类 成员变量: 姓名,年龄,成绩</li></ol><p>代码如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类无参&quot;</span>);<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <br>    <span class="hljs-built_in">this</span>.name = name;  <br>    <span class="hljs-built_in">this</span>.age = age;  <br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">//super(); // 调用父类无参,默认就存在，可以不写，必须再第一行  </span><br>    System.out.println(<span class="hljs-string">&quot;子类无参&quot;</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <br>    <span class="hljs-built_in">super</span>(name, age);  <span class="hljs-comment">// 调用父类有参构造  </span><br>    System.out.println(<span class="hljs-string">&quot;父类有参&quot;</span>);  <br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(); <span class="hljs-comment">//无参构造创建对象  </span><br>System.out.println(<span class="hljs-string">&quot;----------&quot;</span>);  <br>  <br><span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">23</span>);  <br>System.out.println(s2.name+<span class="hljs-string">&quot; &quot;</span>+ s2.age);<br>    &#125;<br>&#125;<br><br>输出结果：<br>父类无参<br>子类无参<br>----------<br>父类有参<br>zhangsan <span class="hljs-number">23</span><br></code></pre></td></tr></table></figure></p><p><strong>父类无参：</strong></p><p><img src="/img/11-Java面向对象进阶-static-继承/adb03faf41054ee8af43e112dbcea5b2.png" /></p><p><strong>父类有参：</strong></p><p><img src="/img/11-Java面向对象进阶-static-继承/821a536041a14c65bba450515cd78e51.png" /></p><h3 id="小结-2">3.8.3 小结</h3><ul><li>子类不能继承父类的构造方法，但是可以通过super调用</li><li>子类构造方法的第一行，有一个默认的super(0:</li><li>默认先访问父类中无参的构造方法，再执行自己。</li><li>如果想要方法文父类有参构造，必须手动书写。</li></ul><h2 id="super...和this...总结">3.9 super(...)和this(...)总结</h2><h3 id="总结">3.9.1 总结</h3><p>this : 理解为一个变量，表示当前方法调用者的地址值； super : 代表父类存储空间</p><h3 id="super和this的用法格式">3.9.2 super和this的用法格式</h3><p>访问成员变量格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.成员变量    --    本类的<br><span class="hljs-built_in">super</span>.成员变量    --    父类的<br><br></code></pre></td></tr></table></figure><p>访问成员方法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.成员方法名()  --    本类的    <br><span class="hljs-built_in">super</span>.成员方法名()   --    父类的<br></code></pre></td></tr></table></figure><p>访问构造方法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">super</span>(...) -- 调用父类的构造方法，根据参数匹配确认<br><span class="hljs-built_in">this</span>(...) -- 调用本类的其他构造方法，根据参数匹配确认<br></code></pre></td></tr></table></figure><h3 id="super....用法演示">3.9.3 super(....)用法演示</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;凤姐&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类无参&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name , <span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name ;<br>        <span class="hljs-built_in">this</span>.age = age ;<br>    &#125;<br><br>    <span class="hljs-comment">// getter/setter省略</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行</span><br>        System.out.println(<span class="hljs-string">&quot;子类无参&quot;</span>);<br>    &#125;<br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name ， <span class="hljs-type">int</span> age，<span class="hljs-type">double</span> score)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name ,age);<span class="hljs-comment">// 调用父类有参构造方法Person(String name , int age)初始化name和age</span><br>        <span class="hljs-built_in">this</span>.score = score;    <br>        System.out.println(<span class="hljs-string">&quot;子类有参&quot;</span>);<br>     &#125;<br>      <span class="hljs-comment">// getter/setter省略</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 调用子类有参数构造方法</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>，<span class="hljs-number">20</span>，<span class="hljs-number">99</span>);<br>        System.out.println(s2.getScore()); <span class="hljs-comment">// 99</span><br>        System.out.println(s2.getName()); <span class="hljs-comment">// 输出 张三</span><br>        System.out.println(s2.getAge()); <span class="hljs-comment">// 输出 20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p><p>super(..)是根据参数去确定调用父类哪个构造方法的。</p><h3 id="super...案例图解">3.9.4 super(...)案例图解</h3><p><strong>父类空间优先于子类对象产生</strong></p><p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造七调用时，一定先调用父类的构造方法。理解图解如下：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fN0EXS8c-1682256310760)(./附件/13.jpg)]</p><h3 id="this...用法演示">3.9.5 this(...)用法演示</h3><p>this(...) * 默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。 * 为了借用其他构造方法的功能。 * 一般给一些数据赋默认值时会用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br>    <span class="hljs-keyword">private</span> String school ;<br><br><span class="hljs-comment">//需求：学校默认为xxx大学</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//调用本类其他构造方法</span><br><span class="hljs-comment">//虚拟机不会在添加super（）</span><br>        <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;xxx大学&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, <span class="hljs-type">char</span> sex)</span> &#123;<br>    <span class="hljs-comment">//不会在添加super();</span><br>        <span class="hljs-built_in">this</span>.name = name ;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.school = school;<br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>注意： - this（）必须写在第一行 - 虚拟机不会在添加super（）</p><h3 id="小结-3">3.9.6 小结</h3><ul><li><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p></li><li><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p></li><li><p><strong>super(..)和this(...)是根据参数去确定调用父类哪个构造方法的。</strong></p></li><li><p>super(..)可以调用父类构造方法初始化继承自父类的成员变量的数据。</p></li><li><p>this(..)可以调用本类中的其他构造方法。</p></li></ul><h2 id="练习">4. 练习</h2><p>写一个继承结构下的标准Javabean</p><p><strong>需求：</strong> 1.经理 成员变量：工号，姓名，工资，管理奖金 成员方法：工作（管理其他人），吃饭（吃米饭）</p><p>2.厨师 成员变量：工号，姓名，工资 成员方法：工作（炒菜），吃饭（吃米饭）</p><p><strong>代码示例：</strong></p><p><strong>父类Worker</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> extent4;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> &#123;  <br>    <span class="hljs-keyword">private</span> String id;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.id = id;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.salary = salary;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> id;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(String id)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.id = id;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSalary</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> salary;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSalary</span><span class="hljs-params">(<span class="hljs-type">double</span> salary)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.salary = salary;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;工作&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃米饭&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>子类Manger</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> extent4;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Worker</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> bonus;  <br>  <br>  <br>    <span class="hljs-comment">//空参构造  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Manager</span><span class="hljs-params">()</span> &#123;  <br>  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 带全部参数的构造（父类和子类所有的成员变量）  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Manager</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary, <span class="hljs-type">double</span> bonus)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(id, name, salary);  <br>        <span class="hljs-built_in">this</span>.bonus = bonus;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-comment">// 只用写子类的get&amp;set  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getBonus</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> bonus;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBonus</span><span class="hljs-params">(<span class="hljs-type">double</span> bonus)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.bonus = bonus;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;管理其他人&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>子类Cook</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> extent4;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Worker</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cook</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cook</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(id, name, salary);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;炒菜&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> extent4;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Manager</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>(<span class="hljs-string">&quot;00a&quot;</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">8888</span>, <span class="hljs-number">6666</span>);  <br>        System.out.println(manager.getId() + <span class="hljs-string">&quot;, &quot;</span> + manager.getName() + <span class="hljs-string">&quot;, &quot;</span> + manager.getSalary() + <span class="hljs-string">&quot;, &quot;</span> + manager.getBonus());  <br>        manager.job();  <br>        manager.eat();  <br>  <br>  <br>        <span class="hljs-type">Cook</span> <span class="hljs-variable">cook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cook</span>();  <br>        cook.setId(<span class="hljs-string">&quot;002&quot;</span>);  <br>        cook.setName(<span class="hljs-string">&quot;lisi&quot;</span>);  <br>        cook.setSalary(<span class="hljs-number">6666</span>);  <br>        System.out.println(cook.getId() + <span class="hljs-string">&quot;, &quot;</span> + cook.getName() + <span class="hljs-string">&quot;, &quot;</span> + cook.getSalary());  <br>        cook.job();  <br>        cook.eat();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java10-集合ArrayList</title>
    <link href="/2023/06/29/Java10-%E9%9B%86%E5%90%88ArrayList/"/>
    <url>/2023/06/29/Java10-%E9%9B%86%E5%90%88ArrayList/</url>
    
    <content type="html"><![CDATA[<h2 id="arraylist">1.ArrayList</h2><h3 id="集合和数组的优势对比">集合和数组的优势对比：</h3><ol type="1"><li>长度可变</li><li>添加数据的时候不需要考虑索引，默认将数据添加到末尾</li></ol><h3 id="arraylist类概述">1.1 ArrayList类概述</h3><ul><li><p>什么是集合</p><p>提供一种存储空间==可变==的存储模型，存储的数据容量可以发生改变</p></li><li><p>ArrayList集合的特点</p><p>长度可以变化，只能存储引用数据类型。</p></li><li><p>泛型的使用</p><p>用于<em>约束</em>集合中存储元素的<em>数据类型</em></p></li></ul><h3 id="arraylist类常用方法">1.2 ArrayList类常用方法</h3><h4 id="构造方法">1.2.1 构造方法</h4><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public ArrayList()</td><td>创建一个空的集合对象</td></tr></tbody></table><p>格式：<code>ArrayList&lt;E&gt; array = new ArrayList&lt;E&gt;();</code></p><h4 id="成员方法">1.2.2 成员方法</h4><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public boolean add(要添加的元素)</td><td>将指定的元素追加到此集合的末尾</td></tr><tr class="even"><td>public boolean remove(要删除的元素)</td><td>删除指定元素,返回值表示是否删除成功</td></tr><tr class="odd"><td>public E remove(int index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr class="even"><td>public E set(int index,E element)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr class="odd"><td>public E get(int index)</td><td>返回指定索引处的元素</td></tr><tr class="even"><td>public int size()</td><td>返回集合中的元素的个数</td></tr></tbody></table><h4 id="示例代码">1.2.3 示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayListDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建集合</span><br>        ArrayList&lt;String&gt; array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>        <span class="hljs-comment">//添加元素</span><br>        array.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        array.add(<span class="hljs-string">&quot;world&quot;</span>);<br>        array.add(<span class="hljs-string">&quot;java&quot;</span>);<br><br>        <span class="hljs-comment">//public boolean remove(Object o)：删除指定的元素，返回删除是否成功</span><br>        array.remove(<span class="hljs-string">&quot;world&quot;</span>)); <span class="hljs-comment">// true</span><br>        array.remove(<span class="hljs-string">&quot;javaee&quot;</span>));<span class="hljs-comment">// false</span><br><br>        <span class="hljs-comment">//public E remove(int index)：删除指定索引处的元素，返回被删除的元素</span><br>        array.remove(<span class="hljs-number">1</span>); <span class="hljs-comment">// world</span><br><br>        <span class="hljs-comment">//IndexOutOfBoundsException</span><br>        array.remove(<span class="hljs-number">3</span>); <span class="hljs-comment">//IndexOutOfBoundsException</span><br><br>        <span class="hljs-comment">//public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素</span><br>        array.set(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;javaee&quot;</span>); <span class="hljs-comment">//返回world。把1索引的值改成javaee</span><br><br>        <span class="hljs-comment">//IndexOutOfBoundsException</span><br>        array.set(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;javaee&quot;</span>);<span class="hljs-comment">// IndexOutOfBoundsException</span><br><br>        <span class="hljs-comment">//public E get(int index)：返回指定索引处的元素</span><br>        array.get(<span class="hljs-number">0</span>); <br>        array.get(<span class="hljs-number">1</span>);<br>        array.get(<span class="hljs-number">2</span>);<br>        <br><br>        <span class="hljs-comment">//public int size()：返回集合中的元素的个数</span><br>        array.size();<br><br>        <span class="hljs-comment">//输出集合</span><br>        System.out.println(<span class="hljs-string">&quot;array:&quot;</span> + array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="arraylist遍历">1.3 ArrayList遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//遍历</span><br><span class="hljs-comment">//快捷键: list.fori 正向遍历</span><br><span class="hljs-comment">//list.forr 倒着遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>        System.out.println(list.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基本数据类型对应的包装类">1.4 基本数据类型对应的包装类</h3><p>byte Byte shot Short char Char int Interger long Long float Float double Double boolean Boolean</p><h3 id="添加对象">1.5 添加对象</h3><p>需求：</p><p>1，main方法中定义一个集合，存入三个用户对象。</p><p>用户属性为：id，username，password</p><p>2，要求：定义一个方法，根据id查找对应的学生信息。</p><p>如果存在，返回索引</p><p>如果不存在，返回-1</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayListDemo6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*需求：</span><br><span class="hljs-comment">        1，main方法中定义一个集合，存入三个用户对象。</span><br><span class="hljs-comment">        用户属性为：id，username，password</span><br><span class="hljs-comment">        2，要求：定义一个方法，根据id查找对应的学生信息。</span><br><span class="hljs-comment">        如果存在，返回索引</span><br><span class="hljs-comment">        如果不存在，返回-1*/</span><br><br><br>        <span class="hljs-comment">//1.创建集合对象</span><br>        ArrayList&lt;User&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">//2.创建用户对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;heima001&quot;</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;heima002&quot;</span>, <span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;heima003&quot;</span>, <span class="hljs-string">&quot;wangwu&quot;</span>, <span class="hljs-string">&quot;1234qwer&quot;</span>);<br><br>        <span class="hljs-comment">//3.把用户对象添加到集合当中</span><br>        list.add(u1);<br>        list.add(u2);<br>        list.add(u3);<br><br>        <span class="hljs-comment">//4.调用方法，通过id获取对应的索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> getIndex(list, <span class="hljs-string">&quot;heima001&quot;</span>);<br><br>        System.out.println(index);<br><br>    &#125;<br><br><br>    <span class="hljs-comment">//1.我要干嘛？  根据id查找对应的学生信息</span><br>    <span class="hljs-comment">//2.我干这件事情需要什么才能完成？   集合 id</span><br>    <span class="hljs-comment">//3.方法的调用处是否需要继续使用方法的结果？</span><br>    <span class="hljs-comment">//要用必须返回，不要用可以返回也可以不返回</span><br>    <span class="hljs-comment">//明确说明需要有返回值 int</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIndex</span><span class="hljs-params">(ArrayList&lt;User&gt; list, String id)</span> &#123;<br>        <span class="hljs-comment">//遍历集合得到每一个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> u.getId();<br>            <span class="hljs-keyword">if</span>(uid.equals(id))&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//因为只有当集合里面所有的元素都比较完了，才能断定id是不存在的。</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="判断用户的是否存在">1.6 判断用户的是否存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayListDemo5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">/* 需求：</span><br><span class="hljs-comment">        1，main方法中定义一个集合，存入三个用户对象。</span><br><span class="hljs-comment">        用户属性为：id，username，password</span><br><span class="hljs-comment">        2，要求：定义一个方法，根据id查找对应的学生信息。</span><br><span class="hljs-comment">        如果存在，返回true</span><br><span class="hljs-comment">        如果不存在，返回false*/</span><br><br>        <span class="hljs-comment">//1.定义集合</span><br>        ArrayList&lt;User&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">//2.创建对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;heima001&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;heima002&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;12345678&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;heima003&quot;</span>,<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-string">&quot;1234qwer&quot;</span>);<br><br>        <span class="hljs-comment">//3.把用户对象添加到集合当中</span><br>        list.add(u1);<br>        list.add(u2);<br>        list.add(u3);<br><br>        <span class="hljs-comment">//4.调用方法，查询id是否存在</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> contains(list, <span class="hljs-string">&quot;heima001&quot;</span>);<br>        System.out.println(result);<br><br>    &#125;<br><br>    <span class="hljs-comment">//定义在测试类中的方法需要加static</span><br>    <span class="hljs-comment">//1.我要干嘛？ 我要根据id查询学生是否存在</span><br>    <span class="hljs-comment">//2.我干这件事情，需要什么才能完成？ 集合 id</span><br>    <span class="hljs-comment">//3.方法的调用处是否需要使用方法的结果？</span><br>    <span class="hljs-comment">//如果要用，必须返回，如果不用，可以返回也可以不返回</span><br>    <span class="hljs-comment">//但是本题明确说明需要返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(ArrayList&lt;User&gt; list, String id)</span>&#123;<br>        <span class="hljs-comment">//循环遍历集合，得到集合里面的每一个元素</span><br>        <span class="hljs-comment">//再进行判断</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-comment">//i 索引  list.get(i); 元素</span><br>            <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-comment">//判断id是否存在，我是拿着谁跟谁比较</span><br>            <span class="hljs-comment">//需要把用户对象里面的id拿出来再进行比较。</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> u.getId();<br>            <span class="hljs-keyword">if</span>(id.equals(uid))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//return 关键字：作用就是结束方法。</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//只有当集合里面所有的元素全部比较完毕才能认为是不存在的。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java09-字符串</title>
    <link href="/2023/06/29/Java09-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/06/29/Java09-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="string类">1.String类</h2><h3 id="string类概述">1.1String类概述</h3><pre><code class="hljs">String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！</code></pre><h3 id="string类的特点">1.2String类的特点</h3><ul><li>字符串不可变，它们的值在创建后不能被更改</li><li>虽然 String 的值是不可变的，但是它们可以被共享</li><li>字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )</li></ul><h3 id="string类的构造方法">1.3String类的构造方法</h3><ul><li><p>常用的构造方法</p><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public String()</td><td>创建一个空白字符串对象，不含有任何内容</td></tr><tr class="even"><td>public String(char[] chs)</td><td>根据字符数组的内容，来创建字符串对象</td></tr><tr class="odd"><td>public String(byte[] bys)</td><td>根据字节数组的内容，来创建字符串对象</td></tr><tr class="even"><td>String s = “abc”;</td><td>直接赋值的方式创建字符串对象，内容就是abc</td></tr></tbody></table></li></ul><h3 id="创建字符串对象两种方式的区别">1.4创建字符串对象两种方式的区别</h3><ul><li><p>通过构造方法创建 通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同</p></li><li><p>直接赋值方式创建 当使用双引号直接赋值时，系统会检查该字符串在串池中是否存在。 不存在：创建新的 存在：复用</p></li></ul><p>String是个引用类型,有它的属性和方法,继承obj,只不过重写了返回的对象是他自己,也就是字符组。</p><p>赋值：在串池里面，new出来的：在堆里面 串池也是堆内存中开辟的一个空间</p><h3 id="字符串的比较">1.5字符串的比较</h3><h4 id="号的作用">1.5.1 <code>==</code> 号的作用</h4><ul><li>比较基本数据类型：比较的是具体的值</li><li>比较引用数据类型：比较的是对象地址值</li></ul><h4 id="equals方法的作用">1.5.2equals方法的作用</h4><ul><li>方法介绍</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> s1.equals(s2)     比较两个字符串内容是否完全相同、区分大小写<br>           equalsIgnoreCase        忽略大小写<br></code></pre></td></tr></table></figure><ul><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//构造方法的方式得到对象</span><br>        <span class="hljs-type">char</span>[] chs = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs);<br><br>        <span class="hljs-comment">//直接赋值的方式得到对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><br>        <span class="hljs-comment">//比较字符串对象地址是否相同</span><br>        System.out.println(s1 == s2);<br>        System.out.println(s1 == s3);<br>        System.out.println(s3 == s4);<br>        System.out.println(<span class="hljs-string">&quot;--------&quot;</span>);<br><br>        <span class="hljs-comment">//比较字符串内容是否相同</span><br>        System.out.println(s1.equals(s2));<br>        System.out.println(s1.equals(s3));<br>        System.out.println(s3.equals(s4));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="遍历字符串案例">1.6遍历字符串案例</h3><p>. charAt(索引)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符串直接遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//两个方法：</span><br>        <span class="hljs-comment">//charAt()：会根据索引获取对应的字符</span><br>        <span class="hljs-comment">//length(): 会返回字符串的长度</span><br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str.charAt(i);<br>            System.out.println(c);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="统计字符次数案例">1.7统计字符次数案例</h3><h4 id="案例需求">1.7.1案例需求</h4><pre><code class="hljs">键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数(不考虑其他字符)</code></pre><h4 id="代码实现">1.7.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 统计个数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//键盘录入一个字符串，统计大写，小写，数字出现的次数</span><br><br><br>        <span class="hljs-comment">//1.键盘录入一个字符串</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入一个字符串&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.next();<br><br><br>        <span class="hljs-comment">//2.统计 --- 计数器count</span><br>        <span class="hljs-comment">//此时我要统计的有3样东西，所以要定义3个计数器分别进行统计</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bigCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">smallCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numberCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//得到这个字符串里面每一个字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str.charAt(i);<br>            <span class="hljs-comment">//对c进行判断</span><br>            <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>                smallCount++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)&#123;<br>                bigCount++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                numberCount++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//3.当循环结束之后，三个变量记录的就是对应的个数</span><br>        System.out.println(<span class="hljs-string">&quot;大写字符有:&quot;</span> + bigCount + <span class="hljs-string">&quot;个&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;小写字符有:&quot;</span> + smallCount + <span class="hljs-string">&quot;个&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;数字字符有:&quot;</span> + numberCount + <span class="hljs-string">&quot;个&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="金额转换">1.8 金额转换</h3><h4 id="案例需求-1">1.8.1 案例需求</h4><pre><code class="hljs">把2135变成：零佰零拾零万贰仟壹佰叁拾伍元 把789变成：零佰零拾零万零仟柒佰捌拾玖元</code></pre><h4 id="代码实现-1">1.8.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.键盘录入一个金额</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> money;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;请录入一个金额&quot;</span>);<br>            money = sc.nextInt();<br>            <span class="hljs-keyword">if</span> (money &gt;= <span class="hljs-number">0</span> &amp;&amp; money &lt;= <span class="hljs-number">9999999</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;金额无效&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//定义一个变量用来表示钱的大写</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">moneyStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">//2.得到money里面的每一位数字,再转成中文</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-comment">//2135</span><br>            <span class="hljs-comment">//从右往左获取数据，因为右侧是数据的个位</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">ge</span> <span class="hljs-operator">=</span> money % <span class="hljs-number">10</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">capitalNumber</span> <span class="hljs-operator">=</span> getCapitalNumber(ge);<br>            <span class="hljs-comment">//把转换之后的大写拼接到moneyStr当中</span><br>            moneyStr = capitalNumber + moneyStr;<br>            <span class="hljs-comment">//第一次循环 ： &quot;伍&quot; + &quot;&quot; = &quot;伍&quot;</span><br>            <span class="hljs-comment">//第二次循环 ： &quot;叁&quot; + &quot;伍&quot; = &quot;叁伍&quot;</span><br>            <span class="hljs-comment">//去掉刚刚获取的数据</span><br>            money = money / <span class="hljs-number">10</span>;<br><br>            <span class="hljs-comment">//如果数字上的每一位全部获取到了，那么money记录的就是0，此时循环结束</span><br>            <span class="hljs-keyword">if</span> (money == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//3.在前面补0，补齐7位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span> - moneyStr.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            moneyStr = <span class="hljs-string">&quot;零&quot;</span> + moneyStr;<br>        &#125;<br>        System.out.println(moneyStr);<span class="hljs-comment">//零零零贰壹叁伍</span><br><br>        <span class="hljs-comment">//4.插入单位</span><br>        <span class="hljs-comment">//定义一个数组表示单位</span><br>        String[] arr = &#123;<span class="hljs-string">&quot;佰&quot;</span>,<span class="hljs-string">&quot;拾&quot;</span>,<span class="hljs-string">&quot;万&quot;</span>,<span class="hljs-string">&quot;仟&quot;</span>,<span class="hljs-string">&quot;佰&quot;</span>,<span class="hljs-string">&quot;拾&quot;</span>,<span class="hljs-string">&quot;元&quot;</span>&#125;;<br>        <span class="hljs-comment">//               零    零   零   贰   壹   叁   伍</span><br><br>        <span class="hljs-comment">//遍历moneyStr，依次得到 零    零   零   贰   壹   叁   伍</span><br>        <span class="hljs-comment">//然后把arr的单位插入进去</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; moneyStr.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> moneyStr.charAt(i);<br>            <span class="hljs-comment">//把大写数字和单位拼接到result当中</span><br>            result = result + c + arr[i];<br>        &#125;<br><br>        <span class="hljs-comment">//5.打印最终结果</span><br>        System.out.println(result);<br><br>    &#125;<br><br><br>    <span class="hljs-comment">//定义一个方法把数字变成大写的中文</span><br>    <span class="hljs-comment">//1 -- 壹</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getCapitalNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-comment">//定义数组，让数字跟大写的中文产生一个对应关系</span><br>        String[] arr = &#123;<span class="hljs-string">&quot;零&quot;</span>, <span class="hljs-string">&quot;壹&quot;</span>, <span class="hljs-string">&quot;贰&quot;</span>, <span class="hljs-string">&quot;叁&quot;</span>, <span class="hljs-string">&quot;肆&quot;</span>, <span class="hljs-string">&quot;伍&quot;</span>, <span class="hljs-string">&quot;陆&quot;</span>, <span class="hljs-string">&quot;柒&quot;</span>, <span class="hljs-string">&quot;捌&quot;</span>, <span class="hljs-string">&quot;玖&quot;</span>&#125;;<br>        <span class="hljs-comment">//返回结果</span><br>        <span class="hljs-keyword">return</span> arr[number];<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="手机号屏蔽">1.9 手机号屏蔽</h3><p>需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽</p><p>最终效果为：<code>131****9468</code></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 手机号屏蔽</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test8</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽</span><br><span class="hljs-comment">        最终效果为：131****9468*/</span><br><br>        <span class="hljs-comment">//1.键盘录入一个手机号码</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入手机号码&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">phoneNumber</span> <span class="hljs-operator">=</span> sc.next();<span class="hljs-comment">//13112349408</span><br><br>        <span class="hljs-comment">//2.截取手机号码中的前三位</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">star</span> <span class="hljs-operator">=</span> phoneNumber.substring(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">//3.截取手机号码中的最后四位</span><br>        <span class="hljs-comment">//此时我用substring方法，是用1个参数的，还是两个参数的？1个参数的会更好</span><br>        <span class="hljs-comment">//因为现在我要截取到最后，所以建议使用1个参数的。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> phoneNumber.substring(<span class="hljs-number">7</span>);<br><br>        <span class="hljs-comment">//4.拼接</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> star + <span class="hljs-string">&quot;****&quot;</span> + end;<br><br>        System.out.println(result);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="敏感词替换">1.10 敏感词替换</h3><p>需求1：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 敏感词替换</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.定义一个变量表示骂人的话</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">talk</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TMD&quot;</span>;<br><br><br>        <span class="hljs-comment">//2.把这句话中的敏感词进行替换</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> talk.replace(<span class="hljs-string">&quot;TMD&quot;</span>, <span class="hljs-string">&quot;***&quot;</span>);<br><br>        <span class="hljs-comment">//3.打印</span><br>        System.out.println(talk);<br>        System.out.println(result);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>需求2：如果要替换的敏感词比较多怎么办？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 多个敏感词替换</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test10</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//实际开发中，敏感词会有很多很多</span><br><br>        <span class="hljs-comment">//1.先键盘录入要说的话</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入要说的话&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">talk</span> <span class="hljs-operator">=</span> sc.next();<span class="hljs-comment">//TMD,GDX,ctmd,ZZ</span><br><br>        <span class="hljs-comment">//2.定义一个数组用来存多个敏感词</span><br>        String[] arr = &#123;<span class="hljs-string">&quot;TMD&quot;</span>,<span class="hljs-string">&quot;GDX&quot;</span>,<span class="hljs-string">&quot;ctmd&quot;</span>,<span class="hljs-string">&quot;ZZ&quot;</span>,<span class="hljs-string">&quot;lj&quot;</span>,<span class="hljs-string">&quot;FW&quot;</span>,<span class="hljs-string">&quot;nt&quot;</span>&#125;;<br><br>        <span class="hljs-comment">//3.把说的话中所有的敏感词都替换为***</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">//i 索引</span><br>            <span class="hljs-comment">//arr[i] 元素 --- 敏感词</span><br>            talk = talk.replace(arr[i],<span class="hljs-string">&quot;***&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//4.打印结果</span><br>        System.out.println(talk);<span class="hljs-comment">//***,***,***,***</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="身份证信息查看">1.11 身份证信息查看</h3><pre><code class="hljs">身份证的每一位都是有固定的含义：</code></pre><ul><li>1、2位：省份</li><li>3、4位：城市</li><li>5、6位：区县</li><li>7-14位：出生年、月、日</li><li>15、16位：所在地派出所</li><li>17位：性别（奇数男性，偶数女性）</li><li>18位：个人信息码（随机产生）</li></ul><p>要求打印内容方式如下：</p><pre><code class="hljs">人物信息为：出生年月日：XXXX年X月X日性别为：男/女</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDemo11</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.定义一个字符串记录身份证号码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;321281202001011234&quot;</span>;<br><br>        <span class="hljs-comment">//2.获取出生年月日</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> id.substring(<span class="hljs-number">6</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> id.substring(<span class="hljs-number">10</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> id.substring(<span class="hljs-number">12</span>, <span class="hljs-number">14</span>);<br><br><br>        System.out.println(<span class="hljs-string">&quot;人物信息为：&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;出生年月日:&quot;</span> + year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + day + <span class="hljs-string">&quot;日&quot;</span>);<br><br>        <span class="hljs-comment">//3.获取性别</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> id.charAt(<span class="hljs-number">16</span>);<span class="hljs-comment">//&#x27;3&#x27;  ---&gt; 3</span><br>        <span class="hljs-comment">//利用ASCII码表进行转换</span><br>        <span class="hljs-comment">//&#x27;0&#x27; ---&gt;  48</span><br>        <span class="hljs-comment">//&#x27;1&#x27; ---&gt;  49</span><br>        <span class="hljs-comment">//&#x27;2&#x27; ---&gt;  50</span><br>        <span class="hljs-comment">//&#x27;3&#x27; ---&gt;  51</span><br>        <span class="hljs-comment">//&#x27;4&#x27; ---&gt;  52</span><br>        <span class="hljs-comment">//&#x27;5&#x27; ---&gt;  53</span><br>        <span class="hljs-comment">//&#x27;6&#x27; ---&gt;  54</span><br>        <span class="hljs-comment">//&#x27;7&#x27; ---&gt;  55</span><br>        <span class="hljs-comment">//&#x27;8&#x27; ---&gt;  56</span><br>        <span class="hljs-comment">//&#x27;9&#x27; ---&gt;  57</span><br><br>       <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> gender - <span class="hljs-number">48</span>;<br>        <span class="hljs-keyword">if</span>(num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;性别为:女&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;性别为:男&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stringbuilder">2.StringBuilder</h2><p>StringBuilder 可以看成是一个容器，创建之后里面的内容是可变的。</p><p>当我们在拼接字符串和反转字符串的时候会使用到</p><h3 id="构造方法">2.1 构造方法</h3><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public StringBuilder()</td><td>创建一个空白可变字符串对象，不含有任何内容</td></tr><tr class="even"><td>public StringBuilder(String str)</td><td>根据字符串的内容，来创建可变字符串对象.初始化存在str</td></tr></tbody></table><h3 id="常用方法">2.2 常用方法</h3><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public StringBuilder append(任意类型)</td><td>添加数据，并返回对象本身</td></tr><tr class="even"><td>public StringBuilder reverse()</td><td>反转容器中的内容</td></tr><tr class="odd"><td>public int length（）</td><td>返回长度（字符出现的个数）</td></tr><tr class="even"><td>public String toString()</td><td>把StringBuilder转换为String</td></tr></tbody></table><h3 id="基本使用">2.3 基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilderDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//0.创建对象</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><br>        <span class="hljs-comment">//1.添加元素</span><br>        <span class="hljs-comment">/*sb.append(1);</span><br><span class="hljs-comment">        sb.append(2.3);</span><br><span class="hljs-comment">        sb.append(true);</span><br><span class="hljs-comment">        System.out.println(sb);//结果 abc12.3true</span><br><span class="hljs-comment">        */</span><br>        <br>        <span class="hljs-comment">//2.反转</span><br>        sb.reverse();<br>System.out.println(sb);<span class="hljs-comment">//结果 cba</span><br>        <span class="hljs-comment">//3.获取长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> sb.length();<br>        System.out.println(len);<span class="hljs-comment">//结果 3</span><br><br><span class="hljs-comment">//4.把StringBuilder变回String</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br><br>        <span class="hljs-comment">//打印</span><br>        <span class="hljs-comment">//普及：</span><br>        <span class="hljs-comment">//因为StringBuilder是Java已经写好的类</span><br>        <span class="hljs-comment">//java在底层对他做了一些特殊处理。</span><br>        <span class="hljs-comment">//打印对象不是地址值而是属性值。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链式编程">2.4 链式编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilderDemo4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.创建对象</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-comment">//2.添加字符串</span><br>        sb.append(<span class="hljs-string">&quot;aaa&quot;</span>).append(<span class="hljs-string">&quot;bbb&quot;</span>).append(<span class="hljs-string">&quot;ccc&quot;</span>).append(<span class="hljs-string">&quot;ddd&quot;</span>);<br><br>        System.out.println(sb);<span class="hljs-comment">//aaabbbcccddd</span><br><br>        <span class="hljs-comment">//3.再把StringBuilder变回字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br>        System.out.println(str);<span class="hljs-comment">//aaabbbcccddd</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stringjoiner">3. StringJoiner</h2><ul><li>StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。</li><li>作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。</li><li>JDK8出现的</li></ul><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public StringJoiner（间隔符号）</td><td>指定拼接的间隔符号</td></tr><tr class="even"><td>public StringJoiner（间隔符号，开始符号，结束符号）</td><td>指定拼接的间隔符号，开始符号，结束符号</td></tr></tbody></table><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public StringJoiner add(任意类型)</td><td>添加数据，并返回对象本身</td></tr><tr class="even"><td>public int length（）</td><td>返回长度（字符出现的个数）</td></tr><tr class="odd"><td>public String toString()</td><td>把StringBuilder转换为String</td></tr></tbody></table><p>基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建一个对象，并指定中间的间隔符号</span><br><span class="hljs-type">StringJoiner</span> <span class="hljs-variable">sj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;---&quot;</span>);<br><span class="hljs-comment">//2.添加元素</span><br>sj.add(<span class="hljs-string">&quot;aaa&quot;</span>).add(<span class="hljs-string">&quot;bbb&quot;</span>).add(<span class="hljs-string">&quot;ccc&quot;</span>);<br><span class="hljs-comment">//3.打印结果</span><br>System.out.println(sj);<span class="hljs-comment">//aaa---bbb---ccc</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建对象</span><br><span class="hljs-type">StringJoiner</span> <span class="hljs-variable">sj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;, &quot;</span>,<span class="hljs-string">&quot;[&quot;</span>,<span class="hljs-string">&quot;]&quot;</span>);<br><span class="hljs-comment">//2.添加元素</span><br>sj.add(<span class="hljs-string">&quot;aaa&quot;</span>).add(<span class="hljs-string">&quot;bbb&quot;</span>).add(<span class="hljs-string">&quot;ccc&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> sj.length();<br>System.out.println(len);<span class="hljs-comment">//15</span><br><span class="hljs-comment">//3.打印</span><br>System.out.println(sj);<span class="hljs-comment">//[aaa, bbb, ccc]</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sj.toString();<br>System.out.println(str);<span class="hljs-comment">//[aaa, bbb, ccc]</span><br></code></pre></td></tr></table></figure><h2 id="关于字符串的底层原理">关于字符串的底层原理：</h2><ol type="1"><li><p>字符串存储的内存原理</p><p>String s = “abc”；直接赋值</p><p>特点：</p><p>此时字符串abc是存在字符串常量池中的。</p><p>先检查字符串常量池中有没有字符串abc，如果有，不会创建新的，而是直接复用。如果没有abc，才会创建一个新的。</p><p>所以，直接赋值的方式，代码简单，而且节约内存。</p></li><li><p>new出来的字符串</p><p>看到new关键字，一定是在堆里面开辟了一个小空间。</p><p>String s1 = new String（“abc”）；</p><p>String s2 = “abc”；</p><p>s1记录的是new出来的，在堆里面的地址值。</p><p>s2是直接赋值的，所以记录的是字符串常量池中的地址值。</p></li><li><p><code>==</code>号比较的到底是什么？</p><p>如果比较的是基本数据类型：比的是具体的数值是否相等。</p><p>如果比较的是引用数据类型：比的是地址值是否相等。</p><p>结论：<code>==</code>只能用于比较基本数据类型。不能比较引用数据类型。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java08-面向对象</title>
    <link href="/2023/06/29/Java08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/06/29/Java08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="类和对象">1. 类和对象</h2><h3 id="类和对象的理解">1.1 类和对象的理解</h3><p>客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。</p><ul><li>类<ul><li>类的理解<ul><li>类是对现实生活中一类具有共同属性和行为的事物的抽象</li><li>类是对象的数据类型，类是具有相同属性和行为的一组对象的集合</li><li>简单理解：类就是对现实事物的一种描述</li></ul></li><li>类的组成<ul><li>属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）</li><li>行为：指事物能执行的操作，例如：手机事物（打电话，发短信）</li></ul></li></ul></li><li>类和对象的关系<ul><li>类：类是对现实生活中一类具有共同属性和行为的事物的抽象</li><li>对象：是能够看得到摸的着的真实存在的实体</li><li>简单理解：<strong>类是对事物的一种描述，对象则为具体存在的事物</strong></li></ul></li></ul><h3 id="类的定义">1.2 类的定义</h3><p>类的组成是由属性和行为两部分组成</p><ul><li>属性：在类中通过成员变量来体现（类中方法外的变量）</li><li>行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）</li></ul><p>类的定义步骤：</p><p>①定义类 类名首字母建议大写，需要见名知意，驼峰模式。 一个Java文件中可以定义多个class类，且只能一个类是public修饰，而且public修饰的类名必须成为代码文件名。 实际开发中建议还是一个文件定义一个class类。</p><p>②编写类的成员变量 修饰符 数据类型 变量名称 = 初始化值；</p><p>③编写类的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 类名 &#123;<br><span class="hljs-comment">// 成员变量</span><br>变量<span class="hljs-number">1</span>的数据类型 变量<span class="hljs-number">1</span>；<br>变量<span class="hljs-number">2</span>的数据类型 变量<span class="hljs-number">2</span>;<br>…<br><span class="hljs-comment">// 成员方法</span><br>方法<span class="hljs-number">1</span>;<br>方法<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    手机类：</span><br><span class="hljs-comment">        类名：</span><br><span class="hljs-comment">        手机(Phone)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        成员变量：</span><br><span class="hljs-comment">        品牌(brand)</span><br><span class="hljs-comment">        价格(price)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        成员方法：</span><br><span class="hljs-comment">        打电话(call)</span><br><span class="hljs-comment">        发短信(sendMessage)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br>    <span class="hljs-comment">//成员变量</span><br>    String brand;<br>    <span class="hljs-type">int</span> price;<br><br>    <span class="hljs-comment">//成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>定义类的补充注意事项</p><ul><li><p>用来描述一类事物的类，专业叫做：Javabean类。 在javabean类中，是不写main方法的。</p></li><li><p>在以前，编写main方法的类，叫做测试类。 我们可以在测试类中创建javabean类的对象并进行赋值调用。</p></li></ul><p>定义类技巧 - 属性多为名词 - 动词多为行为 ### 1.3 对象的使用</p><ul><li>创建对象的格式：<ul><li>类名 对象名 = new 类名();</li></ul></li><li>调用成员的格式：<ul><li>对象名.成员变量</li><li>对象名.成员方法();</li></ul></li><li>示例代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建对象</span><br><span class="hljs-comment">        格式：类名 对象名 = new 类名();</span><br><span class="hljs-comment">        范例：Phone p = new Phone();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    使用对象</span><br><span class="hljs-comment">        1：使用成员变量</span><br><span class="hljs-comment">            格式：对象名.变量名</span><br><span class="hljs-comment">            范例：p.brand</span><br><span class="hljs-comment">        2：使用成员方法</span><br><span class="hljs-comment">            格式：对象名.方法名()</span><br><span class="hljs-comment">            范例：p.call()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建对象</span><br>        <span class="hljs-type">Phone</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br><br>        <span class="hljs-comment">//使用成员变量</span><br>        System.out.println(p.brand);<br>        System.out.println(p.price);<br><br>        p.brand = <span class="hljs-string">&quot;小米&quot;</span>;<br>        p.price = <span class="hljs-number">2999</span>;<br><br>        System.out.println(p.brand);<br>        System.out.println(p.price);<br><br>        <span class="hljs-comment">//使用成员方法</span><br>        p.call();<br>        p.sendMessage();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="对象内存图">2. 对象内存图</h2><h3 id="单个对象内存图">2.1 单个对象内存图</h3><p>1.加载class文件 2.申明局部变量 3.在堆内存中开辟一个空间 4.默认初始化 5.显示初始化 6.构造方法初始化 7.将堆内存中的地址值赋值给左边的局部变量</p><ul><li>成员变量使用过程</li></ul><p><img src="/img/08-Java面向对象/a988fe806c874853b9932cd82f4f0ace.png" /></p><ul><li>成员方法调用过程</li></ul><p><img src="/img/08-Java面向对象/9452a4e92a064994a789cf8933907fee.png" /></p><h3 id="多个对象内存图">2.2 多个对象内存图</h3><ul><li>成员变量使用过程</li></ul><p><img src="/img/08-Java面向对象/3fc24a8afebb4205b22c3ab626fac3e1.png" /></p><ul><li>成员方法调用过程</li></ul><p><img src="/img/08-Java面向对象/42357759542a4e1e928a5e259b3bbec0.png" /></p><ul><li><p>总结：</p><p>多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份</p></li></ul><h2 id="成员变量和局部变量">3. 成员变量和局部变量</h2><h3 id="成员变量和局部变量的区别">3.1 成员变量和局部变量的区别</h3><table><thead><tr class="header"><th>区别</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr class="odd"><td>类中位置不同</td><td>类中方法外</td><td>方法内部或方法声明上</td></tr><tr class="even"><td>初始化值不同</td><td>有默认初始化值</td><td>没有默认初始化值，必须先定义，赋值才能使用</td></tr><tr class="odd"><td>内存中位置不同</td><td>堆内存</td><td>栈内存</td></tr><tr class="even"><td>生命周期不同</td><td>随着对象的存在而存在，随着对象的消失而消失</td><td>随着方法的调用而存在，醉着方法的调用完毕而消失</td></tr><tr class="odd"><td>作用域</td><td>整个类中有效</td><td>当前方法中有效</td></tr></tbody></table><h2 id="封装">4. 封装</h2><p>黑马程序员Java P83</p><h3 id="封装思想">4.1 封装思想</h3><ol type="1"><li><p>封装概述 是面向对象三大特征之一（封装，继承，多态） 有选择的暴露</p><p><strong>对象代表什么，就得封装对应的数据，并提供数据对应的行为</strong> （java bean类）</p></li><li><p>封装代码实现 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 成员变量private，提供对应的getXxx()/setXxx()方法</p></li></ol><h3 id="private关键字">4.2 private关键字</h3><p>private是一个权限修饰符，可以用来修饰成员（成员变量，成员方法）</p><ul><li><p>被private修饰的成员，只能在本类进行访问，不能在其他类直接调用(如测试类). 如果需要被其他类使用，提供相应的操作:</p><ul><li>提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰</li><li>提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰</li></ul></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    学生类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//成员变量</span><br>    String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//提供get/set方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>        <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">0</span> || a&gt;<span class="hljs-number">120</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;你给的年龄有误&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            age = a;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-comment">//成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;,&quot;</span> + age);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    学生测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-comment">//给成员变量赋值</span><br>        s.name = <span class="hljs-string">&quot;林青霞&quot;</span>;<br>        s.setAge(<span class="hljs-number">30</span>);<br>        <span class="hljs-comment">//调用show方法</span><br>        s.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="this关键字">4.3 this关键字</h3><ul><li>==this==修饰的变量用于==指代成员变量==，其主要作用是（区分局部变量和成员变量的重名问题）<ul><li>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量</li><li>方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量</li><li>不写this的话就是就近原则</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;,&quot;</span> + age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>this的内存原理 黑马P89 this的本质:所在方法调用者的地址值</li></ul><h2 id="构造方法">5. 构造方法</h2><h3 id="构造方法概述">5.1 构造方法概述</h3><p>构造方法是一种特殊的方法,也叫作构造器、构造函数。</p><ul><li><p>作用： 创造对象的时候，由虚拟机自动调用构造方法，给成员变量进行初始化(即赋值)的。完成对象数据的初始化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();  <span class="hljs-comment">//空参的构造方法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">new为创建对象</span><br><span class="hljs-comment">空参构造先把对象创建出来,Student为自己创建的方法</span><br><span class="hljs-comment">后续在用   </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p></li><li><p>种类 无参数构造方法：初始化的对象时，成员变量的数据均采用默认值。 有参数构造方法：在初始化对象的时候，同时可以为对象进行赋值。</p></li><li><p>格式：</p><p>public class 类名{ 修饰符 类名( 参数 ) { 方法体; } }</p></li><li><p>示例代码：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;无参构造方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;,&quot;</span> + age);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<span class="hljs-comment">// 无参构造方法</span><br>        s.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造方法的注意事项">5.2 构造方法的注意事项</h3><ul><li><p>构造方法的定义 如果没有定义构造方法，系统将给出一个默认的无参数构造方法 如果定义了构造方法，系统将不再提供默认的构造方法 如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法</p></li><li><p>构造方法的重载 带参构造方法和无参数构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载</p></li><li><p>推荐的使用方式 无论是否使用，==都写==无参和带全部参数的构造方法</p></li><li><p>重要功能！</p></li></ul><p>可以使用带参构造，为成员变量进行初始化</p><ul><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    学生类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;,&quot;</span> + age);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s1.show();<br><br>        <span class="hljs-comment">//public Student(String name)</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;林青霞&quot;</span>);<br>        s2.show();<br><br>        <span class="hljs-comment">//public Student(int age)</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">30</span>);<br>        s3.show();<br><br>        <span class="hljs-comment">//public Student(String name,int age)</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;林青霞&quot;</span>,<span class="hljs-number">30</span>);<br>        s4.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="标准javabean类制作">5.3 标准JavaBean类制作</h3><p>① 类名需要见名知意</p><p>② 成员变量使用private修饰</p><p>③ 提供至少两个构造方法</p><ul><li>无参构造方法</li><li>带全部参数的构造方法</li></ul><p>④ 成员方法</p><ul><li>提供每一个成员变量对应的setXxx()/getXxx()</li><li>如果还有其他行为，也需要写上</li></ul><h3 id="例1">5.4 例1</h3><p>需求：</p><pre><code class="hljs">定义标准学生类，要求分别使用空参和有参构造方法创建对象，空参创建的对象通过setXxx赋值，有参创建的对象直接赋值，并通过show方法展示数据。 </code></pre><ul><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//成员变量</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">//成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;,&quot;</span> + age);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建对象并为其成员变量赋值的两种方式</span><br><span class="hljs-comment">        1:无参构造方法创建对象后使用setXxx()赋值</span><br><span class="hljs-comment">        2:使用带参构造方法直接创建带有属性值的对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//无参构造方法创建对象后使用setXxx()赋值</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s1.setName(<span class="hljs-string">&quot;林青霞&quot;</span>);<br>        s1.setAge(<span class="hljs-number">30</span>);<br>        s1.show();<br><br>        <span class="hljs-comment">//使用带参构造方法直接创建带有属性值的对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;林青霞&quot;</span>,<span class="hljs-number">30</span>);<br>        s2.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例2">5.4 例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-comment">//1.私有化全部的成员变量</span><br>    <span class="hljs-comment">//2.空参构造</span><br>    <span class="hljs-comment">//3.带全部参数的构造</span><br>    <span class="hljs-comment">//4.针对于每一个私有化的成员变量都要提供其对应的get和set方法</span><br>    <span class="hljs-comment">//5.如果当前事物还有其他行为，那么也要写出来，比如学生的吃饭，睡觉等行为</span><br><br>    <span class="hljs-keyword">private</span> String username;<span class="hljs-comment">//用户名</span><br>    <span class="hljs-keyword">private</span> String password;<span class="hljs-comment">//密码</span><br>    <span class="hljs-keyword">private</span> String email;<span class="hljs-comment">//邮箱</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> gender;<span class="hljs-comment">//性别</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄</span><br><br>    <span class="hljs-comment">//空参构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">//带全部参数的构造</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String username, String password, String email, <span class="hljs-type">char</span> gender, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.password = password;<br>        <span class="hljs-built_in">this</span>.email = email;<br>        <span class="hljs-built_in">this</span>.gender = gender;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">//get和set</span><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;<br>        <span class="hljs-built_in">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPassword</span><span class="hljs-params">(String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getEmail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> email;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEmail</span><span class="hljs-params">(String email)</span> &#123;<br>        <span class="hljs-built_in">this</span>.email = email;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getGender</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> gender;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGender</span><span class="hljs-params">(<span class="hljs-type">char</span> gender)</span> &#123;<br>        <span class="hljs-built_in">this</span>.gender = gender;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(username + <span class="hljs-string">&quot;在吃饭&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//写一个标准的javabean类</span><br>        <span class="hljs-comment">//咱们在课后只要能把这个标准的javabean能自己写出来，那么就表示今天的知识点就ok了</span><br><br><br>        <span class="hljs-comment">//利用空参构造创建对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-comment">//如果利用空参创建对象，还想赋值只能用set方法赋值</span><br>        u1.setUsername(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        u1.setPassword(<span class="hljs-string">&quot;1234qwer&quot;</span>);<br>        u1.setEmail(<span class="hljs-string">&quot;zjl256904767@outlook.com&quot;</span>);<br>        u1.setGender(<span class="hljs-string">&#x27;男&#x27;</span>);<br>        u1.setAge(<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//获取属性的值并打印</span><br>        System.out.println(u1.getUsername() + <span class="hljs-string">&quot;, &quot;</span> + u1.getPassword()<br>                + <span class="hljs-string">&quot;, &quot;</span> + u1.getEmail() + <span class="hljs-string">&quot;, &quot;</span> + u1.getGender() + <span class="hljs-string">&quot;, &quot;</span> + u1.getAge());<br>        u1.eat();<br><br>        System.out.println(<span class="hljs-string">&quot;=============================&quot;</span>);<br><br>        <span class="hljs-comment">//简单的办法</span><br>        <span class="hljs-comment">//利用带全部参数的构造来创建对象</span><br>        <span class="hljs-comment">//快捷键:ctrl + p</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;12345678&quot;</span>,<span class="hljs-string">&quot;lisi@outlook.com&quot;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-number">24</span>);<br>        System.out.println(u2.getUsername() + <span class="hljs-string">&quot;, &quot;</span> + u2.getPassword()<br>                + <span class="hljs-string">&quot;, &quot;</span> + u2.getEmail() + <span class="hljs-string">&quot;, &quot;</span> + u2.getGender() + <span class="hljs-string">&quot;, &quot;</span> + u2.getAge());<br>        u2.eat();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="基本数据类型与引用数据类型">6.基本数据类型与引用数据类型</h2><p>从内存的角度去解释： 基本数据类型：数据值是存储在自己的空间中 引用数据类型：数据值是存储在其他空间中， 自己空间中存储的是地址值。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java07-方法</title>
    <link href="/2023/06/29/Java07-%E6%96%B9%E6%B3%95/"/>
    <url>/2023/06/29/Java07-%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="方法概述">1. 方法概述</h2><h3 id="方法的概念">1.1 方法的概念</h3><p>方法（method）是程序中最小的执行单元</p><p>注意： * 方法必须先创建才可以使用，该过程即为方法定义（把一些代码打包在一起） * 方法定义后并不是直接运行，需要手动使用才执行，该过程即为方法调用</p><h2 id="方法的定义和调用">2. 方法的定义和调用</h2><h3 id="无参数方法定义和调用">2.1 无参数方法定义和调用</h3><ul><li><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> 方法名 (  ) &#123;<br><span class="hljs-comment">// 方法体;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">方法名();<br></code></pre></td></tr></table></figure></li><li><p>注意： 方法必须先定义，后调用，否则程序将报错 方法定义要写在main方法外面，类的里面</p></li></ul><h3 id="有参数方法定义和调用">2.2 有参数方法定义和调用</h3><ul><li><p>定义格式： 参数：数据类型 变量名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> 方法名 (参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span>, 参数<span class="hljs-number">3.</span>..) &#123;<br>方法体;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">方法名(参数)；<br><br>方法名(参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>)；<br></code></pre></td></tr></table></figure></li></ul><p>注意： - 方法定义时，参数中的数据类型与变量名都不能缺少 - 方法定义时，多个参数之间使用逗号( ，)分隔 * 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配</p><h3 id="形参和实参">2.3 形参和实参</h3><ol type="1"><li>形参：方法定义中的参数</li></ol><p>等同于变量定义格式，例如：int number</p><ol start="2" type="1"><li>实参：方法调用中的参数</li></ol><p>等同于使用变量或常量，例如： 10 number</p><h3 id="带返回值方法定义和调用">2.4 带返回值方法定义和调用</h3><ul><li><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 返回值类型 方法名 ( 参数 ) &#123; <br>  方法体<br>   <span class="hljs-keyword">return</span> 返回值 ;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接调用</span><br>方法名 ( 实参 ) ;<br><br><span class="hljs-comment">//赋值调用</span><br>数据类型 变量名 = 方法名 ( 实参 ) ;<br><br><span class="hljs-comment">//输出调用</span><br>sout(方法名 ( 实参 ))<br></code></pre></td></tr></table></figure></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">isEvenNumber ( <span class="hljs-number">5</span> ) ;<br><span class="hljs-type">boolean</span>  <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span>  isEvenNumber ( <span class="hljs-number">5</span> ); <br></code></pre></td></tr></table></figure></li></ul><p>注意： - 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错 - 方法的返回值通常会使用变量接收，否则该返回值将无意义</p><h3 id="方法定义的小技巧">2.5==方法定义的小技巧==</h3><ol start="0" type="1"><li>需要==重复==用到的模块定义为方法</li><li>我要干什么？ （方法体）</li><li>我干这件事情需要什么才能完成？ （形参）</li><li>方法的调用处是否需要继续使用方法的结果 （返回值） ## 3. 方法的注意事项</li></ol><h3 id="方法的注意事项">3.1 方法的注意事项</h3><ul><li><p>方法不能嵌套定义</p><p>示例代码：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodOne</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodTwo</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// 这里会引发编译错误!!!</span><br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据</p><p>示例代码：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodTwo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//return 100; 编译错误，因为没有具体返回值类型</span><br>        <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//System.out.println(100); return语句后面不能跟数据或代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>return语句下面，不能编写代码，因为永远执行不到，属于无效的代码 方法没有返回值：可以省路不写。如果书写，表示结束方法 方法有返回值：必须要写。表示结束方法和返回结果</p></li></ul><h3 id="方法的通用格式">3.2 方法的通用格式</h3><ul><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 返回值类型 方法名(参数) &#123;<br>   方法体; <br>   <span class="hljs-keyword">return</span> 数据 ;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>解释：</p></li></ul><p>public static 修饰符，目前先记住这个格式</p><p>返回值类型 方法操作完毕之后返回的数据的数据类型</p><p>如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return</p><p>方法名 调用方法时候使用的标识</p><p>参数 由数据类型和变量名组成，多个参数之间用逗号隔开</p><p>方法体 完成功能的代码块</p><p>return 如果方法操作完毕，有数据返回，用于把数据返回给调用者</p><ul><li><p>定义方法时，要做到两个明确</p><ul><li>明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型</li><li>明确参数：主要是明确参数的类型和数量</li></ul></li><li><p>调用方法时的注意：</p><ul><li>void类型的方法，直接调用即可</li><li>非void类型的方法，推荐用变量接收调用</li></ul></li></ul><h2 id="方法重载">4. 方法重载</h2><h3 id="方法重载-1">4.1 方法重载</h3><ul><li><p>方法重载概念</p><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载</p><ul><li>多个方法在==同一类中==</li><li>多个方法具有==相同的方法名==</li><li>多个方法的==参数不相同==，类型不同、数量不同 或 顺序不同(不建议)</li></ul></li><li><p>简单记：同一个类中，方法名相同，参数（形参）不同的方法。 与返回值无关。只有三个条件，不看其他条件。</p></li></ul><p><strong>注意：</strong> * 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式 * 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载</p><ul><li><p>正确范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>    <span class="hljs-comment">//方法体</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span> &#123;<br>    <span class="hljs-comment">//方法体</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>    <span class="hljs-comment">//方法体</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-comment">//方法体</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>错误范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>    <span class="hljs-comment">//方法体</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123; <span class="hljs-comment">/*错误原因：重载与返回值无关*/</span><br>    <span class="hljs-comment">//方法体</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>        <span class="hljs-comment">//方法体</span><br>    &#125;<br>&#125; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span> &#123; <span class="hljs-comment">/*错误原因：这是两个类的两个fn方法*/</span><br>        <span class="hljs-comment">//方法体</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="方法重载练习">6.2 方法重载练习</h3><ul><li><p>需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long）</p></li><li><p>思路：</p><ul><li>①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数</li><li>②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数</li><li>③定义所有的重载方法，两个byte类型与两个short类型参数</li><li>④完成方法的调用，测试运行结果</li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//调用方法</span><br>        System.out.println(compare(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>        System.out.println(compare((<span class="hljs-type">byte</span>) <span class="hljs-number">10</span>, (<span class="hljs-type">byte</span>) <span class="hljs-number">20</span>));<br>        System.out.println(compare((<span class="hljs-type">short</span>) <span class="hljs-number">10</span>, (<span class="hljs-type">short</span>) <span class="hljs-number">20</span>));<br>        System.out.println(compare(<span class="hljs-number">10L</span>, <span class="hljs-number">20L</span>));<br>    &#125;<br><br>    <span class="hljs-comment">//int</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;int&quot;</span>);<br>        <span class="hljs-keyword">return</span> a == b;<br>    &#125;<br><br>    <span class="hljs-comment">//byte</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">byte</span> a, <span class="hljs-type">byte</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;byte&quot;</span>);<br>        <span class="hljs-keyword">return</span> a == b;<br>    &#125;<br><br>    <span class="hljs-comment">//short</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">short</span> a, <span class="hljs-type">short</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;short&quot;</span>);<br>        <span class="hljs-keyword">return</span> a == b;<br>    &#125;<br><br>    <span class="hljs-comment">//long</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;long&quot;</span>);<br>        <span class="hljs-keyword">return</span> a == b;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="数组遍历">7.3 数组遍历</h3><ul><li><p>需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55]</p></li><li><p>思路：</p><ul><li><p>①因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”);</p><p>System.out.println(“内容”); 输出内容并换行</p><p>System.out.print(“内容”); 输出内容不换行</p><p>System.out.println(); 起到换行的作用</p></li><li><p>②定义一个数组，用静态初始化完成数组元素初始化</p></li><li><p>③定义一个方法，用数组遍历通用格式对数组进行遍历</p></li><li><p>④用新的输出语句修改遍历操作</p></li><li><p>⑤调用遍历方法</p></li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">/*  //先打印数据，再进行换行</span><br><span class="hljs-comment">        System.out.println(&quot;aaa&quot;);</span><br><span class="hljs-comment">        //只打印不换行</span><br><span class="hljs-comment">        System.out.print(&quot;bbb&quot;);</span><br><span class="hljs-comment">        System.out.print(&quot;ddd&quot;);</span><br><span class="hljs-comment">        //不打印任何内容，只换行</span><br><span class="hljs-comment">        System.out.println();</span><br><span class="hljs-comment">        System.out.print(&quot;cc&quot;);*/</span><br>        <span class="hljs-comment">//设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55]</span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        printArr(arr);<br>    &#125;<br>    <span class="hljs-comment">//1.我要遍历数组</span><br>    <span class="hljs-comment">//2.需要什么？  数组</span><br>    <span class="hljs-comment">//3.调用处是否需要使用方法的结果。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArr</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;[&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i == arr.length - <span class="hljs-number">1</span>)&#123;<br>                System.out.println(arr[i] + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                System.out.print(arr[i] + <span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="数组最大值">7.4 数组最大值</h3><ul><li><p>需求：设计一个方法用于获取数组中元素的最大值</p></li><li><p>思路：</p><ul><li>①定义一个数组，用静态初始化完成数组元素初始化</li><li>②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了</li><li>③调用获取最大值方法，用变量接收返回结果</li><li>④把结果输出在控制台</li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodTest02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//定义一个数组，用静态初始化完成数组元素初始化</span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">45</span>, <span class="hljs-number">98</span>, <span class="hljs-number">73</span>, <span class="hljs-number">60</span>&#125;;<br><br>        <span class="hljs-comment">//调用获取最大值方法，用变量接收返回结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> getMax(arr);<br><br>        <span class="hljs-comment">//把结果输出在控制台</span><br>        System.out.println(<span class="hljs-string">&quot;number:&quot;</span> + number);<br>    &#125;<br><br>    <span class="hljs-comment">//定义一个方法，用来获取数组中的最大值</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        两个明确：</span><br><span class="hljs-comment">            返回值类型：int</span><br><span class="hljs-comment">            参数：int[] arr</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>; x&lt;arr.length; x++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[x] &gt; max) &#123;<br>                max = arr[x];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="获取索引">7.6 获取索引</h3><p>需求：</p><pre><code class="hljs">定义一个方法获取数字，在数组中的索引位置，将结果返回给调用处，如果有重复的，只要获取第一个即可。</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.demo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//定义一个方法获取数字，在数组中的索引位置，将结果返回给调用处</span><br>        <span class="hljs-comment">//如果有重复的，只要获取第一个即可</span><br><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> contains(arr, <span class="hljs-number">3</span>);<br>        System.out.println(index);<br>    &#125;<br><br>    <span class="hljs-comment">//1. 我要干嘛？判断数组中的某一个数是否存在</span><br>    <span class="hljs-comment">//2. 需要什么？数组 数字</span><br>    <span class="hljs-comment">//3. 调用处是否需要继续使用？返回</span><br>    <span class="hljs-comment">//获取number在arr中的位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-comment">//遍历arr得到每一个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">//拿着每一个元素跟number比较</span><br>            <span class="hljs-keyword">if</span>(arr[i] == number)&#123;<br>                <span class="hljs-comment">//如果相等，表示找到了</span><br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//当循环结束之后，如果还不能返回索引，表示数组中不存在该数据</span><br>        <span class="hljs-comment">//可以返回-1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java06-数组</title>
    <link href="/2023/06/29/Java06-%E6%95%B0%E7%BB%84/"/>
    <url>/2023/06/29/Java06-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数组">1.数组</h1><h3 id="概念">概念：</h3><p>指的是一种容器，可以同来存储==同种数据类型==的多个值。</p><p>但是数组容器在存储数据的时候，需要结合隐式转换考虑。</p><p><strong>建议：</strong> 容器的类，和存储的数据类型保持一致。</p><h1 id="数组的定义">2.数组的定义</h1><h3 id="格式一">格式一：</h3><p>(常用) 数据类型 [ ] 数组名</p><p>比如：<code>int [ ] array</code></p><h3 id="格式二">格式二：</h3><p>数据类型 数组名 []</p><p>比如：<code>int array []</code></p><h1 id="数组的静态初始化">3.数组的静态初始化</h1><h3 id="完整格式">完整格式：</h3><p>数据类型 [] 数组名 = new 数据类型[]{元素1，元素2，元素3，元素4...};</p><p>比如：<code>int[] arr = new int[]&#123;11,22,33&#125;;</code></p><h3 id="简化格式">简化格式 :</h3><p>数据类型[] 数组名 = {元素1，元素2，元素3，元素4...};</p><p>比如：<code>int[] array = &#123;1,2,3,4,5&#125;;</code></p><h3 id="注意点">注意点：</h3><ul><li>等号前后的数据类型必须保持一致。</li><li>数组一旦创建之后，长度不能发生变化。</li></ul><h1 id="地址值">4.地址值</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>System.out.println(arr);<span class="hljs-comment">//[I@6d03e736</span><br><br><span class="hljs-type">double</span>[] arr2 = &#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>&#125;;<br>System.out.println(arr2);<span class="hljs-comment">//[D@568db2f2</span><br></code></pre></td></tr></table></figure><p>打印数组的时候，实际出现的是数组的==地址值==。</p><p>数组的地址值：就表示数组在内存中的位置。</p><p>以<code>[I@6d03e736</code>为例：</p><p><code>[</code>：表示现在打印的是一个数组。</p><p>I：表示现在打印的数组是int类型的。</p><p>@：仅仅是一个间隔符号而已。</p><p>6d03e736：就是数组在内存中真正的地址值。（十六进制的）</p><p>习惯性把<code>[I@6d03e736</code> 这个整体称之为数组的地址值。</p><h1 id="数组元素访问">5.数组元素访问</h1><h3 id="格式">格式：</h3><p>数组名[索引];</p><h3 id="作用">作用：</h3><ul><li><p>获取数组中对应索引上的值</p></li><li><p>修改数组中对应索引上的值</p><p>一旦修改之后，原来的值就会被覆盖了。</p></li></ul><p><strong>例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <br>       <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>       <span class="hljs-comment">//需求1：获取arr数组中，3索引上的值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">3</span>];<br>        System.out.println(number);<br>        System.out.println(arr[<span class="hljs-number">3</span>]);<br><br>       <span class="hljs-comment">//需求2：将arr数组中，3索引上的值修改为10</span><br>            arr[<span class="hljs-number">3</span>] = <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;修改之后为:&quot;</span> + arr[<span class="hljs-number">3</span>]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的遍历">6.数组的遍历</h1><p>遍历：把数组里面所有的内容一个一个全部取出来。</p><p>数组的长度：数组名.length;</p><p>通用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>    <span class="hljs-comment">//在循环的过程中，i依次表示数组中的每一个索引</span><br>    sout(arr[i]);<span class="hljs-comment">//就可以把数组里面的每一个元素都获取出来，并打印在控制台上了。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>附：</strong> idea快速遍历数组 数组名.fori</p><h1 id="数组的动态初始化">7.数组的动态初始化</h1><p>只指定长度，无初始值</p><h3 id="格式-1">格式：</h3><p>数据类型[] 数组名 = new 数据类型[数组的长度];</p><h3 id="例">例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个数组，存3个人的年龄，年龄未知</span><br><span class="hljs-type">int</span>[] agesArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h3 id="数组的默认初始化值">数组的默认初始化值：</h3><p>整数类型：0</p><p>小数类型：0.0</p><p>布尔类型：false</p><p>字符类型：'000'</p><p>引用类型：null</p><h1 id="数组两种初始化方式的区别">8.数组两种初始化方式的区别</h1><p>静态初始化：<code>int[] arr = &#123;1,2,3,4,5&#125;;</code></p><p>动态初始化：<code>int[] arr = new int[5];</code></p><p>静态初始化：手动指定数组的元素，系统会根据元素的个数，计算出数组的长度。</p><p>动态初始化：手动指定数组长度，由系统给出默认初始化值。</p><h3 id="使用场景">使用场景：</h3><p>只明确元素个数，但是不明确具体的数据，推荐使用动态初始化。</p><p>已经明确了要操作的所有数据，推荐使用静态初始化。</p><h3 id="举例">举例：</h3><ul><li><p>使用数组来存储键盘录入的5个整数。</p><p><code>int[] arr = new int[5];</code></p></li><li><p>将全班的学生成绩存入数组中，已知学生成绩为：66,77,88,99,100</p><p><code>int[] arr = &#123;66,77,88,99,100&#125;;</code></p></li></ul><h1 id="二维数组">9.二维数组</h1><h2 id="静态初始化">静态初始化</h2><h3 id="格式-2">格式：</h3><p><code>数据类型[][] 数组名=new 据类型[][] &#123;&#123;元素1，元素2&#125;,&#123;元素1，元素2&#125;&#125;</code> 比如：<code>int[][] array = new int[][]&#123;&#123;11,22&#125;,&#123;33,44&#125;&#125;</code></p><h3 id="简化格式-1">简化格式：</h3><p><code>数据类型[][] 数组名=&#123;&#123;元素1，元素2&#125;,&#123;元素1，元素2&#125;&#125;</code></p><h2 id="获取元素">获取元素</h2><h3 id="格式-3">格式</h3><p><code>arr[i][j]</code></p><h2 id="二维数组的遍历">二维数组的遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">arr.fori<br>  arr[i].fori<br>    <span class="hljs-title function_">sout</span><span class="hljs-params">(arr[i][j])</span><br></code></pre></td></tr></table></figure><h2 id="动态初始化">动态初始化</h2><h3 id="格式-4">格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">`数据类型[][] 数组名=<span class="hljs-keyword">new</span> 数据类型[m][n]`<br><span class="hljs-comment">// m表示这个二维数组，可以存放多少个一维数组 </span><br><span class="hljs-comment">//n表示每一个一维数组，可以存放多少个元素</span><br></code></pre></td></tr></table></figure><h2 id="二维数组地址值">二维数组地址值</h2><p><img src="/img/06-Java数组/85e10cf54f6a41e695ad103f5defcdd3.png" /> <img src="/img/06-Java数组/9d5945949af649db9f30f4101b5b2b38.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java05-高级循环(forr while)</title>
    <link href="/2023/06/29/Java05-%E9%AB%98%E7%BA%A7%E5%BE%AA%E7%8E%AF-for-while/"/>
    <url>/2023/06/29/Java05-%E9%AB%98%E7%BA%A7%E5%BE%AA%E7%8E%AF-for-while/</url>
    
    <content type="html"><![CDATA[<h2 id="无限循环">1.无限循环</h2><h3 id="概念">概念：</h3><pre><code class="hljs">又叫死循环。循环一直停不下来。</code></pre><h3 id="for格式">for格式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(;;)&#123;<br>    System.out.println(<span class="hljs-string">&quot;循环执行一直在打印内容&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><p>初始化语句可以空着不写，表示循环之前不定义任何的控制变量。</p><p>条件判断语句可以空着不写，如果不写，默认表示true，循环一直进行。</p><p>条件控制语句可以空着不写，表示每次循环体执行完毕后，控制变量不做任何变化。</p><h3 id="while格式">while格式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;循环执行一直在打印内容&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><pre><code class="hljs">小括号里面就不能省略了，true一定要写出来，否则代码会报错。</code></pre><h3 id="do...while格式">do...while格式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;循环执行一直在打印内容&quot;</span>);<br>&#125;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>解释：</p><pre><code class="hljs">小括号里面就不能省略了，true一定要写出来，否则代码会报错。</code></pre><h3 id="无限循环的注意事项">无限循环的注意事项：</h3><ul><li>最为常用的格式：while</li><li>无限循环下面不能再写其他代码了，因为永远执行不到。</li></ul><h2 id="条件控制语句">2.条件控制语句</h2><ul><li>break</li><li>continue</li></ul><h3 id="break">break:</h3><pre><code class="hljs">不能单独存在的。可以用在switch和循环中，表示结束，跳出的意思。</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.吃1~5号包子</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    System.out.println(<span class="hljs-string">&quot;在吃第&quot;</span> + i + <span class="hljs-string">&quot;个包子&quot;</span>);<br>    <span class="hljs-comment">//2.吃完第三个的时候就不吃了</span><br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-keyword">break</span>;<span class="hljs-comment">//结束整个循环。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="continue">continue:</h3><pre><code class="hljs">不能单独存在的。只能存在于循环当中。表示：跳过本次循环，继续执行下次循环。</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.吃1~5号包子</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-comment">//2.第3个包子有虫子就跳过，继续吃下面的包子</span><br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-comment">//跳过本次循环（本次循环中，下面的代码就不执行了），继续执行下次循环。</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;在吃第&quot;</span> + i + <span class="hljs-string">&quot;个包子&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="random">3. Random</h2><p>Random跟Scanner一样，也是Java提前写好的类，我们不需要关心是如何实现的，只要直接使用就可以了。</p><h3 id="使用步骤">使用步骤：</h3><ol type="1"><li>导包</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-comment">// 导包的动作必须出现在类定义的上边。</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>创建对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span> ();<br><span class="hljs-comment">// 上面这个格式里面，只有r是变量名，可以变，其他的都不允许变。</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>生成随机数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> r.nextInt(随机数的范围);<br><span class="hljs-comment">// 上面这个格式里面，只有number是变量名，可以变，其他的都不允许变。</span><br><span class="hljs-comment">// 随机数范围的特点：从0开始，不包含指定值。比如：参数为10，生成的范围[0,10)</span><br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.导包</span><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//2.创建对象</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-comment">//3.生成随机数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">100</span>);<span class="hljs-comment">//包左不包右，包头不包尾</span><br>        <span class="hljs-comment">//0 ~ 99</span><br>        System.out.println(number);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="逢七过">4. 逢七过</h2><p>需求：</p><pre><code class="hljs">朋友聚会的时候可能会玩一个游戏：逢7过 游戏规则：从任意一个数字开始报数，当你要报的数字是包含7或者是7的倍数时都要说过：过使用程序在控制台打印出1-100之间的满足逢七必过规则的数据 </code></pre><p>举例：</p><pre><code class="hljs">1 2 3 4 5 6 过 8 9 10 11 12 13 过 15 16 过 18 ...</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*朋友聚会的时候可能会玩一个游戏：逢7过</span><br><span class="hljs-comment">        游戏规则：从任意一个数字开始报数，当你要报的数字是包含7或者是7的倍数时都要说过：过</span><br><span class="hljs-comment">        需求：使用程序在控制台打印出1-100之间的满足逢七必过规则的数据*/</span><br><span class="hljs-comment">//分析：</span><br><span class="hljs-comment">//个位7  十位7   7倍数</span><br><span class="hljs-comment">//1 2 3 4 5 6 过 8 9 10 11 12 13 过 15 16 过 18 19 20 过....</span><br><span class="hljs-comment">//69 过 过 过 过 过 过... 80</span><br><span class="hljs-comment">//1.得到1~100之间的每一个数字</span><br><span class="hljs-comment">//开始：1</span><br><span class="hljs-comment">//结束：100</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>    <span class="hljs-comment">//2.判断每一个数字，如果符合规则，就打印过，如果不符合规则就打印真实的数字</span><br>    <span class="hljs-keyword">if</span>(i % <span class="hljs-number">10</span> == <span class="hljs-number">7</span> || i / <span class="hljs-number">10</span> % <span class="hljs-number">10</span> == <span class="hljs-number">7</span>  ||  i % <span class="hljs-number">7</span> == <span class="hljs-number">0</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;过&quot;</span>);<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="平方根">5. 平方根</h2><p>需求：</p><pre><code class="hljs">键盘录入一个大于等于2的整数 x ，计算并返回 x 的 平方根 。结果只保留整数部分 ，小数部分将被舍去 。</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*需求：键盘录入一个大于等于2的整数 x ，计算并返回 x 的 平方根 。</span><br><span class="hljs-comment">        结果只保留整数部分 ，小数部分将被舍去 。*/</span><br><br><br><span class="hljs-comment">//分析：</span><br><span class="hljs-comment">//平方根   16的平方根4</span><br><span class="hljs-comment">//         4的平方根2</span><br><br><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// 1 * 1 = 1 &lt; 10</span><br><span class="hljs-comment">// 2 * 2 = 4 &lt; 10</span><br><span class="hljs-comment">// 3 * 3 = 9 &lt; 10</span><br><span class="hljs-comment">// 4 * 4 = 16 &gt; 10</span><br><span class="hljs-comment">//推断：10的平方根是在3~4之间。</span><br><br><br><span class="hljs-comment">// 20</span><br><span class="hljs-comment">// 1 * 1 = 1 &lt; 20</span><br><span class="hljs-comment">// 2 * 2 = 4 &lt; 20</span><br><span class="hljs-comment">// 3 * 3 = 9 &lt; 20</span><br><span class="hljs-comment">// 4 * 4 = 16 &lt; 20</span><br><span class="hljs-comment">// 5 * 5 = 25 &gt; 20</span><br><span class="hljs-comment">//推断：20的平方根是在4~5之间。</span><br><br><br><span class="hljs-comment">//在代码当中</span><br><span class="hljs-comment">//从1开始循环，拿着数字的平方跟原来的数字进行比较</span><br><span class="hljs-comment">//如果小于的，那么继续往后判断</span><br><span class="hljs-comment">//如果相等，那么当前数字就是平方根</span><br><span class="hljs-comment">//如果大于的，那么前一个数字就是平方跟的整数部分</span><br><br><br><span class="hljs-comment">//1.键盘录入一个整数</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入一个整数&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> sc.nextInt();<br><span class="hljs-comment">//2.从1开始循环判断</span><br><span class="hljs-comment">//开始：1 结束: number</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= number; i++) &#123;<br>    <span class="hljs-comment">//用i * i 再跟number进行比较</span><br>    <span class="hljs-keyword">if</span>(i * i == number)&#123;<br>        System.out.println(i + <span class="hljs-string">&quot;就是&quot;</span> + number + <span class="hljs-string">&quot;的平方根&quot;</span>);<br>        <span class="hljs-comment">//一旦找到了，循环就可以停止了，后面的数字就不需要再找了，提高代码的运行效率。</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i * i &gt; number)&#123;<br>        System.out.println((i - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;就是&quot;</span> + number + <span class="hljs-string">&quot;平方根的整数部分&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断是否为质数">6.判断是否为质数</h2><p>需求：</p><pre><code class="hljs">键盘录入一个正整数 x ，判断该整数是否为一个质数。 </code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//需求：键盘录入一个正整数 x ，判断该整数是否为一个质数。</span><br><br><span class="hljs-comment">//质数：</span><br><span class="hljs-comment">//如果一个整数只能被1和本身整除，那么这个数就是质数。否则这个数叫做合数</span><br><span class="hljs-comment">//7 = 1 * 7 质数</span><br><span class="hljs-comment">//8 = 1 * 8  2 * 4 合数</span><br><br><br><span class="hljs-comment">//分析：</span><br><span class="hljs-comment">//1.键盘录入一个正整数</span><br><span class="hljs-comment">//number</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入一个正整数&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> sc.nextInt();<span class="hljs-comment">//9</span><br><br><span class="hljs-comment">//定义一个变量，表示标记</span><br><span class="hljs-comment">//标记着number是否为一个质数</span><br><span class="hljs-comment">//true： 是一个质数</span><br><span class="hljs-comment">//false : 不是一个质数</span><br><br><span class="hljs-comment">//表示最初就认为number是一个质数</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><br><span class="hljs-comment">//2.判断</span><br><span class="hljs-comment">//写一个循环，从2开始判断，一直判断到number-1为止</span><br><span class="hljs-comment">//看这个范围之内，有没有数字可以被number整除</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; number; i++) &#123;<br>    <span class="hljs-comment">//i 依次表示这个范围之内的每一个数字</span><br>    <span class="hljs-comment">//看number是否能被i整除就可以了</span><br>    <span class="hljs-keyword">if</span>(number % i == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 9 % 2 = 1</span><br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//System.out.println(number + &quot;不是一个质数&quot;);</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-comment">/*else&#123;</span><br><span class="hljs-comment">                System.out.println(number + &quot;是一个质数&quot;);</span><br><span class="hljs-comment">            &#125;*/</span><br>&#125;<br><br><span class="hljs-comment">//只有当这个循环结束了，表示这个范围之内所有的数字都判断完毕了</span><br><span class="hljs-comment">//此时才能断定number是一个质数</span><br><span class="hljs-keyword">if</span>(flag)&#123;<br>    System.out.println(number + <span class="hljs-string">&quot;是一个质数&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    System.out.println(number + <span class="hljs-string">&quot;不是一个质数&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="猜数字小游戏">7. 猜数字小游戏</h2><p>需求：</p><pre><code class="hljs">程序自动生成一个1-100之间的随机数，在代码中使用键盘录入去猜出这个数字是多少？</code></pre><p>要求：</p><pre><code class="hljs">使用循环猜，一直猜中为止。</code></pre><p>思路分析：</p><ol type="1"><li>生成一个1-100之间的随机数</li><li>使用键盘录入去猜出这个数字是多少</li><li>把反复猜的代码写在循环中</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.生成一个1-100之间的随机数</span><br><span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">100</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">// 0 ~ 99 + 1 --- 1 ~ 100</span><br>System.out.println(number);<br><br><span class="hljs-comment">//2.使用键盘录入去猜出这个数字是多少？</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;请输入一个整数&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">guessNumber</span> <span class="hljs-operator">=</span> sc.nextInt();<br>    <span class="hljs-comment">//3.比较</span><br>    <span class="hljs-keyword">if</span>(guessNumber &gt; number)&#123;<br>        System.out.println(<span class="hljs-string">&quot;您猜的数字大了&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(guessNumber &lt; number)&#123;<br>        System.out.println(<span class="hljs-string">&quot;您猜的数字小了&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;恭喜你，猜中了&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java04-判断和循环</title>
    <link href="/2023/06/29/Java04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/"/>
    <url>/2023/06/29/Java04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-流程控制语句">第一章 流程控制语句</h2><p>在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。</p><h3 id="流程控制语句分类">1.1 流程控制语句分类</h3><pre><code class="hljs">顺序结构判断和选择结构(if, switch)循环结构(for, while, do…while)</code></pre><h3 id="顺序结构">1.2 顺序结构</h3><p>顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。</p><p>顺序结构执行流程图：</p><p><img src="/img/04-Java判断和循环/7ededb84db2e49cd8c0887a2f4873189.png" /></p><h2 id="第二章-判断语句if语句">第二章 判断语句：if语句</h2><h3 id="if语句格式1">2.1 if语句格式1</h3><p>格式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (关系表达式) &#123;<br>    语句体;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>执行流程：</p><p>①首先计算关系表达式的值</p><p>②如果关系表达式的值为true就执行语句体</p><p>③如果关系表达式的值为false就不执行语句体</p><p>④继续执行后面的语句内容</p><p><img src="/img/04-Java判断和循环/678e041956b54723a24ead3103ac6b28.png" /> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IfDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;开始&quot;</span>);<br><span class="hljs-comment">//定义两个变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-comment">//需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b</span><br><span class="hljs-keyword">if</span>(a == b) &#123;<br>System.out.println(<span class="hljs-string">&quot;a等于b&quot;</span>);<br>&#125;<br><span class="hljs-comment">//需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c</span><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span>(a == c) &#123;<br>System.out.println(<span class="hljs-string">&quot;a等于c&quot;</span>);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if语句格式2">2.2 if语句格式2</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (关系表达式) &#123;<br>    语句体<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    语句体<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式的值</p><p>②如果关系表达式的值为true就执行语句体1</p><p>③如果关系表达式的值为false就执行语句体2</p><p>④继续执行后面的语句内容</p><p><img src="/img/04-Java判断和循环/39c52aa5d50049e48513a724a5aceb87.png" /></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IfDemo02</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;开始&quot;</span>);<br><span class="hljs-comment">//定义两个变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-comment">//需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b</span><br><span class="hljs-keyword">if</span>(a &gt; b) &#123;<br>System.out.println(<span class="hljs-string">&quot;a的值大于b&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;a的值不大于b&quot;</span>);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if语句格式3">2.3 if语句格式3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">格式：<br><span class="hljs-keyword">if</span> (关系表达式<span class="hljs-number">1</span>) &#123;<br>    语句体<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (关系表达式<span class="hljs-number">2</span>) &#123;<br>    语句体<span class="hljs-number">2</span>;<br>&#125; <br>…<br><span class="hljs-keyword">else</span> &#123;<br>    语句体n+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式1的值</p><p>②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值</p><p>③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值</p><p>④…</p><p>⑤如果没有任何关系表达式为true，就执行语句体n+1。</p><p><img src="/img/04-Java判断和循环/273c4ba80bbb4f51a924fb7b81f1d75c.png" /></p><h2 id="第三章-switch语句">第三章 switch语句</h2><h3 id="格式">3.1 格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (表达式) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>语句体<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>语句体<span class="hljs-number">2</span>;<br><span class="hljs-keyword">break</span>;<br>...<br><span class="hljs-keyword">default</span>:<br>语句体n+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="执行流程">3.2 <strong>执行流程：</strong></h3><ul><li>首先计算出表达式的值</li><li>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。</li><li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。</li></ul><h4 id="练习运动计划">练习：运动计划</h4><ul><li><p>需求：键盘录入星期数，显示今天的减肥活动。</p><p>周一：跑步</p><p>周二：游泳</p><p>周三：慢走</p><p>周四：动感单车</p><p>周五：拳击</p><p>周六：爬山</p><p>周日：好好吃一顿</p></li><li><p>代码示例：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwitchDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.键盘录入一个整数表示星期</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入一个整数表示星期&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">week</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-comment">//2.书写一个switch语句去跟week进行匹配</span><br>        <span class="hljs-keyword">switch</span> (week)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                System.out.println(<span class="hljs-string">&quot;跑步&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                System.out.println(<span class="hljs-string">&quot;游泳&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                System.out.println(<span class="hljs-string">&quot;慢走&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                System.out.println(<span class="hljs-string">&quot;动感单车&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                System.out.println(<span class="hljs-string">&quot;拳击&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                System.out.println(<span class="hljs-string">&quot;爬山&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>                System.out.println(<span class="hljs-string">&quot;好好吃一顿&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                System.out.println(<span class="hljs-string">&quot;输入错误，没有这个星期&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="switch的扩展知识">3.3 switch的扩展知识：</h3><ul><li><p>default的位置和省略情况</p><p>default可以放在任意位置，也可以省略</p></li><li><p>case穿透</p><p>不写break会引发case穿透现象</p></li><li><p>switch在JDK12的新特性</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">switch</span> (number) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> -&gt; System.out.println(<span class="hljs-string">&quot;一&quot;</span>);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> -&gt; System.out.println(<span class="hljs-string">&quot;二&quot;</span>);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span> -&gt; System.out.println(<span class="hljs-string">&quot;三&quot;</span>);<br>    <span class="hljs-keyword">default</span> -&gt; System.out.println(<span class="hljs-string">&quot;其他&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>switch和if第三种格式各自的使用场景</li></ul><p>当我们需要对一个范围进行判断的时候，用if的第三种格式</p><p>当我们把有限个数据列举出来，选择其中一个执行的时候，用switch语句</p><p>比如：</p><p>小明的考试成绩，如果用switch，那么需要写100个case，太麻烦了，所以用if简单。</p><p>如果是星期，月份，客服电话中0~9的功能选择就可以用switch</p><h2 id="第四章-循环结构">第四章 循环结构</h2><h3 id="for循环结构掌握">4.1 for循环结构（掌握）</h3><p>循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环。</p><h4 id="for循环格式">4.1.1 for循环格式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (初始化语句;条件判断语句;条件控制语句) &#123;<br>循环体语句;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>格式解释：</strong></p><ul><li>初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样</li><li>条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去</li><li>循环体语句： 用于表示循环反复执行的内容，简单说就是循环反复执行的事情</li><li>条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去</li></ul><p><strong>执行流程：</strong></p><p>①执行初始化语句</p><p>②执行条件判断语句，看其结果是true还是false</p><pre><code class="hljs">         如果是false，循环结束         如果是true，继续执行</code></pre><p>③执行循环体语句</p><p>④执行条件控制语句</p><p>⑤回到②继续</p><p><strong>for循环书写技巧：</strong></p><ul><li>确定循环的开始条件</li><li>确定循环的结束条件</li><li>确定循环要重复执行的代码</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.确定循环的开始条件</span><br><span class="hljs-comment">//2.确定循环的结束条件</span><br><span class="hljs-comment">//3.确定要重复执行的代码</span><br><br><span class="hljs-comment">//需求：打印5次HelloWorld</span><br><span class="hljs-comment">//开始条件：1</span><br><span class="hljs-comment">//结束条件：5</span><br><span class="hljs-comment">//重复代码：打印语句</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="while循环">4.2 while循环</h3><h4 id="格式-1">4.2.1 格式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化语句;<br><span class="hljs-keyword">while</span>(条件判断语句)&#123;<br>循环体;<br>条件控制语句;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="实例打印5次helloworld">实例：打印5次HelloWorld</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i &lt;= <span class="hljs-number">5</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>    i++;<br>&#125;<br>System.out.println(i);<br></code></pre></td></tr></table></figure><h3 id="do...while循环">4.3 do...while循环</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化语句;<br><span class="hljs-keyword">do</span>&#123;<br>    循环体;<br>    条件控制语句;<br>&#125;<span class="hljs-keyword">while</span>(条件判断语句);<br></code></pre></td></tr></table></figure><p>特点：</p><pre><code class="hljs">先执行，再判断。</code></pre><h3 id="三种格式的区别">4.4 三种格式的区别：</h3><pre><code class="hljs">for和while循环，是先判断，再执行。do...while是先执行，再判断。当知道循环次数或者循环范围的时候，用for循环。当不知道循环次数，也不知道循环范围，但是知道循环的结束条件时，用while循环。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java03-运算符</title>
    <link href="/2023/06/29/Java03-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2023/06/29/Java03-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="运算符和表达式">1.运算符和表达式</h1><h3 id="运算符">运算符：</h3><pre><code class="hljs">就是对常量或者变量进行操作的符号。比如： +  -  *  / </code></pre><h3 id="表达式">表达式：</h3><pre><code class="hljs">用运算符把常量或者变量连接起来的，符合Java语法的式子就是表达式。比如：a + b 这个整体就是表达式。而其中+是算术运算符的一种，所以这个表达式也称之为算术表达式。</code></pre><h1 id="算术运算符">2.算术运算符</h1><p>分类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">+ - * / %<br></code></pre></td></tr></table></figure><p>运算特点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">+ - * :跟数学中一样.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">/：<br><span class="hljs-number">1.</span>整数相除结果只能得到整除，如果结果想要是小数，必须要有小数参数。<br><span class="hljs-number">2.</span>小数直接参与运算，得到的结果有可能是不精确的。<br>案例：<br>System.out.println( <span class="hljs-number">10</span> / <span class="hljs-number">3</span>);<span class="hljs-comment">//3</span><br>System.out.println(<span class="hljs-number">10.0</span> / <span class="hljs-number">3</span>);<span class="hljs-comment">//3.3333333333333335</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">%：取模、取余。<br>   做的也是除法运算，只不过获取的是余数而已。<br>案例：<br>System.out.println(<span class="hljs-number">10</span> % <span class="hljs-number">2</span>);<span class="hljs-comment">//0</span><br>System.out.println(<span class="hljs-number">10</span> % <span class="hljs-number">3</span>);<span class="hljs-comment">//1</span><br>应用场景：<br><span class="hljs-comment">//可以利用取模来判断一个数是奇数还是偶数</span><br>System.out.println(<span class="hljs-number">15</span> % <span class="hljs-number">2</span>);<span class="hljs-comment">//1  奇数</span><br></code></pre></td></tr></table></figure><h3 id="练习数值拆分">练习：数值拆分</h3><p>需求：键盘录入一个三位数，将其拆分为个位、十位、百位后，打印在控制台</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.键盘录入一个三位数</span><br><span class="hljs-comment">//导包 --- 创建对象 --- 接收数据</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入一个三位数&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> sc.nextInt();<span class="hljs-comment">//123</span><br><br><span class="hljs-comment">//2.获取这个三位数的个位、十位、百位并打印出来</span><br><span class="hljs-comment">//公式：</span><br><span class="hljs-comment">//针对于任意的一个数而言</span><br><span class="hljs-comment">//个位： 数字 % 10</span><br><span class="hljs-type">int</span> <span class="hljs-variable">ones</span> <span class="hljs-operator">=</span> number % <span class="hljs-number">10</span>;<br><span class="hljs-comment">//十位： 数字 / 10 % 10</span><br><span class="hljs-type">int</span> <span class="hljs-variable">tens</span> <span class="hljs-operator">=</span> number / <span class="hljs-number">10</span> % <span class="hljs-number">10</span>;<br><span class="hljs-comment">//百位： 数字 / 100 % 10</span><br><span class="hljs-type">int</span> <span class="hljs-variable">hundreds</span> <span class="hljs-operator">=</span> number / <span class="hljs-number">100</span>  % <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//输出结果</span><br>System.out.println(ones);<br>System.out.println(tens);<br>System.out.println(hundreds);<br></code></pre></td></tr></table></figure><p>公式：</p><p>获取任意一个数上每一位数。</p><p>个位：数字 % 10</p><p>十位：数字 / 10 % 10</p><p>百位：数字 / 100 % 10</p><p>千位：数字 / 1000 % 10</p><p>以此类推</p><h1 id="隐式转换">3.隐式转换</h1><h3 id="概念">概念：</h3><p>也叫自动类型提升。</p><p>就是把一个取值范围小的数据或者变量，赋值给另一个取值范围大的变量。此时不需要我们额外写代码单独实现，是程序自动帮我们完成的。</p><p>简单记忆：就是小的给大的，可以直接给。</p><h3 id="两种提升规则">两种提升规则：</h3><ul><li>取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算。</li><li>byte、short、char三种类型的数据在运算的时候，都会直接先提升为int，然后再进行运算。</li></ul><h3 id="取值范围从小到大的关系">取值范围从小到大的关系：</h3><pre><code class="hljs">byte \&lt;short \&lt;int \&lt;long \&lt;float \&lt;double</code></pre><h1 id="强制转换">4.强制转换</h1><h3 id="概念-1">概念：</h3><p>如果要把一个取值范围大的数据或者变量赋值给另一个取值范围小的变量。是不允许直接操作。如果一定要这么干，就需要加入强制转换。</p><h3 id="书写格式">书写格式：</h3><pre><code class="hljs">目标数据类型 变量名 = （目标数据类型）被强转的数据；</code></pre><p>简单理解：要转成什么类型的，那么就在小括号中写什么类型就可以了。</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatorDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">12.3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) a;<br>        System.out.println(b);<span class="hljs-comment">//12</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意点：</p><pre><code class="hljs">强制转换有可能会导致数据发生错误。（数据的精度丢失）</code></pre><h1 id="字符串的操作">5.字符串的+操作</h1><h3 id="核心技巧">核心技巧：</h3><ul><li>当+操作中出现字符串时，此时就是字符串的连接符，会将前后的数据进行拼接，并产生一个新的字符串。</li><li>当连续进行+操作时，从左到右逐个执行的。</li></ul><h1 id="字符串相加的练习">6.字符串相加的练习：</h1><p>案例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结果："1abc1"</p><p>解释：</p><pre><code class="hljs">第一步： 1 + &quot;abc&quot;。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串&quot;1abc&quot;第二步：  &quot;1abc&quot; + 1。这个过程中，有字符串参与的，所以做的也是拼接操作，产生一个新的字符串&quot;1abc1&quot;</code></pre><p>案例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结果：“3abc21”</p><p>解释：</p><pre><code class="hljs">第一步：1 + 2 。在这个过程中，没有字符串参与的，所以做的是加法运算，结果为3。第二步：3 + &quot;abc&quot;。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串&quot;3abc&quot;。第三步：&quot;3abc&quot; + 2。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串&quot;3abc2&quot;。第四步：&quot;3abc2&quot; + 1。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串“3abc21”</code></pre><h1 id="字符的操作">8.字符的+操作</h1><h3 id="规则">规则：</h3><pre><code class="hljs">当+操作中出现了**字符**，会拿着字符到计算机内置的ASCII码表中去查对应的数字，然后再进行计算。</code></pre><h3 id="案例">案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> c + <span class="hljs-number">0</span>;<br>System.out.println(result);<span class="hljs-comment">//97</span><br></code></pre></td></tr></table></figure><p>ASCII码表中：</p><pre><code class="hljs">&#39;a&#39;   -----    97&#39;A&#39;   -----    65</code></pre><h1 id="算术运算符的总结">9.算术运算符的总结</h1><p>分类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">+ - * / %  这些操作跟小学数学几乎是一模一样的。<br></code></pre></td></tr></table></figure><p>注意点：</p><ul><li>/ 和 % 的区别：他们两个都是做除法运算，/取结果的商。% 取结果的余数。</li><li>整数操作只能得到整数，如果想要得到小数，必须有浮点数参与运算。</li></ul><p>算术运算符的高级用法：</p><p>是以+为例进行的讲解，其余减法，乘法，除法的运算规则也是一样的。</p><p>特例：字符串只有+操作，没有其他操作。</p><h1 id="自增自减运算符">10.自增自减运算符</h1><h3 id="分类">分类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">++  自增运算符<br>--  自减运算符<br></code></pre></td></tr></table></figure><p>++：就是把变量里面的值+1</p><p>--：就是把变量里面的值-1</p><h3 id="使用方式">使用方式：</h3><ul><li>放在变量的前面，我们叫做先++。 比如：++a</li><li>放在变量的后面，我们叫做后++。 比如：a++</li></ul><h3 id="注意点">注意点：</h3><pre><code class="hljs">不管是先++，还是后++。单独写在一行的时候，运算结果是一模一样的。</code></pre><h3 id="案例-1">案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//++</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>a++;<span class="hljs-comment">//就是让变量a里面的值 + 1</span><br>System.out.println(a);<span class="hljs-comment">//11</span><br>++a;<span class="hljs-comment">//就是让变量a里面的值 + 1</span><br>System.out.println(a);<span class="hljs-comment">//12</span><br></code></pre></td></tr></table></figure><h3 id="自增自减运算符的应用场景">自增自减运算符的应用场景：</h3><p>某些情况下，变量需要进行加1或者减1的时候使用。</p><p>比如：过生日多一岁，就用到了自增运算符。</p><p>比如：购物商场中，选择商品数量，也用到了自增或者自减运算符。</p><p>比如：统计很多数据中，有多少个数据满足要求，也用到了自增运算符。</p><h1 id="赋值运算符">11.赋值运算符</h1><p>最为常用的： =</p><p>运算过程：就是把等号右边的结果赋值给左边的变量</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatorDemo6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.最为简单的赋值运算符用法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-comment">//就是把10赋值给变量a</span><br>        System.out.println(a);<br><br>        <span class="hljs-comment">//2.如果等号右边需要进行计算。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<span class="hljs-comment">//先计算等号右边的，把计算的结果赋值给左边的变量</span><br>        System.out.println(c);<br><br>        <span class="hljs-comment">//3.特殊的用法</span><br>        a = a + <span class="hljs-number">10</span>;<span class="hljs-comment">//先计算等号右边的，把计算的结果赋值给左边的变量</span><br>        System.out.println(a);<span class="hljs-comment">//20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="扩展赋值运算符">12.扩展赋值运算符</h1><h3 id="分类-1">分类：</h3><pre><code class="hljs">+=、-=、*=、/=、%=</code></pre><h3 id="运算规则">运算规则：</h3><pre><code class="hljs">就是把左边跟右边进行运算，把最终的结果赋值给左边，对右边没有任何影响。</code></pre><h3 id="案例-2">案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatorDemo7</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//扩展赋值运算符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        a += b;<span class="hljs-comment">//把左边和右边相加，再把最终的结果赋值给左边，对右边没有任何影响</span><br>        <span class="hljs-comment">// 相当于 a = a + b;</span><br>        System.out.println(a);<span class="hljs-comment">//30</span><br>        System.out.println(b);<span class="hljs-comment">//20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意点-1">注意点：</h3><p>扩展的赋值运算符中隐层还包含了一个强制转换。</p><p>以+=为例。</p><p>a += b ;实际上相当于 a = (byte)(a + b);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatorDemo8</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-comment">//a += b;</span><br>        a = (<span class="hljs-type">byte</span>)(a + b);<br>        System.out.println(a);<span class="hljs-comment">//30</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="关系运算符">13.关系运算符</h1><p>又叫比较运算符，其实就是拿着左边跟右边进行了判断而已。</p><h3 id="分类-2">分类：</h3><table><thead><tr class="header"><th>符号</th><th>解释</th></tr></thead><tbody><tr class="odd"><td>==</td><td>就是判断左边跟右边是否相等，如果成立就是true，如果不成立就是false</td></tr><tr class="even"><td>!=</td><td>就是判断左边跟右边是否不相等，如果成立就是true，如果不成立就是false</td></tr><tr class="odd"><td>&gt;</td><td>就是判断左边是否大于右边，如果成立就是true，如果不成立就是false</td></tr><tr class="even"><td>&gt;=</td><td>就是判断左边是否大于等于右边，如果成立就是true，如果不成立就是false</td></tr><tr class="odd"><td>&lt;</td><td>就是判断左边是否小于右边，如果成立就是true，如果不成立就是false</td></tr><tr class="even"><td>&lt;=</td><td>就是判断左边是否小于等于右边，如果成立就是true，如果不成立就是false</td></tr></tbody></table><h3 id="注意点-2">注意点：</h3><ul><li>关系运算符最终的结果一定是布尔类型的。要么是true，要么是false</li><li>在写==的时候，千万不要写成=</li></ul><h1 id="逻辑运算符">14.逻辑运算符</h1><h3 id="和-的使用">&amp; 和 | 的使用：</h3><p>&amp;：逻辑与（而且）</p><pre><code class="hljs">两边都为真，结果才是真，只要有一个为假，那么结果就是假。</code></pre><p>|：逻辑或（或者）</p><pre><code class="hljs">两边都为假，结果才是假，只要有一个为真，那么结果就是真。</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// &amp;  //两边都是真，结果才是真。</span><br>System.out.println(<span class="hljs-literal">true</span> &amp; <span class="hljs-literal">true</span>);<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-literal">false</span> &amp; <span class="hljs-literal">false</span>);<span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-literal">true</span> &amp; <span class="hljs-literal">false</span>);<span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-literal">false</span> &amp; <span class="hljs-literal">true</span>);<span class="hljs-comment">//false</span><br><br>System.out.println(<span class="hljs-string">&quot;===================================&quot;</span>);<br><br><span class="hljs-comment">// | 或  //两边都是假，结果才是假，如果有一个为真，那么结果就是真。</span><br>System.out.println(<span class="hljs-literal">true</span> | <span class="hljs-literal">true</span>);<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-literal">false</span> | <span class="hljs-literal">false</span>);<span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-literal">true</span> | <span class="hljs-literal">false</span>);<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-literal">false</span> | <span class="hljs-literal">true</span>);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>使用技巧：</p><pre><code class="hljs">当两种条件只要满足其中一个的时候，可以使用或</code></pre><h3 id="异或的使用">^（异或）的使用：</h3><pre><code class="hljs">在以后用的不多，了解一下即可。</code></pre><p>计算规则：如果两边相同，结果为false，如果两边不同，结果为true</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//^   //左右不相同，结果才是true，左右相同结果就是false</span><br>System.out.println(<span class="hljs-literal">true</span> ^ <span class="hljs-literal">true</span>);<span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-literal">false</span> ^ <span class="hljs-literal">false</span>);<span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-literal">true</span> ^ <span class="hljs-literal">false</span>);<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-literal">false</span> ^ <span class="hljs-literal">true</span>);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h3 id="取反的使用">!（取反）的使用：</h3><pre><code class="hljs">是取反，也叫做非。</code></pre><p>计算规则：false取反就是true，true取反就是false</p><p>温馨提示：<strong>取反最多只用一个。</strong></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(!<span class="hljs-literal">false</span>);<span class="hljs-comment">//true</span><br>System.out.println(!<span class="hljs-literal">true</span>);<span class="hljs-comment">//false</span><br><br>System.out.println(!!<span class="hljs-literal">false</span>);<span class="hljs-comment">//注意点：取反最多只用一个。</span><br></code></pre></td></tr></table></figure><h1 id="短路逻辑运算符">15.短路逻辑运算符</h1><p>分类： &amp;&amp; ||</p><h3 id="section">&amp;&amp;：</h3><pre><code class="hljs">运算结果跟&amp;是一模一样的，只不过具有短路效果。</code></pre><h3 id="section-1">||：</h3><pre><code class="hljs">运算结果跟|是一模一样的。只不过具有短路效果。</code></pre><h3 id="逻辑核心">逻辑核心：</h3><pre><code class="hljs">当左边不能确定整个表达式的结果，右边才会执行。当左边能确定整个表达式的结果，那么右边就不会执行了。从而提高了代码的运行效率。</code></pre><h3 id="举例">举例：</h3><ul><li><p>用户登录案例</p><p>用户名正确 &amp; 密码正确</p><p>如果使用一个&amp;，不管用户名是否正确都会去验证密码。</p></li></ul><p>思考：</p><pre><code class="hljs">如果用户名输入正确了，那么我们再判断密码是否正确，是符合业务逻辑的。但是如果用户名输入错误了，那么现在还有必要去比较密码吗？没有不要了。如果使用一个&amp;，那么左边和右边不管什么情况下，都会执行。用户名正确  &amp;&amp;  密码正确如果用户名输入正确了，那么才会验证密码是否输入正确。如果用户名输入错误了，那么就不会再去验证密码是否正确，最终的结果直接为false。从而提高了程序运行的效率。</code></pre><h3 id="总结">总结：</h3><pre><code class="hljs">&amp;&amp; 和 &amp; 、||和|的运行结果都是一模一样的。但是短路逻辑运算符可以提高程序的运行效率。</code></pre><h3 id="建议">建议：</h3><pre><code class="hljs">最为常用： &amp;&amp;   ||   ！</code></pre><h1 id="三元运算符">16.三元运算符</h1><p>又叫做：三元表达式或者问号冒号表达式。</p><h3 id="格式">格式：</h3><pre><code class="hljs">关系表达式 ？ 表达式1 ：表达式2 ；</code></pre><h3 id="计算规则">计算规则：</h3><ul><li>计算关系表达式的值。</li><li>如果关系表达式的值为真，那么执行表达式1。</li><li>如果关系表达式的值为假，那么执行表达式2。</li></ul><h3 id="注意点-3">注意点：</h3><pre><code class="hljs">三元运算符的最终结果一定要被使用，要么赋值给一个变量，要么直接打印出来。</code></pre><h3 id="案例-3">案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatorDemo12</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//需求：求两个数的较大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        <span class="hljs-comment">//格式：关系表达式 ？ 表达式1 ： 表达式2 ；</span><br>        <span class="hljs-comment">//注意点：</span><br>        <span class="hljs-comment">//三元运算符的最终结果一定要被使用。</span><br>        <span class="hljs-comment">//要么赋值给一个变量，要么直接输出。</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span>  a &gt; b ? a : b ;<br>        System.out.println(max);<br><br><br>        System.out.println(a &gt; b ? a : b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java02-基础概念</title>
    <link href="/2023/06/29/Java02-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/06/29/Java02-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="java基础概念">Java基础概念</h1><h2 id="注释">1. 注释</h2><p>注释是对代码的解释和说明文字。</p><p>Java中的注释分为三种：</p><ul><li>单行注释：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是单行注释文字</span><br></code></pre></td></tr></table></figure><ul><li>多行注释：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">*/</span><br>注意：多行注释不能嵌套使用。<br></code></pre></td></tr></table></figure><ul><li>文档注释：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="使用的技巧">使用的技巧</h3><pre><code class="hljs">如果我们要对代码进行解释，那么就可以使用注释。当注释的内容比较少，一行就写完了，可以用单行注释。如果注释的内容比较多，需要写在多行，那么可以使用多行注释。</code></pre><h3 id="注意">注意：</h3><pre><code class="hljs">注释的内容不会参与编译和运行的，仅仅是对代码的解释说明而已。所以，不管在注释当中写什么内容，都不会影响代码运行的结果。</code></pre><h2 id="关键字">2. 关键字</h2><h3 id="概念">2.1 概念</h3><pre><code class="hljs">被Java赋予了特定含义的英文单词。当我们在代码中写了关键字之后，程序在运行的时候，就知道要做什么事情了。</code></pre><table><thead><tr class="header"><th><strong>abstract</strong></th><th><strong>assert</strong></th><th><strong>boolean</strong></th><th><strong>break</strong></th><th><strong>byte</strong></th></tr></thead><tbody><tr class="odd"><td><strong>case</strong></td><td><strong>catch</strong></td><td><strong>char</strong></td><td><strong>class</strong></td><td><strong>const</strong></td></tr><tr class="even"><td><strong>continue</strong></td><td><strong>default</strong></td><td><strong>do</strong></td><td><strong>double</strong></td><td><strong>else</strong></td></tr><tr class="odd"><td><strong>enum</strong></td><td><strong>extends</strong></td><td><strong>final</strong></td><td><strong>finally</strong></td><td><strong>float</strong></td></tr><tr class="even"><td><strong>for</strong></td><td><strong>goto</strong></td><td><strong>if</strong></td><td><strong>implements</strong></td><td><strong>import</strong></td></tr><tr class="odd"><td><strong>instanceof</strong></td><td><strong>int</strong></td><td><strong>interface</strong></td><td><strong>long</strong></td><td><strong>native</strong></td></tr><tr class="even"><td><strong>new</strong></td><td><strong>package</strong></td><td><strong>private</strong></td><td><strong>protected</strong></td><td><strong>public</strong></td></tr><tr class="odd"><td><strong>return</strong></td><td><strong>strictfp</strong></td><td><strong>short</strong></td><td><strong>static</strong></td><td><strong>super</strong></td></tr><tr class="even"><td><strong>switch</strong></td><td><strong>synchronized</strong></td><td><strong>this</strong></td><td><strong>throw</strong></td><td><strong>throws</strong></td></tr><tr class="odd"><td><strong>transient</strong></td><td><strong>try</strong></td><td><strong>void</strong></td><td><strong>volatile</strong></td><td><strong>while</strong></td></tr></tbody></table><h3 id="第一个关键字class">2.2 第一个关键字class</h3><pre><code class="hljs">表示定义一个类 创建一个类。</code></pre><p>类：Java项目最基本的组成单元，一个完整的Java项目有可能会有成千上万个类来组成的。</p><p>class后面跟随的就是这个类的名字，简称：类名。</p><p>在类名后面会有一对大括号，表示这个类的内容。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>解释：class表示定义类。</p><pre><code class="hljs">类名：HelloWorldHelloWorld后面的大括号表示这个类的范围。</code></pre><h2 id="字面量">3. 字面量</h2><p>作用：告诉程序员，数据在程序中的书写格式。</p><table><thead><tr class="header"><th><strong>字面量类型</strong></th><th><strong>说明</strong></th><th><strong>程序中的写法</strong></th></tr></thead><tbody><tr class="odd"><td>整数</td><td>不带小数的数字</td><td>666，-88</td></tr><tr class="even"><td>小数</td><td>带小数的数字</td><td>13.14，-5.21</td></tr><tr class="odd"><td>字符</td><td>必须使用单引号，有且仅能一个字符</td><td>‘A’，‘0’， ‘我’</td></tr><tr class="even"><td>字符串</td><td>必须使用双引号，内容可有可无</td><td>“HelloWorld”，“程序员”</td></tr><tr class="odd"><td>布尔值</td><td>布尔值，表示真假，只有两个值：true，false</td><td>true 、false</td></tr><tr class="even"><td>空值</td><td>一个特殊的值，空值</td><td>值是：null</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-number">10</span>); <span class="hljs-comment">// 输出一个整数</span><br>        System.out.println(<span class="hljs-number">5.5</span>); <span class="hljs-comment">// 输出一个小数</span><br>        System.out.println(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// 输出一个字符</span><br>        System.out.println(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 输出boolean值true</span><br>        System.out.println(<span class="hljs-string">&quot;程序员&quot;</span>); <span class="hljs-comment">// 输出字符串</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区分技巧">区分技巧</h3><ol type="1"><li>不带小数点的数字都是整数类型的字面量。</li><li>只要带了小数点，那么就是小数类型的字面量。</li><li>只要用双引号引起来的，不管里面的内容是什么，不管里面有没有内容，都是字符串类型的字面量。</li><li>字符类型的字面量必须用单引号引起来，不管内容是什么，但是个数有且只能有一个。</li><li>字符类型的字面量只有两个值，true、false。</li><li>空类型的字面量只有一个值，null。</li></ol><h2 id="变量">4. 变量</h2><h3 id="什么是变量">4.1 什么是变量？</h3><pre><code class="hljs">变量就在程序中临时存储数据的容器。但是这个容器中只能存一个值。</code></pre><h3 id="变量的定义格式">4.2 变量的定义格式</h3><pre><code class="hljs">数据类型 变量名 = 数据值；</code></pre><h4 id="格式详解">4.2.1 格式详解</h4><pre><code class="hljs">数据类型：限定了变量当中能存储什么类型的数据。如果要存10，那么数据类型就需要写整数类型。如果要存10.0，那么数据类型就需要写小数类型。变量名：其实就是这个容器的名字。当以后想要使用变量里面的数据时，直接使用变量名就可以了。数据值：真正存储在容器中的数据。分号：表示语句的结束，就跟以前写作文时候的句号是一样的。</code></pre><h4 id="常用的数据类型">4.2.2 常用的数据类型</h4><pre><code class="hljs">整数：int小数：（浮点数）double其他数据类型稍后讲解</code></pre><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableDemo</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">//定义一个整数类型的变量</span><br><span class="hljs-comment">//数据类型 变量名 = 数据值;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>System.out.println(a);<span class="hljs-comment">//16</span><br><br><span class="hljs-comment">//定义一个小数类型的变量</span><br><span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10.1</span>;<br>System.out.println(b);<span class="hljs-comment">//10.1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="变量的注意事项">4.2.3 变量的注意事项</h4><ul><li>变量名不能重复</li><li>在一条语句中，可以定义多个变量。但是这种方式影响代码的阅读，所以了解一下即可。</li><li>变量在使用之前必须要赋值。</li></ul><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableDemo2</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">//1.变量名不允许重复</span><br><span class="hljs-comment">//int a = 10;</span><br><span class="hljs-comment">//int a = 20;</span><br><span class="hljs-comment">//System.out.println(a);</span><br><br><span class="hljs-comment">//2.一条语句可以定义多个变量</span><br><span class="hljs-comment">//了解。</span><br><span class="hljs-comment">//int a = 10, b = 20, c = 20,d = 20;</span><br><span class="hljs-comment">//System.out.println(a);//?</span><br><span class="hljs-comment">//System.out.println(b);//?</span><br><br><br><span class="hljs-comment">//3.变量在使用之前必须要赋值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>System.out.println(a);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="变量的练习">4.3 变量的练习</h3><pre><code class="hljs">需求：说出公交车到终点站之后，车上一共有多少乘客？        一开始没有乘客。       第一站：上去一位乘客，没有下来乘客。       第二站：上去两位乘客，下来一位乘客。       第三站：上去两位乘客，下来一位乘客。       第四站：没有上去乘客，下来一位乘客。       第五站：上去一位乘客，没有下来乘客。       问：到了终点站之后，车上一共多少乘客？代码解析：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableBus</span>&#123;<br><span class="hljs-comment">//主入口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">//一开始没有乘客。</span><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//第一站：上去一位乘客</span><br><span class="hljs-comment">//在原有的基础上 + 1</span><br>count = count + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//System.out.println(count);</span><br><span class="hljs-comment">//第二站：上去两位乘客，下来一位乘客</span><br>count = count + <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; <br><span class="hljs-comment">//第三站：上去两位乘客，下来一位乘客</span><br>count = count + <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br><span class="hljs-comment">//第四站：下来一位乘客</span><br>count = count - <span class="hljs-number">1</span>;<br><span class="hljs-comment">//第五站：上去一位乘客</span><br>count = count + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//请问：到了终点站，车上一共几位乘客。</span><br>System.out.println(count);<span class="hljs-comment">//3</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据类型">5. 数据类型</h2><h3 id="java语言数据类型的分类">5.1 Java语言数据类型的分类</h3><ul><li>基本数据类型</li><li>引用数据类型（面向对象的时候再深入学习）</li></ul><h3 id="基本数据类型的四类八种">5.2 基本数据类型的四类八种</h3><table><thead><tr class="header"><th style="text-align: center;">数据类型</th><th style="text-align: center;">关键字</th><th style="text-align: center;">内存占用</th><th style="text-align: center;">取值范围</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">整数</td><td style="text-align: center;">byte</td><td style="text-align: center;">1</td><td style="text-align: center;">负的2的7次方 ~ 2的7次方-1(-128~127)</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">short</td><td style="text-align: center;">2</td><td style="text-align: center;">负的2的15次方 ~ 2的15次方-1(-32768~32767)</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">int</td><td style="text-align: center;">4</td><td style="text-align: center;">负的2的31次方 ~ 2的31次方-1</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">long</td><td style="text-align: center;">8</td><td style="text-align: center;">负的2的63次方 ~ 2的63次方-1</td></tr><tr class="odd"><td style="text-align: center;">浮点数</td><td style="text-align: center;">float</td><td style="text-align: center;">4</td><td style="text-align: center;">1.401298e<sup>-45</sup> ~ 3.402823e<sup>+38</sup></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">double</td><td style="text-align: center;">8</td><td style="text-align: center;">4.9000000e<sup>-324</sup> ~ 1.797693e<sup>+308</sup></td></tr><tr class="odd"><td style="text-align: center;">字符</td><td style="text-align: center;">char</td><td style="text-align: center;">2</td><td style="text-align: center;">0-65535</td></tr><tr class="even"><td style="text-align: center;">布尔</td><td style="text-align: center;">boolean</td><td style="text-align: center;">1</td><td style="text-align: center;">true，false</td></tr></tbody></table><h4 id="说明">说明</h4><pre><code class="hljs">e^+38^表示是乘以10的38次方，同样，e^-45^表示乘以10的负45次方。在java中整数默认是int类型，浮点数默认是double类型。</code></pre><h4 id="需要记忆以下几点">需要记忆以下几点</h4><p>byte类型的取值范围：</p><pre><code class="hljs">-128 ~ 127</code></pre><p>int类型的大概取值范围：</p><pre><code class="hljs">-21亿多  ~ 21亿多</code></pre><p>整数类型和小数类型的取值范围大小关系：</p><pre><code class="hljs">double &gt; float &gt; long &gt; int &gt; short &gt; byte</code></pre><p>最为常用的数据类型选择：</p><ul><li><p>在定义变量的时候，要根据实际的情况来选择不同类型的变量。</p><p>比如：人的年龄，可以选择byte类型。</p><p>比如：地球的年龄，可以选择long类型。</p></li><li><p>如果整数类型中，不太确定范围，那么默认使用int类型。</p></li><li><p>如果小数类型中，不太确定范围，那么默认使用double类型。</p></li><li><p>如果要定义字符类型的变量，那么使用char</p></li><li><p>如果要定义布尔类型的变量，那么使用boolean</p></li></ul><h3 id="定义8种基本数据类型变量">5.3 定义8种基本数据类型变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableDemo3</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//1.定义byte类型的变量</span><br>        <span class="hljs-comment">//数据类型 变量名 = 数据值;</span><br>        <span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(a);<br><br>        <span class="hljs-comment">//2.定义short类型的变量</span><br>        <span class="hljs-type">short</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        System.out.println(b);<br><br>        <span class="hljs-comment">//3.定义int类型的变量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>        System.out.println(c);<br><br>        <span class="hljs-comment">//4.定义long类型的变量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">123456789123456789L</span>;<br>        System.out.println(d);<br><br>        <span class="hljs-comment">//5.定义float类型的变量</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-number">10.1F</span>;<br>        System.out.println(e);<br><br>        <span class="hljs-comment">//6.定义double类型的变量</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">20.3</span>;<br>        System.out.println(f);<br><br>        <span class="hljs-comment">//7.定义char类型的变量</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>        System.out.println(g);<br><br>        <span class="hljs-comment">//8.定义boolean类型的变量</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        System.out.println(h);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意-1"><strong>注意</strong></h4><ul><li>如果要定义 一个整数类型的变量，不知道选择哪种数据类型了，默认使用int。</li><li>如果要定义 一个小数类型的变量，不知道选择哪种数据类型了，默认使用double。</li><li>如果要定义一个long类型的变量，那么在数据值的后面需要加上L后缀。（大小写都可以，建议大写。）</li><li>如果要定义一个float类型的变量，那么在数据值的后面需要加上F后缀。（大小写都可以）</li></ul><h2 id="标识符">6. 标识符</h2><p>业内大多数程序员都在遵守阿里巴巴的命名规则。</p><h3 id="硬性要求">6.1 硬性要求：</h3><pre><code class="hljs">必须要这么做，否则代码会报错。</code></pre><ul><li>必须由数字、字母、下划线_、美元符号$组成。</li><li>数字不能开头</li><li>不能是关键字</li><li>区分大小写的。</li></ul><h3 id="软性建议">6.2 软性建议：</h3><pre><code class="hljs">如果不这么做，代码不会报错，但是会让代码显不规范。</code></pre><h3 id="小驼峰命名法">6.2.1 小驼峰命名法</h3><p>适用于变量名和方法名</p><ul><li><p>如果是一个单词，那么全部小写，比如：name</p></li><li><p>如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge</p></li></ul><h3 id="大驼峰命名法">6.2.2 大驼峰命名法</h3><p>适用于类名</p><ul><li><p>如果是一个单词，那么首字母大写。比如：Demo、Test。</p></li><li><p>如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld</p></li></ul><p><strong>不管起什么名字，都要做到见名知意。</strong></p><h3 id="阿里巴巴命名规范细节">阿里巴巴命名规范细节：</h3><ol type="1"><li><p>尽量不要用拼音。但是一些国际通用的拼音可视为英文单词。</p><p>正确：alibaba、hangzhou、nanjing</p><p>错误：jiage、dazhe</p></li><li><p>平时在给变量名、方法名、类名起名字的时候，不要使用下划线或美元符号。</p><p>错误：_name</p><p>正确：name</p></li></ol><h2 id="键盘录入">7. 键盘录入</h2><pre><code class="hljs">键盘录入的实际功能Java已经帮我们写好了，不需要我们自己再实现了，而Java写好的功能都放在了Scanner这个类中，所以，我们只要直接使用Scanner这个类就可以了。</code></pre><p>使用步骤：</p><p>第一步：</p><pre><code class="hljs">导包：其实就是表示先找到Scanner这个类在哪。</code></pre><p>第二步：</p><pre><code class="hljs">创建对象：其实就表示申明一下，我准备开始用Scanner这个类了。</code></pre><p>第三步：</p><pre><code class="hljs">接收数据：也是真正干活的代码。</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//导包，其实就是先找到Scanner这个类在哪</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScannerDemo1</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">//2.创建对象，其实就是申明一下，我准备开始用Scanner这个类了。</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//3.接收数据</span><br><span class="hljs-comment">//当程序运行之后，我们在键盘输入的数据就会被变量i给接收了</span><br>System.out.println(<span class="hljs-string">&quot;请输入一个数字&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sc.nextInt();<br>System.out.println(i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java01-Java入门</title>
    <link href="/2023/06/27/Java01-Java%E5%85%A5%E9%97%A8/"/>
    <url>/2023/06/27/Java01-Java%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="java概述">1. Java概述</h2><h3 id="java是什么">1.1 Java是什么？</h3><p>语言：人与人交流沟通的表达方式</p><p>计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言</p><p>我们想要让计算机做一些事情，那么就可以通过Java语言告诉计算机就可以了</p><h3 id="下载和安装">1.2 下载和安装</h3><h4 id="下载">1.2.1 下载</h4><p>通过官方网站获取JDK <a href="http://www.oracle.com/">http://www.oracle.com</a></p><p><strong>注意</strong>：针对不同的操作系统，需要下载对应版本的JDK。</p><h4 id="安装">1.2.2 安装</h4><p>傻瓜式安装，下一步即可。默认的安装路径是在<code>C:\Program Files</code>下。</p><p>建议：</p><ul><li>安装在除C盘以外的盘内，在这里插入代码片安装路径不要有中文，不要有空格等一些特殊的符号。</li><li>以后跟开发相关的所有软件建议都安装在同一个文件夹中，方便管理。</li></ul><h4 id="jdk的安装目录介绍">1.2.3 JDK的安装目录介绍</h4><table><thead><tr class="header"><th>目录名称</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>bin</td><td>该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。</td></tr><tr class="even"><td>conf</td><td>该路径下存放了JDK的相关配置文件。</td></tr><tr class="odd"><td>include</td><td>该路径下存放了一些平台特定的头文件。</td></tr><tr class="even"><td>jmods</td><td>该路径下存放了JDK的各种模块。</td></tr><tr class="odd"><td>legal</td><td>该路径下存放了JDK各模块的授权文档。</td></tr><tr class="even"><td>lib</td><td>该路径下存放了JDK工具的一些补充JAR包。</td></tr></tbody></table><h3 id="helloworld小案例">1.3 HelloWorld小案例</h3><p>HelloWorld案例是指在计算机屏幕上输出“HelloWorld”这行文字。各种计算机语言都习惯使用该案例作为第一个演示案例。</p><h4 id="java程序开发运行流程">1.3.1 Java程序开发运行流程</h4><p>开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。</p><h4 id="helloworld案例的编写">1.3.2 HelloWorld案例的编写</h4><ol type="1"><li><p>新建文本文档文件，修改名称为HelloWorld.java。</p><p><strong>注意</strong>：后缀名为java的才是java文件。</p></li><li><p>用记事本打开HelloWorld.java文件，输写程序内容。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><p>保存</p></li><li><p>编译文件。编译后会产生一个class文件。</p><p>java文件：程序员自己编写的代码。</p><p>class文件：交给计算机执行的文件。</p></li><li><p>运行代码</p><p><strong>注意</strong>：运行的是编译之后的class文件。</p></li></ol><blockquote><p>用到两个命令：</p><p>javac + 文件名 + 后缀名 （就是编译java文件）</p><p>java + 文件名（运行编译之后的class文件）</p></blockquote><h3 id="helloworld案例常见问题">1.4 HelloWorld案例常见问题</h3><p>1、非法字符问题。Java中的符号都是英文格式的。</p><p>2、大小写问题。Java语言对大小写敏感（区分大小写）。</p><p>3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。</p><p>4、编译命令后的java文件名需要带文件后缀.java</p><p>5、运行命令后的class文件名（类名）不带文件后缀.class</p><h3 id="环境变量">1.5 环境变量</h3><h4 id="为什么配置环境变量">1.5.1 为什么配置环境变量</h4><pre><code class="hljs">开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在bin目录下使用，而我们想要在任意目录下都能使用，所以就要配置环境变量。</code></pre><p>注意：现在从官网上下载的最新版本的JDK安装时会自动配置javac、java命令的路径到Path环境变量中去 ，所以javac、java可以直接使用。</p><h4 id="配置方式">1.5.2 配置方式</h4><p>以前下载的老版本的JDK是没有自动配置的，而且自动配置的也只包含了4个工具而已，所以我们需要删掉已经配置完毕的，再次重新配置Path环境变量。</p><p><img src="/img/assets/18bc9fbdd5d44dcca776d761afabc52f.png" /></p><p>① <strong>JAVA_HOME</strong>：告诉操作系统JDK安装在了哪个位置</p><p>② <strong>Path</strong>：告诉操作系统JDK提供的javac(编译)、java(执行)命令安装到了哪个位置</p><h3 id="java语言的发展">1.6 Java语言的发展</h3><p>三个版本：</p><ul><li>Java5.0：这是Java的第一个大版本更新。</li><li>Java8.0：这个是目前绝大数公司正在使用的版本。这个版本最为稳定。</li></ul><h3 id="java的三大平台">1.7 Java的三大平台</h3><p>JavaSE、JavaME、JavaEE</p><h4 id="javase">1.7.1 JavaSE</h4><p>是其他两个版本的基础。</p><h4 id="javame">1.7.2 JavaME</h4><p>Java语言的小型版，用于嵌入式消费类电子设备或者小型移动设备的开发。</p><p>其中最为主要的还是小型移动设备的开发（手机）。渐渐的没落了，已经被安卓和IOS给替代了。</p><p>但是，安卓也是可以用Java来开发的。</p><h4 id="javaee">1.7.3 JavaEE</h4><p>用于Web方向的网站开发。（主要从事后台服务器的开发）</p><h3 id="java的主要特性">1.8 Java的主要特性</h3><ul><li>面向对象</li><li>安全性</li><li>多线程</li><li>简单易用</li><li>开源</li><li>跨平台</li></ul><h4 id="java语言跨平台的原理">1.8.1 Java语言跨平台的原理</h4><ul><li>操作系统本身其实是不认识Java语言的。</li><li>但是针对于不同的操作系统，Java提供了不同的虚拟机。</li></ul><p>虚拟机会把Java语言翻译成操作系统能看得懂的语言。</p><p><img src="/img/assets/a009ce99cf0841e89f9c731e67b07b80.png" /></p><h3 id="jre和jdk">1.9 JRE和JDK</h3><p><img src="/img/assets/5a5bce2705344fb29c0a39ceaf57573d.png" /></p><p>JVM（Java Virtual Machine) : Java虚拟机</p><p>JRE（Java Runtime Environment) : Java运行环境，包含了JVM和Java的核心类库（Java API）</p><p>JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具</p><p>总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
