<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Jupyter Notebook 无法跳转网页的问题</title>
    <link href="/2024/02/12/Jupyter-Notebook-%E6%97%A0%E6%B3%95%E8%B7%B3%E8%BD%AC%E7%BD%91%E9%A1%B5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2024/02/12/Jupyter-Notebook-%E6%97%A0%E6%B3%95%E8%B7%B3%E8%BD%AC%E7%BD%91%E9%A1%B5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>不自动跳转浏览器，出现了如下界面：     </p><p><img src="/img/JupyterNotebook/1.jpg" /></p><hr /><h2 id="解决方案">解决方案：</h2><p>（一）打开anaconda命令行，在窗口（或进入虚拟环境）输入以下命令</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">jupyter notebook --<span class="hljs-keyword">generate</span>-<span class="hljs-keyword">config</span><br></code></pre></td></tr></table></figure><p>   （二） 输入后可以看到生成了一个名为Jupyter_notebook_config.py配置文件, 复制该路径</p><p><img src="/img/JupyterNotebook/2.jpg" /></p><p> （三）复制该路径后打开文件。拉到最后输入以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> webbrowserwebbrowser.register(<span class="hljs-string">&#x27;chrome&#x27;</span>,<span class="hljs-literal">None</span>, webbrowser.GenericBrowser(<span class="hljs-string">u&#x27;C://Program Files (x86)//Google//Chrome//Application//chrome.exe&#x27;</span>))c.NotebookApp.browser =<span class="hljs-string">&#x27;chrome&#x27;</span><br></code></pre></td></tr></table></figure><p> 上段代码第二行路径要根据自己浏览器位置修改填写。</p><p>chrome 查询路径可在属性的目标中从 开始到chorme.exe 这一段复制过来并<strong>将路径的\ 用//（双反斜杠）代替</strong>。上段代码第二行路径就可以。注意：复制过来的地址需要将 \ 改成 //。</p><p><img src="/img/JupyterNotebook/3.jpg" /></p><p> （四）保存，退出。重新打开jupyter notebook就可以看到可以打开了。</p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>JupyterNotebook</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jupyter Notebook 环境（内核）配置</title>
    <link href="/2024/02/12/Jupyter-Notebook%E7%8E%AF%E5%A2%83%EF%BC%88%E5%86%85%E6%A0%B8%EF%BC%89%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/02/12/Jupyter-Notebook%E7%8E%AF%E5%A2%83%EF%BC%88%E5%86%85%E6%A0%B8%EF%BC%89%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="安装jupter">1.安装jupter</h2><p>终端输入：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">jupyter notebook</span><br></code></pre></td></tr></table></figure><p>如果未成功激活jupter则要自己先安装jupter：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">pip <span class="hljs-keyword">install </span><span class="hljs-keyword">jupyter </span> <span class="hljs-comment">##安装jupter</span><br><span class="hljs-keyword">jupyter </span>notebook     <span class="hljs-comment">##启动jupter</span><br></code></pre></td></tr></table></figure><h2 id="创建自己的conda环境">2.创建自己的conda环境</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">conda create -n your_env_name <span class="hljs-attribute">python</span>=xxx<br></code></pre></td></tr></table></figure><h2 id="激活环境">3.激活环境</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">activate</span> your_env_name<br></code></pre></td></tr></table></figure><h2 id="安装ipykernel包">4.安装ipykernel包</h2><p>确认是否安装 ipykernel</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> -<span class="hljs-keyword">m</span> ipykernel --<span class="hljs-keyword">version</span><br></code></pre></td></tr></table></figure><p>如果没有安装，则安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">conda <span class="hljs-keyword">install</span> ipykernel<br></code></pre></td></tr></table></figure><h2 id="建立连接">5.建立连接</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">python -m ipykernel install --<span class="hljs-keyword">user</span> <span class="hljs-title">--name</span>=kernel_name<br></code></pre></td></tr></table></figure><h2 id="转换jupyter的虚拟环境">6.转换jupyter的虚拟环境</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/8a75f78ee06e8a67449c216927dcd5be.png" /></p><h2 id="如果想要检查是否链接成功可以输入">7.如果想要检查是否链接成功，可以输入</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">jupyter kernelspec list</span><br></code></pre></td></tr></table></figure><p>显示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2901de3528a1fa3c890fb26da895bd77.png" /></p><h2 id="删除-jupyter-内核">8.删除 jupyter 内核</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">jupyter kernelspec <span class="hljs-built_in">remove</span> kernel_name<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>JupyterNotebook</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jupyter Notebook 配置指定工作路径</title>
    <link href="/2024/02/12/Jupyter-Notebook-%E9%85%8D%E7%BD%AE%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/02/12/Jupyter-Notebook-%E9%85%8D%E7%BD%AE%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p><strong>1 修改工作路径</strong></p><p>（1）新建一个文件夹，作为修改后jupyter notebooks的工作路径，例如“E:\work\taiyi\myself\jupyter-notebook”</p><p>（2）获取jupyter notebook的配置文件</p><p>开始菜单 -&gt; anaconda -&gt; anaconda prompt -&gt; 打开命令窗口，输入：<code>jupyter notebook –-generate-config</code></p><p>如果之前已经配置过notebooks相关信息，执行此命令会提示是否覆盖原有配置，输入<code>y</code>直接覆盖；如果是首次执行此命令，则直接生成配置文件到相应目录。</p><p><img src="https://img-blog.csdnimg.cn/20210606114156967.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW56aGUwMA==,size_16,color_FFFFFF,t_70" /></p><p><img src="https://img-blog.csdnimg.cn/20210606114331923.jpg" /></p><p>（3）修改配置文件</p><p>根据配置文件路径，打开配置文件，修改<code>#c.NotebookApp.notebook_dir = ''</code>此条配置，去掉注释符#，修改工作路径，保存配置文件。</p><p>注：[1] 工作路径最好用“\\”双反斜杠分割；[2] 工作路径最好全英文</p><p><img src="https://img-blog.csdnimg.cn/20210606114359560.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW56aGUwMA==,size_16,color_FFFFFF,t_70" /></p><p>（4）修改Jupyter notebook属性</p><p>该步骤一定要做，否则只修改配置文件，不起作用。</p><p>开始菜单 -&gt; anaconda -&gt; 右键单击jupyter notebook -&gt; 更多 -&gt; 打开文件位置，打开jupyter notebook快捷方式位置 -&gt; jupyter notebook右键点击 -&gt; 属性 -&gt; 目标 -&gt;去掉后面的%USERPROFILE% -&gt; 点击应用、确定</p><p><img src="https://img-blog.csdnimg.cn/20210606114425229.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW56aGUwMA==,size_16,color_FFFFFF,t_70" /></p><p><img src="https://img-blog.csdnimg.cn/20210606114448918.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW56aGUwMA==,size_16,color_FFFFFF,t_70" /></p><p><strong>3 启动jupyter notebook</strong></p><p>开始菜单 -》Anaconda -》 jupyter Notebook -》打开jupyter notebook -》启动notebook后，自动打开命令提示窗口、浏览器自动打开notebook页面地址。此时命令提示窗口的工作路径已修改为配置的路径；notebook页面为空。</p><p><img src="https://img-blog.csdnimg.cn/20210606114514383.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW56aGUwMA==,size_16,color_FFFFFF,t_70" /></p><p><img src="https://img-blog.csdnimg.cn/2021060611453232.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW56aGUwMA==,size_16,color_FFFFFF,t_70" /></p><p>转自：<a href="https://blog.csdn.net/tianwenzhe00/article/details/117622572?spm=1001.2014.3001.5501">jupyter notebook 配置路径_jupyter notebook地址-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>JupyterNotebook</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jupyter Notebook 快捷键</title>
    <link href="/2024/02/12/Jupyter-Notebook-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2024/02/12/Jupyter-Notebook-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="jupyter-notebook-快捷键">Jupyter Notebook 快捷键</h2><p>Jupyter Notebook 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。</p><h3 id="命令模式-按键-esc-开启">命令模式 (按键 Esc 开启)</h3><ul><li><strong>Enter</strong> : 转入编辑模式</li><li><strong>Shift-Enter</strong> : 运行本单元，选中下个单元</li><li><strong>Ctrl-Enter</strong> : 运行本单元</li><li><strong>Alt-Enter</strong> : 运行本单元，在其下插入新单元</li><li><strong>Y</strong> : 单元转入代码状态</li><li><strong>M</strong> :单元转入markdown状态</li><li><strong>R</strong> : 单元转入raw状态</li><li><strong>1</strong> : 设定 1 级标题<br /></li><li><strong>2</strong> : 设定 2 级标题</li><li><strong>3</strong> : 设定 3 级标题</li><li><strong>4</strong> : 设定 4 级标题</li><li><strong>5</strong> : 设定 5 级标题</li><li><strong>6</strong> : 设定 6 级标题</li><li><strong>Up</strong> : 选中上方单元</li><li><strong>K</strong> : 选中上方单元</li><li><strong>Down</strong> : 选中下方单元</li><li><strong>J</strong> : 选中下方单元</li><li><strong>Shift-K</strong> : 扩大选中上方单元</li><li><strong>Shift-J</strong> : 扩大选中下方单元</li><li><strong>A</strong> : 在上方插入新单元</li><li><strong>B</strong> : 在下方插入新单元</li><li><strong>X</strong> : 剪切选中的单元</li><li><strong>C</strong> : 复制选中的单元</li><li><strong>Shift-V</strong> : 粘贴到上方单元</li><li><strong>V</strong> : 粘贴到下方单元</li><li><strong>Z</strong> : 恢复删除的最后一个单元</li><li><strong>D,D</strong> : ==删除选中的单元==</li><li><strong>Shift-M</strong> : 合并选中的单元</li><li><strong>Ctrl-S</strong> : 文件存盘</li><li><strong>S</strong> : 文件存盘</li><li><strong>L</strong> : 转换行号</li><li><strong>O</strong> : 转换输出</li><li><strong>Shift-O</strong> : 转换输出滚动</li><li><strong>Esc</strong> : 关闭页面</li><li><strong>Q</strong> : 关闭页面</li><li><strong>H</strong> : 显示快捷键帮助</li><li><strong>I,I</strong> : 中断Notebook内核</li><li><strong>0,0</strong> : 重启Notebook内核</li><li><strong>Shift</strong> : 忽略</li><li><strong>Shift-Space</strong> : 向上滚动</li><li><strong>Space</strong> : 向下滚动</li></ul><h3 id="编辑模式-enter-键启动">编辑模式 ( Enter 键启动)</h3><ul><li><strong>Tab</strong> : 代码补全或缩进</li><li><strong>Shift-Tab</strong> : 提示<br /></li><li><strong>Ctrl-]</strong> : 缩进<br /></li><li><strong>Ctrl-[</strong> : 解除缩进</li><li><strong>Ctrl-A</strong> : 全选</li><li><strong>Ctrl-Z</strong> : 复原</li><li><strong>Ctrl-Shift-Z</strong> : 再做<br /></li><li><strong>Ctrl-Y</strong> : 再做<br /></li><li><strong>Ctrl-Home</strong> : 跳到单元开头</li><li><strong>Ctrl-Up</strong> : 跳到单元开头</li><li><strong>Ctrl-End</strong> : 跳到单元末尾</li><li><strong>Ctrl-Down</strong> : 跳到单元末尾</li><li><strong>Ctrl-Left</strong> : 跳到左边一个字首</li><li><strong>Ctrl-Right</strong> : 跳到右边一个字首</li><li><strong>Ctrl-Backspace</strong> : 删除前面一个字</li><li><strong>Ctrl-Delete</strong> : 删除后面一个字</li><li><strong>Esc</strong> : 进入命令模式</li><li><strong>Ctrl-M</strong> : 进入命令模式</li><li><strong>Shift-Enter</strong> : 运行本单元，选中下一单元</li><li><strong>Ctrl-Enter</strong> : 运行本单元</li><li><strong>Alt-Enter</strong> : 运行本单元，在下面插入一单元</li><li><strong>Ctrl-Shift--</strong> : 分割单元</li><li><strong>Ctrl-Shift-Subtract</strong> : 分割单元</li><li><strong>Ctrl-S</strong> : 文件存盘</li><li><strong>Shift</strong> : 忽略<br /></li><li><strong>Up</strong> : 光标上移或转入上一单元</li><li><strong>Down</strong> :光标下移或转入下一单元</li></ul><h3 id="其他">其他</h3><p>查看函数或者方法的参数及使用方法：光标移动到方法上面，按shift+tab，弹出文档，连续按选择文档详细程度</p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>JupyterNotebook</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习-Course5-Week3序列模型和注意力机制</title>
    <link href="/2024/02/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course5-Week3%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/02/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course5-Week3%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="编码与解码">1. 编码与解码</h1><p>Sequence to Sequence（序列）模型在机器翻译和语音识别方面都有着广泛的应用。</p><p>下面，我们来看一个机器翻译的简单例子： <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_2.png" /> 针对该机器翻译问题，可以使用“编码网络（encoder network）”+“解码网络（decoder network）”两个RNN模型组合的形式来解决。</p><p>encoder network将输入语句编码为一个特征向量，传递给decoder network，完成翻译。</p><p>具体模型结构如下图所示： <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_1.png" /> 其中，encoder vector代表了输入语句的编码特征。 encoder network和decoder network都是RNN模型，可使用GRU或LSTM单元。</p><p>这种“编码网络（encoder network）”+“解码网络（decoder network）”的模型，在实际的机器翻译应用中有着不错的效果。</p><h1 id="机器翻译">2. 机器翻译</h1><p>Sequence to sequence machine translation模型与我们第一节课介绍的language模型有一些相似，但也存在不同之处。二者模型结构如下所示。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_3.png" /> Language model是自动生成一条完整语句，语句是随机的。而machine translation model是根据输入语句，进行翻译，生成另外一条完整语句。</p><p>上图中，绿色部分表示encoder network，紫色部分表示decoder network。</p><p>decoder network与language model是相似的，encoder network可以看成是language model的输入，是模型的一个条件。也就是说，在输入语句的条件下，生成正确的翻译语句。</p><p>因此，machine translation可以看成是有条件的语言模型（conditional language model）。这就是二者之间的区别与联系。</p><p>所以，machine translation的目标就是根据输入语句，作为条件，找到最佳翻译语句，使其概率最大： <span class="math display">\[maxP(y^{&lt;1&gt;},y^{&lt;2&gt;},\cdots,y^{&lt;Ty&gt;}|x^{&lt;1&gt;},x^{&lt;2&gt;},\cdots,x^{&lt;Tx&gt;})\]</span> 例如，本节笔记开始介绍的例子，列举几个模型可能得到的翻译： <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_4.png" /> 显然，第一条翻译"Jane is visiting Africa in September." 最为准确。那我们的优化目标就是要让这条翻译对应的<span class="math inline">\(P(y^{&lt;1&gt;},\cdots,y^{&lt;Ty&gt;}|x)\)</span>最大化</p><h1 id="贪婪搜索">3. 贪婪搜索</h1><p>实现优化目标的方法之一是使用贪婪搜索（greedy search）。</p><p>Greedy search根据条件，每次只寻找一个最佳单词作为翻译输出，力求把每个单词都翻译准确。</p><p>例如，首先根据输入语句，找到第一个翻译的单词“Jane”，然后再找第二个单词“is”，再继续找第三个单词“visiting”，以此类推。</p><p>这也是其“贪婪”名称的由来。</p><p>Greedy search存在一些缺点。</p><p>首先，因为greedy search每次只搜索一个单词，没有考虑该单词前后关系，概率选择上有可能会出错。</p><ul><li>例如，上面翻译语句中，第三个单词“going”比“visiting”更常见，模型很可能会错误地选择了“going”，而错失最佳翻译语句。</li></ul><p>其次，greedy search大大增加了运算成本，降低运算速度。</p><p>因此，greedy search并不是最佳的方法。</p><p>下一小节，我们将介绍Beam Search，使用近似最优的查找方式，最大化输出概率，寻找最佳的翻译语句。</p><h1 id="beam-search">4. Beam Search</h1><p>Greedy search每次是找出预测概率最大的单词，而beam search则是每次找出预测概率最大的B个单词。其中，参数B表示取概率最大的单词个数，可调。本例中，令B=3。</p><p>按照beam search的搜索原理，首先，先从词汇表中找出翻译的第一个单词概率最大的B个预测单词。例如上面的例子中，预测得到的第一个单词为：in，jane，september。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_6.png" /> <span class="math display">\[\text{概率表示为:}P(\hat{y}^{&lt;1&gt;}|x)\]</span> 然后，再分别以in，jane，september为条件，计算每个词汇表单词作为预测第二个单词的概率。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_7.png" /></p><p>总共有3*1000=3000个概率，从中选出前三个概率最大的， 假如从中选择概率最大的3个作为第二个单词的预测值，得到：in september，jane is，jane visits。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_8.png" /> <span class="math display">\[\text{概率表示为}:P(\hat{y}^{&lt;2&gt;}|x,\hat{y}^{&lt;1&gt;})\]</span> 此时，得到的前两个单词的3种情况的概率为： <span class="math display">\[P(\hat{y}^{&lt;1&gt;},\hat{y}^{&lt;2&gt;}|x)=P(\hat{y}^{&lt;1&gt;}|x)\cdot P(\hat{y}^{&lt;2&gt;}|x,\hat{y}^{&lt;1&gt;})\]</span> 接着，再预测第三个单词。方法一样，分别以in september，jane is，jane visits为条件，计算每个词汇表单词作为预测第三个单词的概率。从中选择概率最大的3个作为第三个单词的预测值，得到：in september jane，jane is visiting，jane visits africa。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_9.png" /></p><p><span class="math display">\[\text{概率表示为:}P(\hat{y}^{&lt;3&gt;}|x,\hat{y}^{&lt;1&gt;},\hat{y}^{&lt;2&gt;})\]</span> 此时，得到的前三个单词的3种情况的概率为： <span class="math display">\[P(\hat{y}^{&lt;1&gt;},\hat{y}^{&lt;2&gt;},\hat{y}^{&lt;3&gt;}|x)=P(\hat{y}^{&lt;1&gt;}|x)\cdot P(\hat{y}^{&lt;2&gt;}|x,\hat{y}^{&lt;1&gt;})\cdot P(\hat{y}^{&lt;3&gt;}|x,\hat{y}^{&lt;1&gt;},\hat{y}^{&lt;2&gt;})\]</span> 以此类推，每次都取概率最大的三种预测。最后，选择概率最大的那一组作为最终的翻译语句。</p><ul><li>Jane is visiting Africa in September.</li></ul><p>值得注意的是，如果参数B=1，则就等同于greedy search。实际应用中，可以根据不同的需要设置B为不同的值。一般B越大，机器翻译越准确，但同时也会增加计算复杂度。</p><p>Beam search中，最终机器翻译的概率是乘积的形式： <span class="math display">\[\textit{arg max}\prod_{t=1}^{T_y}P(\hat{y}^{&lt;t&gt;}|x,\hat{y}^{&lt;1&gt;},\cdots,\hat{y}^{&lt;t-1&gt;})\]</span> 多个概率相乘可能会使乘积结果很小，远小于1，造成数值下溢。为了解决这个问题，可以对上述乘积形式进行取对数log运算，即： <span class="math display">\[\arg\max_{y}\sum_{t=1}^{T_{y}}\log P(y^{&lt;t&gt;}|x,y^{&lt;1&gt;},...,y^{&lt;t-1&gt;})\]</span> 因为取对数运算，将乘积转化为求和形式，避免了数值下溢，使得数据更加稳定有效。</p><p>这种概率表达式还存在一个问题，就是机器翻译的单词越多，乘积形式或求和形式得到的概率就越小，这样会造成模型倾向于选择单词数更少的翻译语句，使机器翻译受单词数目的影响，这显然是不太合适的。</p><p>因此，一种改进方式是进行长度归一化，消除语句长度影响。 <span class="math display">\[\textit{arg max }\frac1{T_y}\sum_{t=1}^{T_y}\log P(\hat{y}^{&lt;t&gt;}|x,\hat{y}^{&lt;1&gt;},\cdots,\hat{y}^{&lt;t-1&gt;})\]</span> 实际应用中，通常会引入归一化因子α： <span class="math display">\[\textit{arg max }\frac1{T_y^\alpha}\sum_{t=1}^{Ty}P(\hat{y}^{&lt;t&gt;}|x,\hat{y}^{&lt;1&gt;},\cdots,\hat{y}^{&lt;t-1&gt;})\]</span> 若α=1，则完全进行长度归一化；若α=0，则不进行长度归一化。一般令α=0.7，效果不错。</p><p>值得一提的是，与BFS (Breadth First Search) 、DFS (Depth First Search)算法不同，beam search运算速度更快，但是并不保证一定能找到正确的翻译语句。</p><p>Beam search是一种近似搜索算法。</p><p>实际应用中，如果机器翻译效果不好，需要通过错误分析，判断是RNN模型问题还是beam search算法问题。</p><p>一般来说，增加训练样本、增大beam search参数B都能提高准确率。</p><p>但是，这种做法并不能得到我们期待的性能，且并不实际。</p><p>首先，为待翻译语句建立人工翻译，记为y∗。</p><p>在RNN模型上使用beam search算法，得到机器翻译，记为y^。</p><p>显然，人工翻译y∗最为准确。</p><ul><li><p>Jane visite l’Afrique en septembre.</p></li><li><p>Human: Jane visits Africa in September. y∗</p></li><li><p>Algorithm: Jane visited Africa last September. y^</p></li></ul><p>这样，整个模型包含两部分：RNN和beam search算法。</p><p>然后，将输入语句输入到RNN模型中，<span class="math inline">\(y^*\)</span>和<span class="math inline">\(\hat{y}\)</span>放入输出层中？分别计算输出是<span class="math inline">\(y^*\)</span>的概率<span class="math inline">\(P(y^*|x)\)</span>和<span class="math inline">\(\hat{y}\)</span>的概率<span class="math inline">\(P(\hat{y}|x)\)</span>。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_10.png" /></p><p>接下来就是比较<span class="math inline">\(P(y^*|x)\)</span>和<span class="math inline">\(P(\hat{y}|x)\)</span>的大小。</p><ul><li><span class="math inline">\(P(y^*|x)&gt;P(\hat{y}|x)\)</span> : Beam search算法有误</li><li><span class="math inline">\(P(y^*|x)&lt;P(\hat{y}|x)\)</span> : RNN模型有误</li></ul><p>如果beam search算法表现不佳，可以调试参数B；若RNN模型不好，则可以增加网络层数，使用正则化，增加训练样本数目等方法来优化。</p><h1 id="bleu-score">5. Bleu Score</h1><p>使用bleu score，对机器翻译进行打分。</p><p>首先，对原语句建立人工翻译参考，一般有多个人工翻译（利用验证集和测试集）。例如下面这个例子：</p><ul><li><p>French: Le chat est sur le tapis.</p></li><li><p>Reference 1: The cat is on the mat.</p></li><li><p>Reference 2: There is a cat on the mat.</p></li></ul><p>上述两个人工翻译都是正确的，作为参考。相应的机器翻译如下所示：</p><ul><li><p>French: Le chat est sur le tapis.</p></li><li><p>Reference 1: The cat is on the mat.</p></li><li><p>Reference 2: There is a cat on the mat.</p></li><li><p>MT output: the the the the the the the.</p></li></ul><p>如上所示，机器翻译为“the the the the the the the.”，效果很差。</p><p>Bleu Score的宗旨是机器翻译越接近参考的人工翻译，其得分越高，方法原理就是看机器翻译的各个单词是否出现在参考翻译中。</p><p>最简单的准确度评价方法是看机器翻译的每个单词是否出现在参考翻译中。</p><p>显然，上述机器翻译的每个单词都出现在参考翻译里，准确率为7/7=1，其中，分母为机器翻译单词数目，分子为相应单词是否出现在参考翻译中。</p><p>但是，这种方法很不科学，并不可取。</p><p>另外一种评价方法是看机器翻译单词出现在参考翻译单个语句中的次数，取最大次数。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_11.png" /> 上述例子对应的准确率为2/7，其中，分母为机器翻译单词数目，分子为相应单词出现在参考翻译中的次数（分子为2是因为“the”在参考1中出现了两次）。</p><p>这种评价方法较为准确。</p><p>上述两种方法都是对单个单词进行评价。</p><p>按照beam search的思想，另外一种更科学的打分方法是bleu score on bigrams，即同时对两个连续单词进行打分。</p><p>仍然是上面那个翻译例子：</p><ul><li><p>French: Le chat est sur le tapis.</p></li><li><p>Reference 1: The cat is on the mat.</p></li><li><p>Reference 2: There is a cat on the mat.</p></li><li><p>MT output: The cat the cat on the mat.</p></li></ul><p>对MIT output进行分解，得到的bigrams及其出现在MIT output中的次数count为：</p><ul><li>the cat: 2</li><li>cat the: 1</li><li>cat on: 1</li><li>on the: 1</li><li>the mat: 1</li></ul><p>然后，统计上述bigrams出现在参考翻译单个语句中的次数（取最大次数）countclipcountclip为：</p><ul><li>the cat: 1</li><li>cat the: 0</li><li>cat on: 1<br /></li><li>on the: 1</li><li>the mat: 1</li></ul><p><img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_12.png" /></p><p>相应的bigrams precision为： <span class="math display">\[\frac{count_{clip}}{count}=\frac{1+0+1+1+1}{2+1+1+1+1}=\frac46=\frac23\]</span> 如果只看单个单词，相应的unigrams precision为：</p><p><span class="math display">\[p_{1}=\frac{\sum_{unigram\in\hat{y}}count_{clip}\:(unigram)}{\sum_{unigram\in\hat{y}}count\:(unigram)}\]</span> 如果是n个连续单词，相应的n-grams precision为： <span class="math display">\[p_n=\frac{\sum_{ngram\in\hat{y}}count_{clip}\left(ngram\right)}{\sum_{ngram\in\hat{y}}count\left(ngram\right)}\]</span> 总结一下，可以同时计算p1,⋯,pn，再对其求平均： <span class="math display">\[p=\frac1n\sum_{i=1}^np_i\]</span> 通常，对上式进行指数处理，并引入参数因子brevity penalty，记为BP。 <span class="math display">\[p=BP\cdot exp(\frac1n\sum_{i=1}^np_i)\]</span> 顾名思义，BP是为了“惩罚”机器翻译语句过短而造成的得分“虚高”的情况。</p><p>其中，BP值由机器翻译长度和参考翻译长度共同决定。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_13.png" /></p><h1 id="注意力模型">6. 注意力模型</h1><p>如果原语句很长，要对整个语句输入RNN的编码网络和解码网络进行翻译，则效果不佳。</p><p>相应的bleu score会随着单词数目增加而逐渐降低。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_15.png" /> 对待长语句，正确的翻译方法是将长语句分段，每次只对长语句的一部分进行翻译。</p><p>人工翻译也是采用这样的方法，高效准确。</p><p>也就是说，每次翻译只注重一部分区域，这种方法使得bleu score不太受语句长度的影响。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_14.png" /> 根据这种“局部聚焦”的思想，建立相应的注意力模型（attention model）。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_16.png" /></p><p><img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_17.png" /> 如上图所示，attention model仍由类似的编码网络 (下)和解码网络(上)构成。其中，<span class="math inline">\(S^{&lt;t&gt;}\)</span>由原语句附近单元共同决定，原则上说，离得越近，注意力权重( attention weights )越大，相当于在你当前的注意力区域有个滑动窗。</p><p>Attention model中选择双向RNN，可以使用GRU单元或者LSTM。由于是双向RNN，每个<span class="math inline">\(a^{&lt;t^{\prime}&gt;}\)</span>表示： <span class="math display">\[a^{&lt;t^{\prime}&gt;}=(a^{\to&lt;t^{\prime}&gt;},a^{\leftarrow&lt;t^{\prime}&gt;})\]</span> RNN编码生成特征，注意力权重用<span class="math inline">\(\alpha\)</span>表示，C是各个RNN神经元经过注意力权重得到的参数值。例如， <span class="math inline">\(\alpha^{&lt;1,t^{\prime}&gt;}\)</span>表示机器翻译的第一个单词 "jane" 对应的第t' 个RNN神经元，<span class="math inline">\(C^{&lt;1&gt;}\)</span>表示机器翻译第一个单词 "jane" 对应的解码网络输入参数。满足： <span class="math display">\[\sum_{t^{\prime}}\alpha^{&lt;1,t^{\prime}&gt;}=1\]</span> <span class="math display">\[C^{&lt;1&gt;}=\sum_{t&#39;}\alpha^{&lt;1,t&#39;&gt;}\cdot a^{&lt;t&#39;&gt;}\]</span> 也就是说，<span class="math inline">\(\alpha^{&lt;t,t^{\prime}&gt;}\)</span>表示输出<span class="math inline">\(\hat{y}^{&lt;t&gt;}\)</span>对RNN单元 <span class="math inline">\(a^{&lt;t^{\prime}&gt;}\)</span> 的注意力权重因子。 为了让<span class="math inline">\(\alpha^{&lt;t,t^{\prime}&gt;}\)</span>之和为1，利用softamx思想，引入参数<span class="math inline">\(e^{&lt;t,t^{\prime}&gt;}\)</span>,使得： <span class="math display">\[\alpha^{&lt;t,t^{\prime}&gt;}=\frac{e^{&lt;t,t^{\prime}&gt;}}{\sum_{t^{\prime}}^{Tx}e^{&lt;t,t^{\prime}&gt;}}\]</span> 这样，只要求出<span class="math inline">\(e^{&lt;t,t^{\prime}&gt;}\)</span>,就能得到<span class="math inline">\(\alpha^{&lt;t,t^{\prime}&gt;}\)</span></p><p>如何求出<span class="math inline">\(e^{&lt;t,t^{\prime}&gt;}\)</span>呢？ 方法是建立一个简单的神经网络，如下图所示。输入是<span class="math inline">\(S^{&lt;t-1&gt;}\)</span>和$a<sup>{t</sup>{}}$1，输出是 <span class="math inline">\(e^{&lt;t,t^{\prime}&gt;}\)</span>。</p><p><img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_18.png" /></p><p>然后，利用梯度下降算法迭代优化，计算得到<span class="math inline">\(e^{&lt;t,t^{\prime}&gt;}\)</span>和<span class="math inline">\(\alpha^{&lt;t,t^{\prime}&gt;}\)</span>。</p><p>Attention model的一个缺点是其计算量较大，若输入句子长度为Tx，输出句子长度为Ty，则计算时间约为Tx∗Ty。</p><p>但是，其性能提升很多，计算量大一些也是可以接受的。</p><h1 id="语音识别">7. 语音识别</h1><p>深度学习中，语音识别的输入是声音，量化成时间序列。</p><p>更一般地，可以把信号转化为频域信号，即声谱图（spectrogram），再进入RNN模型进行语音识别。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_19.png" /> 之前，语言学家们会将语音中每个单词分解成多个音素（phoneme），构建更精准的传统识别算法。</p><p>但在end-to-end深度神经网络模型中，一般不需要这么做也能得到很好的识别效果。</p><p>通常训练样本很大，需要上千上万个小时的语音素材。</p><p>语音识别的注意力模型（attention model）如下图所示： <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_20.png" /> 一般来说，语音识别的输入时间序列都比较长，例如是10s语音信号，采样率为100Hz，则语音长度为1000。</p><p>而翻译的语句通常很短，例如“the quick brown fox”，包含19个字符。</p><p>这时候，Tx与Ty差别很大。为了让Tx=Ty，可以把输出相应字符重复并加入空白（blank），形如： <span class="math display">\[ttt\_h\_eee\_\_\_\sqcup\_\_\_\_qqq\_\_\cdots \]</span> 其中，下划线”<em>“表示空白，”⊔“表示两个单词之间的空字符。这种写法的一个基本准则是没有被空白符”</em>“分割的重复字符将被折叠到一起，即表示一个字符。</p><p>这样，加入了重复字符和空白符、空字符，可以让输出长度也达到1000，即Tx=Ty。这种模型被称为CTC（Connectionist temporal classification）。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_21.png" /></p><h1 id="触发字检测">8. 触发字检测</h1><p>触发字检测（Trigger Word Detection）在很多产品中都有应用，操作方法就是说出触发字通过语音来启动相应的设备。</p><p>例如Amazon Echo的触发字是”Alexa“，百度DuerOS的触发字是”小度你好“，Apple Siri的触发字是”Hey Siri“，Google Home的触发字是”Okay Google“。</p><p>触发字检测系统可以使用RNN模型来建立。</p><p>如下图所示，输入语音中包含一些触发字，其余都是非触发字。</p><p>RNN检测到触发字后输出1，非触发字输出0。</p><p>这样训练的RNN模型就能实现触发字检测。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_22.png" /> 但是这种模型有一个缺点，就是通常训练样本语音中的触发字较非触发字数目少得多，即正负样本分布不均。</p><p>一种解决办法是在出现一个触发字时，将其附近的RNN都输出1。这样就简单粗暴地增加了正样本。 <img src="/img/深度学习-Course5-Week3/3序列模型和注意力机制_23.png" /></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习-Course5-Week2自然语言处理与词嵌入</title>
    <link href="/2024/02/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course5-Week2%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%B8%8E%E8%AF%8D%E5%B5%8C%E5%85%A5/"/>
    <url>/2024/02/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course5-Week2%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%B8%8E%E8%AF%8D%E5%B5%8C%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="word-embedding">1. word embedding</h1><p>上节课我们介绍过表征单词的方式是首先建立一个较大的词汇表（例如10000），然后使用one-hot的方式对每个单词进行编码。</p><ul><li>例如，单词Man，Woman，King，Queen，Apple，Orange分别出现在词汇表的第5391，9853，4914，7157，456，6257的位置，则它们分别用O5391，O9853，O4914，O7157，O456，O6257表示。</li></ul><p>这种one-hot表征单词的方法最大的缺点就是每个单词都是独立的、正交的，无法知道不同单词之间的相似程度。</p><ul><li>例如，Apple和Orange都是水果，词性相近，但是单从one-hot编码上来看，内积为零，无法知道二者的相似性。在NLP中，我们更希望能掌握不同单词之间的相似程度。</li></ul><p>因此，我们可以使用特征表征（Featurized representation）的方法对每个单词进行编码。也就是使用一个特征向量表征单词，特征向量的每个元素都是对该单词某一特征的量化描述，量化范围可以是[-1,1]之间。特征表征的例子如下图所示。 <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入_1.png" /> 特征向量的长度依情况而定，特征元素越多则对单词表征得越全面。这里的特征向量长度设定为300。</p><p>使用特征表征之后，词汇表中的每个单词都可以使用对应的300 x 1的向量来表示，该向量的每个元素表示该单词对应的某个特征值。</p><p>每个单词用e+词汇表索引的方式标记，例如e5391, e9853, e4914, e7157, e456, e6257。</p><p>这种特征表征的优点是根据特征向量能清晰知道不同单词之间的相似程度，例如Apple和Orange之间的相似度较高，很可能属于同一类别。</p><p>这种单词“类别”化的方式，大大提高了有限词汇量的泛化能力。</p><p>这种特征化单词的操作被称为Word Embeddings，即单词嵌入。</p><p>值得一提的是，这里特征向量的每个特征元素含义是具体的，对应到实际特征，例如性别、年龄等。</p><p>而在实际应用中，特征向量很多特征元素并不一定对应到有物理意义的特征，是比较抽象的。</p><p>但是，这并不影响对每个单词的有效表征，同样能比较不同单词之间的相似性。</p><p>每个单词都由高维特征向量表征，为了可视化不同单词之间的相似性，可以使用降维操作，例如t-SNE算法，将300D降到2D平面上。如下图所示。 <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入_2.png" /> 从上图可以看出相似的单词分布距离较近，从而也证明了Word Embeddings能有效表征单词的关键特征。</p><p>之前我们介绍过Named entity识别的例子，每个单词采用的是one-hot编码。</p><p>下图中，因为“orange farmer”是份职业，很明显“Sally Johnson”是一个人名。 <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入_4.png" /> 如果采用featurized representation对每个单词进行编码，再构建该RNN模型。</p><p>一个新的句子：Robert Lin is an apple farmer。</p><p>由于这两个句子中，“apple”与“orange”特征向量很接近，很容易能判断出“Robert Lin”也是一个人名。这就是featurized representation的优点之一。</p><p>可以看出，featurized representation的优点是可以减少训练样本的数目，前提是对海量单词建立特征向量表述（word embedding）。</p><p>② 这样，即使训练样本不够多，测试时遇到陌生单词，例如“durian cultivator”，根据之前海量词汇特征向量就判断出“durian”也是一种水果，与“apple”类似，而“cultivator”与“farmer”也很相似。从而得到与“durian cultivator”对应的应该也是一个人名。</p><p>③ 这种做法将单词用不同的特征来表示，即使是训练样本中没有的单词，也可以根据word embedding的结果得到与其词性相近的单词，从而得到与该单词相近的结果，有效减少了训练样本的数量。</p><p>① featurized representation的特性使得很多NLP任务能方便地进行迁移学习，方法是：</p><ul><li><p>从海量词汇库中学习word embeddings，即所有单词的特征向量。或者从网上下载预训练好的word embeddings。</p></li><li><p>使用较少的训练样本，将word embeddings迁移到新的任务中。</p></li><li><p>（可选）：继续使用新数据微调word embeddings。</p></li></ul><p>② 建议仅当训练样本足够大的时候，再进行上述第三步。</p><p>① 有趣的是，word embeddings与人脸识别与神经风格迁移中介绍的人脸特征编码有很多相似性。</p><p>② 人脸图片经过Siamese网络，得到其特征向量f(x)，这点跟word embedding是类似的。</p><p>③ 二者不同的是Siamese网络输入的人脸图片可以是数据库之外的；而word embedding一般都是已建立的词汇库中的单词，非词汇库单词统一用&lt; UNK &gt;表示。</p><p>① Word embeddings可以帮助我们找到不同单词之间的相似类别关系，如下图所示。 <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入_5.png" /> ② 上例中，特征维度是4维的，分别是[Gender, Royal, Age, Food]。</p><p>③ 常识地，“Man”与“Woman”的关系类比于“King”与“Queen”的关系。而利用Word embeddings可以找到这样的对应类比关系。</p><p>① 我们将“Man”的embedding vector与“Woman”的embedding vector相减： <span class="math display">\[e_{man}-e_{woman}=\begin{bmatrix}-1\\0.01\\0.03\\0.09\end{bmatrix}-\begin{bmatrix}1\\0.02\\0.02\\0.01\end{bmatrix}\approx\begin{bmatrix}-2\\0\\0\\0\end{bmatrix}\]</span> ② 类似地，我们将“King”的embedding vector与“Queen”的embedding vector相减： <span class="math inline">\(e_{king}-e_{queen}=\begin{bmatrix}-0.95\\0.93\\0.70\\0.02\end{bmatrix}-\begin{bmatrix}0.97\\0.95\\0.69\\0.01\end{bmatrix}\approx\begin{bmatrix}-2\\0\\0\\0\end{bmatrix}\)</span> ③ 相减结果表明，“Man”与“Woman”的主要区别是性别，“King”与“Queen”也是一样。</p><p>④ 一般地，A类比于B相当于C类比于“？”，这类问题可以使用embedding vector进行运算。 <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入_6.png" /></p><p>如 上 图 所 示 , 根 据 等 式<span class="math inline">\(e_{man}-e_{woman}\approx e_{king}-e_{?}\)</span>得： <span class="math display">\[e_{?}=e_{king}-e_{man}+e_{woman}\]</span> 利用相似函数，计算与<span class="math inline">\(e_{king}-e_{man}+e_{woman}\)</span>相似性最大的<span class="math inline">\(e\)</span>?，得到<span class="math inline">\(e_{?}=e_{queen}\)</span>。 关于相似函数，比较常用的是cosine similarity。其表达式为： <span class="math display">\[Sim(u,v)=\frac{u^Tv}{||u||\cdot||v||}\]</span> ⑤ 还可以计算Euclidian distance来比较相似性，即||u−v||^2。距离越大，相似性越小。</p><p>① 假设某个词汇库包含了10000个单词，每个单词包含的特征维度为300，那么表征所有单词的embedding matrix维度为300 x 10000，用E来表示。</p><p>② 某单词w的one-hot向量表示为Ow，维度为10000 x 1，则该单词的embedding vector表达式为： <span class="math display">\[e_w=E\cdot O_w\]</span> ③ 因此，只要知道了embedding matrix E，就能计算出所有单词的embedding vector ew。后面我们将重点介绍如何求出E。</p><p>④ 值得一提的是，上述这种矩阵乘积运算<span class="math inline">\(E ⋅ O_{w}\)</span>效率并不高，矩阵维度很大，且<span class="math inline">\(O_{w}\)</span>大部分元素为零。通常做法是直接从E中选取第<span class="math inline">\(w\)</span>列作为<span class="math inline">\(e_{w}\)</span>即可。</p><p>① embedding matrix E可以通过构建自然语言模型，运用梯度下降算法得到。</p><p>② 举个简单的例子，输入样本是下面这句话：</p><ul><li>I want a glass of orange (juice).</li></ul><p>③ 通过这句话的前6个单词，预测最后的单词“juice”。</p><p>④ E未知待求，每个单词可用embedding vector ew表示。</p><p>⑤ 构建的神经网络模型结构如下图所示： <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入.png" /> 神经网络输入层包含6个embedding vactors,每个embedding vector维度是300，则输入层总共有1800个输入。Softmax层有10000个概率输出，与词汇表包含的单词数目一致。正确的输出label是 "juice" 。其中<span class="math inline">\(E,W^{[1]},b^{[1]},W^{[2]},b^{[2]}\)</span>为待求值。对足够的训练例句样本，运用梯度下降算法， 迭代优化，最终求出embedding matrix <span class="math inline">\(E\)</span>。</p><p>==E随机初始化，由O和E得到e，输入神经网络，得到输出，计算损失值，反向传播，更新e，进而更新E。==</p><p>⑥ 这种算法的效果还不错，能够保证具有相似属性单词的embedding vector相近。</p><p>⑦ 为了让神经网络输入层数目固定，可以选择只取预测单词的前4个单词作为输入，例如该句中只选择“a glass of orange”四个单词作为输入。当然，这里的4是超参数，可调。</p><p>⑧ 一般地，我们把输入叫做context，输出叫做target。对应到上面这句话里：</p><ul><li><p>context: a glass of orange</p></li><li><p>target: juice</p></li><li><p>关于context的选择有多种方法：</p></li><li><p>target前n个单词或后n个单词，n可调</p></li><li><p>target前1个单词</p></li><li><p>target附近某1个单词（Skip-Gram）</p></li></ul><p>⑨ 事实证明，不同的context选择方法都能计算出较准确的embedding matrix E。</p><blockquote><p>根据提供的搜索结果，词嵌入的矩阵E是通过构建自然语言模型并应用梯度下降算法得到的。具体而言，词嵌入模型可以使用梯度下降算法来学习词嵌入矩阵E。在训练过程中，模型使用输入样本（例如句子）的一部分来预测样本的某个特定单词。神经网络模型的输入层包含一组嵌入向量，每个向量代表一个单词。这些嵌入向量被映射到待求的词嵌入矩阵E中。然后，通过模型的训练过程，对模型参数进行梯度下降优化，包括嵌入矩阵E、权重W和偏置b等。</p></blockquote><blockquote><p>训练过程中，模型不断调整词嵌入矩阵E的数值，使其能够更好地表示单词之间的语义关系和上下文信息。通过预测任务的优化过程，模型可以学习到适合特定任务的词嵌入表示。</p></blockquote><blockquote><p>需要注意的是，具体的词嵌入实现方法和训练细节可能因模型而异。上述提到的具体示例涉及一个使用梯度下降算法训练的神经网络模型，该模型使用前几个单词来预测后续的一个单词，并通过梯度下降来更新词嵌入矩阵E以优化预测准确性[1]。</p></blockquote><h1 id="skip-gram">2. Skip-Gram</h1><blockquote><p>Skip-Gram算法是一种用于学习词嵌入的模型，其目标是在给定中心词的情况下，预测其周围上下文单词的概率分布。具体而言，Skip-Gram算法通过训练神经网络模型来优化词嵌入矩阵，以便更好地表示单词之间的语义关系和上下文信息。</p></blockquote><blockquote><p>在Skip-Gram算法中，输入是一个中心词，而输出是中心词周围的上下文单词。模型首先使用词嵌入矩阵来将输入的中心词表示为连续向量。然后，通过神经网络模型，在给定中心词的情况下，预测周围上下文单词的概率分布。具体而言，模型可以使用softmax函数来计算每个可能的上下文单词的概率。通过最大化预测的概率分布与实际上下文单词的匹配程度，模型可以通过梯度下降算法来优化词嵌入矩阵，从而得到更好的词向量表示。最终的目标是使得给定中心词的情况下，模型预测出的上下文单词概率尽可能接近实际上下文单词的分布。</p></blockquote><blockquote><p>Skip-Gram算法的优点之一是能够利用大量的训练数据来学习丰富的语义信息。通过将输入的中心词与周围上下文单词进行预测任务，==模型可以学习到单词之间的关联和语义相似性==。这使得Skip-Gram算法在自然语言处理任务中得到了广泛的应用，例如词义相似度计算、文本分类、机器翻译等。</p></blockquote><p>① 上一小节我们介绍了context和target的选择方法，比较流行的是采用Skip-Gram模型。</p><p>② Skip-Gram模型是Word2Vec的一种，Word2Vec的另外一种模型是CBOW（Continuous Bag of Words）。关于CBOW此处不再赘述。</p><p>① 以下面这句话为例：</p><ul><li>I want a glass of orange juice to go along with my cereal.</li></ul><p>② Skip-Gram模型的做法是：首先随机选择一个单词作为context，例如“orange”；然后使用一个宽度为5或10（自定义）的滑动窗，在context附近选择一个单词作为target，可以是“juice”、“glass”、“my”等等。</p><p>③ 最终得到了多个context—target对作为监督式学习样本。</p><p>① 训练的过程是构建自然语言模型，经过softmax单元的输出为：</p><p><span class="math display">\[\hat{y}=\frac{e^{\theta_t^T\cdot e_c}}{\sum_{j=1}^{10000}e^{\theta_j^T\cdot e_c}}\]</span></p><p>其中，<span class="math inline">\(\theta_t\)</span>为target对应的参数，<span class="math inline">\(e_c\)</span>为context的embedding vector,且<span class="math inline">\(e_c=E\cdot O_c\)</span>。</p><p>② 相应的loss function为： <span class="math display">\[L(\hat{y},y)=-\sum_{i=1}^{10000}y_ilog\hat{y}_i\]</span> ③ 然后，运用梯度下降算法，迭代优化，最终得到embedding matrix E。</p><p>④ 然而，这种算法计算量大，影响运算速度。主要因为softmax输出单元为10000个，y^计算公式中包含了大量的求和运算。</p><p>⑤ 解决的办法之一是使用hierarchical softmax classifier，即树形分类器。其结构如下图所示： <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入_7.png" /> ① 这种树形分类器是一种二分类。与之前的softmax分类器不同，它在每个数节点上对目标单词进行区间判断，最终定位到目标单词。</p><p>② 这好比是猜数字游戏，数字范围0～100。我们可以先猜50，如果分类器给出目标数字比50大，则继续猜75，以此类推，每次从数据区间中部开始。</p><p>③ 这种树形分类器最多需要log N步就能找到目标单词，N为单词总数。</p><p>④ 实际应用中，对树形分类器做了一些改进。改进后的树形分类器是非对称的，通常选择把比较常用的单词放在树的顶层，而把不常用的单词放在树的底层。这样更能提高搜索速度。</p><p>① 最后提一点，关于context的采样，需要注意的是如果使用均匀采样，那么一些常用的介词、冠词，例如the, of, a, and, to等出现的概率更大一些。</p><p>② 但是，这些单词的embedding vectors通常不是我们最关心的，我们更关心例如orange, apple， juice等这些名词等。</p><p>③ 所以，实际应用中，一般不选择随机均匀采样的方式来选择context，而是使用其它算法来处理这类问题。</p><blockquote><p>softmax的版本，每次根据上下文去预测下一个词，输出时候需要计算这个上下文词下面接的是词表中所有词的概率。</p></blockquote><h1 id="negative-sampling">3. Negative Sampling</h1><p>① Negative sampling是另外一种有效的求解embedding matrix E的方法。 <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入_8.png" /> ② 它的做法是判断选取的context word和target word是否构成一组正确的context-target对，一般包含一个正样本和k个负样本。</p><p>③ 例如，“orange”为context word，“juice”为target word，很明显“orange juice”是一组context-target对，为正样本，相应的target label为1。若“orange”为context word不变，target word随机选择“king”、“book”、“the”或者“of”等，这些都不是正确的context-target对，为负样本，相应的target label为0。</p><p>④ 一般地，固定某个context word对应的负样本个数k一般遵循：</p><ul><li><p>若训练样本较小，k一般选择5～20；</p></li><li><p>若训练样本较大，k一般选择2～5即可。</p></li></ul><p>① Negative sampling的数学模型为： <span class="math display">\[P(y=1|c,t)=\sigma(\theta_t^T\cdot e_c)\]</span> ② 其中，σ表示sigmoid激活函数。</p><p>① 很明显，negative sampling某个固定的正样本对应k个负样本，即模型总共包含了k+1个binary classification。</p><p>② 对比之前介绍的10000个输出单元的softmax分类，negative sampling转化为k+1个二分类问题，计算量要小很多，大大提高了模型运算速度。</p><p>① 最后提一点，关于如何选择负样本对应的target单词，可以使用随机选择的方法。</p><p>② 但有资料提出一个更实用、效果更好的方法，就是根据该词出现的频率进行选择，相应的概率公式为： <span class="math display">\[P(w_i)=\frac{f(w_i)^{\frac34}}{\sum_j^{10000}f(w_j)^{\frac34}}\]</span> ③ 其中，f(wi)表示单词wi在单词表中出现的概率。</p><h1 id="glove-word-vectors">4. GloVe Word Vectors</h1><p>① GloVe算法引入了一个新的参数：</p><ul><li><p>Xij: 表示i出现在j之前的次数，即i和j同时出现的次数。</p></li><li><p>其中，i表示context，j表示target。</p></li></ul><p>② 一般地，如果不限定context一定在target的前面，则有对称关系Xij=Xji；如果有限定先后，则Xij≠Xji。</p><p>③ 接下来的讨论中，我们默认存在对称关系Xij=Xji。</p><p>① GloVe模型的loss function为： <span class="math display">\[L=\sum_{i=1}^{10000}\sum_{j=1}^{10000}(\theta_i^Te_j-logX_{ij})^2\]</span> ② 从上式可以看出，若两个词的embedding vector越相近，同时出现的次数越多，则对应的loss越小。</p><p>③ 为了防止出现“log 0”，即两个单词不会同时出现，无相关性的情况，对loss function引入一个权重因子f(Xij)： <span class="math display">\[L=\sum_{i=1}^{10000}\sum_{j=1}^{10000}f(X_{ij})(\theta_i^Te_j-logX_{ij})^2\]</span> ④ 当Xij=0时，权重因子f(Xij)=0。这种做法直接忽略了无任何相关性的context和target，只考虑Xij&gt;0的情况。</p><p>⑤ 出现频率较大的单词相应的权重因子f(Xij)较大，出现频率较小的单词相应的权重因子f(Xij)较小一些。</p><p>⑥ 具体的权重因子f(Xij)选取方法可查阅相关论文资料。</p><p>① 一般地，引入偏移量，则loss function表达式为： <span class="math display">\[L=\sum_{i=1}^{10000}\sum_{j=1}^{10000}f(X_{ij})(\theta_i^Te_j+b_i+b_j^{\prime}-logX_{ij})^2\]</span> ② 值得注意的是，参数θi和ej是对称的。</p><p>③ 使用优化算法得到所有参数之后，最终的ew可表示为： <span class="math display">\[e_w=\frac{e_w+\theta_w}2\]</span> ③ 最后提一点的是，无论使用Skip-Gram模型还是GloVe模型等等，计算得到的embedding matrix E的每一个特征值不一定对应有实际物理意义的特征值，如gender，age等。</p><h1 id="sentiment-classification">5. Sentiment Classification</h1><p>① 情感分类一般是根据一句话来判断其喜爱程度，例如1～5星分布，如下图所示。 <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入_9.png" /> ② 情感分类问题的一个主要挑战是缺少足够多的训练样本。</p><p>③ 而Word embedding恰恰可以帮助解决训练样本不足的问题。</p><p>① 首先介绍使用word embedding解决情感分类问题的一个简单模型算法。 <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入_10.png" /> ② 如上图所示，这句话的4个单词分别用embedding vector表示。</p><p>③ e8928, e2468, e4694, e3180计算均值，这样得到的平均向量的维度仍是300。</p><p>④ 最后经过softmax输出1～5星。</p><p>① 这种模型结构简单，计算量不大，不论句子长度多长，都使用平均的方式得到300D的embedding vector。该模型实际表现较好。</p><p>② 但是，这种简单模型的缺点是使用平均方法，没有考虑句子中单词出现的次序，忽略其位置信息。而有时候，不同单词出现的次序直接决定了句意，即情感分类的结果。例如下面这句话：</p><ul><li>Completely lacking in good taste, good service, and good ambience.</li></ul><p>③ 虽然这句话中包含了3个“good”，但是其前面出现了“lacking”，很明显这句话句意是negative的。如果使用上面介绍的平均算法，则很可能会错误识别为positive的，因为忽略了单词出现的次序。</p><p>① 为了解决这一问题，情感分类的另一种模型是RNN。 <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入_11.png" /> ② 该RNN模型是典型的many-to-one模型，考虑单词出现的次序，能够有效识别句子表达的真实情感。</p><p>③ 值得一提的是使用word embedding，能够有效提高模型的泛化能力，即使训练样本不多，也能保证模型有不错的性能。</p><h1 id="debiasing-word-embeddings">6. Debiasing Word Embeddings</h1><p>① Word embeddings中存在一些性别、宗教、种族等偏见或者歧视，例如下面这两句话：</p><ul><li><p>Man: Woman as King: Queen</p></li><li><p>Man: Computer programmer as Woman: Homemaker</p></li><li><p>Father: Doctor as Mother: Nurse</p></li></ul><p>② 很明显，第二句话和第三句话存在性别偏见，因为Woman和Mother也可以是Computer programmer和Doctor。</p><p>③ 以性别偏见为例，我们来探讨下如何消除word embeddings中偏见。 <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入_12.png" /> ① 首先，确定偏见bias的方向。方法是对所有性别对立的单词求差值，再平均。上图展示了bias direction和non-bias direction。 <span class="math display">\[\textit{bias direction}=\frac1N((e_{he}-e_{she})+(e_{male}-e_{female})+\cdots)\]</span> ② 然后，单词中立化（Neutralize）。将需要消除性别偏见的单词投影到non-bias direction上去，消除bias维度，例如babysitter，doctor等。 <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入_13.png" /> ③ 最后，均衡对（Equalize pairs）。让性别对立单词与上面的中立词距离相等，具有同样的相似度。例如让grandmother和grandfather与babysitter的距离同一化。 <img src="/img/深度学习-Course5-Week2/2自然语言处理与词嵌入_14.png" /> ④ 值得注意的是，掌握哪些单词需要中立化非常重要。一般来说，大部分英文单词，例如职业、身份等都需要中立化，消除embedding vector中性别这一维度的影响。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习-Course5-Week1循环序列模型</title>
    <link href="/2024/02/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course5-Week1%E5%BE%AA%E7%8E%AF%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/02/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course5-Week1%E5%BE%AA%E7%8E%AF%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="序列模型">1 序列模型</h1><p>序列模型能够应用在许多领域，例如：</p><ul><li>语音识别</li><li>音乐发生器</li><li>情感分类</li><li>DNA序列分析</li><li>机器翻译</li><li>视频动作识别</li><li>名称实体识别</li></ul><p><img src="/img/深度学习-Course5-Week1/1循环序列模型.png" /></p><p>这些序列模型基本都属于监督式学习，但输入x和输出y不一定都是序列模型。</p><p>如果都是序列模型的话，模型输入长度，输出长度也不一定完全一致。</p><h1 id="名称实体识别">2 名称实体识别</h1><p>下面以名称实体识别为例，介绍序列模型的命名规则，示例语句为：</p><ul><li>Harry Potter and Hermione Granger invented a new spell.</li></ul><p>该句话包含9个单词，输出y即为1 x 9向量，每位表征对应单词是否为人名的一部分，1表示是，0表示否。</p><p>很明显，该句话中“Harry”， “Potter”， “Hermione”， “Granger”均是人名成分，所以，对应的输出y可表示为：</p><p><span class="math display">\[y=\begin{bmatrix}1&amp;1&amp;0&amp;1&amp;1&amp;0&amp;0&amp;0&amp;0\end{bmatrix}\]</span></p><p>一般约定使用<span class="math inline">\(y^{&lt;t&gt;}\)</span>表示序列对应位置的输出，使用<span class="math inline">\(T_y\)</span>表示输出序列长度，则<span class="math inline">\(1\leq t\leq T_y\)</span>。</p><p>对于输入x，表示为： <span class="math display">\[\begin{bmatrix}x^{&lt;1&gt;}&amp;x^{&lt;2&gt;}&amp;x^{&lt;3&gt;}&amp;x^{&lt;4&gt;}&amp;x^{&lt;5&gt;}&amp;x^{&lt;6&gt;}&amp;x^{&lt;7&gt;}&amp;x^{&lt;8&gt;}&amp;x^{&lt;9&gt;}\end{bmatrix}\]</span></p><p>同样，<span class="math inline">\(x^{&lt;t&gt;}\)</span>表示序列对应位置的输入，<span class="math inline">\(T_x\)</span>表示输入序列长度。注意，此例中，<span class="math inline">\(T_x=T_y\)</span>,但是也存在<span class="math inline">\(T_x\neq T_y\)</span>的情况。</p><p>如何来表示每个<span class="math inline">\(x^{&lt;t&gt;}\)</span>呢？方法是首先建立一个词汇库vocabulary，尽可能包含更多的词汇。例如一个包含10000个词汇的词汇库为： <img src="/img/深度学习-Course5-Week1/1循环序列模型_1.png" /></p><p>该词汇库可看成是 10000 x 1 的向量。</p><p>然后，使用one-hot编码，例句中的每个单词<span class="math inline">\(x^{&lt;t&gt;}\)</span>都可以表示成10000 x 1的向量，词汇表中与<span class="math inline">\(x^{&lt;t&gt;}\)</span>对应的位置为1，其它位置为0。该<span class="math inline">\(x^{&lt;t&gt;}\)</span>为one-hot向量。如果出现词汇表之外的单词，可以使用UNK或其他字符串来表示。</p><p>对于多样本，以上序列模型对应的命名规则可表示为：<span class="math inline">\(X^{(i)&lt;t&gt;}\)</span>，<span class="math inline">\(y^{(i)&lt;t&gt;}\)</span>，<span class="math inline">\(T_x^{(i)}\)</span>，<span class="math inline">\(T_y^{(i)}\)</span>。其中，<span class="math inline">\(i\)</span>表示第i个样本。不同样本的<span class="math inline">\(T_x^{(i)}\)</span>或<span class="math inline">\(T_y^{(i)}\)</span>都有可能不同。</p><h1 id="rnn">3 RNN</h1><p>标准的神经网络不适合解决序列模型问题，而循环神经网络（RNN）是专门用来解决序列模型问题的。</p><p>RNN模型结构如下：</p><p><img src="/img/深度学习-Course5-Week1/1循环序列模型_2.png" /></p><p>序列模型从左到右，依次传递，此例中，<span class="math inline">\(T_x=T_y\)</span>。<span class="math inline">\(x^{&lt;t&gt;}\)</span>到<span class="math inline">\(\hat{y}^{&lt;t&gt;}\)</span>之间是隐藏神经元。<span class="math inline">\(a^{&lt;t&gt;}\)</span>会传入到第<span class="math inline">\(t+1\)</span>个元素中，作为输入。其中，<span class="math inline">\(a^{&lt;0&gt;}\)</span>一般为零向量。</p><p>RNN模型包含三类权重系数，分别是<span class="math inline">\(Wax\)</span>，<span class="math inline">\(Waa\)</span>，<span class="math inline">\(Wya\)</span>。且不同元素之间同一位置共享同一权重系数。 <img src="/img/深度学习-Course5-Week1/1循环序列模型_3.png" /></p><p><img src="/img/深度学习-Course5-Week1/rnn_step_forward_figure2_v3a.png" /></p><p>RNN的正向传播（Forward Propagation）过程为：</p><p><span class="math display">\[\begin{gathered}a^{&lt;t&gt;}=g(W_{aa}\cdot a^{&lt;t-1&gt;}+W_{ax}\cdot x^{&lt;t&gt;}+ba)\\\hat{y}^{&lt;t&gt;}=g(W_{ya}\cdot a^{&lt;t&gt;}+b_y)\end{gathered}\]</span></p><p>其中，g(⋅)表示激活函数，不同的问题需要使用不同的激活函数。</p><p>为了简化表达式，可以对上式进行整合：</p><p><span class="math display">\[\left.W_{aa}\cdot a^{&lt;t-1&gt;}+W_{ax}\cdot x^{&lt;t&gt;}=[W_{aa}W_{ax}]\left[\begin{array}{c}a^{&lt;t-1&gt;}\\x^{&lt;t&gt;}\end{array}\right.\right]\to W_a[a^{&lt;t-1&gt;},x^{&lt;t&gt;}]\]</span></p><p>则正向传播可表示为： <span class="math display">\[\begin{gathered}a^{&lt;t&gt;}=g(W_a[a^{&lt;t-1&gt;},x^{&lt;t&gt;}]+b_a)\\\hat{y}^{&lt;t&gt;}=g(W_y\cdot a^{&lt;t&gt;}+b_y)\end{gathered}\]</span></p><p>针对上面识别人名的例子，经过RNN正向传播，单个元素的Loss function为：</p><p><span class="math display">\[L^{&lt;t&gt;}(\hat{y}^{&lt;t&gt;},y^{&lt;t&gt;})=-y^{&lt;t&gt;}log\hat{y}^{&lt;t&gt;}-(1-y^{&lt;t&gt;})log(1-\hat{y}^{&lt;t&gt;})\]</span></p><p>该样本所有元素的Loss function为：</p><p><span class="math display">\[L(\hat{y},y)=\sum_{t=1}^{T_y}L^{&lt;t&gt;}(\hat{y}^{&lt;t&gt;},y^{&lt;t&gt;})\]</span></p><p>然后，反向传播（Backpropagation）过程就是从右到左分别计算L(y^,y)对参数Wa，Wy，ba，by的偏导数。思路与做法与标准的神经网络是一样的。一般可以通过成熟的深度学习框架自动求导，例如PyTorch、Tensorflow等。</p><p>这种从右到左的求导过程被称为Backpropagation through time。</p><h1 id="不同种类rnn">4 不同种类RNN</h1><p>以上介绍的例子中，Tx=Ty。但是在很多RNN模型中，Tx是不等于Ty的。</p><p>根据Tx与Ty的关系，RNN模型包含以下几个类型：</p><ul><li>One to one: Tx=1,Ty=1Tx=1,Ty=1</li><li>One to many: Tx=1,Ty&gt;1Tx=1,Ty&gt;1</li><li>Many to one: Tx&gt;1,Ty=1Tx&gt;1,Ty=1</li><li>Many to many: Tx=TyTx=Ty<br /></li><li>Many to many: Tx≠TyTx≠Ty</li></ul><p>不同类型相应的示例结构如下： <img src="/img/深度学习-Course5-Week1/1循环序列模型_4.png" /></p><p>Many to many: Tx≠TyTx≠Ty 有文本翻译等。</p><h1 id="语言模型和序列生成">5 语言模型和序列生成</h1><p>语言模型是自然语言处理（NLP）中最基本和最重要的任务之一。</p><p>使用RNN能够很好地建立需要的不同语言风格的语言模型。</p><p>什么是语言模型呢？举个例子，在语音识别中，某句语音有两种翻译：</p><ul><li><p>The apple and pair salad.</p></li><li><p>The apple and pear salad.</p></li></ul><p>很明显，第二句话更有可能是正确的翻译。</p><p>语言模型实际上会计算出这两句话各自的出现概率。比如第一句话概率为<span class="math inline">\(10^{−13}\)</span>，第二句话概率为<span class="math inline">\(10^{−10}\)</span>。</p><p>也就是说，利用语言模型得到各自语句的概率，选择概率最大的语句作为正确的翻译。</p><p>概率计算的表达式为： <span class="math display">\[P(y^{&lt;1&gt;},y^{&lt;2&gt;},\cdots,y^{&lt;Ty&gt;})\]</span> 如何使用RNN构建语言模型？</p><p>首先，我们需要一个足够大的训练集，训练集由大量的单词语句语料库（corpus）构成。</p><p>然后，对corpus的每句话进行切分词（tokenize）。做法就跟第2节介绍的一样，建立vocabulary，对每个单词进行one-hot编码。</p><p>例如下面这句话：</p><ul><li>The Egyptian Mau is a bread of cat.</li></ul><p>One-hot编码已经介绍过了，不再赘述。</p><p>还需注意的是，每句话结束末尾，需要加上&lt; EOS &gt;作为语句结束符。</p><p>另外，若语句中有词汇表中没有的单词，用&lt; UNK &gt;表示。假设单词“Mau”不在词汇表中，则上面这句话可表示为：</p><ul><li>The Egyptian &lt; UNK &gt; is a bread of cat. &lt; EOS &gt;</li></ul><p>准备好训练集并对语料库进行切分词等处理之后，接下来构建相应的RNN模型。 <img src="/img/深度学习-Course5-Week1/1循环序列模型_5.png" /></p><p>语言模型的RNN结构如上图所示，<span class="math inline">\(x^{&lt;1&gt;}\)</span>和<span class="math inline">\(a^{&lt;0&gt;}\)</span>均为零向量。Softmax输出层<span class="math inline">\(\hat{y}^{&lt;1&gt;}\)</span>表示出现该语句第一个单词的概率，softmax输出层<span class="math inline">\(\hat{y}^{&lt;2&gt;}\)</span>表示在第一个单词基础上出现第二个单词的概率，即条件概率，以此类推，最后是出现&lt; EOS &gt;的条件概率。</p><p>单个元素的softmax loss function为： <span class="math display">\[L^{&lt;t&gt;}(\hat{y}^{&lt;t&gt;},y^{&lt;t&gt;})=-\sum_iy_i^{&lt;t&gt;}log\hat{y}_i^{&lt;t&gt;}\]</span> 该样本所有元素的Loss function为： <span class="math display">\[L(\hat{y},y)=\sum_tL^{&lt;t&gt;}(\hat{y}^{&lt;t&gt;},y^{&lt;t&gt;})\]</span> 对语料库的每条语句进行RNN模型训练，最终得到的模型可以根据给出语句的前几个单词预测其余部分，将语句补充完整。</p><p>例如给出“Cats average 15”，RNN模型可能预测完整的语句是“Cats average 15 hours of sleep a day.”。</p><p>最后补充一点，整个语句出现的概率等于语句中所有元素出现的条件概率乘积。例如某个语句包含<span class="math inline">\(y^{&lt;1&gt;},y^{&lt;2&gt;},y^{&lt;3&gt;}\)</span>，则整个语句出现的概率为： <span class="math display">\[P(y^{&lt;1&gt;},y^{&lt;2&gt;},y^{&lt;3&gt;})=P(y^{&lt;1&gt;})\cdot P(y^{&lt;2&gt;}|y^{&lt;1&gt;})\cdot P(y^{&lt;3&gt;}|y^{&lt;1&gt;},y^{&lt;2&gt;})\]</span></p><h1 id="序列采样">6 序列采样</h1><p>利用训练好的RNN语言模型，可以进行新的序列采样，从而随机产生新的语句。</p><p>与上一节介绍的一样，相应的RNN模型如下所示： <img src="/img/深度学习-Course5-Week1/1循环序列模型_5.png" /></p><p>首先，从第一个元素输出<span class="math inline">\(\hat{y}^{&lt;1&gt;}\)</span>的softmax分布中随机选取一个word作为新语句的首单词。然后，<span class="math inline">\(y^{&lt;1&gt;}\)</span>作为<span class="math inline">\(x^{&lt;2&gt;}\)</span> ,得到<span class="math inline">\(\hat{y}^{&lt;1&gt;}\)</span>的softmax分布。从中选取概率最大的word作为<span class="math inline">\(y^{&lt;2&gt;}\)</span>,继续将<span class="math inline">\(y^{&lt;2&gt;}\)</span>作为<span class="math inline">\(x^{&lt;3&gt;}\)</span>,以此类推。直到产生&lt; EOS&gt;结束符，则标志语句生成完毕。当然，也可以设定语句长度上限，达到长度上限即停止生成新的单词。最终，根据随机选择的首单词，RNN模型会生成一条新的语句。</p><p>值得一提的是，如果不希望新的语句中包含&lt; UNK &gt;标志符，可以在每次产生&lt; UNK &gt;时重新采样，直到生成非&lt; UNK &gt;标志符为止。</p><p>以上介绍的是word level RNN，即每次生成单个word，语句由多个words构成。</p><p>另外一种情况是character level RNN，即词汇表由单个英文字母或字符组成，如下所示：</p><p><span class="math display">\[Vocabulay=[a,b,c,\cdots,z,.,;,,0,1,\cdots,9,A,B,\cdots,Z]\]</span> Character level RNN与word level RNN不同的是，<span class="math inline">\(y^{&lt;t&gt;}\)</span>由单个字符组成而不是word。训练集中的每句话都当成是由许多字符组成的。</p><p>character level RNN的优点是能有效避免遇到词汇表中不存在的单词&lt; UNK &gt;。</p><p>但是，character level RNN的缺点也很突出。由于是字符表征，每句话的字符数量很大，这种大的跨度不利于寻找语句前部分和后部分之间的依赖性。另外，character level RNN的在训练时的计算量也是庞大的。</p><p>基于这些缺点，目前character level RNN的应用并不广泛，但是在特定应用下仍然有发展的趋势。</p><h1 id="rnns-梯度消失和爆炸">7 RNNs 梯度消失和爆炸</h1><p>语句中可能存在跨度很大的依赖关系，即某个word可能与它距离较远的某个word具有强依赖关系。例如下面这两条语句：</p><ul><li><p>The cat, which already ate fish, was full.</p></li><li><p>The cats, which already ate fish, were full.</p></li></ul><p>第一句话中，was受cat影响；第二句话中，were受cats影响。它们之间都跨越了很多单词。</p><p>而一般的RNN模型每个元素受其周围附近的影响较大，难以建立跨度较大的依赖性。</p><p>上面两句话的这种依赖关系，由于跨度很大，普通的RNN网络容易出现梯度消失，捕捉不到它们之间的依赖，造成语法错误。</p><p>另一方面，RNN也可能出现梯度爆炸的问题，即gradient过大。梯度爆炸是指在训练过程中，大量误差梯度累积，导致对 NN 模型权重的更新非常大。这些权重可能会变得过大，导致溢出，识别为 NaN（"Not a Number"）</p><p>常用的解决办法是设定一个阈值，一旦梯度最大值达到这个阈值，就对整个梯度向量进行尺度缩小。这种做法被称为gradient clipping。</p><h1 id="gru">8 GRU</h1><p>RNN的隐藏层单元结构如下图所示：</p><p><img src="/img/深度学习-Course5-Week1/1循环序列模型_6.png" /></p><p><span class="math inline">\(a^{&lt;t&gt;}\)</span> 的表达式为: <span class="math display">\[a^{&lt;t&gt;}=tanh(W_a[a^{&lt;t-1&gt;},x^{&lt;t&gt;}]+b_a)\]</span></p><p>为了解决梯度消失问题，对上述单元进行修改，添加了记忆单元，构建GRU，如下图所示： <img src="/img/深度学习-Course5-Week1/1循环序列模型_7.png" /> 相应的表达式为： <span class="math display">\[\begin{aligned}\tilde{c}^{&lt;t&gt;} &amp; =tanh(W_{c}[c^{&lt;t-1&gt;},x^{&lt;t&gt;}]+b_{c})\\ \Gamma_{u} &amp; =\sigma(W_{u}[c^{&lt;t-1&gt;},x^{&lt;t&gt;}]+b_{u})\\ c^{&lt;t&gt;} &amp; =\Gamma*\tilde{c}^{&lt;t&gt;}+(1-\Gamma_{u})*c^{&lt;t-1&gt;}\end{aligned}\]</span> 其中，<span class="math inline">\(c^{&lt;t-1&gt;}=a^{&lt;t-1&gt;}\)</span>，<span class="math inline">\(c^{&lt;t&gt;}=a^{&lt;t&gt;}\)</span>。<span class="math inline">\(\Gamma_u\)</span>意为gate，记忆单元。当<span class="math inline">\(\Gamma_u=1\)</span>时，代表更新；当 <span class="math inline">\(\Gamma_u=0\)</span>时，代表记忆，保留之前的模块输出。这一点跟CNN中的ResNets的作用有点类似。因此，<span class="math inline">\(\Gamma_u\)</span>能够保证RNN模型中跨度很大的依赖关系不受影响，消除梯度消失问题。</p><p>上面介绍的是简化的GRU模型，完整的GRU添加了另外一个gate，即Γr，表达式如下：</p><p><span class="math display">\[\begin{gathered}\widetilde{c}^{&lt;t&gt;}=tanh(W_{c}[\Gamma_{r}*c^{&lt;t-1&gt;},x^{&lt;t&gt;}]+b_{c})\\ \Gamma_{u}=\sigma(W_{u}[c^{&lt;t-1&gt;},x^{&lt;t&gt;}]+b_{u})\\ \Gamma_{r}=\sigma(W_{r}[c^{&lt;t-1&gt;},x^{&lt;t&gt;}]+b_{r})\\ c^{&lt;t&gt;}=\Gamma_{}*\tilde{c}^{&lt;t&gt;}+\left(1-\Gamma_{u}\right)*c^{&lt;t-1&gt;}\\ a^{&lt;t&gt;}=c^{&lt;t&gt;}\\ \end{gathered}\]</span> 注意，以上表达式中的∗表示元素相乘，而非矩阵相乘。</p><p>GRU可以看成是简化的LSTM，两种方法都具有各自的优势。</p><h1 id="lstm">9 LSTM</h1><p>LSTM是另一种更强大的解决梯度消失问题的方法。它对应的RNN隐藏层单元结构如下图所示： <img src="/img/深度学习-Course5-Week1/1循环序列模型_8.png" /> 相应的表达式为： <span class="math display">\[\begin{gathered}\widetilde{c}^{&lt;t&gt;}=tanh(W_c[a^{&lt;t-1&gt;},x^{&lt;t&gt;}]+b_c) \\\Gamma_u=\sigma(W_u[a^{&lt;t-1&gt;},x^{&lt;t&gt;}]+b_u) \\\Gamma_f=\sigma(W_f[a^{&lt;t-1&gt;},x^{&lt;t&gt;}]+b_f) \\\Gamma_o=\sigma(W_o[a^{&lt;t-1&gt;},x^{&lt;t&gt;}]+b_o) \\c^{&lt;t&gt;}=\Gamma_{u}*\tilde{c}^{&lt;t&gt;}+\Gamma_{f}*c^{&lt;t-1&gt;} \\a^{&lt;t&gt;}=\Gamma_o*c^{&lt;t&gt;} \end{gathered}\]</span> LSTM包含三个门：<span class="math inline">\(\Gamma_u\)</span>，<span class="math inline">\(\Gamma_f\)</span>，<span class="math inline">\(\Gamma_o\)</span>分别对应更新门（update gate），遗忘门（forget gate）和输出门（output gate）。</p><p>如果考虑<span class="math inline">\(c^{&lt;t−1&gt;}\)</span>对<span class="math inline">\(\Gamma_u\)</span>，<span class="math inline">\(\Gamma_f\)</span>，<span class="math inline">\(\Gamma_o\)</span>的影响，可加入peephole connection，对LSTM的表达式进行修改： <span class="math display">\[\begin{gathered}\tilde{c}^{&lt;t&gt;}=tanh(W_{c}[a^{&lt;t-1&gt;},x^{&lt;t&gt;}]+b_{c})\\ \Gamma_{u}=\sigma(W_{u}[a^{&lt;t-1&gt;},x^{&lt;t&gt;},c^{&lt;t-1&gt;}]+b_{u})\\ \Gamma_{f}=\sigma(W_{f}[a^{&lt;t-1&gt;},x^{&lt;t&gt;},c^{&lt;t-1&gt;}]+b_{f})\\ \Gamma_{o}=\sigma(W_{o}[a^{&lt;t-1&gt;},x^{&lt;t&gt;},c^{&lt;t-1&gt;}]+b_{o})\\ c^{&lt;t&gt;}=\Gamma_{u}*\tilde{c}^{&lt;t&gt;}+\Gamma_{f}*c^{&lt;t-1&gt;}\\ a^{&lt;t&gt;}=\Gamma_{o}*c^{&lt;t&gt;}\end{gathered}\]</span></p><p><span class="math inline">\(\Gamma_u\)</span>维度等于 LSTM 隐藏单元数量.</p><h1 id="双向rnn">10 双向RNN</h1><p>我们在前面简单提过Bidirectional RNN，它的结构如下图所示： <img src="/img/深度学习-Course5-Week1/1循环序列模型_12.png" /> BRNN对应的输出表达式为： <span class="math display">\[\hat{y}^{&lt;t&gt;}=g(W_y[a^{\to&lt;t&gt;},a^{\leftarrow&lt;t&gt;}]+b_y)\]</span> BRNN能够同时对序列进行双向处理，性能大大提高。</p><p>但是计算量较大，且在处理实时语音时，需要等到完整的一句话结束时才能进行分析。</p><h1 id="deep-rnns">11 Deep RNNs</h1><p>Deep RNNs由多层RNN组成，其结构如下图所示。 <img src="/img/深度学习-Course5-Week1/1循环序列模型_14.png" /> 与RNN一样，用上标<span class="math inline">\([l]\)</span>表示层数，Deep RNNs中 <span class="math inline">\(a^{[l]&lt;t&gt;}\)</span> 的表达式为：</p><p><span class="math display">\[a^{[l]&lt;t&gt;}=g(W_a^{[l]}[a^{[l]&lt;t-1&gt;},a^{[l-1]&lt;t&gt;}]+b_a^{[l]})\]</span> 我们知道DNN层数可达100多，而Deep RNNs一般没有那么多层，3层RNNs已经较复杂了。</p><p>另外一种Deep RNNs结构是每个输出层上还有一些垂直单元，如下图所示。 <img src="/img/深度学习-Course5-Week1/1循环序列模型_15.png" /></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习-Course3-Week2机器学习策略(2)</title>
    <link href="/2024/02/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course3-Week2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AD%96%E7%95%A5-2/"/>
    <url>/2024/02/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course3-Week2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AD%96%E7%95%A5-2/</url>
    
    <content type="html"><![CDATA[<h1 id="误差分析">1 误差分析</h1><p>误差分析是对建立的机器学习模型进行错误分析的过程。通过正确且有针对性地进行误差分析，可以帮助我们理解模型产生错误的原因并提出相应的改进措施。</p><p>举个例子来说明，假设我们正在开发一个猫类识别模型，并且已经建立的模型的错误率为10%。我们发现该模型会将一些狗类图片错误地分类成猫。为了提高模型的正确率，一种常规解决办法是扩大狗类的样本，增强模型对狗类（负样本）的训练。</p><p>然而，这个过程可能会耗费几个月的时间，并且需要投入大量的成本。因此，我们需要进行误差分析来判断是否值得这么做，即扩大狗类样本、重新训练模型对提高模型准确率的效果有多大。</p><p>一种简单的方法是从分类错误的样本中统计狗类样本的数量，并根据其比重来判断问题的重要性。假设狗类样本仅占错误样本的5%，即使我们花费几个月的时间扩大狗类样本，改进后的模型的错误率也只能降到9.5%。与之前的10%相比，并没有得到显著的改善。这种情况下，我们将这种性能限制称为性能上限。</p><p>相反，如果错误样本中狗类的比重达到50%，那么改进后的模型的错误率有望降低到5%，改善效果很大。因此，在这种情况下，值得花费更多的时间扩大狗类样本。</p><p>误差分析的好处在于，它可以避免我们花费大量的时间和精力去解决对提高模型性能收效甚微的问题，相反，它让我们能够专注于解决影响模型正确率的主要问题。</p><p>同时，误差分析还可以评估多个影响模型性能的因素，并通过它们在错误样本中所占的比例来判断它们的重要性。例如，在猫类识别模型中，可能有以下几个影响因素：</p><ul><li>修正将狗照片错误地识别为猫的问题</li><li>修正对大型猫类（如狮子、豹子等）的错误识别</li><li>提高模型对模糊图片的性能</li></ul><p><img src="/img/深度学习-Course3-Week2/2机器学习策略(2).png" /></p><p>通常情况下，比例越大，影响越大，我们就应该花费更多的时间和精力来解决这些问题。误差分析让我们能够更加有针对性地改进模型，提高工作效率。</p><h1 id="数据标签不正确">2 数据标签不正确</h1><p>在监督式学习中，训练样本中的输出（y）有时会出现错误的标注，也就是incorrectly labeled examples。</p><p>对于随机性的标注错误（random errors），深度学习算法具有较强的容错性，一般可以忽略不计，因为这些错误在整个训练集中是随机分布的，并不会对模型的性能产生显著影响。</p><p>然而，如果出现系统性错误（systematic errors），这将对深度学习算法造成较大影响，并且可能降低模型的性能。</p><p>但是，如果dev/test sets中出现了不正确的标签数据，我们该如何处理呢？这个问题可以通过进行误差分析来解决。</p><p>我们可以利用它来统计dev sets中所有分类错误的样本中，不正确标记数据（incorrectly labeled data）所占的比例。</p><p>根据该比例的大小，我们可以决定是否修正所有不正确标记的数据，或者是否可以忽略它们。举个例子，假设：</p><ul><li><p>整体dev set error: 10%</p></li><li><p>不正确标记造成的错误: 0.6%</p></li><li><p>其他原因造成的错误: 9.4%</p></li></ul><p>从上面的数据我们可以看出，不正确标记造成的错误仅占dev set error的6%，而其他类型的错误占了dev set error的94%。因此，在这种情况下，我们可以将不正确标记的数据忽略掉。</p><p>如果我们对深度学习算法进行优化后，出现了如下情况：</p><ul><li><p>整体dev set error: 2%</p></li><li><p>不正确标记造成的错误: 0.6%</p></li><li><p>其他原因造成的错误: 1.4%</p></li></ul><p>从上面的数据我们可以看出，不正确标记造成的错误仍然占dev set error的30%，而其他类型的错误占了dev set error的70%。</p><p>因此，在这种情况下，我们不能忽略不正确标记的数据，需要手动修正它们。</p><p>我们知道，dev set的主要作用是用来比较不同算法之间的性能，选择错误率最小的算法模型。</p><p>然而，如果dev/test sets中存在不正确标记的数据，当不同算法的错误率非常接近时，我们无法仅仅通过整体dev set error来判断哪个算法模型更好，必须修正不正确标记的数据。</p><p>在修正dev/test set数据时，有几条建议：</p><ul><li><p>==对dev和test sets应用相同的处理方法，以确保它们来自同一分布==</p></li><li><p>考虑检查你的算法正确分类和错误分类的样本</p></li><li><p>训练集和dev/test数据可能来自稍有不同的分布，需要注意处理。</p></li></ul><h1 id="构建模型">3 构建模型</h1><p>对于如何构建一个机器学习应用模型，我们应该先快速构建第一个简单模型，然后再反复迭代优化。</p><p>在深度学习领域构建机器学习应用模型时，我们可以按照以下步骤进行：</p><h2 id="设置开发测试集和评估指标">1. 设置开发/测试集和评估指标</h2><p>在构建模型之前，我们需要准备好开发集和测试集，并选择合适的评估指标来衡量模型的性能。开发集和测试集的划分是为了能够评估模型在未见过的数据上的表现，并且评估指标应该与我们的应用需求相匹配，例如准确率、召回率等。</p><h2 id="快速构建初始系统">2. 快速构建初始系统</h2><p>接下来，我们需要快速构建一个简单的初始模型。这个初始模型可能并不是最优的，但它可以帮助我们建立一个基准来进行后续的优化。在构建初始模型时，可以使用一些基本的模型结构和算法，并进行简单的训练。</p><h2 id="使用偏差方差分析和错误分析">3. 使用偏差/方差分析和错误分析</h2><p>在构建初始系统之后，我们需要进行进一步的优化。为了确定下一步的优化方向，我们可以使用偏差/方差分析和错误分析的方法进行评估。</p><ul><li><p>偏差/方差分析：偏差是指模型在训练集上的错误率，方差是指模型在测试集上的错误率。通过分析模型的偏差和方差，我们可以了解模型的欠拟合和过拟合情况，进而针对性地进行调整。</p></li><li><p>错误分析：错误分析是对模型在开发集或测试集上的错误进行详细的分析和定位。通过错误分析，我们可以识别模型常犯的错误类型，并分析其原因，从而引导我们优化模型。</p></li></ul><p>通过以上步骤，我们可以逐步改进我们的模型，不断迭代优化，最终达到更好的性能。</p><p>请注意，在进行模型训练和优化时，我们还需要注意训练集和开发/测试集的数据可能来自稍有不同的分布。因此，在进行错误分析时，我们需要注意误差的来源是否与数据分布的偏差有关，进一步确定是否需要进行数据标注的修正或其他调整。</p><h1 id="训练集和测试集不同分布">4 训练集和测试集不同分布</h1><p>在深度学习中，当训练集（train set）和验证/测试集（dev/test set）来自不同的分布时，我们需要采取一些方法来构建准确的机器学习模型。</p><p>我们以猫类识别为例，训练集来自网络下载的图片，比较清晰，而验证/测试集来自用户手机拍摄的图片，比较模糊。</p><p><img src="/img/深度学习-Course3-Week2/2机器学习策略(2)_1.png" /></p><p>训练集的大小为200,000，而验证/测试集的大小为10,000，即训练集远大于验证/测试集。</p><p>尽管验证/测试集的质量不高，但最终模型主要应用在对这些模糊照片的识别上。</p><p>面对训练集和验证/测试集来自不同分布的情况，有两种解决方法：</p><p>第一种方法是将训练集和验证/测试集完全混合，然后随机选择一部分作为训练集，另一部分作为验证/测试集。</p><p>比如，混合21万例样本，然后随机选择20.5万例样本作为训练集，2,500例作为验证集，2,500例作为测试集。这种方法的优点是实现训练集和验证/测试集分布一致，但缺点是验证/测试集中网络下载图片所占比例远大于手机拍摄的图片。</p><p>第二种方法是将原来的训练集和一部分验证/测试集组合作为训练集，剩下的验证/测试集分别作为验证集和测试集。</p><p>比如，20万例网络下载的图片和5,000例手机拍摄的图片组合成训练集，剩下的2,500例手机拍摄的图片作为验证集，2,500例手机拍摄的图片作为测试集。这样可以保证验证集最接近实际应用场景，该方法比较常用且性能表现较好。</p><p>需要注意的是，当训练集和验证/测试集来源于不同分布时，无法直接通过相对误差的大小来判断是否出现了variance（方差）问题。我们可以引入一个训练-验证集（train-dev set），该集合与训练集来自相同的分布，但不用于训练模型，而是与验证集一样用于验证。</p><p>通过引入训练-验证集，我们有了训练误差、训练-验证误差和验证误差三种误差。其中，训练误差与训练-验证误差的差值反映了variance（方差）问题；训练-验证误差与验证误差的差值反映了数据不匹配问题，即样本分布不一致的问题。</p><p><img src="/img/深度学习-Course3-Week2/2机器学习策略(2)_2.png" /></p><p>通过以上方法，我们可以比较准确地定位出现的是variance还是数据不匹配问题。</p><p>训练集与开发/测试集样本分布不一致,我们可以采取以下两个建议：</p><ol type="1"><li><p>进行手动错误分析（manual error analysis）来理解训练集与开发/测试集之间的差异。</p></li><li><p>使训练数据更加相似，或者收集更多与开发/测试集相似的数据。</p></li></ol><p>为了使训练集与开发/测试集更加相似，我们可以使用人工数据合成的方法来进行处理。例如，考虑一个说话人识别的问题，实际的应用场景（开发/测试集）可能包含背景噪声，而训练集很可能没有背景噪声。</p><p>为了解决这个问题，我们可以在训练集上人工添加背景噪声，以合成类似实际场景的声音。通过这样的操作，我们可以让模型在更真实的环境下进行训练，从而获得更准确的结果。</p><p>然而，需要注意的是，我们不能简单地给每段语音都添加同一段背景噪声。这样做会导致模型过度适应特定的背景噪声，从而降低模型的效果。因此，在人工数据合成时，我们需要特别注意避免过拟合背景噪声的问题。</p><h1 id="迁移学习">5 迁移学习</h1><h2 id="什么是迁移学习transfer-learning">5.1 什么是迁移学习（Transfer Learning）</h2><p>迁移学习是深度学习中一种强大的技术，可以将已经训练好的模型的一部分知识（网络结构）直接应用到类似模型中。</p><p>例如，我们可以将已经训练好的猫类识别的神经网络模型的一部分网络结构应用到使用X光片预测疾病的模型中。</p><h2 id="迁移学习的原理">5.2 迁移学习的原理</h2><p>迁移学习的原理是基于神经网络浅层部分能够检测出许多图片固有特征，例如图像边缘、曲线等。</p><p>对于新的任务，使用之前训练好的神经网络部分可以帮助更快、更准确地提取特征，尤其是针对处理相似类型的数据。</p><p>例如，由于图片处理具有相同的特点，第一个训练好的神经网络已经学习如何提取有用的图片特征。</p><p>即使即将训练的第二个神经网络样本数量较少，通过复用第一个神经网络的结构和权重系数，仍然可以获得健壮性良好的模型。</p><p>如果我们已经有一个训练好的神经网络，用来做图像识别。现在，我们想要构建另外一个通过X光片进行诊断的模型。迁移学习的做法是无需重新构建新的模型，而是利用之前的神经网络模型，只改变样本输入、输出以及输出层的权重系数<span class="math inline">\(W^{[L]},\:b^{[L]}\)</span>。也就是说对新的样本(X,Y),重新训练输出层权重系数<span class="math inline">\(W^{[L]},b^{[L]}\)</span>,而其它层所有的权重系数<span class="math inline">\(W^{[l]},b^{[l]}\)</span>保持不变。</p><p><img src="/img/深度学习-Course3-Week2/2机器学习策略(2)_3.png" /></p><p>迁移学习，重新训练权重系数，如果需要构建新模型的样本数量较少，那么可以像刚才所说的，只训练输出层的权重系数<span class="math inline">\(W^{[L]},b^{[L]}\)</span>,保持其它层所有的权重系数<span class="math inline">\(W^{[l]},b^{[l]}\)</span>不变。这种做法相对来说比较简单。如果样本数量足够多，那么也可以只保留网络结构，重新训练所有层的权重系数。这种做法使得模型更加精确，因为毕竟样本对模型的影响最大。选择哪种方法通常由数据量决定。</p><p>顺便提一下，如果重新训练所有权重系数，初始<span class="math inline">\(W^{[l]},b^{[l]}\)</span>由之前的模型训练得到，这一过程称为预训练。之后，不断调试、优化<span class="math inline">\(W^{[l]},b^{[l]}\)</span>的过程称为微调。预训练和微调分别对应上图中的黑色箭头和红色箭头。</p><p>预训练可以学习许多低层次的特征。低层次特征：低层次特征往往是泛化的、易于表达的，如纹理、颜色、边缘、棱角等等。高层次特征往往是复杂的、难以说明的，比如金色的头发、瓢虫的翅膀、缤纷的花儿等等。</p><p>迁移学习可以保留原神经网络的一部分，再添加新的网络层。具体问题，具体分析，可以去掉输出层后再增加额外一些神经层。 <img src="/img/深度学习-Course3-Week2/2机器学习策略(2)_4.png" /></p><h2 id="迁移学习的应用场景">5.3 迁移学习的应用场景</h2><p>迁移学习主要适用于以下场景：</p><ol type="1"><li><p>任务A和任务B具有相同的输入数据x。例如都是图像，都是语音等</p></li><li><p>对于任务A，拥有大量的数据，而任务B的数据相对较少。</p></li><li><p>任务A的底层特征对于任务B的学习具有帮助。</p></li></ol><p>在应用迁移学习时，可以保留原神经网络的一部分结构，并根据具体问题添加新的网络层。具体而言，可以根据需求去除原输出层并增加额外的神经层。</p><p>总之，迁移学习可通过重新训练权重系数来应用已有模型，针对不同任务进行任务特定的微调。这样的过程可以通过预训练和微调来实现，其中预训练是利用之前的模型训练得到初始权重系数，而微调是针对新任务不断优化权重系数的过程。</p><h1 id="多任务学习">6 多任务学习</h1><p>多任务学习是指通过一个神经网络模型来同时解决多个任务。与普通的分类问题不同，多任务学习将多个任务融合在一个模型中，可以实现多分类效果。比如在汽车自动驾驶中，我们需要同时检测行人、车辆、交通标志和信号灯。多任务学习就可以将这些任务整合在一个模型中，输出一个多维的向量作为结果</p><p>如果有C个，那么输出y的维度是(C,1)。</p><p>例如汽车自动驾驶中，需要实现的多任务为行人、车辆、交通标志和信号灯。如果检测出汽车和交通标志，则y为： <span class="math display">\[y=\begin{bmatrix}0\\1\\1\\0\end{bmatrix}\]</span></p><p>多任务学习模型的cost function为：</p><p><span class="math inline">\(\frac1m\sum_{i=1}^m\sum_{j=1}^cL(\hat{y}_j^{(i)},y_j^{(i)})\)</span></p><p>其中，j表示任务下标，总有c个任务。对应的loss function为：</p><p><span class="math display">\[L(\hat{y}_j^{(i)},y_j^{(i)})=-y_j^{(i)}log\hat{y}_j^{(i)}-(1-y_j^{(i)})log\mathrm{~}(1-\hat{y}_j^{(i)})\]</span></p><p>值得一提的是，多任务学习与Softmax回归的区别在于Softmax回归是单标签的，即输出向量y只有一个元素为1；而多任务学习是多个标签的，即输出向量y可以有多个元素为1。</p><p>多任务学习的应用场合主要包括三点：</p><ul><li>需要训练一组任务，其中共享底层特征会有所好处。</li><li>通常情况下，每个任务的数据量相似。</li><li>可以训练足够大的神经网络以在所有任务上取得良好的表现。</li></ul><p>多任务学习在实际应用中并不是十分常见，相比之下，迁移学习更常被使用</p><h1 id="端到端深度学习">7 端到端深度学习</h1><p>端到端深度学习是一种将所有不同阶段的数据处理系统或学习系统模块组合在一起的方法，通过一个单一的神经网络模型来实现所有的功能。该方法将所有模块混合在一起，只关心输入和输出。</p><p>以语音识别为例，传统的算法流程和端到端模型的区别如下： <img src="/img/深度学习-Course3-Week2/2机器学习策略(2)_5.png" /></p><p>如果训练样本足够大，神经网络模型足够复杂，那么端到端模型的性能比传统机器学习分块模型更好。这是因为端到端模型允许神经网络模型内部通过自我训练模型特征和自我调节来增加整体契合度。</p><p>端到端深度学习有优点也有缺点:</p><p>优点：</p><ul><li>让数据说话：端到端深度学习方法可以让数据自己发挥作用，减少了手工设计组件的需求。</li></ul><p>缺点：</p><ul><li>可能需要大量的数据：为了获得良好的性能，端到端深度学习模型通常需要大量的训练数据。</li><li>可能不太可解释和可解释性：与传统的分块模型相比，端到端深度学习模型可能更难解释和解释其内部的工作原理</li></ul>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习-Course3-Week1机器学习策略(1)</title>
    <link href="/2024/02/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course3-Week1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AD%96%E7%95%A5-1/"/>
    <url>/2024/02/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course3-Week1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AD%96%E7%95%A5-1/</url>
    
    <content type="html"><![CDATA[<h1 id="ml策略">1 ML策略</h1><p>当我们面对一个深度神经网络模型时，我们通常希望从多个方面对其进行优化。一些常见的优化方法包括：</p><ul><li>收集更多的数据</li><li>收集更多样的训练集</li><li>使用梯度下降算法或Adam优化算法来训练更长时间</li><li>尝试更大的网络</li><li>尝试更小的网络</li><li>添加dropout层</li><li>添加L2正则化</li><li>优化网络架构，如选择合适的激活函数和隐藏单元数量等。</li></ul><p>然而，仅仅盲目选择和尝试这些方法可能会费时且效果甚微。因此，旨在快速、高效地找到最优机器学习模型的策略至关重要。</p><h1 id="正交化方法">2 正交化方法</h1><p>正交化是一种通用的调参策略，可以帮助我们更有效地调试和优化深度学习模型。</p><p>正交化方法的核心思想是每次只调整一个参数，保持其他参数不变，从而使模型在某一方面的性能发生改变。</p><p>可以将正交化方法类比为旧式电视机的旋钮。电视机的每个旋钮对应一个功能，调整一个旋钮只会影响对应功能的表现，而不会影响其他功能。也就是说，这些旋钮彼此之间是互不影响的，即正交的。通过这种方法，我们可以快速有效地调试和优化机器学习模型。</p><p>在监督式学习模型中，我们可以将优化分为四个独立的“功能”：</p><ol type="1"><li>在损失函数上更好地拟合训练集</li><li>在损失函数上更好地拟合验证集</li><li>在损失函数上更好地拟合测试集</li><li>在实际应用中表现良好</li></ol><p>为了实现这四个功能，我们可以采用不同的调节方法。</p><p>其中，第一条优化训练集可以通过使用更复杂NN，使用Adam等优化算法来实现；第二条优化验证集可以通过正则化，采用更多训练样本来实现；第三条优化测试集可以通过使用更多的验证集样本来实现；第四条提升实际应用模型可以通过更换验证集，使用新的cost function来实现。</p><p>然而，需要注意的是，在模型功能调试中不推荐使用早停法（early stopping），因为它会同时影响训练集和验证集的性能，不具有独立性、正交性，从而破坏了正交性的原则。</p><h1 id="单值评估指标">3 单值评估指标</h1><p>在建立和优化机器学习模型时，使用单个指标来评估模型的性能非常重要。单值评估指标，把多个性能指标综合在一起，用于比较不同超参数对应的模型的优劣，从而选择最优模型。</p><p>举个例子，我们有模型A和模型B，它们的准确率和召回率如下：</p><ul><li>模型A：准确率=0.8，召回率=0.6</li><li>模型B：准确率=0.7，召回率=0.8</li></ul><p>如果只看准确率，模型B似乎更好；如果只看召回率，模型A似乎更好。为了综合考虑准确率(Precision)和召回率(Recall)，并进行比较，我们可以使用F1 Score作为单值评价指标。</p><p>F1 Score综合了准确率和召回率的大小，计算公式如下： <span class="math display">\[F1=\frac{2\cdot P\cdot R}{P+R}\]</span> 通过计算，模型A的F1 Score为0.67，模型B的F1 Score为0.74。根据F1 Score，我们可以确定模型B比模型A更好。</p><p>除了F1 Score之外，还可以使用平均值作为单值评估指标，来评估模型的性能。例如，对于多个模型A, B, C, D, E, F，我们可以计算其在不同国家样本上的错误率，并选择平均错误率最小的模型作为最优模型。 <img src="/img/深度学习-Course3-Week1/1机器学习策略(1).png" /></p><h1 id="优化指标和满意指标">4 优化指标和满意指标</h1><p>有时候，要将所有的性能指标综合在一起构成单值评价指标会比较困难。为了解决这个问题，我们可以将某些性能作为优化指标（Optimizing metic），寻求最优化值；而将某些性能作为满意指标（Satisficing metic），只需要满足阈值即可。</p><p>以猫类识别为例，假设有A、B、C三个模型，它们的准确率（Accuracy）和运行时间（Running time）如下表所示：</p><table><thead><tr class="header"><th>模型</th><th>准确率</th><th>运行时间</th></tr></thead><tbody><tr class="odd"><td>A</td><td>90%</td><td>60ms</td></tr><tr class="even"><td>B</td><td>92%</td><td>90ms</td></tr><tr class="odd"><td>C</td><td>95%</td><td>1500ms</td></tr></tbody></table><p>准确率和运行时间不太适合综合成单值评价指标。因此，可以将准确率作为优化指标，将运行时间作为满意指标。也就是说，在运行时间满足阈值的情况下，选择准确率最高的模型。</p><p>例如，如果设定运行时间必须在100ms以内，那么显然模型C不满足阈值条件，可以先剔除。然后比较模型A和模型B，发现模型B的准确率更高，性能更好。</p><p>总结来说，优化指标是需要优化的，越优越好；而满意指标只要满足设定的阈值就可以。</p><h1 id="训练验证测试分布">5 训练/验证/测试分布</h1><p>Train/dev/test大小的设置对于机器学习模型训练非常重要，合理的设置可以大大提高模型训练效率和质量。</p><p>原则上，应该尽量保证dev集合和test集合来源于同一分布，并且都能够反映出实际样本的情况。如果dev集合和test集合不来自同一分布，那么从dev集合上选择的“最佳”模型往往无法在test集合上表现良好，就像射击时从一个靶心附近打出一支箭，但是实际靶心的位置偏离之前的靶心。</p><p>在样本数量不多（小于一万）的情况下，通常将Train/dev/test集合的比例设为60%/20%/20%。在没有dev集合的情况下，可以将Train/test集合的比例设为70%/30%。而在样本数量很大（百万级别）的情况下，通常将比例设为98%/1%/1%或者99%/1%。</p><p>有时候需要根据实际情况动态调整算法模型的评价标准。</p><p>以猫类识别为例，初始的评价标准是错误率，算法A的错误率为3%，算法B的错误率为5%。 显然，算法A更好一些。然而，在实际使用中，发现算法A会误识别一些色情图片，而算法B则没有这个问题。从用户的角度来看，他们可能更倾向于选择算法B，尽管它的错误率更高。</p><p>在这种情况下，我们需要改变之前的评价标准，考虑到新情况进行调整。例如，增加色情图片的权重，增加其代价。</p><p>改变前的损失函数（Cost Function）： <span class="math display">\[J=\frac1m\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})\]</span> 改变评价标准后的损失函数（Cost Function）： <span class="math display">\[J=\frac1{w^{(i)}}\sum_{i=1}^mw^{(i)}L(\hat{y}^{(i)},y^{(i)})\]</span> <span class="math display">\[\left.w^{(i)}=\left\{\begin{array}{ll}1,&amp;x^{(i)}\textit{is non}-porn\\10,&amp;x^{(i)}\textit{is porn}\end{array}\right.\right.\]</span> 总结来说，机器学习可以分为两个过程：</p><ol type="1"><li>定义评价分类器的指标；</li><li>如何在这个指标上取得好的成绩。</li></ol><p>也就是说，第一步是找到靶心，第二步是通过训练将箭射中靶心。在训练的过程中，可能需要根据实际情况改变算法模型的评价标准，进行动态调整。另外，当dev/test集合与实际使用的样本分布不一致时，也需要动态调整评价标准。</p><h1 id="人类水平表现">6 人类水平表现</h1><p>在深度学习中，我们经常将机器学习模型的表现与人类水平表现进行比较。 <img src="/img/深度学习-Course3-Week1/1机器学习策略(1)_1.png" /> 图中，横坐标表示训练时间，纵坐标表示准确性。机器学习模型在训练过程中会逐渐接近甚至超过人类的表现水平。 然而，一旦超过了人类水平表现，进一步提升模型准确性的速度就会变慢，直到接近理想的最优准确性，，我们称之为贝叶斯最优误差（bayes optimal error）。理论上来说，任何模型都不可能超越这个最优准确性，它代表着最佳的表现水平。</p><p>人类在某些领域有很出色的表现，比如图像识别和语音识别等。因此，让机器学习模型不断接近人类水平表现是非常重要的，也需要付出很多努力：</p><ul><li>从人类那里获取有标签的数据</li><li>从错误分析中获取见解：为什么一个人能够得到正确答案</li><li>更好地分析偏差/方差</li></ul><p>在实际应用中，我们需要关注训练误差、验证误差和人类水平误差之间的相对值。</p><p>例如，对于猫类识别的问题，如果人类水平误差为1%，训练误差为8%，验证误差为10%。 <img src="/img/深度学习-Course3-Week1/1机器学习策略(1)_2.png" /> 由于训练误差与人类水平误差相差7%，验证误差与训练误差相差2%，因此目标是尽量减小训练误差，也就是减小偏差。</p><p>如果图像非常模糊，人眼看不清楚，人类水平误差上升到了7.5%。 <img src="/img/深度学习-Course3-Week1/1机器学习策略(1)_3.png" /> 在这种情况下，由于训练误差与人类水平误差只相差0.5%，验证误差与训练误差相差2%，因此目标是尽量减小验证误差，也就是减小方差。这是相对而言的。</p><p>对于物体识别这样的计算机视觉问题，人类水平误差非常低，接近于贝叶斯最佳误差。</p><p>因此，上面的例子中的1%和7.5%都可以近似看作是对应贝叶斯最佳误差的表示。</p><p>在实际应用中，我们通常使用人类水平误差来代表贝叶斯最佳误差。</p><p>一般来说，训练误差与人类水平误差之间的差值被称为偏差，也称为可避免偏差；验证误差与训练误差之间的差值被称为方差。</p><p>通过比较偏差和方差的相对大小，我们可以判断算法模型是否出现欠拟合或过拟合的情况。</p><p>我们之前提到过，人类水平表现能够代表贝叶斯最佳误差。但是，人类水平表现如何被定义？</p><p>以医学图像识别为例，不同人群的错误率会有所不同：</p><ul><li>典型人类：误差率为3%</li><li>典型医生：误差率为1%</li><li>经验丰富的医生：误差率为0.7%</li><li>由经验丰富的医生组成的团队：误差率为0.5%</li></ul><p>不同人群的错误率不同。通常情况下，我们将表现最好的那一组即由经验丰富的医生组成的团队作为人类水平表现。</p><p>那么，在这个例子中，人类水平误差为0.5%。</p><p>然而，在实际应用中，不同的人可能选择不同的人类水平标准，这会带来一些影响。</p><p>如果某个模型的训练误差为0.7%，验证误差为0.8%。 <img src="/img/深度学习-Course3-Week1/1机器学习策略(1)_4.png" /> 如果选择由经验丰富的医生组成的团队作为人类水平表现，即人类水平误差为0.5%，那么偏差比方差更突出。</p><p>如果选择经验丰富的医生，即人类水平误差为0.7%，那么方差更突出。</p><p>也就是说，选择不同的人类水平误差，在某些情况下可能会影响偏差和方差的相对变化。</p><p>当然，这种情况通常只会在模型表现非常好，接近贝叶斯最佳误差的时候出现。</p><p>对于自然感知问题，例如视觉、听觉等问题，机器学习的表现不如人类。但是在很多其他方面，例如在线广告、产品推荐、物流（预测运输时间）和贷款批准等方面，机器学习模型的表现已经超过了人类。</p><p>实际上，使机器学习模型超过人类水平表现是相当困难的。</p><p>然而，只要提供足够多的样本数据，训练复杂的神经网络，模型的预测准确性就会大大提高，很有可能接近或甚至超过人类水平。</p><p>需要注意的是，当算法模型的表现超过人类水平时，很难通过人的直觉来解决如何进一步提升模型性能的问题。</p><h1 id="提高模型性能">7 提高模型性能</h1><p>提高机器学习模型的性能主要涉及两个问题：可避免的偏差（avoidable bias）和方差（variance）。可避免的偏差指的是训练误差与人类水平误差之间的差距，而方差指的是验证误差与训练误差之间的差距。</p><p>解决可避免的偏差的常用方法包括：</p><ul><li>训练更大的模型</li><li>进行更长时间/更好的优化算法（如动量、RMSprop、Adam）</li><li>搜索更好的神经网络架构和超参数</li></ul><p>解决方差的常用方法包括：</p><ul><li>增加数据量</li><li>正则化（如L2正则化、dropout和数据增强）</li><li>搜索更好的神经网络架构和超参数</li></ul><p>通过采用这些方法，我们可以逐步改善模型性能，并使其接近最优水平。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习-Course2-Week3超参数调试 Batch正则化</title>
    <link href="/2024/02/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course2-Week3%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%95-Batch%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <url>/2024/02/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course2-Week3%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%95-Batch%E6%AD%A3%E5%88%99%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="超参数调试">1 超参数调试</h1><h2 id="超参数">超参数</h2><p>深度神经网络需要调试的超参数（Hyperparameters）较多，包括：</p><ul><li><span class="math inline">\(\alpha\)</span> : 学习率因子</li><li><span class="math inline">\(\beta\)</span> : 动量梯度下降因子</li><li><span class="math inline">\(\beta_1,\beta_2,\varepsilon:\)</span> Adam算法参数</li><li>#ayers : 神经网络层数</li><li>#hidden units：各隐藏层神经元个数</li><li>learning rate decay:学习因子下降参数</li><li>mini-batch size:批量训练样本包含的样本个数</li></ul><p>通常来说，==学习因子α==是最重要的超参数，也是需要重点调试的超参数。</p><p>==动量梯度下降因子β、各隐藏层神经元个数#hidden units和mini-batch size==的重要性仅次于α。</p><p>然后就是神经网络层数#layers和学习因子下降参数learning rate decay。</p><p>Adam算法的三个参数<span class="math inline">\(β_1\)</span> , <span class="math inline">\(β_2\)</span>,ε一般常设置为0.9，0.999和<span class="math inline">\(10^{−8}\)</span>，不需要反复调试。</p><h2 id="超参数调试方法">超参数调试方法</h2><p>如何选择和调试超参数？</p><ul><li><strong>随机采样</strong></li></ul><blockquote><p>传统的方法是均匀间隔地选择参数取值点，然后根据验证集的表现选择最佳参数。然而，在深度神经网络中，使用随机选择更好。随机采样的好处是可以得到更多不同的参数组合。对于每个参数，我们随机选择一些取值点，从而增加了选择最优参数的可能性。</p></blockquote><p>传统机器学习中，我们对每个参数等距离选取任意个数的点，然后，分别使用不同点对应的参数组合进行训练，最后根据验证集上的表现好坏，来选定最佳的参数。</p><p>例如有两个待调试的参数，分别在每个参数上选取5个点，这样构成了5x5=25中参数组合，如下图所示： <img src="/img/深度学习-Course2-Week3/3超参数调试，batch正则化和程序框架.png" /></p><p>这种做法在参数比较少的时候效果较好。但是在深度神经网络模型中，我们一般不采用这种均匀间隔取点的方法，比较好的做法是使用随机采样。</p><p>也就是说，对于上面这个例子，我们随机选择25个点，作为待调试的超参数，如下图所示： <img src="/img/深度学习-Course2-Week3/3超参数调试，batch正则化和程序框架_1.png" /> 随机化选择参数的目的是为了尽可能地得到更多种参数组合。还是上面的例子，如果使用均匀采样的话，每个参数只有5种情况；而使用随机采样的话，每个参数有25种可能的情况，因此更有可能得到最佳的参数组合。</p><p>这种做法带来的另外一个好处就是对重要性不同的参数之间的选择效果更好。假设hyperparameter1为α，hyperparameter2为ε，显然二者的重要性是不一样的。</p><p>如果使用第一种均匀采样的方法，ε的影响很小，相当于只选择了5个α值。而如果使用第二种随机采样的方法，ε和α都有可能选择25种不同值。这大大增加了α调试的个数，更有可能选择到最优值。</p><p>其实，在实际应用中完全不知道哪个参数更加重要的情况下，随机采样的方式能有效解决这一问题，但是均匀采样做不到这点。</p><ul><li><strong>粗调至细调</strong></li></ul><blockquote><p>通过随机采样，我们可能找到了表现较好的一些参数区域。为了得到更精确的最佳参数，我们应该继续对选定区域进行由粗到细的采样，即放大表现较好的区域，并对该区域进行更密集的随机采样。</p></blockquote><p>在经过随机采样之后，我们可能得到<strong>某些区域</strong>模型的表现较好。</p><p>为了得到更精确的最佳参数，我们应该继续对选定的区域进行由粗到细的采样（coarse to fine sampling scheme）。也就是放大表现较好的区域，再对此区域做更密集的随机采样。 <img src="/img/深度学习-Course2-Week3/3超参数调试，batch正则化和程序框架_2.png" /></p><ul><li><strong>重要参数的非均匀采样</strong></li></ul><blockquote><p>对于重要性不同的参数，需要使用非均匀采样。例如，对于学习率因子α，使用非均匀采样可以获得更多在重要区间的取值点。通常，将线性区间转化为对数区间，然后在对数区间进行均匀采样，最后将对数值转换回线性值。</p></blockquote><p>上一部分讲的调试参数使用随机采样，对于某些超参数是可以进行尺度均匀采样的，但是某些超参数需要选择不同的合适尺度进行随机采样。</p><p>例如对于超参数#layers和#hidden units，都是正整数，是可以进行均匀随机采样的，即超参数每次变化的尺度都是一致的（如每次变化为1，犹如一个刻度尺一样，刻度是均匀的）。</p><p>但是，对于某些超参数，可能需要非均匀随机采样（即非均匀刻度尺）。例如超参数α，待调范围是[0.0001, 1]。如果使用均匀随机采样，那么有90%的采样点分布在[0.1, 1]之间，只有10%分布在[0.0001, 0.1]之间。</p><p>这在实际应用中是不太好的，因为最佳的α值可能主要分布在[0.0001, 0.1]之间，而[0.1, 1]范围内α值效果并不好。因此我们更关注的是区间[0.0001, 0.1]，应该在这个区间内细分更多刻度。</p><p>通常的做法是将线性区转换为对数区间，将均匀尺度转化为非均匀尺度，然后再在对数区间下进行均匀采样。这样，[0.0001, 0.001]，[0.001, 0.01]，[0.01, 0.1]，[0.1, 1]各个区间内随机采样的超参数个数基本一致，也就扩大了之前、[0.0001, 0.1]区间内采样值个数。 <img src="/img/深度学习-Course2-Week3/3超参数调试，batch正则化和程序框架_3.png" /> 一般解法是，如果线性区间为[a, b]，令m=log(a)，n=log(b)，则对应的log区间为[m,n]。</p><p>对log区间的[m,n]进行随机均匀采样，然后得到的采样值r，最后反推到线性区间，即<span class="math inline">\(10^r\)</span>。</p><p><span class="math inline">\(10^r\)</span>就是最终采样的超参数。</p><p>除了α之外，动量梯度因子β也是一样，在超参数调试的时候也需要进行非均匀采样。</p><p>一般β的取值范围在[0.9, 0.999]之间，那么1−β的取值范围就在[0.001, 0.1]之间。那么直接对1−β在[0.001, 0.1]区间内进行log变换即可。</p><p>这里解释下为什么β也需要向α那样做非均匀采样。假设β从0.9000变化为0.9005，那么1/(1−β)基本没有变化。但假设β从0.9990变化为0.9995，那么1/(1−β)前后差别1000。β越接近1，指数加权平均的个数越多，变化越大。所以对β接近1的区间，应该采集得更密集一些。</p><p>经过调试选择完最佳的超参数并不是一成不变的，一段时间之后（例如一个月），需要根据新的数据和实际情况，再次调试超参数，以获得实时的最佳模型。</p><h2 id="超参数调试方法-1">超参数调试方法</h2><p>当计算资源有限，只能训练一个模型时，可以在该模型上调试不同的超参数，以获得最佳表现。我们称之为Babysitting one model。</p><p>当计算资源充足，可以同时训练多个模型时，可以在每个模型上调试不同的超参数，并选择表现最佳的模型。我们称之为Training many models in parallel。 <img src="/img/深度学习-Course2-Week3/3超参数调试，batch正则化和程序框架_4.png" /></p><h1 id="批标准化batch-normalization">2 批标准化（Batch Normalization）</h1><p>Batch Normalization不仅可以让调试超参数更加简单，而且可以让神经网络模型更加“健壮”。也就是说较好模型可接受的超参数范围更大一些，包容性更强，使得更容易去训练一个深度神经网络。</p><p>Batch Normalization通过对隐藏层的输入进行标准化处理，使得神经网络更容易训练，提高训练速度和准确度。</p><h2 id="batch-normalization的原理">## Batch Normalization的原理</h2><p>在神经网络中，第<span class="math inline">\(l\)</span>层隐藏层的输入就是第<span class="math inline">\(l-1\)</span>层隐藏层的输出<span class="math inline">\(A^{[l-1]}\)</span>。对<span class="math inline">\(A^{[l-1]}\)</span>进行标准化处理，从原理上来说可以提高<span class="math inline">\(W^{[l]}\)</span>和<span class="math inline">\(b^{[l]}\)</span>的训练速度和准确度。实际应用中，一般是对<span class="math inline">\(Z^{[l-1]}\)</span>进行标准化处理而不是<span class="math inline">\(A^{[l-1]}\)</span> 。</p><p>具体而言，对第<span class="math inline">\(l\)</span>层隐藏层的输入<span class="math inline">\(Z^{[l-1]}\)</span>做如下标准化处理： <span class="math display">\[\begin{gathered}\mu=\frac{1}{m}\sum_{i}z^{(i)} \\\sigma^{2}=\frac{1}{m}\sum_{i}(z_{i}-\mu)^{2} \\z_{norm}^{(i)}=\frac{z^{(i)}-\mu}{\sqrt{\sigma^2+\varepsilon}} \end{gathered}\]</span> 其中，m是单个mini-batch包含样本个数，<span class="math inline">\(\varepsilon\)</span>是为了防止分母为零，可取值<span class="math inline">\(10^{-8}\)</span>。这样，使得该隐藏层的所有输入<span class="math inline">\(z^{(i)}\)</span>均值为0，方差为1。</p><p>但是，大部分情况下并不希望所有的<span class="math inline">\(z^{(i)}\)</span>均值都为0,方差都为1，也不太合理。通常需要对<span class="math inline">\(z^{(i)}\)</span>进行进一步处理：</p><p><span class="math display">\[\tilde{z}^{(i)}=\gamma\cdot z_{norm}^{(i)}+\beta \]</span></p><p>上式中，<span class="math inline">\(\gamma\)</span>和<span class="math inline">\(\beta\)</span>是learnable parameters,类似于W 和b一样，可以通过梯度下降等算法求得。这里 , <span class="math inline">\(\gamma\)</span>和<span class="math inline">\(\beta\)</span>的作用是让<span class="math inline">\(\tilde{z}^{(i)}\)</span>的均值和方差为任意值，只需调整其值就可以了。例如，令：</p><p><span class="math display">\[\gamma=\sqrt{\sigma^2+\varepsilon},\quad\beta=u\]</span></p><p>则<span class="math inline">\(\widetilde{z}^{(i)}=z^{(i)}\)</span> ,即identity function。可见，设置<span class="math inline">\(\gamma\)</span>和<span class="math inline">\(\beta\)</span>为不同的值，可以得到任意的均值和方差。</p><p>这样，通过Batch Normalization,对隐藏层的各个<span class="math inline">\(z^{[l](i)}\)</span>进行标准化处理，得到<span class="math inline">\(\tilde{z}^{[l](i)}\)</span>,替代<span class="math inline">\(z^{[l](i)}\)</span>。</p><p>值得注意的是，输入的标准化处理Normalizing inputs和隐藏层的标准化处理Batch Normalization 是有区别的。Normalizing inputs使所有输入的均值为0，方差为1。而Batch Normalization可使各隐藏层输入的均值和方差为任意值。实际上，从激活函数的角度来说，如果各隐藏层的输入均值在靠近0的区域即处于激活函数的线性区域，这样不利于训练好的非线性神经网络，得到的模型效果也不会太好。这也解释了为什么需要用<span class="math inline">\(\gamma\)</span>和<span class="math inline">\(\beta\)</span>来对<span class="math inline">\(z^{[l](i)}\)</span>作进一步处理。</p><h2 id="在神经网络中应用batch-normalization">在神经网络中应用Batch Normalization</h2><p>在神经网络中应用Batch Normalization时，我们需要对每一层的隐藏层进行标准化处理。整个流程如下图所示： <img src="/img/深度学习-Course2-Week3/3超参数调试，batch正则化和程序框架_5.png" /></p><p>实际上，Batch Norm经常使用在mini-batch上，这也是其名称的由来。</p><p>值得注意的是，因为Batch Norm对各隐藏层<span class="math inline">\(Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}\)</span>有去均值的操作，所以这里的常数项<span class="math inline">\(b^{[l]}\)</span>可以消去，其数值效果完全可以由<span class="math inline">\(\tilde{Z}^{[l]}\)</span>中的<span class="math inline">\(\beta\)</span>来实现。因此，我们在使用Batch Norm 的时候，可以忽略各隐藏层的常数项<span class="math inline">\(b^{[l]}\)</span>。在使用梯度下降算法时，分别对<span class="math inline">\(W^{[l]}\)</span>,<span class="math inline">\(\beta^{[l]}\)</span>和<span class="math inline">\(\gamma^{[l]}\)</span>进行迭代更新。除了传统的梯度下降算法之外，还可以使用我们之前介绍过的动量梯度下降、RMSprop或者Adam等优化算法。</p><p>我们可以把输入特征做均值为0，方差为1的规范化处理，来加快学习速度。而Batch Norm也是对隐藏层各神经元的输入做类似的规范化处理。</p><p>总的来说，Batch Norm不仅能够提高神经网络训练速度，而且能让神经网络的权重W的更新更加“稳健”，尤其在深层神经网络中更加明显。</p><h2 id="batch-normalization的正则化效果">Batch Normalization的正则化效果</h2><p>Batch Norm也起到轻微的正则化（regularization）效果。具体表现在：</p><ul><li>每个mini-batch都进行均值为0，方差为1的归一化操作</li><li>每个mini-batch中，对各个隐藏层的<span class="math inline">\(Z^{[l]}\)</span>添加了随机噪声，效果类似于Dropout</li><li>mini-batch越小，正则化效果越明显</li></ul><p>但是，Batch Norm的正则化效果比较微弱，正则化也不是Batch Norm的主要功能。</p><h2 id="在测试过程中的使用">在测试过程中的使用</h2><p>训练过程中，Batch Norm是对单个mini-batch进行操作的，但在测试过程中，如果是单个样本，该如何使用Batch Norm进行处理呢？</p><p>首先，回顾一下训练过程中Batch Norm的主要过程： <span class="math display">\[\begin{gathered}\mu=\frac{1}{m}\sum_{i}z^{(i)}\\ \sigma^2=\frac{1}{m}\sum_{i}(z^{(i)}-\mu)^2\\ z_{norm}^{(i)}=\frac{z^{(i)}-\mu}{\sqrt{\sigma^2+\varepsilon}}\\ \tilde{z}^{(i)}=\gamma\cdot z_{norm}^{(i)}+\beta\end{gathered}\]</span> 其中，<span class="math inline">\(\mu\)</span>和<span class="math inline">\(\sigma^{2}\)</span>是对单个mini-batch中所有m个样本求得的。在测试过程中，如果只有一个样本，求其均值和方差是没有意义的，就需要对<span class="math inline">\(\mu\)</span>和<span class="math inline">\(\sigma^{2}\)</span>进行估计。</p><p>我们使用指数加权平均的方法估计单个样本的<span class="math inline">\(\mu\)</span>和<span class="math inline">\(\sigma^2\)</span>。并利用训练过程中得到的<span class="math inline">\(γ\)</span>和<span class="math inline">\(β\)</span>计算出各层的<span class="math inline">\(\tilde{z}^{(i)}\)</span>。</p><h2 id="总结">总结</h2><p>Batch Normalization不仅可以提高神经网络的训练速度，还可以使神经网络的权重更新更加稳健。在深层神经网络中，由于输入数据在每一层变换后可能会发生分布改变，Batch Normalization可以帮助维持输入的稳定性。此外，Batch Normalization还具有轻微的正则化效果。</p><h1 id="softmax回归">3 Softmax回归</h1><p>目前我们介绍的都是二分类问题，神经网络输出层只有一个神经元，表示预测输出y是正类的概率P(y=1|x)，y&gt;0.5则判断为正类，y^&lt;0.5则判断为负类。</p><p>对于多分类问题，用C表示种类个数，神经网络中输出层就有C个神经元，即<span class="math inline">\(n^{[L]}=C\)</span>。其中，每个 神经元的输出依次对应属于该类的概率，即<span class="math inline">\(P(y=c|x)\)</span>。为了处理多分类问题，我们一般使用Softmax回归模型。</p><p>Softmax回归模型输出层的激活函数如下所示：</p><p><span class="math display">\[\begin{gathered}z^{[L]}=W^{[L]}a^{[L-1]}+b^{[L]}\\a_i^{[L]}=\frac{e^{z_i^{[L]}}}{\sum_{i=1}^Ce^{z_i^{[L]}}}\end{gathered}\]</span></p><p>输出层每个神经元的输出<span class="math inline">\(a_i^{[L]}\)</span>对应属于该类的概率，满足： <span class="math display">\[\sum_{i=1}^Ca_i^{[L]}=1\]</span> 所有的<span class="math inline">\(a_i^{[L]}\)</span>,即<span class="math inline">\(\hat{y}\)</span> ,维度为(C,1)。</p><p>softmax的损失函数为： <img src="/img/深度学习-Course2-Week3/softmax损失函数.png" /></p><p>损失函数衡量的是在一个训练样例上的表现如何，所以对于一个特定的训练样本，y只能取一个值。因此最终只能针对 的一个值计算 的负对数，即在该特定训练样本中y的实际值等于j的任何值。例如，当y等于2时，损失函数只计算 <span class="math inline">\(-\log a_{2}\)</span></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习-Course2-Week2优化算法</title>
    <link href="/2024/02/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course2-Week2%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    <url>/2024/02/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course2-Week2%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="mini-batch梯度下降">1 Mini-batch梯度下降</h1><p>之前我们介绍的神经网络训练过程是对所有m个样本，称为batch，通过向量化计算方式，同时进行的。</p><p>如果m很大，例如达到百万数量级，训练速度往往会很慢，因为每次迭代都要对所有样本进行求和运算和矩阵运算。我们将这种梯度下降算法称为Batch Gradient Descent。</p><p>为了解决这一问题，我们可以把m个训练样本分成若干个子集，称为mini-batches，这样每个子集包含的数据量就小了，例如只有1000，然后每次在单一子集上进行神经网络训练，速度就会大大提高。这种梯度下降算法叫做Mini-batch Gradient Descent。</p><p>假设总的训练样本个数m=5000000,其维度为<span class="math inline">\((n_x,m)\)</span>。将其分成5000个子集，每个mini-batch含有1000个样本。我们将每个mini-batch记为<span class="math inline">\(X^{\{t\}}\)</span>,其维度为<span class="math inline">\((n_x,1000)\)</span>。相应的每个mini-batch的输出记为<span class="math inline">\(Y^{\{t\}}\)</span>,其 维 度 为 (1,1000)，且<span class="math inline">\(t=1,2,\cdots,5000\)</span>。</p><p>这里顺便总结一下我们遇到的神经网络中几类字母的上标含义：</p><p><span class="math inline">\(X^{(i)}:\)</span> 第i个样本 <span class="math inline">\(Z^{[l]}:\)</span> 神经网络第<span class="math inline">\(l\)</span>层网络的线性输出 <span class="math inline">\(X^{\{t\}},Y^{\{t\}}:\)</span> 第t组mini-batch</p><p>Mini-batches Gradient Descent的实现过程是先将总的训练样本分成T个子集（mini-batches），然后对每个mini-batch进行神经网络训练，包括向前传播，计算Cost Function，反向传播，循环至T个mini-batch都训练完毕。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">for  <span class="hljs-built_in">t</span>=<span class="hljs-number">1</span>,⋯,<span class="hljs-built_in">T</span> &#123;<br>    Forward Propagation<br>    ComputeCostFunction<br>    BackwardPropagation<br>    <span class="hljs-symbol">W:</span>=W−α⋅dW<br>    <span class="hljs-symbol">b:</span>=b−α⋅<span class="hljs-built_in">db</span><br>&#125;<br></code></pre></td></tr></table></figure><p>经过T次循环之后，所有m个训练样本都进行了梯度下降计算。这个过程，我们称之为经历了一个epoch。</p><p>对于Batch Gradient Descent而言，一个epoch只进行一次梯度下降算法；而Mini-Batches Gradient Descent，一个epoch会进行T次梯度下降算法。</p><p>值得一提的是，对于Mini-Batches Gradient Descent，可以进行多次epoch训练。而且，每次epoch，最好是将总体训练数据重新打乱、重新分成T组mini-batches，这样有利于训练出最佳的神经网络模型。</p><p>Batch gradient descent和Mini-batch gradient descent的cost曲线如下图所示：</p><p><img src="/img/深度学习-Course2-Week2/2优化算法.png" /></p><p>对于一般的神经网络模型，使用Batch gradient descent，随着迭代次数增加，cost是不断减小的。然而，使用Mini-batch gradient descent，随着在不同的mini-batch上迭代训练，其cost不是单调下降，而是受类似noise的影响，出现振荡。但整体的趋势是下降的，最终也能得到较低的cost值。</p><p>之所以出现细微振荡的原因是不同的mini-batch之间是有差异的。例如可能第一个子集<span class="math inline">\((X^{\{1\}},Y^{\{1\}})\)</span>是好的子集，而第二个子集<span class="math inline">\((X^{\{2\}},Y^{\{2\}})\)</span>包含了一些噪声noise。出现细微振荡是正常的。</p><p>如何选择每个mini-batch的大小，即包含的样本个数呢？有两个极端：如果mini-batch size=m ,即为Batch gradient descent ,只包含一个子集 为<span class="math inline">\((X^{\{1\}},Y^{\{1\}})=(X,Y)\)</span> ;如果mini-batch size=1 , 即为Stachastic gradient descent,每个样本就是一个子集<span class="math inline">\((X^{\{1\}},Y^{\{1\}})=(x^{(i)},y^{(i)})\)</span> ,共有m个子集。</p><p>我们来比较一下Batch gradient descent和Stachastic gradient descent的梯度下降曲线。 <img src="/img/深度学习-Course2-Week2/2优化算法_1.png" /></p><p>如图所示，蓝色的线代表Batch gradient descent，紫色的线代表Stachastic gradient descent。</p><p>Batch gradient descent会比较平稳地接近全局最小值，但是因为使用了所有m个样本，每次前进的速度有些慢。</p><p>Stachastic gradient descent每次前进速度很快，但是路线曲折，有较大的振荡，最终会在最小值附近来回波动，难以真正达到最小值处。而且在数值处理上就不能使用向量化的方法来提高运算速度。</p><p>实际使用中，mini-batch size不能设置得太大（Batch gradient descent），也不能设置得太小（Stachastic gradient descent）。</p><p>这样，相当于结合了Batch gradient descent和Stachastic gradient descent各自的优点，既能使用向量化优化算法，又能较快速地找到最小值。</p><p>mini-batch gradient descent的梯度下降曲线如下图绿色所示，每次前进速度较快，且振荡较小，基本能接近全局最小值。 <img src="/img/深度学习-Course2-Week2/2优化算法_2.png" /> 一般来说，如果总体样本数量m不太大时，例如m≤2000m≤2000，建议直接使用Batch gradient descent。</p><p>如果总体样本数量m很大时，建议将样本分成许多mini-batches。推荐常用的mini-batch size为64,128,256,512。这些都是2的幂。</p><p>之所以这样设置的原因是计算机存储数据一般是2的幂，这样设置可以提高运算速度。</p><h1 id="指数加权平均">2 指数加权平均</h1><h2 id="指数加权平均概念">指数加权平均概念</h2><p>该部分我们将介绍指数加权平均（Exponentially weighted averages）的概念。</p><p>我们记录半年内伦敦市的气温变化，并在二维平面上绘制出来，如下图所示：</p><p><img src="/img/深度学习-Course2-Week2/2优化算法_3.png" /> 如果我们希望看到半年内气温的整体变化趋势，可以通过移动平均（moving average）的方法来对每天气温进行平滑处</p><p>例如我们可以设V0=0，当成第0天的气温值。</p><p>第一天的气温与第0天的气温有关： <span class="math display">\[V_1=0.9V_0+0.1\theta_1\]</span></p><p>第二天的气温与第一天的气温有关： <span class="math display">\[V_2=0.9V_1+0.1\theta_2\]</span></p><p>第三天的气温与第二天的气温有关： <span class="math display">\[V_3=0.9V_2+0.1\theta_3\]</span></p><p>即第t天与第t-1天的气温迭代关系为： <span class="math display">\[V_t=0.9V_{t-1}+0.1\theta_t\]</span></p><p>经过移动平均处理得到的气温如下图红色曲线所示： <img src="/img/深度学习-Course2-Week2/2优化算法_5.png" /> 这种滑动平均算法称为指数加权平均（exponentially weighted average）。根据之前的推导公式，其一般形式为： <span class="math display">\[V_t=\beta V_{t-1}+(1-\beta)\theta_t\]</span></p><p>上面的例子中，β=0.9。β值决定了指数加权平均的天数，近似表示为<span class="math inline">\(\frac1{1-\beta}\)</span></p><p>例如，当<span class="math inline">\(\beta=0.9\)</span>,则<span class="math inline">\(\frac{1}{1-\beta}=10\)</span>,表示将前10天进行指数加权平均。当<span class="math inline">\(\beta=0.98\)</span>,则<span class="math inline">\(\frac{1}{1-\beta}=50\)</span>,表示将前50天进行指数加权平均。<span class="math inline">\(\beta\)</span>值越大，则指数加权平均的天数越多，平均后的趋势线就越平缓，但是同时也会向右平移。下图绿色曲线和黄色曲线分别表示了<span class="math inline">\(\beta=0.98\)</span>和<span class="math inline">\(\beta=0.5\)</span>时，指数加权平均的结果。 <img src="/img/深度学习-Course2-Week2/2优化算法_6.png" /></p><p>这里简单解释一下公式1/(1−β)是怎么来的。准确来说，指数加权平均算法跟之前所有天的数值都有关系，根据之前的推导公式就能看出。</p><p>但是指数是衰减的，一般认为衰减到1/e就可以忽略不计了。因此，根据之前的推导公式，我们只要证明下式就好了： <span class="math display">\[\beta^{\frac1{1-\beta}}=\frac1e\]</span> 令<span class="math inline">\(\frac{1}{1-\beta}=N\)</span> ,<span class="math inline">\(N&gt;0\)</span> ,则<span class="math inline">\(\beta=1-\frac{1}{N}\)</span> ,<span class="math inline">\(\frac{1}{N}&lt;1\)</span>。即证明转化为： <span class="math display">\[(1-\frac1N)^N=\frac1e\]</span></p><p>显然，当N&gt;&gt;0时，上述等式是近似成立的。</p><p>至此，简单解释了为什么指数加权平均的天数的计算公式为1/(1−β)。</p><h2 id="偏差修正">偏差修正</h2><p>上文中提到当β=0.98时，指数加权平均结果如下图绿色曲线所示。但是实际上，真实曲线如紫色曲线所示。 <img src="/img/深度学习-Course2-Week2/2优化算法_7.png" /> 我们注意到，紫色曲线与绿色曲线的区别是，紫色曲线开始的时候相对较低一些。这是因为开始时我们设置V0=0，所以初始值会相对小一些，直到后面受前面的影响渐渐变小，趋于正常。</p><p>修正这种问题的方法是进行偏移校正（bias correction），即在每次计算完Vt后，对Vt进行下式处理：<span class="math inline">\(\frac{V_t}{1-\beta^t}\)</span></p><p>在刚开始的时候，t比较小，<span class="math inline">\((1-\beta^t)&lt;1\)</span>,这样就将<span class="math inline">\(V_t\)</span>修正得更大一些，效果是把紫色曲线开始部分向上提升一些，与绿色曲线接近重合。随着t增大<span class="math inline">\((1-\beta^t)\approx1\)</span>，<span class="math inline">\(V_t\)</span>基本不变，紫色曲线与绿色曲线依然重合。这样就实现了简单的偏移校正，得到我们希望的绿色曲线。</p><p>值得一提的是，机器学习中，偏移校正并不是必须的。因为，在迭代一次次后（t较大），Vt受初始值影响微乎其微，紫色曲线与绿色曲线基本重合。所以，一般可以忽略初始迭代过程，等到一定迭代之后再取值，这样就不需要进行偏移校正了。</p><h1 id="动量梯度下降算法">3 动量梯度下降算法</h1><p>该部分将介绍动量梯度下降算法，其速度要比传统的梯度下降算法快很多。做法是在每次训练时，对梯度进行指数加权平均处理，然后用得到的梯度值更新权重W和常数项b。下面介绍具体的实现过程。 <img src="/img/深度学习-Course2-Week2/2优化算法_8.png" /> 原始的梯度下降算法如上图蓝色折线所示。在梯度下降过程中，梯度下降的振荡较大，尤其对于W、b之间数值范围差别较大的情况。此时每一点处的梯度只与当前方向有关，产生类似折线的效果，前进缓慢。</p><p>而如果对梯度进行指数加权平均，这样使当前梯度不仅与当前方向有关，还与之前的方向有关，这样处理让梯度前进方向更加平滑，减少振荡，能够更快地到达最小值处。</p><p>这是因为之前的梯度方向可以保证是大致指向极小值方向的，而当前的可能是也可能不是，因此如果是，则用之前的梯度加强其收敛速度，否则用之前的去抵消以减弱收敛速度，这种方法的问题即容易积累动量从而越过极小值。</p><p>权重W和常数项b的指数加权平均表达式如下： <span class="math display">\[\begin{aligned}V_{dW}&amp;=\beta\cdot V_{dW}+(1-\beta)\cdot dW\\V_{db}&amp;=\beta\cdot V_{db}+(1-\beta)\cdot db\end{aligned}\]</span> 初始时，令Vdw=0,Vdb=0。一般设置β=0.9，即指数加权平均前10天的数据，实际应用效果较好。</p><p>另外，关于偏移校正，可以不使用。因为经过10次迭代后，随着滑动平均的过程，偏移情况会逐渐消失。</p><h1 id="rmsprop">4 RMSprop</h1><p>RMSprop是另外一种优化梯度下降速度的算法。每次迭代训练过程中，其权重W和常数项b的更新表达式为： <span class="math display">\[\begin{gathered}S_W=\beta S_{dW}+(1-\beta)dW^2 \\S_b=\beta S_{db}+(1-\beta)db^2 \\W:=W-\alpha\frac{dW}{\sqrt{S_{W}}},b:=b-\alpha\frac{db}{\sqrt{S_{b}}} \end{gathered}\]</span></p><p>下面简单解释一下RMSprop算法的原理，仍然以下图为例，为了便于分析，令水平方向为W的方向，垂直方向为b的方向。 <img src="/img/深度学习-Course2-Week2/2优化算法_13.png" /></p><p>从图中可以看出，梯度下降(蓝色折线)在垂直方向 (b)上振荡较大，在水平方向(W)上振荡较小，表示在b方向上梯度较大，即<span class="math inline">\(db\)</span>较大，而在W方向上梯度较小，即<span class="math inline">\(dW\)</span>较小。因此，上述表达式中<span class="math inline">\(S_{b}\)</span>较大，而<span class="math inline">\(S_W\)</span>较小。在更新W和b的表达式中，变化值 <span class="math inline">\(\frac{dW}{\sqrt{Sw}}\)</span>较大，而<span class="math inline">\(\frac{db}{\sqrt{S_b}}\)</span>较小。也就使得W变化得多一些，b变化得少一些。即加快了W方向的速度，减小了b方向的速度，减小振荡，实现快速梯度下降算法，其梯度下降过程如绿色折线所示。总得来说，就是如果哪个方向振荡大，就减小该方向的更新速度， 从而减小振荡。</p><p>还有一点需要注意的是为了避免RMSprop算法中分母为零，通常可以在分母增加一个极小的常数ε： <span class="math display">\[W:=W-\alpha\frac{dW}{\sqrt{S_W}+\varepsilon},\mathrm{~}b:=b-\alpha\frac{db}{\sqrt{S_b}+\varepsilon}\]</span> 其中，ε=10^−8，或者其它较小值。</p><h1 id="adam优化算法">5 Adam优化算法</h1><p>Adam（Adaptive Moment Estimation）算法结合了动量梯度下降算法和RMSprop算法。其算法流程为： <span class="math display">\[\begin{aligned}&amp;V_{dW}=0,S_{dW},V_{db}=0,S_{db}=0 \\&amp;\text{On iteration t:} \\&amp;&amp;&amp;\textit{Cimpute d}W,db \\&amp;&amp;&amp;\begin{aligned}V_{dW}=\beta_1V_{dW}+(1-\beta_1)dW,V_{db}=\beta_1V_{db}+(1-\beta_1)db\end{aligned} \\&amp;&amp;&amp;\begin{aligned}S_{dW}=\beta_2S_{dW}+(1-\beta_2)dW^2,S_{db}=\beta_2S_{db}+(1-\beta_2)db^2\end{aligned} \\&amp;&amp;&amp;V_{dW}^{corrected}=\frac{V_{dW}}{1-\beta_1^t},V_{db}^{corrected}=\frac{V_{db}}{1-\beta_1^t} \\&amp;&amp;&amp;S_{dW}^{corrected}=\frac{S_{dW}}{1-\beta_2^t},S_{db}^{corrected}=\frac{S_{db}}{1-\beta_2^t} \\&amp;&amp;&amp;W:=W-\alpha\frac{V_{dW}^{corrected}}{\sqrt{S_{dW}^{corrected}}+\varepsilon},b:=b-\alpha\frac{V_{db}^{corrected}}{\sqrt{S_{db}^{corrected}}+\varepsilon}\end{aligned}\]</span></p><p>Adam 算法包含了几个超参数，分别是：<span class="math inline">\(\alpha,\beta_1,\beta_2,\varepsilon\)</span>。其中，<span class="math inline">\(\beta_1\)</span>通常设置为0.9，<span class="math inline">\(\beta_2\)</span>通常设置为0.999,<span class="math inline">\(\varepsilon\)</span>通常设置为<span class="math inline">\(10^{-8}\)</span>。一般只需要对<span class="math inline">\(\beta_{1}\)</span>和<span class="math inline">\(\beta_{2}\)</span>进行调试。</p><p>实际应用中，Adam算法结合了动量梯度下降和RMSprop各自的优点，使得神经网络训练速度大大提高。</p><h1 id="学习率衰减">6 学习率衰减</h1><p>减小学习因子α也能有效提高神经网络训练速度，这种方法被称为learning rate decay。</p><p>学习率衰减就是随着迭代次数增加，学习因子α逐渐减小。</p><p>下面用图示的方式来解释这样做的好处。下图中，蓝色折线表示使用恒定的学习因子α，由于每次训练α相同，步进长度不变，在接近最优值处的振荡也大，在最优值附近较大范围内振荡，与最优值距离就比较远。 <img src="/img/深度学习-Course2-Week2/2优化算法_14.png" /> 绿色折线表示使用不断减小的α，随着训练次数增加，α逐渐减小，步进长度减小，使得能够在最优值处较小范围内微弱振荡，不断逼近最优值。相比较恒定的α来说，learning rate decay更接近最优值。</p><p>Learning rate decay中对α可由下列公式得到： <span class="math display">\[\alpha=\frac1{1+\textit{deca}y\_rate*epoch}\alpha_0\]</span> 其中，deacy_rate是参数（可调），epoch是训练完所有样本的次数。随着epoch增加，α会不断变小。</p><p>除了上面计算α的公式之外，还有其它可供选择的计算公式： <span class="math display">\[\begin{gathered}\alpha=0.95^{epoch}\cdot\alpha_0\\\alpha=\frac k{\sqrt{epoch}}\cdot\alpha_0\quad or\quad\frac k{\sqrt{t}}\cdot\alpha_0\end{gathered}\]</span></p><p>其中，k为可调参数，t为mini-bach number。</p><p>除此之外，还可以设置α为关于t的离散值，随着t增加，α呈阶梯式减小。 <img src="/img/深度学习-Course2-Week2/2优化算法_15.png" /></p><p>也可以根据训练情况手动调整当前的α值，但会比较耗时间。</p><h1 id="局部最优问题">7 局部最优问题</h1><p>在使用梯度下降算法不断减小cost function时，可能会得到局部最优解（local optima）而不是全局最优解（global optima）。</p><p>之前我们对局部最优解的理解是形如碗状的凹槽，如下图左边所示。但是在神经网络中，局部最优解的概念发生了变化。 <img src="/img/深度学习-Course2-Week2/2优化算法_11.png" /> 准确地来说，大部分梯度为零的“最优点”并不是这些凹槽处，而是形如右边所示的马鞍状，称为saddle point。</p><p>也就是说，梯度为零并不能保证都是convex（极小值），也有可能是concave（极大值）。</p><p>特别是在神经网络中参数很多的情况下，所有参数梯度为零的点很可能都是右边所示的马鞍状的saddle point，而不是左边那样的local optimum。</p><p>类似马鞍状的plateaus会降低神经网络学习速度。Plateaus是梯度接近于零的平缓区域，如下图所示。在plateaus上梯度很小，前进缓慢，到达saddle point需要很长时间。</p><p>到达saddle point后，由于随机扰动，梯度一般能够沿着图中绿色箭头，离开saddle point，继续前进，只是在plateaus上花费了太多时间。 <img src="/img/深度学习-Course2-Week2/2优化算法_12.png" /></p><p>总的来说，关于local optima，有两点总结：</p><ul><li><p>只要选择合理的强大的神经网络，一般不太可能陷入local optima</p></li><li><p>Plateaus可能会使梯度下降变慢，降低学习速度</p></li></ul><p>值得一提的是，上文介绍的动量梯度下降，RMSprop，Adam算法都能有效解决plateaus下降过慢的问题，大大提高神经网络的学习速度。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习-Course2-Week1深度学习实用层面</title>
    <link href="/2024/02/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course2-Week1%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2/"/>
    <url>/2024/02/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course2-Week1%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="训练验证测试集train-dev-test-sets">1.1 训练，验证，测试集（Train / Dev / Test sets）</h1><h2 id="数据集划分">数据集划分</h2><p>一般我们将所有的样本数据分成三个部分：Train/Dev/Test sets。</p><ul><li>训练集（Train sets）：用于训练深度学习模型。</li><li>验证集（Dev sets）：用于验证不同算法的表现，并选择最佳的算法模型。</li><li>测试集（Test sets）：用于测试最佳算法的实际表现，提供无偏估计。</li></ul><h2 id="数据集比例设定">数据集比例设定</h2><ul><li><p>通常设置Train sets和Test sets的数量比例为70%和30%。如果有Dev sets，则设置比例为60%、20%、20%，分别对应Train/Dev/Test sets。</p></li><li><p>对于大数据样本，可将 Dev sets 和 Test sets 的比例设置得更低，如 1% 或 0.5%。例如，对于 100 万样本，可以采用 98%/1%/1% 或 99%/0.5%/0.5% 的比例分配。</p></li></ul><h2 id="超参数优化">超参数优化</h2><ul><li>构建神经网络时需设置多个超参数，如层数、每个隐藏层神经元个数、学习速率、激活函数等。</li><li>通过反复迭代更新来获得最佳参数值。循环迭代过程包括：提出想法（Idea）、选择初始参数值、构建神经网络模型结构、通过代码实现神经网络、验证参数对应的神经网络性能。</li><li>通过多次循环调整参数并选择最佳参数值来优化神经网络性能。</li></ul><p><img src="/img/深度学习-Course2-Week1/1深度学习的实用层面.png" /></p><h2 id="训练效率提升">训练效率提升</h2><ul><li>应用深度学习是一个反复迭代的过程，需要通过多次循环训练得到最优化参数。</li><li>循环训练的关键是单次循环所需时间，单次循环越快，训练过程越快。合适的 Train/Dev/Test sets 数量能有效提高训练效率。</li></ul><h1 id="偏差方差bias-variance">1.2 偏差，方差（Bias /Variance）</h1><h2 id="偏差和方差的概念"><strong>偏差和方差的概念</strong></h2><p>在传统的机器学习算法中，偏差(Bias)和方差(Variance)是对立的，分别对应着欠拟合和过拟合，我们常常需要在Bias和Variance之间进行权衡。</p><p>而在深度学习中，我们可以同时减小Bias和Variance，构建最佳神经网络模型。</p><h2 id="偏差和方差的权衡"><strong>偏差和方差的权衡</strong></h2><p><img src="/img/深度学习-Course2-Week1/1深度学习的实用层面_1.png" /></p><ul><li>针对数据集，当使用简单模型（如逻辑回归）无法很好地拟合数据时，出现高偏差（high bias），即“欠拟合”（underfitting）。</li><li>相反，当使用过于复杂的模型（如深度神经网络）能够完美拟合数据，但泛化能力较差时，出现高方差（high variance），即“过拟合”（overfitting）。</li><li>介于过度拟合和欠拟合之间，存在一些适度拟合的模型，这种数据拟合看起来更加合理。</li></ul><p>对于二维数据集，可以通过绘制数据和可视化分割边界来观察偏差和方差的情况。在多维空间数据中，虽无法直接绘制数据，但可以通过训练集误差和验证集误差研究偏差和方差。</p><h2 id="训练集误差和验证集误差"><strong>训练集误差和验证集误差</strong></h2><ul><li>关键数据包括训练集误差（Train set error）和验证集误差（Dev set error）。</li><li>通过比较训练集误差和验证集误差，可以诊断算法是否具有高方差或高偏差。</li></ul><h2 id="诊断算法的高偏差和高方差"><strong>诊断算法的高偏差和高方差</strong></h2><p>我们以识别猫狗为例，人类都能正确识别所有猫类图片 即base error为0。base error不同，相应的Train set error和Dev set error会有所变化，但没有相对变化。，对于此种情况：</p><p><img src="/img/深度学习-Course2-Week1/1深度学习的实用层面_2.png" /></p><ul><li><p><strong>高方差</strong>：假设Train set error为1%，而Dev set error为11%，即该算法模型对训练样本的识别很好，但是对验证集的识别却不太好。这说明了该模型对训练样本可能存在过拟合，模型泛化能力不强，导致验证集识别率低。这恰恰是high variance的表现。<strong>训练集误差较低，但验证集误差较高，导致过度拟合。</strong></p></li><li><p><strong>高偏差</strong>：假设Train set error为15%，而Dev set error为16%，虽然二者error接近，即该算法模型对训练样本和验证集的识别都不是太好。这说明了该模型对训练样本存在欠拟合。这恰恰是high bias的表现。<strong>训练集误差和验证集误差都较高，导致欠拟合。</strong></p></li><li><p><strong>高偏差&amp;高方差</strong>： 假设Train set error为15%，而Dev set error为30%，说明了该模型既存在high bias也存在high variance（深度学习中最坏的情况）。</p></li><li><p><strong>低偏差&amp;低方差</strong>： 再假设Train set error为0.5%，而Dev set error为1%，即low bias和low variance，是最好的情况。</p></li></ul><h2 id="高偏差高方差的情况"><strong>高偏差&amp;高方差的情况</strong></h2><p>一般来说，Train set error体现了是否出现bias，Dev set error体现了是否出现variance（正确地说，应该是Dev set error与Train set error的相对差值）。</p><p>我们已经通过二维平面展示了high bias或者high variance的模型，下图展示了high bias and high variance的模型： <img src="/img/深度学习-Course2-Week1/1深度学习的实用层面_3.png" /> 模型既存在high bias也存在high variance，可以理解成某段区域是欠拟合的，某段区域是过拟合的。</p><h2 id="如何减小high-bias和high-variance">如何减小high bias和high variance</h2><ul><li><p>减少high bias ：增加神经网络的隐藏层个数、神经元个数，训练时间延长，选择其它更复杂的NN模型等。</p></li><li><p>减少high variance ：增加训练样本数据，进行正则化Regularization，选择其他更复杂的NN模型等</p></li></ul><h1 id="机器学习基础basic-recipe-for-machine-learning">1.3 机器学习基础（Basic Recipe for Machine Learning）</h1><p><img src="/img/深度学习-Course2-Week1/1深度学习的实用层面_4.png" /></p><p>在训练神经网络时，我们需要考虑偏差（bias）和方差（variance）的问题。初始模型训练完成后，我们首先要评估算法的偏差水平。如果偏差较高，意味着模型无法很好地拟合训练集数据，可以选择一个新的网络架构，例如增加更多的隐藏层或隐藏单元，这样通常可以提升模型的拟合能力。另外，可以花费更多时间来训练网络，或者尝试使用更先进的优化算法。</p><p>一旦偏差降低到可接受的水平，我们需要检查方差的问题。如果方差较高，解决方案之一是增加更多的数据。然而，有时候我们无法获得更多的数据，这时我们可以尝试使用正则化方法来减少过拟合。</p><p>有时候，我们不得不反复尝试不同的方法。但是，如果能找到更合适的神经网络架构，有时候它可以同时减少偏差和方差。</p><h1 id="正则化regularization">1.4 正则化（Regularization）</h1><p>如果出现了过拟合，可以通过扩大训练样本数量来减小方差，但是通常获得更多训练样本的成本太高，比较困难。所以，更可行有效的办法就是使用正则化（regularization）来解决。</p><p>常见正则化类型有L1正则化和L2正则化，其中L2正则化是最常用的。</p><h2 id="l2-regularization">L2 regularization</h2><p>L2正则化采用矩阵范数的平方来衡量模型复杂度，将矩阵中所有元素的平方和作为正则化项，并乘以正则化参数λ和系数1/2m，加入到损失函数中，从而减小参数的值。将之前的Logistic regression采用L2 regularization 为： <span class="math display">\[\begin{gathered}J(w,b)=\frac1m\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})+\frac\lambda{2m}||w||_2^2\\||w||_2^2=\sum_{j=1}^{n_x}w_j^2=w^Tw\end{gathered}\]</span></p><p>在神经网络中应用L2正则化： <span class="math display">\[\begin{gathered}\begin{aligned}J(w^{[1]},b^{[1]},\cdots,w^{[L]},b^{[L]})&amp;=\frac1m\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})+\frac\lambda{2m}\sum_{l=1}^L||w^{[l]}||^2\\\\||w^{[l]}||^2&amp;=\sum_{i=1}^{n^{[l]}}\sum_{j=1}^{n^{[l-1]}}(w_{ij}^{[l]})^2\end{aligned}\end{gathered}\]</span></p><p>神经网络含有一个成本函数，该函数包含所有参数，其中正则项为<span class="math inline">\(\frac\lambda{2m}\sum_{l=1}^L||w^{[l]}||^2\)</span>，其中<span class="math inline">\(L\)</span>是神经网络所含的层数。</p><p>由于加入了正则化项，梯度下降算法中的计算表达式需要做如下修改： <span class="math display">\[\begin{gathered}dw^{[l]}=dw_{before}^{[l]}+\frac\lambda mw^{[l]}\\\\w^{[l]}:=w^{[l]}-\alpha\cdot dw^{[l]}\end{gathered}\]</span> L2正则化也被称为“权重衰减(weight decay)”，因为它乘以一个系数<span class="math inline">\((1 - \alpha\frac{\lambda}{m})\)</span>来减小权重指标。不断迭代更新，不断地减小。 <span class="math display">\[\begin{aligned}w^{[l]}&amp; :=w^{[l]}-\alpha\cdot dw^{[l]}  \\&amp;=w^{[l]}-\alpha\cdot(dw_{before}^{[l]}+\frac\lambda mw^{[l]}) \\&amp;=(1-\alpha\frac\lambda m)w^{[l]}-\alpha\cdot dw_{before}^{[l]}\end{aligned}\]</span></p><h2 id="l1-regularization">L1 regularization</h2><p><span class="math display">\[\begin{gathered}J(w,b)=\frac1m\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})+\frac\lambda{2m}||w||_1\\||w||_1=\sum_{j=1}^{nx}|w_j|\end{gathered}\]</span> 使用L1正则化，正则项为<span class="math inline">\(\frac{\lambda}{m}\)</span>乘以<span class="math inline">\(\sum_{j= 1}^{n_{x}}{|w|}\)</span>，其中<span class="math inline">\(\sum_{j =1}^{n_{x}}{|w|}\)</span>也被称为参数<span class="math inline">\(w\)</span>向量的L1范数。使用L1正则化后，<span class="math inline">\(w\)</span>最终会是稀疏的，即<span class="math inline">\(w\)</span>向量中有很多0，其优点是能够降低存储内存。</p><p>然而，实际上L1 regularization在解决high variance方面比L2 regularization并不更具优势。而且，L1的在微分求导方面比较复杂。所以，一般L2 regularization更加常用。</p><h2 id="总结">总结</h2><p>正则化能够通过减小参数的值来降低模型的复杂度，从而防止过拟合的出现。 正则化的目的就是让权重w在一个约束范围内梯度下降并寻找最优解</p><h1 id="为什么正则化有利于预防过拟合呢why-regularization-reduces-overfitting">1.5 为什么正则化有利于预防过拟合呢？（Why regularization reduces overfitting?）</h1><p><img src="/img/深度学习-Course2-Week1/1深度学习的实用层面_6.png" /></p><p>假如我们选择了非常复杂的神经网络模型，如上图左上角所示。在未使用正则化的情况下，我们得到的分类超平面可能是类似上图右侧的过拟合。但是，如果使用L2 regularization,当<span class="math inline">\(\lambda\)</span>很大时，<span class="math inline">\(w^{[l]}\approx0\)</span>。<span class="math inline">\(w^{[l]}\)</span>近似为零，意味着该神经网络模型中的某些神经元实际的作用很小，可以忽略。</p><p><img src="/img/深度学习-Course2-Week1/1深度学习的实用层面_7.png" /></p><p>从效果上来看，其实是将某些神经元给忽略掉了。这样原本过于复杂的神经网络模型就变得不那么复杂了，而变得非常简单化了。如上图所示，整个简化的神经网络模型变成了一个逻辑回归模型。问题就从high variance变成了high bias 了。</p><p>还有另外一个直观的例子来解释为什么正则化能够避免发生过拟合。假设激活函数是tanh函数。tanh函数的特点是在z接近零的区域，函数近似是线性的，而当|z|很大的时候，函数非线性且变化缓慢。当使用正则化，<span class="math inline">\(\lambda\)</span>较大，即对权重<span class="math inline">\(w^{[l]}\)</span>的惩罚较大，<span class="math inline">\(w^{[l]}\)</span>减小。因为<span class="math inline">\(z^{[l]}=w^{[l]}a^{[l]}+b^{[l]}\)</span>，当<span class="math inline">\(w^{[l]}\)</span>减小的时候，<span class="math inline">\(z^{[l]}\)</span>也会减小。则此时的<span class="math inline">\(z^{[l]}\)</span>分布在tanh函数的近似线性区域（下图红色部分）。那么这个神经元起的作用就相当于是linear regression。如果每个神经元对应的权重<span class="math inline">\(w^{[l]}\)</span>都比较小，那么整个神经网络模型相当于是多个linear regression的组合，即可看成一个linear network。得到的分类超平面就会比较简单，不会出现过拟合现象。 <img src="/img/深度学习-Course2-Week1/1深度学习的实用层面_8.png" /></p><h1 id="dropoutdropout">1.6 Dropout（Dropout）</h1><p>除了L2 regularization之外，还有另外一种防止过拟合的有效方法：Dropout。</p><p>Dropout是指在深度学习网络的训练过程中，对于每层的神经元，按照一定的概率将其暂时从网络中丢弃。也就是说，每次训练时，每一层都有部分神经元不工作，起到简化复杂网络模型的效果，从而避免发生过拟合。</p><p><img src="/img/深度学习-Course2-Week1/1深度学习的实用层面_9.png" /></p><p>Dropout有不同的实现方法，接下来介绍一种常用的方法：Inverted dropout。</p><p>（1）假设对于第l层神经元，设定保留神经元比例概率keep_prob=0.8，即该层有20%的神经元停止工作。</p><p>（2）dl为dropout向量，设置dl为随机vector，其中80%的元素为1，20%的元素为0。在python中可以使用如下语句生成dropout vector：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dl = np.random.rand(al.shape[<span class="hljs-number">0</span>],al.shape[<span class="hljs-number">1</span>])&lt;keep_prob<br></code></pre></td></tr></table></figure><p>（3）然后，第l层经过dropout，随机删减20%的神经元，只保留80%的神经元，其输出为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">al = np.multiply(al,dl)<br></code></pre></td></tr></table></figure><p>（4）最后，还要对al进行scale up处理，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">al /= keep_prob<br></code></pre></td></tr></table></figure><p>以上就是Inverted dropout的方法。之所以要对al进行scale up是为了保证在经过dropout后，al作为下一层神经元的输入值尽量保持不变。</p><p>假设第l层有50个神经元，经过dropout后，有10个神经元停止工作，这样只有40个神经元有作用。</p><p>那么得到的al只相当于原来的80%，期望值小了20%。scale up后，能够尽可能保持al的期望值相比之前没有大的变化，不影响整体。</p><p>Inverted dropout的另外一个好处就是在对该dropout后的神经网络进行测试时能够减少scaling问题。</p><p>因为在训练时，使用scale up保证al的期望值没有大的变化，测试时就不需要再对样本数据进行类似的尺度伸缩操作了。</p><h1 id="理解-dropoutunderstanding-dropout">1.7 理解 dropout（Understanding Dropout）</h1><h2 id="dropout基本概念">Dropout基本概念</h2><p>在每次迭代训练时，随机删除掉隐藏层一定数量的神经元；然后，在删除后的剩下的神经元上进行正向和反向更新权重w和常数项b；接着，下一次迭代中，再恢复之前删除的神经元，重新随机删除一定数量的神经元，进行正向和反向更新w和b。不断重复上述过程，直至迭代训练完成。</p><p>值得注意的是，使用dropout训练结束后，==在测试和实际应用模型时，不需要进行dropout和随机删减神经元==，所有的神经元都在工作。</p><h2 id="dropout防止过拟合的原理">Dropout防止过拟合的原理</h2><p>Dropout通过每次迭代训练时，随机选择不同的神经元，相当于每次都在不同的神经网络上进行训练，类似机器学习中Bagging的方法，能够防止过拟合。</p><h2 id="从权重w的角度解释防止过拟合的原理">从权重w的角度解释防止过拟合的原理</h2><p>对于某个神经元来说，某次训练时，它的某些输入在dropout的作用被过滤了。而在下一次训练时，又有不同的某些输入被过滤。经过多次训练后，某些输入被过滤，某些输入被保留。</p><p>这样，该神经元就不会受某个输入非常大的影响，影响被均匀化了。也就是说，对应的权重w不会很大。</p><p>这从效果上来说，与L2 regularization是类似的，都是对权重w进行“惩罚”，减小了w的值。</p><p>总的来说，对于同一组训练数据，利用不同的神经网络训练之后，求其输出的平均值可以减少过拟合。</p><p>Dropout就是利用这个原理，每次丢掉一定数量的隐藏层神经元，相当于在不同的神经网络上进行训练，这样就减少了神经元之间的依赖性，即每个神经元不能依赖于某几个其他的神经元（指层与层之间相连接的神经元），使神经网络更加能学习到与其他神经元之间的更加健壮robust的特征。</p><h2 id="注意事项">注意事项</h2><p>首先，不同隐藏层的dropout系数keep_prob可以不同。一般来说，神经元越多的隐藏层，keep_out可以设置得小一些，例如0.5；神经元越少的隐藏层，keep_out可以设置的大一些，例如0.8，设置是1。</p><p>另外，实际应用中，不建议对输入层进行dropout，如果输入层维度很大，例如图片，那么可以设置dropout，但keep_out应设置的大一些，例如0.8，0.9。</p><p>总体来说，就是越容易出现overfitting的隐藏层，其keep_prob就设置的相对小一些。没有准确固定的做法，通常可以根据validation进行选择。</p><p>Dropout在电脑视觉CV领域应用比较广泛，因为输入层维度较大，而且没有足够多的样本数量。</p><p>值得注意的是dropout是一种regularization技巧，用来防止过拟合的，最好只在需要regularization的时候使用dropout。</p><p>使用dropout的时候，可以通过绘制cost function来进行debug，看看dropout是否正确执行。一般做法是，将所有层的keep_prob全设置为1，再绘制cost function，即涵盖所有神经元，看J是否单调下降。下一次迭代训练时，再将keep_prob设置为其它值。</p><h1 id="其他正则化方法other-regularization-methods">1.8 其他正则化方法（Other regularization methods）</h1><h2 id="数据增强">数据增强</h2><p>除了L2 regularization和dropout regularization之外，还有其它减少过拟合的方法。</p><p>其中一种方法是增加训练样本数量。但是通常成本较高，难以获得额外的训练样本。但是，我们可以对已有的训练样本进行一些处理来“制造”出更多的样本，称为data augmentation。</p><p>例如图片识别问题中，可以对已有的图片进行水平翻转、任意角度旋转、缩放或扩大等等。 <img src="/img/深度学习-Course2-Week1/1深度学习的实用层面_10.png" /></p><p>这些处理都能“制造”出新的训练样本。虽然这些是基于原有样本的，但是对增大训练样本数量还是有很有帮助的，不需要增加额外成本，却能起到防止过拟合的效果。</p><h2 id="early-stopping">early stopping</h2><p>一个神经网络模型随着迭代训练次数增加，train set error一般是单调减小的，而dev set error 先减小，之后又增大。</p><p>也就是说训练次数过多时，模型会对训练样本拟合的越来越好，但是对验证集拟合效果逐渐变差，即发生了过拟合。</p><p>因此，迭代训练次数不是越多越好，可以通过train set error和dev set error随着迭代次数的变化趋势，选择合适的迭代次数，即early stopping。 <img src="/img/深度学习-Course2-Week1/1深度学习的实用层面_11.png" /></p><p>然而，Early stopping有其自身缺点。通常来说，机器学习训练模型有两个目标：一是优化cost function，尽量减小J；二是防止过拟合。</p><p>这两个目标彼此对立的，即减小J的同时可能会造成过拟合，反之亦然。我们把这二者之间的关系称为正交化orthogonalization。</p><p>在深度学习中，我们可以同时减小Bias和Variance，构建最佳神经网络模型。</p><p>但是，Early stopping的做法通过减少迭代次数来防止过拟合，这样J就不会足够小。也就是说，early stopping将上述两个目标融合在一起，同时优化，但可能没有“分而治之”的效果好。</p><p>与early stopping相比，L2 regularization可以实现“分而治之”的效果：迭代训练足够多，可以减小J，而且也能有效防止过拟合。</p><p>而L2 regularization的缺点之一是最优的正则化参数λ的选择比较复杂。</p><p>对这一点来说，early stopping比较简单。总的来说，L2 regularization更加常用一些。</p><h1 id="归一化输入normalizing-inputs">1.9 归一化输入（Normalizing inputs）</h1><p>在训练神经网络时，标准化输入可以提高训练的速度。标准化输入就是对训练数据集进行归一化的操作，即将原始数据减去其均值μ后，再除以其方差σ^2： <span class="math display">\[\begin{gathered}\mu=\frac{1}{m}\sum_{i=1}^{m}X^{(i)} \\\sigma^{2}=\frac1m\sum_{i=1}^{m}(X^{(i)})^{2} \\\begin{aligned}X:=\frac{X-\mu}{\sigma^2}\end{aligned} \end{gathered}\]</span> 以二维平面为例，下图展示了其归一化过程：</p><p><img src="/img/深度学习-Course2-Week1/1深度学习的实用层面_12.png" /></p><p>值得注意的是，由于训练集进行了标准化处理，那么对于测试集或在实际应用时，应该使用同样的μ和σ^2对其进行标准化处理。这样保证了训练集合测试集的标准化操作一致。</p><p>之所以要对输入进行标准化操作，主要是为了让所有输入归一化同样的尺度上，方便进行梯度下降算法时能够更快更准确地找到全局最优解。(原理可参考机器学习笔记-&gt;0监督学习-&gt;特征缩放)</p><h1 id="梯度消失梯度爆炸vanishing-exploding-gradients">1.10 梯度消失/梯度爆炸（Vanishing / Exploding gradients）</h1><p>在神经网络尤其是深度神经网络中存在可能存在这样一个问题：梯度消失和梯度爆炸。</p><p>意思是当训练一个层数非常多的神经网络时，计算得到的梯度可能非常小或非常大，甚至是指数级别的减小或增大。这样会让训练过程变得非常困难。</p><p><img src="/img/深度学习-Course2-Week1/1深度学习的实用层面_13.png" /></p><p>为了简化复杂度，便于分析，我们令各层的激活函数为线性函数，即<span class="math inline">\(g(Z)=Z\)</span>。且忽略各层常数项b的影响，令b全部为零。那么，该网络的预测输出<span class="math inline">\(\hat{Y}\)</span>为：</p><p><span class="math inline">\(\hat{Y}=W^{[L]}W^{[L-1]}W^{[L-2]}\ldots W^{[3]}W^{[2]}W^{[1]}X\)</span> 如果各层权重<span class="math inline">\(W^{[l]}\)</span>的元素都稍大于1，例如1.5, 则预测输出<span class="math inline">\(\hat{Y}\)</span>将正比于<span class="math inline">\(1.5^L\)</span>。L越大，<span class="math inline">\(\hat{Y}\)</span>越大，且呈指数型增长。我们称之为数值爆炸。 相反，如果各层权重<span class="math inline">\(W^{[l]}\)</span>的元素都稍小于1，例如0.5,则预测输出<span class="math inline">\(\hat{Y}\)</span>将正比于<span class="math inline">\(0.5^L\)</span>。网络层数L越多，<span class="math inline">\(\hat{Y}\)</span>呈指数型减小。我们称之为数值消失。</p><p>也就是说，如果各层权重<span class="math inline">\(W^{[l]}\)</span>都大于1或者都小于1，那么各层激活函数的输出将随着层数<span class="math inline">\(l\)</span>的增加，呈指数型增大或减小。当层数很大时，出现数值爆炸或消失。同样，这种情况也会引起梯度呈现同样的指数型增大或减小的变化。L非常大时，例如L=150,则梯度会非常大或非常小，引起每次更新的步进长度过大或者过小，这让训练变得十分困难。</p><h1 id="神经网络的权重初始化weight-initialization-for-deep-networksvanishing-exploding-gradients">1.11 神经网络的权重初始化（Weight Initialization for Deep NetworksVanishing /Exploding gradients）</h1><p>下面介绍如何改善梯度消失/梯度爆炸这类问题，方法是对权重w进行一些初始化处理。</p><p>如果激活函数是tanh，在初始化w时，令其方差为1/n。相应的python伪代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">w[l] = np.random.randn(n[l],n[l-<span class="hljs-number">1</span>])*np.sqrt(<span class="hljs-number">1</span>/n[l-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>如果激活函数是ReLU，权重w的初始化一般令其方差为2/n：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">w[l] = np.random.randn(n[l],n[l-<span class="hljs-number">1</span>])*np.sqrt(<span class="hljs-number">2</span>/n[l-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>除此之外，Yoshua Bengio提出了另外一种初始Bengio提出了另外一种初始化w的方法,令其方差为：<span class="math inline">\(\frac2{n^{[l-1]}n^{[l]}}\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">w[l] = np.random.randn(n[l],n[l-<span class="hljs-number">1</span>])*np.sqrt(<span class="hljs-number">2</span>/n[l-<span class="hljs-number">1</span>]*n[l])<br></code></pre></td></tr></table></figure><h1 id="梯度检验gradient-checking">1.12 梯度检验（Gradient checking）</h1><p>Back Propagation神经网络有一项重要的测试是梯度检查（gradient checking）。其目的是检查验证反向传播过程中梯度下降算法是否正确。</p><h2 id="梯度的数值逼近">梯度的数值逼近</h2><p><img src="/img/深度学习-Course2-Week1/1深度学习的实用层面_14.png" /></p><p>利用微分思想（中值定理<span class="math inline">\(f(x)=(f(b)-f(a))/(b-a)\)</span>），函数f在点θ处的梯度可以表示成： <span class="math display">\[g(\theta)=\frac{f(\theta+\varepsilon)-f(\theta-\varepsilon)}{2\varepsilon}\]</span> 其中，ε&gt;0，且足够小。</p><p>函数f在点θ处的梯度近似等于<span class="math inline">\(g(\theta)\)</span>的值。</p><h2 id="梯度检验">梯度检验</h2><p>用函数值去估计梯度，然后和记录下来的dw或者db比较，看是不是算对了</p><p>梯度检查首先要做的是分别将<span class="math inline">\(W^{[1]},b^{[1]},\cdots,W^{[L]},b^{[L]}\)</span>这些矩阵构造成一维向量，然后将这些一维向量组合起来构成一个更大的一维 向 量 <span class="math inline">\(\theta\)</span>。这 样 cost function <span class="math inline">\(J(W^{[1]},b^{[1]},\ldots,W^{[L]},b^{[L]})\)</span> 就 可以表示成<span class="math inline">\(J(\theta)\)</span>。</p><p>然后将反向传播过程通过梯度下降算法得到的 <span class="math inline">\(dW^{[1]},db^{[1]},\cdots,dW^{[L]},db^{[L]}\)</span>按照一样的顺序构造成一个一维向量<span class="math inline">\(d\theta\)</span>。<span class="math inline">\(d\theta\)</span>的维度与<span class="math inline">\(\theta\)</span>一致。</p><p>接着利用<span class="math inline">\(J(\theta)\)</span>对每个<span class="math inline">\(\theta_i\)</span>计算近似梯度，其值与反 向传播算法得到的<span class="math inline">\(d\theta_i\)</span>相比较，检查是否一致。例如，对于第i个元素，近似梯度为： <span class="math display">\[d\theta_{approx}[i]=\frac{J(\theta_1,\theta_2,\cdots,\theta_i+\varepsilon,\cdots)-J(\theta_1,\theta_2,\cdots,\theta_i-\varepsilon,\cdots)}{2\varepsilon}\]</span></p><p>计算完所有<span class="math inline">\(\theta_i\)</span>的近似梯度后，可以计算<span class="math inline">\(d\theta_{approx}\)</span>与<span class="math inline">\(d\theta\)</span>的欧氏(Euclidean) 距离来比较二者的相似度。公式如下：</p><p><span class="math display">\[\frac{||d\theta_{approx}-d\theta||_2}{||d\theta_{approx}||_2+||d\theta||_2}\]</span></p><p>一般来说，如果欧氏距离越小，例如<span class="math inline">\(10^{-7}\)</span>,甚至更小，则表明<span class="math inline">\(d\theta_{approx}\)</span>与<span class="math inline">\(d\theta\)</span>越接近，即反向梯度计算是正确的，没有bugs。</p><p>如果欧氏距离较大， 例如<span class="math inline">\(10^{-5}\)</span>,则表明梯度计算可能出现问题，需要再次检查是否有bugs存在。</p><p>如果欧氏距离很大，例如<span class="math inline">\(10^{-3}\)</span>,甚至更大，则表明<span class="math inline">\(d\theta_{approx}\)</span>与<span class="math inline">\(d\theta\)</span>差别很大，梯度下降计算过程有bugs，需要仔细检查。</p><h2 id="梯度检验应用的注意事项">梯度检验应用的注意事项</h2><ul><li><p>不要在整个训练过程中都进行梯度检查，仅仅作为debug使用。</p></li><li><p>如果梯度检查出现错误，找到对应出错的梯度，检查其推导是否出现错误。</p></li><li><p>注意不要忽略正则化项，计算近似梯度的时候要包括进去。</p></li><li><p>梯度检查时关闭dropout，检查完毕后再打开dropout。</p></li><li><p>随机初始化时运行梯度检查，经过一些训练后再进行梯度检查（不常用）。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习-Course1_Week4深层神经网络</title>
    <link href="/2024/02/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course1-Week4%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/02/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course1-Week4%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="深层神经网络">1 深层神经网络</h1><p>深层神经网络其实就是包含更多的隐藏层神经网络。</p><p><img src="/img/深度学习-Course1_Week4/4深层神经网络.png" /></p><h1 id="深层神经网络正向传播">2 深层神经网络正向传播</h1><p>接下来，我们来推导一下深层神经网络的正向传播过程。 <img src="/img/深度学习-Course1_Week4/4深层神经网络_1.png" /></p><p>以4层神经网络为例，对于单个样本。</p><p>第1层，l=1： <span class="math display">\[\begin{gathered}z^{[1]}=W^{[1]}x+b^{[1]}=W^{[1]}a^{[0]}+b^{[1]}\\a^{[1]}=g^{[1]}(z^{[1]})\end{gathered}\]</span></p><p>第2层，l=2： <span class="math display">\[\begin{gathered}z^{[2]}=W^{[2]}a^{[1]}+b^{[2]}\\a^{[2]}=g^{[2]}(z^{[2]})\end{gathered}\]</span></p><p>第3层，l=3： <span class="math display">\[\begin{gathered}z^{[3]}=W^{[3]}a^{[2]}+b^{[3]}\\a^{[3]}=g^{[3]}(z^{[3]})\end{gathered}\]</span></p><p>第4层，l=4： <span class="math display">\[\begin{gathered}z^{[4]}=W^{[4]}a^{[3]}+b^{[4]}\\a^{[4]}=g^{[4]}(z^{[4]})\end{gathered}\]</span></p><p>如果有m个训练样本，其向量化矩阵形式为：</p><p>第1层，l=1： <span class="math display">\[\begin{gathered}Z^{[1]}=W^{[1]}X+b^{[1]}=W^{[1]}A^{[0]}+b^{[1]}\\A^{[1]}=g^{[1]}(Z^{[1]})\end{gathered}\]</span></p><p>第2层，l=2： <span class="math display">\[\begin{gathered}Z^{[2]}=W^{[2]}A^{[1]}+b^{[2]}\\A^{[2]}=g^{[2]}(Z^{[2]})\end{gathered}\]</span></p><p>第3层，l=3： <span class="math display">\[\begin{gathered}Z^{[3]}=W^{[3]}A^{[2]}+b^{[3]}\\A^{[3]}=g^{[3]}(Z^{[3]})\end{gathered}\]</span></p><p>第4层，l=4： <span class="math display">\[\begin{gathered}Z^{[4]}=W^{[4]}A^{[3]}+b^{[4]}\\A^{[4]}=g^{[4]}(Z^{[4]})\end{gathered}\]</span></p><p>因此，向前传播：</p><ul><li><p>公式： <span class="math display">\[\begin{array}{c}\mathrm{z^{[l]}=W^{[l]}\cdot a^{[l-1]}+b^{[l]}}\\\mathrm{a^{[l]}=g^{[l]}(z^{[l]})}\end{array}\]</span></p></li><li><p>向量化： <span class="math display">\[\begin{gathered}Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}\\A^{[l]}=g^{[l]}(Z^{[l]})\end{gathered}\]</span> 其中l=1,⋯,L</p></li></ul><h1 id="正确处理矩阵维度">3 正确处理矩阵维度</h1><p><strong>单个训练样本</strong> 对于单个训练样本，输入x的维度是( <span class="math inline">\(n^{[0]},1\)</span> )</p><p>参数<span class="math inline">\(W^{[l]}\)</span>和<span class="math inline">\(b^{[l]}\)</span>的维度分别是 : <span class="math display">\[\begin{gathered}W^{[l]}:(n^{[l]},n^{[l-1]})\\b^{[l]}:(n^{[l]},1)\end{gathered}\]</span></p><p>反向传播过程中的<span class="math inline">\(dW^{[l]}\)</span>和<span class="math inline">\(db^{[l]}\)</span>的维度分别是： <span class="math display">\[\begin{gathered}dW^{[l]}:(n^{[l]},n^{[l-1]})\\db^{[l]}:(n^{[l]},1)\end{gathered}\]</span> 正向传播过程中的<span class="math inline">\(z^{[l]}\)</span>和<span class="math inline">\(a^{[l]}\)</span>的维度分别是： <span class="math display">\[\begin{aligned}z^{[l]}&amp;:&amp;(n^{[l]},1)\\a^{[l]}&amp;:&amp;(n^{[l]},1)\end{aligned}\]</span></p><p><strong>m个训练样本</strong> 对于m个训练样本，输入矩阵X的维度是( <span class="math inline">\(n^{[0]},m\)</span> )。</p><p><span class="math inline">\(W^{[l]}\)</span>和<span class="math inline">\(b^{[l]}\)</span>的维度与只有单个样本是一致的： <span class="math display">\[\begin{gathered}W^{[l]}:(n^{[l]},n^{[l-1]})\\b^{[l]}:(n^{[l]},1)\end{gathered}\]</span> <span class="math inline">\(dW^{[l]}\)</span>和<span class="math inline">\(db^{[l]}\)</span>的维度分别与<span class="math inline">\(W^{[l]}\)</span>和<span class="math inline">\(b^{[l]}\)</span>的相同</p><p><span class="math inline">\(Z^{[l]}\)</span>和<span class="math inline">\(A^{[l]}\)</span>的维度分别是： <span class="math display">\[\begin{aligned}Z^{[l]}&amp;:&amp;(n^{[l]},m)\\A^{[l]}&amp;:&amp;(n^{[l]},m)\end{aligned}\]</span> <span class="math inline">\(dZ^{[l]}\)</span> 和 <span class="math inline">\(dA^{[l]}\)</span>的维度分别与<span class="math inline">\(Z^{[l]}\)</span>和<span class="math inline">\(A^{[l]}\)</span>的相同</p><h1 id="深层神经网络流程块">5 深层神经网络流程块</h1><p>下面用流程块图来解释神经网络正向传播和反向传播过程。如下图所示，对于第l层来说，正向传播过程中： <img src="/img/深度学习-Course1_Week4/4深层神经网络_2.png" /></p><p><img src="/img/深度学习-Course1_Week4/4深层神经网络_3.png" /></p><p>这是第l层的流程块图，对于神经网络所有层，整体的流程块图正向传播过程和反向传播过程如下所示： <img src="/img/深度学习-Course1_Week4/4深层神经网络_4.png" /> <img src="/img/深度学习-Course1_Week4/4深层神经网络_5.png" /></p><h1 id="前向传播和反向传播">6 前向传播和反向传播</h1><p>之前我们学习了构成深度神经网络的基本模块，比如每一层都有前向传播步骤以及一个相反的反向传播步骤，这次视频我们讲讲如何实现这些步骤。</p><p>先讲<strong>前向传播</strong>，输入<span class="math inline">\(a^{[l-1]}\)</span>，输出是<span class="math inline">\(a^{[l]}\)</span>，缓存为<span class="math inline">\(z^{[l]}\)</span>；从实现的角度来说我们可以缓存下<span class="math inline">\(w^{[l]}\)</span>和<span class="math inline">\(b^{[l]}\)</span>，这样更容易在不同的环节中调用函数。 <img src="/img/深度学习-Course1_Week4/4深层神经网络_6.png" /></p><p>所以前向传播的步骤为： <span class="math inline">\(z^{[l]}=W^{[l]}\cdot a^{[l-1]}+b^{[l]}\)</span> <span class="math inline">\(a^{[l]}=g^{[l]}(z^{[l]})\)</span></p><p>向量化实现过程为： <span class="math inline">\(Z^{[l]}=W^{[l]}\cdot A^{[l-1]}+b^{[l]}\)</span> <span class="math inline">\(A^{[l]}=g^{[l]}(Z^{[l]})\)</span></p><p>前向传播需要输入<span class="math inline">\(A^{[0]}\)</span>也就是<span class="math inline">\(X\)</span>,来初始化；初始化的是第一层的输入值。<span class="math inline">\(a^{[0]}\)</span>对应于一个训练样本的输入特征，而<span class="math inline">\(A^{[0]}\)</span>对应于一整个训练样本的输入特征，所以这就是这条链的第一个前向函数的输入，重复这个步骤就可以从左到右计算前向传播。</p><p>下面讲<strong>反向传播</strong>的步骤： 输入为<span class="math inline">\(da^{[l]}\)</span>,输出为<span class="math inline">\(da^{[l-1]}\)</span>,<span class="math inline">\(dw^{[l]}\)</span>,<span class="math inline">\(db^{[l]}\)</span></p><p><img src="/img/深度学习-Course1_Week4/4深层神经网络_8.png" /> 反向传播的步骤为： （1） <span class="math inline">\(d{ {z}^{[l]} }=d{ {a}^{[l]} }*{ {g}^{[l]} }&#39;( { {z}^{[l]} })\)</span></p><p>（2） <span class="math inline">\(d{ {w}^{[l]} }=d{ {z}^{[l]} }\cdot{ {a}^{[l-1]} }~\)</span></p><p>（3） <span class="math inline">\(d{ {b}^{[l]} }=d{ {z}^{[l]} }~~\)</span></p><p>（4） <span class="math inline">\(d{ {a}^{[l-1]} }={ {w}^{\left[ l \right]T} }\cdot { {dz}^{[l]} }\)</span></p><p>（5） <span class="math inline">\(d{ {z}^{[l]} }={ {w}^{[l+1]T} }d{ {z}^{[l+1]} }\cdot \text{ }{ {g}^{[l]} }&#39;( { {z}^{[l]} })~\)</span></p><p>式子（5）由式子（4）带入式子（1）得到，前四个式子就可实现反向函数。</p><p>向量化实现过程为： （6） <span class="math inline">\(d{ {Z}^{[l]} }=d{ {A}^{[l]} }*{ {g}^{\left[ l \right]} }&#39;\left({ {Z}^{[l]} } \right)~~\)</span></p><p>（7） <span class="math inline">\(d{ {W}^{[l]} }=\frac{1}{m}\text{}d{ {Z}^{[l]} }\cdot { {A}^{\left[ l-1 \right]T} }\)</span></p><p>（8） <span class="math inline">\(d{ {b}^{[l]} }=\frac{1}{m}\text{ }np.sum(d{ {z}^{[l]} },axis=1,keepdims=True)\)</span></p><p>（9） <span class="math inline">\(d{ {A}^{[l-1]} }={ {W}^{\left[ l \right]T} }.d{ {Z}^{[l]} }\)</span></p><p><strong>总结：</strong> <img src="/img/深度学习-Course1_Week4/4深层神经网络_9.png" /></p><h1 id="神经网络参数和超参数">7 神经网络参数和超参数</h1><p>神经网络中的参数（parameters）就是我们熟悉的<span class="math inline">\(W^{[l]}\)</span>和<span class="math inline">\(b^{[l]}\)</span>。而超参数（hyperparameters）则是例如学习速率<span class="math inline">\(\alpha\)</span>，训练迭代次数 N,神经网络层数L,各层神经元个数<span class="math inline">\(n^{[l]}\)</span>，激活函数<span class="math inline">\(g(z)\)</span>等。之所以叫做超参数的原因是它们决定了参数<span class="math inline">\(W^{[l]}\)</span>和<span class="math inline">\(b^{[l]}\)</span>的值。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习-Course1_Week3浅层神经网络</title>
    <link href="/2024/02/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course1-Week3%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/02/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course1-Week3%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="神经网络概述">1 神经网络概述</h1><p>神经网络的结构与逻辑回归类似，只是神经网络的层数比逻辑回归多一层，多出来的中间那层称为隐藏层。 <img src="/img/深度学习-Course1_Week3/3浅层神经网络_1.png" /></p><p>最右边这一层叫做<strong>输出层</strong>（output layer），因为最后一层输出的是整个神经网络的预测值。最左边一层叫<strong>输入层</strong>（input layer）。在输入层和输出层中间的所有层都叫<strong>隐藏层</strong>，在神经网络中输入层和输出层都有明确的数值，而中间的层并没有告诉确切的数值，是未知的，所以叫隐藏层。</p><p>该神经网络为两层神经网络，一般我们不把输入层纳入神经网络的层数中，除输入层以外的所有层数总数为网络的总层数。</p><h1 id="浅层神经网络">2 浅层神经网络</h1><p>如下图所示，单隐藏层神经网络就是典型的浅层（shallow）神经网络，因为网络层数交少（浅）。</p><p><img src="/img/深度学习-Course1_Week3/3浅层神经网络_2.png" /> 结构上，从左到右，可以分成三层：输入层（Input layer），隐藏层（Hidden layer）和输出层（Output layer）。</p><h1 id="计算神经网络输出">3 计算神经网络输出</h1><p>接下来我们开始详细推导神经网络的计算过程。</p><p>两层神经网络可以看成是计算完第一层的逻辑回归后再重复计算一次逻辑回归。如下图所示，逻辑回归的正向计算可以分解成计算z和a的两部分：</p><p><img src="/img/深度学习-Course1_Week3/3浅层神经网络_3.png" /></p><p>对于两层神经网络，从输入层到隐藏层对应一次逻辑回归运算；从隐藏层到输出层对应一次逻辑回归运算。每层计算时，要注意对应的上标和下标，一般我们记上标方括号表示layer，下标表示第几个神经元。例如<span class="math inline">\(a_i^{[l]}\)</span>表示第l层的第i个神经 元。注意，i从1开始，l从0开始。</p><p>下面，我们将从输入层到输出层的计算公式列出来： <span class="math display">\[\begin{gathered}z_{1}^{[1]} =w_1^{[1]T}x+b_1^{[1]},\mathrm{~}a_1^{[1]}=\sigma(z_1^{[1]}) \\z_2^{[1]} =w_2^{[1]T}x+b_2^{[1]},a_2^{[1]}=\sigma(z_2^{[1]}) \\z_3^{[1]} =w_3^{[1]T}x+b_3^{[1]},~a_3^{[1]}=\sigma(z_3^{[1]}) \\z_4^{[1]} =w_4^{[1]T}x+b_4^{[1]},a_4^{[1]}=\sigma(z_4^{[1]}) \end{gathered}\]</span></p><p>然后，从隐藏层到输出层的计算公式为： <span class="math display">\[z_1^{[2]}=w_1^{[2]T}a^{[1]}+b_1^{[2]},\mathrm{~}a_1^{[2]}=\sigma(z_1^{[2]})\]</span> 其中<span class="math inline">\(a^{[1]}\)</span>为： <span class="math display">\[a^{[1]}=\begin{bmatrix}a_1^{[1]}\\a_2^{[1]}\\a_3^{[1]}\\a_4^{[1]}\end{bmatrix}\]</span> 上述每个节点的计算都对应着一次逻辑运算的过程，分别由计算z和a两部分组成。</p><p>同样的，为了提高程序运算速度，我们引入向量化和矩阵运算的思想，将上述表达式转换成矩阵运算的形式： <img src="/img/深度学习-Course1_Week3/3浅层神经网络_4.png" /></p><h1 id="矩阵运算">4 矩阵运算</h1><p>对于m个训练样本的运算，不使用for循环，利用矩阵运算的思想，输入矩阵X的维度为（<span class="math inline">\(n_x\)</span>,m）。这样，我们可以将for循环写成矩阵运算的形式： <img src="/img/深度学习-Course1_Week3/3浅层神经网络_5.png" /> 其中，<span class="math inline">\(Z^{[1]}\)</span>的维度是(4,m),4是隐藏层神经元的个数；<span class="math inline">\(A^{[1]}\)</span>的维度与<span class="math inline">\(Z^{[1]}\)</span>相同；<span class="math inline">\(Z^{[2]}\)</span>和<span class="math inline">\(A^{[2]}\)</span>的维度均为(1,m)。对上面这四个矩阵来说，均可以这样来理解：行表示神经元个数，列表示样本书目m</p><h1 id="非线性激活函数">5 非线性激活函数</h1><p>原先的四种激活函数都是非线性（non-linear）的。那是否可以使用线性激活函数呢？答案是不行！</p><p>如果使用线性激活函数，使用神经网络与直接使用线性模型的效果并没有什么两样。即便是包含多层隐藏层的神经网络，如果使用线性函数作为激活函数最终的输出仍然是输入X的线性模型。这样的话神经网络就没有任何作用了。因此，隐藏层的激活函数必须要是非线性的。</p><p>另外，如果所有的隐藏层全部使用线性激活函数，只有输出层使用非线性激活函数，那么整个神经网络的结构就类似于一个简单的逻辑回归模型，而失去了神经网络模型本身的优势和价值。</p><p>但是，如果是预测问题而不是分类问题，并且输出y是连续的情况下，输出层的激活函数可以使用线性函数。如果输出y恒为正值，则也可以使用ReLU激活函数，具体情况，具体分析。</p><h1 id="激活函数的导数">6激活函数的导数</h1><ol type="1"><li><strong>sigmoid activation function</strong> <img src="/img/深度学习-Course1_Week3/3浅层神经网络_8.png" /></li></ol><p><span class="math inline">\(\frac{d}{dz}g(z)=\frac{1}{1+e^{-z}}(1-\frac{1}{1+e^{-z}})=g(z)(1-g(z))\)</span> 当<span class="math inline">\(z=10\)</span>或<span class="math inline">\(z=-10\)</span> ;<span class="math inline">\({\frac{d}{dz}}g(z)\approx0\)</span> 当<span class="math inline">\(z=0\)</span> <span class="math inline">\(\frac{d}{dz}g(z)=g(z)(1-g(z))=1/4\)</span></p><p>在神经网络中<span class="math inline">\(\begin{aligned}a=g(z);g(z)^{&#39;}=\frac{d}{dz}g(z)=a(1-a)\end{aligned}\)</span></p><ol start="2" type="1"><li><strong>Tanh activation function</strong> <img src="/img/深度学习-Course1_Week3/3浅层神经网络_7.png" /></li></ol><p><span class="math inline">\(g(z)=tanh(z)=\frac{e^{z}-e^{-z}}{e^{z}+e^{-z}}\)</span> <span class="math inline">\(\frac d{dz}g(z)=1-(tanh(z))^2\)</span></p><p>当<span class="math inline">\(z=10\)</span>或<span class="math inline">\(z=-10\:\frac{d}{dz}g(z)\approx0\)</span> 当<span class="math inline">\(z=0,\:\frac{d}{dz}g(z)\text{=1-}(0)\text{=1}\)</span></p><ol start="3" type="1"><li><p><strong>Rectified Linear Unit (ReLU)</strong> <img src="/img/深度学习-Course1_Week3/3浅层神经网络_9.png" /> <span class="math inline">\(g(z)=max(0,z)\)</span> <span class="math display">\[\left.g(z)^{&#39;}=\left\{\begin{array}{ll}0&amp;\text{if z&lt;0}\\1&amp;\text{if z&gt;0}\\undefined&amp;\text{if z=0}\end{array}\right.\right.\]</span> 注：通常在<span class="math inline">\(z= 0\)</span>的时候给定其导数1,0；当然<span class="math inline">\(z=0\)</span>的情况很少很少</p></li><li><p><strong>Leaky linear unit (Leaky ReLU)</strong> <span class="math inline">\(g(z)=\max(0.01z,z)\)</span> <span class="math display">\[\left.g(z)^{&#39;}=\left\{\begin{array}{ll}0.01&amp;\text{if z&lt;0}\\1&amp;\text{if z&gt;0}\\undefined&amp;\text{if z=0}\end{array}\right.\right.\]</span></p></li></ol><h1 id="反向传播">7 反向传播</h1><p>浅层神经网络：</p><ul><li>参数： W<span class="math inline">\(^{[1]},\mathrm{b}^{[1]},\mathrm{W}^{[2]},\mathrm{b}^{[2]};\)</span></li><li>输入层特征向量个数： <span class="math inline">\(\mathrm{n_x= n^{[ 0] }; }\)</span></li><li>隐藏层神经元个数： n<span class="math inline">\(^{[1]}\)</span>,</li><li>输出层神经元个数： n<span class="math inline">\(^{[2]}=1;\)</span></li><li>W<span class="math inline">\(^{[1]}\)</span>的维度为(n<span class="math inline">\(^{[1]},\mathrm{n}^{[0]})\)</span>, b<span class="math inline">\(^{[1]}\)</span>的维度为(n<span class="math inline">\(^{[1]},1);\)</span></li><li>W<span class="math inline">\(^{[2]}\)</span>的维度为(n<span class="math inline">\(^{[2]},\mathrm{n}^{[1]})\)</span>, b<span class="math inline">\(^{[2]}\)</span>的维度为(n<span class="math inline">\(^{[2]},1);\)</span></li></ul><p>我们仍然使用计算图的方式来推导神经网络反向传播过程。 <img src="/img/深度学习-Course1_Week3/3浅层神经网络_11.png" /> 由于多了一个隐藏层，神经网络的计算图要比逻辑回归的复杂一些。对于单个训练样本，正向过程很容易，反向过程可以根据梯度计算方法逐一推导。 <img src="/img/深度学习-Course1_Week3/3浅层神经网络_12.png" /></p><p>总结一下，浅层神经网络（包含一个隐藏层），m个训练样本的正向传播过程和反向传播过程分别包含了6个表达式，下图为神经网络反向传播公式（左）和其代码向量化（右）： <img src="/img/深度学习-Course1_Week3/3浅层神经网络_10.png" /></p><h1 id="随即初始化">8 随即初始化</h1><p>当你训练神经网络时，如果你把权重w都初始化为0，那么梯度下降将不会起作用。</p><p><img src="/img/深度学习-Course1_Week3/3浅层神经网络_13.png" /></p><p>举个简单的例子，一个浅层神经网络包含两个输 入，隐藏层包含两个神经元。如果权重<span class="math inline">\(W^{[1]}\)</span>和 入 <span class="math inline">\(W^{[2]}\)</span>都初始化为零,即 <span class="math display">\[\begin{aligned}W^{[1]}&amp;=\begin{bmatrix}0&amp;0\\0&amp;0\end{bmatrix}\\W^{[2]}&amp;=\begin{bmatrix}0&amp;0\end{bmatrix}\end{aligned}\]</span></p><p>这样使得隐藏层第一个神经元的输出等于第二个神经元的输出，即<span class="math inline">\(a_1^{[1]}=a_2^{[1]}\)</span>。经过推导得到<span class="math inline">\(dz_1^{[1]}=dz_2^{[1]}\)</span>,以及<span class="math inline">\(dW_1^{[1]}=dW_2^{[1]}\)</span>。因此，这样的结果是隐藏层两个神经元对应的权重行向量<span class="math inline">\(W_1^{[1]}\)</span>和<span class="math inline">\(W_2^{[1]}\)</span>每次迭代更新都会得到完全相同的结果，<span class="math inline">\(W_1^{[1]}\)</span>始终等于<span class="math inline">\(W_2^{[1]}\)</span>,完全对称。这样隐藏层设置多个神经元就没有任何意义了。但是，参数b可以全部初始化为零，并不会影响神经网络训练效果</p><p>在初始化的时候，w参数要进行随机初始化，b则不存在对称性的问题它可以设置为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">W = np.random.rand((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))* <span class="hljs-number">0.01</span><br>b = np.zero((<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))<br><br></code></pre></td></tr></table></figure><p>这里我们将W的值乘以0.01是为了尽可能使得权重W初始化为较小的值，这是因为如果使用sigmoid函数或者tanh函数作为激活函数时，W比较小，则<span class="math inline">\(Z = W X + b\)</span>所得的值也比较小，处在0的附近，0点区域的附近梯度较大，能够大大提高算法的更新速度。而如果W设置的太大的话，得到的梯度较小，训练过程因此会变得很慢。</p><p>ReLU和Leaky ReLU作为激活函数时，不存在这种问题，因为在大于0的时候，梯度均为1。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习-Course1_Week2神经网络基础知识</title>
    <link href="/2024/02/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course1-Week2%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/02/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course1-Week2%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二分类binary-classification">2.1 二分类(Binary Classification)</h1><p>我们知道逻辑回归是一个用于二分类(<strong>binary classification</strong>)的算法。。 二分类就是输出y只有{0,1}两个离散值（也有{-1,1}的情况）。 我们以一个图像识别问题为例，判断图片中是否有猫存在，0代表noncat，1代表cat。其输入是由特征向量𝑥表示的图像，并预测相应的标签𝑦是1还是0。 <img src="/img/深度学习-Course1-Week2/2神经网络的编程基础.png" /> 在计算机中为了保存一张图片，需要保存三个矩阵，它们分别对应图片中的红、绿、蓝三种颜色通道，三个矩阵与图像大小相同，如果图片大小为64x64像素，那么你就有三个规模为64x64的矩阵，分别对应图片中红、绿、蓝三种像素的强度值。 <img src="/img/深度学习-Course1-Week2/2神经网络的编程基础_1.png" /></p><p>单元格中的值表示将用于创建 n 维特征向量的像素强度。在模式识别和机器学习中，一个特征向量代表一个图像。为了创建特征向量 𝑥，每种颜色的像素强度值将被“展开”或“重塑”。输入特征向量𝑥的维度为𝑛= 64*64*3 = 12288。</p><p><img src="/img/深度学习-Course1-Week2/2神经网络的编程基础_2.png" /></p><p>所以在二分类问题中，我们的目标是学习一个分类器：输入一幅以特征向量𝑥表示的图像，并预测相应的输出标签𝑦是1还是0。</p><p><strong>Notation</strong></p><ul><li>样本： <span class="math inline">\((x,y)\)</span>, 训练样本包含<span class="math inline">\(m\)</span>个；</li><li>其中<span class="math inline">\(x\in R^{n_x}\)</span>,表示样本<span class="math inline">\(x\)</span> 包含<span class="math inline">\(n_x\)</span>个特征；</li><li><span class="math inline">\(y\in0,1\)</span>,目标值属于0、1分类；</li><li>m个训练数据:<span class="math inline">\(\left\{(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),\cdots,(x^{(m)},y^{(m)})\right\}\)</span></li></ul><p>输入神经网络时样本数据的形状为： <img src="/img/深度学习-Course1-Week2/2神经网络的编程基础_5.png" /></p><h1 id="逻辑回归logistic-regression">2.2 逻辑回归(Logistic Regression)</h1><p>接下来我们就来介绍如何使用逻辑回归来解决二分类问题。</p><p>逻辑回归中，给定输入 <span class="math inline">\(x\)</span>, 预测值 <span class="math inline">\(\hat{y}=P(y=1|x),\mathrm{where}0\leq\hat{y}\leq1\)</span> 表示为1的概率，取值范围在[0,1]之间。</p><p>这是其与二分类模型不同的地方。逻辑回归的预测值为一个连续的概率。</p><p>Logistic回归中使用的参数是：</p><ul><li>输入特征向量：<span class="math inline">\(x\in\mathbb{R}^{n_x}\)</span> ，其中 <span class="math inline">\(𝑛_𝑥\)</span> 是特征数量</li><li>训练标签：𝑦 ε 0,1</li><li>权重：<span class="math inline">\(w\in\mathbb{R}^{n_x}\)</span> ，其中<span class="math inline">\(𝑛_𝑥\)</span> 是特征数量</li><li>阈值：𝑏 ε ℝ</li><li>输出：<span class="math inline">\(\hat{y}=\sigma(w^{T}x+b)\)</span></li><li>Sigmoid 函数：<span class="math inline">\(s=\sigma(w^{T}x+b)=\sigma(z){=}\frac{1}{1+e^{-z}}\)</span></li></ul><p><span class="math inline">\(w^{T}x+b\)</span>是一个线性函数 (𝑎𝑥 + 𝑏)，其输出为一个连续的概率。但由于我们正在寻找 [0,1] 之间的概率约束，因此使用 sigmoid 函数将输出边界限制在在[0,1] 之间，如下图所示。 <img src="/img/深度学习-Course1-Week2/2神经网络的编程基础_6.png" /></p><p>sigmoid函数的公式为：<span class="math inline">\(\sigma(z){=}\frac{1}{1+e^{-z}}\)</span></p><p>其中，z是一个实数。</p><p>需要注意以下几点：</p><ol type="1"><li><p>当z非常大时，sigmoid函数接近于1。这是因为指数<span class="math inline">\(e^{-x}\)</span>会变得非常小，接近于0，所以1除以1加上一个接近于0的项，结果就会接近于1。</p></li><li><p>相反地，当x非常小或为一个绝对值很大的负数时，sigmoid函数接近于0。可以将其看作是1除以1加上一个非常非常大的数，结果就会接近于0。</p></li><li><p>实际上，当x变成一个绝对值很大的负数时，sigmoid函数会非常接近于0。</p></li></ol><p>因此，在实现逻辑回归时，我们的目标是通过调整机器学习参数w和b，使得sigmoid函数能够很好地估计给定情况的概率。</p><p>现在你已经知道逻辑回归模型是什么样子了，下一步要做的是使用代价函数训练参数w和参数b。</p><h1 id="逻辑回归的代价函数logistic-regression-cost-function">2.3 逻辑回归的代价函数（Logistic Regression Cost Function）</h1><p>为了训练参数𝑤和𝑏，我们需要定义一个成本函数。</p><h2 id="损失函数">损失函数</h2><p>损失函数测量预测 <span class="math inline">\((\hat{y}^{(i)})\)</span> 和期望输出 <span class="math inline">\(({y}^{(i)})\)</span>之间的差异。 换句话说，损失函数计算单个训练示例的误差。</p><p>对于逻辑回归，我们一般不使用平方误差<span class="math inline">\(L(\hat{y},y)=\frac12(\hat{y}-y)^2\)</span>来作为Loss function。因为上面的平方误差损失函数一般是非凸函数（non-convex），其在使用梯度下降算法的时候，容易得到局部最优解，而不是全局最优解，因此要选择凸函数，所以我们在逻辑回归模型中定义另外一个损失函数。 <span class="math display">\[L\left(\hat{y},y\right)=-y\log(\hat{y})-(1-y)\log(1-\hat{y})\]</span></p><p>当<span class="math inline">\(y=1\)</span>时，<span class="math inline">\(L(\hat{y},y)=-\log\hat{y}\)</span>。如果<span class="math inline">\(\hat{y}\)</span>越接近1，<span class="math inline">\(L(\hat{y},y)\approx0\)</span>,表示预测效果越好；如果<span class="math inline">\(\hat{y}\)</span>越接近0， <span class="math inline">\(L(\hat{y},y)\approx+\infty\)</span>,表示预测效果越差；</p><p>当<span class="math inline">\(y=0\)</span>时，<span class="math inline">\(L(\hat{y},y)=-\log(1-\hat{y})\)</span>。如果<span class="math inline">\(\hat{y}\)</span>越接近0，<span class="math inline">\(L(\hat{y},y)\approx0\)</span>,表示预测效果越好；如果<span class="math inline">\(\hat{y}\)</span>越接近1，<span class="math inline">\(L(\hat{y},y)\approx+\infty\)</span>,表示预测效果越差；</p><p>我们的目标是最小化样本点的损失Loss Function, 损失函数是针对单个样本点的。</p><h2 id="成本函数">成本函数</h2><p>Loss function是针对单个样本的，成本函数是整个训练集的损失函数的平均值。 <span class="math display">\[J(w,b)=\frac{1}{m}\sum_{i=1}^{m}L\big(\hat{y}^{(i)},y^{(i)}\big)=-\frac{1}{m}\sum_{i=1}^{m}\big[(y^{(i)}\log\big(\hat{y}^{(i)}\big)+\big(1-y^{(i)}\big)\log(1-\hat{y}^{(i)})\big]\]</span></p><h1 id="梯度下降gradient-descent">2.4 梯度下降（Gradient Descent）</h1><p>我们已经知道Cost function的表达式了，那么如何找到最小化成本的函数J(w,b)的w和b呢，接下来将使用梯度下降（Gradient Descent）算法来进行优化。</p><p>由于J(w,b)是convex function，梯度下降算法是先随机选择一组参数w和b值，然后每次迭代的过程中分别沿着w和b的梯度（偏导数）的反方向前进一小步，不断修正w和b。</p><p>每次迭代更新w和b后，都能让J(w,b)更接近全局最小值。梯度下降的过程如下图所示。</p><p><img src="/img/深度学习-Course1-Week2/2神经网络的编程基础_10.png" /></p><p>梯度下降算法每次迭代更新，w和b的修正表达式为： <span class="math display">\[w:=w-\alpha\frac{\partial J(w,b)}{\partial w}\]</span></p><p><span class="math display">\[b:=b-\alpha\frac{\partial J(w,b)}{\partial b}\]</span></p><p>上式中，<span class="math inline">\(\alpha\)</span>是学习因子( learning rate),表示梯度下降的步进长度。<span class="math inline">\(\alpha\)</span>越大，w和b每次更新的“步伐”更大一些；<span class="math inline">\(\alpha\)</span>越小，w和b每次更新的<span class="math inline">\(^\mathrm{\iota}\)</span>步伐”更小一些。</p><p>在程序代码中，我们通常使用dw来表示<span class="math inline">\(\frac{\partial J(w,b)}{\partial w}\)</span> ,用db来表示<span class="math inline">\(\frac{\partial J(w,b)}{\partial b}\)</span>。微积分里，<span class="math inline">\(\frac{df}{dx}\)</span>表 示对单一变量求导数，<span class="math inline">\(\frac{\partial f}{\partial x}\)</span>表示对多个变量中某个变量求偏导数。</p><p>梯度下降算法能够保证每次迭代w和b都能向着J(w,b)全局最小化的方向进行。</p><h1 id="计算图computation-graph">2.5 计算图（Computation Graph）</h1><p>整个神经网络的训练过程实际上包含了两个过程：正向传播（Forward Propagation）和反向传播（Back Propagation）。</p><p>正向传播是从输入到输出，由神经网络计算得到预测输出的过程；反向传播是从输出到输入，利用输出计算出对应的梯度或导数，对参数w和b计算梯度的过程。</p><p>下面，我们用计算图（Computation graph）的形式来理解这两个过程。</p><p>举个简单的例子，假如Cost function为J(a,b,c)=3(a+bc)，包含a，b，c三个变量。 我们用u表示bc，v表示a+u，则J=3v。 它的计算图可以写成如下图所示： <img src="/img/深度学习-Course1-Week2/2神经网络的编程基础_7.png" /></p><p>首先计算u=bc，接着计算v=a+u，最后计算J=3v</p><p>计算图中，这种从左到右，从输入到输出的过程就对应着神经网络或者逻辑回归中输入与权重经过运算计算得到Cost function的正向过程。</p><h1 id="计算图导数derivatives-with-a-computation-graph">2.6 计算图导数（Derivatives with a Computation Graph）</h1><p>上一部分介绍的是计算图的正向传播（Forward Propagation），下面我们来介绍其反向传播（Back Propagation），即计算输出对输入的偏导数。</p><p>还是上个计算图的例子，输入参数有3个，分别是a，b，c。 <img src="/img/深度学习-Course1-Week2/2神经网络的编程基础_8.png" /> 首先计算J对参数a的偏导数。从计算图上来看，从右到左，J是v的函数，v是a的函数。则利用求导技巧，可以得到： <span class="math inline">\(\frac{\partial J}{\partial a}=\frac{\partial J}{\partial v}\cdot\frac{\partial v}{\partial a}=3\cdot1=3\)</span></p><p>然后计算J对参数b的偏导数。从计算图上来看，从右到左，J是v的函数，v是u的函数，u是b的函数。可以推导： <span class="math inline">\(\frac{\partial J}{\partial b}=\frac{\partial J}{\partial v}\cdot\frac{\partial v}{\partial u}\cdot\frac{\partial u}{\partial b}=3\cdot1\cdot c=3\cdot1\cdot2=6\)</span></p><p>最后计算J对参数c的偏导数。仍从计算图上来看，从右到左，J是v的函数，v是u的函数，u是c的函数。可以推导： <span class="math inline">\(\frac{\partial J}{\partial c}=\frac{\partial J}{\partial v}\cdot\frac{\partial v}{\partial u}\cdot\frac{\partial u}{\partial c}=3\cdot1\cdot b=3\cdot1\cdot3=9\)</span></p><h1 id="逻辑回归的梯度下降logistic-regression-gradient-descent">2.7 逻辑回归的梯度下降（Logistic Regression Gradient Descent）</h1><p>我们对逻辑回归进行梯度计算。</p><p>对单个样本而言，逻辑回归损失函数如下：</p><p><span class="math display">\[\begin{gathered}z=w^Tx+b \\\hat{y}=a=\sigma(z) \\L(a,y)=-(ylog(a)+(1-y)log(1-a)) \end{gathered}\]</span></p><p>对于<strong>正向传播</strong>： 假设输入样本x有两个特征(<span class="math inline">\(x_1,x_2\)</span>)，相应的权重w维度也是2，即(<span class="math inline">\(w_1,w_2\)</span>)。则<span class="math inline">\(z=w_1x_1+w_2x_2+b\)</span>，正向传播计算图如下：</p><p><img src="/img/深度学习-Course1-Week2/2神经网络的编程基础_11.png" /></p><p>对于<strong>反向传播</strong>：</p><p><img src="/img/深度学习-Course1-Week2/2神经网络的编程基础_12.png" /></p><p>知道了<span class="math inline">\(d_z\)</span>之后，就可以直接对<span class="math inline">\(w_1\)</span>，<span class="math inline">\(w_2\)</span>和b进行求导了。 <span class="math display">\[\begin{aligned}dw_1&amp;=\frac{\partial L}{\partial w_1}=\frac{\partial L}{\partial z}\cdot\frac{\partial z}{\partial w_1}=x_1\cdot dz=x_1(a-y)\\dw_2&amp;=\frac{\partial L}{\partial w_2}=\frac{\partial L}{\partial z}\cdot\frac{\partial z}{\partial w_2}=x_2\cdot dz=x_2(a-y)\\db&amp;=\frac{\partial L}{\partial b}=\frac{\partial L}{\partial z}\cdot\frac{\partial z}{\partial b}=1\cdot dz=a-y\end{aligned}\]</span></p><p>则梯度下降算法可表示为：</p><p><span class="math display">\[\begin{gathered}w_1:=w_1-\alpha\:dw_1\\w_2:=w_2-\alpha\:dw_2\\b:=b-\alpha\:db\end{gathered}\]</span></p><p><strong>总结：</strong> 首先知道参数w和b，利用正向传播计算出损失函数的值，接着根据损失函数的值利用反向传播计算出w和b的导数，最后利用计算出的导数更新w和b的值 <span class="math display">\[\begin{gathered}w=w-\alpha\frac{\partial J(w,b)}{\partial w} \\b=b-\alpha\frac{\partial J(w,b)}{\partial b} \end{gathered}\]</span> 依次循环，直到损失函数最小。</p><h1 id="m个样本的梯度下降的例gradient-descent-on-m-examples">2.8 m个样本的梯度下降的例(Gradient Descent on m Examples)</h1><p><img src="/img/深度学习-Course1-Week2/2神经网络的编程基础_9.png" /></p><p>Cost function关于w和b的偏导数可以写成和平均的形式： <span class="math display">\[\begin{gathered}\begin{aligned}dw_1&amp;=\frac1m\sum_{i=1}^mx_1^{(i)}(a^{(i)}-y^{(i)})\\\\dw_2&amp;=\frac1m\sum_{i=1}^mx_2^{(i)}(a^{(i)}-y^{(i)})\\\\db&amp;=\frac1m\sum_{i=1}^m(a^{(i)}-y^{(i)})\end{aligned}\end{gathered}\]</span></p><p><span class="math inline">\(\mathrm{d}\omega_{1}\)</span> 、<span class="math inline">\(\mathrm{d}\omega_{2}\)</span> 用于累加，单个样本中的偏导数都累加在此，最后求平均，所以初始化为0。</p><p>在上述的梯度下降算法中，我们是利用for循环对每个样本进行<span class="math inline">\(dw_1\)</span>，<span class="math inline">\(dw_2\)</span>和<span class="math inline">\(d_b\)</span>的累加计算最后再求平均数的。</p><p>在深度学习中，样本数量m通常很大，使用for循环会让神经网络程序运行得很慢。</p><p>所以，我们应该尽量避免使用for循环操作，而使用矩阵运算，能够大大提高程序运行速度。</p><h1 id="向量化vectorization">2.9 向量化(Vectorization)</h1><p>深度学习算法中，数据量很大，在程序中应该尽量减少使用循环语句，而可以使用向量运算来提高程序运行速度。</p><p>向量化（Vectorization）就是利用矩阵运算的思想，大大提高运算速度。</p><h1 id="向量化逻辑回归vectorizing-logistic-regression">2.10 向量化逻辑回归(Vectorizing Logistic Regression)</h1><p>我们前面介绍过，整个训练样本构成的输入矩阵X的维度是（<span class="math inline">\(n_{x}\)</span>，m），权重矩阵w的维度是（<span class="math inline">\(n_{x}\)</span>，1），b是一个常数值，而整个训练样本构成的输出矩阵Y的维度为（1，m）。</p><p>利用向量化的思想，所有m个样本的线性输出Z可以用矩阵表示： <span class="math inline">\(Z=w^TX+b\)</span></p><p>在python的numpy库中可以如下表示，其中，w.T表示w的转置。</p><p><span class="math display">\[\begin{array}{rcl}Z&amp;=&amp;\text{np.dot(w. T, X)}&amp;+&amp;\text{b}\\\text{A}&amp;=&amp;\text{sigmoid(Z)}&amp;&amp;\end{array}\]</span> 这样，我们就能够使用向量化矩阵运算代替for循环，对所有m个样本同时运算，大大提高了运算速度。</p><h1 id="向量化逻辑回归的梯度计算vectorizing-logistic-regressions-gradient">2.11 向量化逻辑回归的梯度计算（Vectorizing Logistic Regression's Gradient）</h1><p>逻辑回归中的梯度下降算法如何转化为向量化的矩阵形式。</p><p>对于m个样本，<span class="math inline">\(d_Z\)</span>的维度是 (1, m), 可表示为：</p><p><span class="math display">\[\begin{aligned}dZ=A-Y\end{aligned}\]</span></p><p><span class="math inline">\(d_b\)</span>可表示为：</p><p><span class="math display">\[db=\frac1m\sum_{i=1}^mdz^{(i)}\]</span></p><p><span class="math inline">\(d_w\)</span>可表示为： <span class="math display">\[dw=\frac1mX\cdot dZ^T\]</span> 于单次迭代，梯度下降算法流程如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">Z = np. dot(w.T,X) + b<br>A = sigmoid (<span class="hljs-number">2</span>)<br>dZ =A - Y<br>dw = <span class="hljs-number">1</span>/m*np.dot(X,dZ.T) <br>db = <span class="hljs-number">1</span>/m米np. <span class="hljs-built_in">sum</span>(d2)<br><br>w = w - alpha*dw<br>b = b - alpha*db<br></code></pre></td></tr></table></figure><h1 id="关于-python与numpy向量的使用技巧a-note-on-python-or-numpy-vectors">2.12 关于 Python与numpy向量的使用技巧（A note on python or numpy vectors）</h1><p>python中，如果我们用下列语句来定义一个向量： <code>a = np.random.randn(5)</code></p><p>这条语句生成的a的维度是(5，)。它既不是行向量也不是列向量，我们把a叫做rankv1 array。</p><p>这种定义会带来一些问题。例如我们对a进行转置，还是会得到a本身。</p><p>所以，如果我们要定义(5,1)的列向量或者(1,5)的行向量，最好使用下来标准语句，避免使用rank1 array。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> = np<span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.randn</span>(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>)<br><span class="hljs-selector-tag">b</span> = np<span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.randn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>除此之外，我们还可以使用assert语句对向量或数组的维度进行判断，例如： <code>assert(a.shape ==(5,1))</code></p><p>assert会对内嵌语句进行判断，即判断a的维度是不是(5,1)的。如果不是，则程序在此处停止。</p><p>另外，还可以使用reshape函数对数组设定所需的维度： <code>a.reshape((5,1))</code></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习-Course1_Week1深度学习引言</title>
    <link href="/2024/02/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course1-Week1%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%95%E8%A8%80/"/>
    <url>/2024/02/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Course1-Week1%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%95%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>主要介绍神经网络的概念、深度学习兴起的原因、课程内容等，无笔记内容</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>天猫重复购买预测-02数据探索</title>
    <link href="/2023/12/02/%E5%A4%A9%E7%8C%AB%E9%87%8D%E5%A4%8D%E8%B4%AD%E4%B9%B0%E9%A2%84%E6%B5%8B-02%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/"/>
    <url>/2023/12/02/%E5%A4%A9%E7%8C%AB%E9%87%8D%E5%A4%8D%E8%B4%AD%E4%B9%B0%E9%A2%84%E6%B5%8B-02%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="工具导入和数据读取">1 工具导入和数据读取</h2><h3 id="工具导入">工具导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)<br> <br>%matplotlib inline<br></code></pre></td></tr></table></figure><h3 id="数据读取">数据读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">读取数据集</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>test_data = pd.read_csv(<span class="hljs-string">&#x27;./data/data_format1/test_format1.csv&#x27;</span>)<br>train_data = pd.read_csv(<span class="hljs-string">&#x27;./data/data_format1/train_format1.csv&#x27;</span>)<br><br>user_info = pd.read_csv(<span class="hljs-string">&#x27;./data/data_format1/user_info_format1.csv&#x27;</span>)<br>user_log = pd.read_csv(<span class="hljs-string">&#x27;./data/data_format1/user_log_format1.csv&#x27;</span>)<br><br><span class="hljs-comment">#user_info = pd.read_csv(&#x27;./data_format1/user_info_format1.csv&#x27;).drop_duplicates()</span><br><span class="hljs-comment">#user_log = pd.read_csv(&#x27;./data_format1/user_log_format1.csv&#x27;).rename(columns=&#123;&quot;seller_id&quot;:&#x27;merchant_id&#x27;&#125;)</span><br><br></code></pre></td></tr></table></figure><h3 id="数据集样例查看">数据集样例查看</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data.head(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>user_id</th><th>merchant_id</th><th>label</th></tr></thead><tbody><tr><th>0</th><td>34176</td><td>3906</td><td>0</td></tr><tr><th>1</th><td>34176</td><td>121</td><td>0</td></tr><tr><th>2</th><td>34176</td><td>4356</td><td>1</td></tr><tr><th>3</th><td>34176</td><td>2217</td><td>0</td></tr><tr><th>4</th><td>230784</td><td>4818</td><td>0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">test_data.head(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>user_id</th><th>merchant_id</th><th>prob</th></tr></thead><tbody><tr><th>0</th><td>163968</td><td>4605</td><td>NaN</td></tr><tr><th>1</th><td>360576</td><td>1581</td><td>NaN</td></tr><tr><th>2</th><td>98688</td><td>1964</td><td>NaN</td></tr><tr><th>3</th><td>98688</td><td>3645</td><td>NaN</td></tr><tr><th>4</th><td>295296</td><td>3361</td><td>NaN</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_info.head(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>user_id</th><th>age_range</th><th>gender</th></tr></thead><tbody><tr><th>0</th><td>376517</td><td>6.0</td><td>1.0</td></tr><tr><th>1</th><td>234512</td><td>5.0</td><td>0.0</td></tr><tr><th>2</th><td>344532</td><td>5.0</td><td>0.0</td></tr><tr><th>3</th><td>186135</td><td>5.0</td><td>0.0</td></tr><tr><th>4</th><td>30230</td><td>5.0</td><td>0.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_log.head(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>user_id</th><th>item_id</th><th>cat_id</th><th>seller_id</th><th>brand_id</th><th>time_stamp</th><th>action_type</th></tr></thead><tbody><tr><th>0</th><td>328862</td><td>323294</td><td>833</td><td>2882</td><td>2661.0</td><td>829</td><td>0</td></tr><tr><th>1</th><td>328862</td><td>844400</td><td>1271</td><td>2882</td><td>2661.0</td><td>829</td><td>0</td></tr><tr><th>2</th><td>328862</td><td>575153</td><td>1271</td><td>2882</td><td>2661.0</td><td>829</td><td>0</td></tr><tr><th>3</th><td>328862</td><td>996875</td><td>1271</td><td>2882</td><td>2661.0</td><td>829</td><td>0</td></tr><tr><th>4</th><td>328862</td><td>1086186</td><td>1271</td><td>1253</td><td>1049.0</td><td>829</td><td>0</td></tr></tbody></table></div><h2 id="单变量数据分析">2 单变量数据分析</h2><h3 id="数据类型和数据大小">2.1 数据类型和数据大小</h3><p><strong>用户信息数据</strong></p><ol type="1"><li>数据集中共有2个float64类型和1个int64类型的数据</li><li>数据大小9.7MB</li><li>数据集共有424170条数据</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_info.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 424170 entries, 0 to 424169Data columns (total 3 columns): #   Column     Non-Null Count   Dtype  ---  ------     --------------   -----   0   user_id    424170 non-null  int64   1   age_range  421953 non-null  float64 2   gender     417734 non-null  float64dtypes: float64(2), int64(1)memory usage: 9.7 MB</code></pre><p><strong>用户行为数据</strong></p><ol type="1"><li>数据集中共有6个int64类型和1个float64类型的数据</li><li>数据大小2.9GB</li><li>数据集共有54925330条数据</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_log.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 54925330 entries, 0 to 54925329Data columns (total 7 columns): #   Column       Dtype  ---  ------       -----   0   user_id      int64   1   item_id      int64   2   cat_id       int64   3   seller_id    int64   4   brand_id     float64 5   time_stamp   int64   6   action_type  int64  dtypes: float64(1), int64(6)memory usage: 2.9 GB</code></pre><p><strong>用户购买训练数据</strong></p><ol type="1"><li>数据均为int64类型</li><li>数据大小6MB</li><li>数据集共有260864条数据</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 260864 entries, 0 to 260863Data columns (total 3 columns): #   Column       Non-Null Count   Dtype---  ------       --------------   ----- 0   user_id      260864 non-null  int64 1   merchant_id  260864 non-null  int64 2   label        260864 non-null  int64dtypes: int64(3)memory usage: 6.0 MB</code></pre><h3 id="缺失值查看">2.2 缺失值查看</h3><p>使用Pandas中count()函数及shape()函数进行统计：count()函数可以统计不为空数据的个数；shape()函数则可以统计数据样本的个数；将shape()函数与count()函数做差就可以得到数据的缺失个数，再用缺失的个数除以样本的个数来计算样本中此字段的缺失率。</p><p><strong>（1）用户信息数据缺失，年龄值缺失情况</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(user_info.shape[<span class="hljs-number">0</span>]-user_info[<span class="hljs-string">&#x27;age_range&#x27;</span>].count())/user_info.shape[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.005226677982884221</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_info[user_info[<span class="hljs-string">&#x27;age_range&#x27;</span>].isna() | (user_info[<span class="hljs-string">&#x27;age_range&#x27;</span>] == <span class="hljs-number">0</span>)].count()<br></code></pre></td></tr></table></figure><pre><code class="hljs">user_id      95131age_range    92914gender       90664dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_info.groupby([<span class="hljs-string">&#x27;age_range&#x27;</span>])[[<span class="hljs-string">&#x27;user_id&#x27;</span>]].count()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>user_id</th></tr><tr><th>age_range</th><th></th></tr></thead><tbody><tr><th>0.0</th><td>92914</td></tr><tr><th>1.0</th><td>24</td></tr><tr><th>2.0</th><td>52871</td></tr><tr><th>3.0</th><td>111654</td></tr><tr><th>4.0</th><td>79991</td></tr><tr><th>5.0</th><td>40777</td></tr><tr><th>6.0</th><td>35464</td></tr><tr><th>7.0</th><td>6992</td></tr><tr><th>8.0</th><td>1266</td></tr></tbody></table></div><ol type="1"><li>年龄值为空的缺失率为0.5%</li><li>年龄值缺失或者年龄值默认为0时，可认为数据缺失</li><li>有缺失值的数据共计95131条数据</li></ol><p><strong>（2）查看性别缺失情况</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(user_info.shape[<span class="hljs-number">0</span>]-user_info[<span class="hljs-string">&#x27;gender&#x27;</span>].count())/user_info.shape[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.01517316170403376</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_info[user_info[<span class="hljs-string">&#x27;gender&#x27;</span>].isna() | (user_info[<span class="hljs-string">&#x27;gender&#x27;</span>] == <span class="hljs-number">2</span>)].count()<br></code></pre></td></tr></table></figure><pre><code class="hljs">user_id      16862age_range    14664gender       10426dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_info.groupby([<span class="hljs-string">&#x27;gender&#x27;</span>])[[<span class="hljs-string">&#x27;user_id&#x27;</span>]].count()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>user_id</th></tr><tr><th>gender</th><th></th></tr></thead><tbody><tr><th>0.0</th><td>285638</td></tr><tr><th>1.0</th><td>121670</td></tr><tr><th>2.0</th><td>10426</td></tr></tbody></table></div><ol type="1"><li><p>性别值为空的缺失率 1.5%</p></li><li><p>当性别值缺失或者性别值默认为2时，可认为该数据缺失</p></li><li><p>有缺失值的数据共计16862条数据</p></li></ol><p><strong>（3）查看年龄或者性别其中有一个有缺失的情况</strong></p><p>共计106330条数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_info[user_info[<span class="hljs-string">&#x27;age_range&#x27;</span>].isna() | (user_info[<span class="hljs-string">&#x27;age_range&#x27;</span>] == <span class="hljs-number">0</span>) | user_info[<span class="hljs-string">&#x27;gender&#x27;</span>].isna() | (user_info[<span class="hljs-string">&#x27;gender&#x27;</span>] == <span class="hljs-number">2</span>)].count()<br></code></pre></td></tr></table></figure><pre><code class="hljs">user_id      106330age_range    104113gender        99894dtype: int64</code></pre><p><strong>（4）用户行为日志信息</strong></p><p>brand_id字段有91015条缺失数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_log.isna().<span class="hljs-built_in">sum</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">user_id            0item_id            0cat_id             0seller_id          0brand_id       91015time_stamp         0action_type        0dtype: int64</code></pre><h2 id="观察数据分布">3 观察数据分布</h2><h3 id="整体数据统计信息">3.1 整体数据统计信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_info.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>user_id</th><th>age_range</th><th>gender</th></tr></thead><tbody><tr><th>count</th><td>424170.000000</td><td>421953.000000</td><td>417734.000000</td></tr><tr><th>mean</th><td>212085.500000</td><td>2.930262</td><td>0.341179</td></tr><tr><th>std</th><td>122447.476178</td><td>1.942978</td><td>0.524112</td></tr><tr><th>min</th><td>1.000000</td><td>0.000000</td><td>0.000000</td></tr><tr><th>25%</th><td>106043.250000</td><td>2.000000</td><td>0.000000</td></tr><tr><th>50%</th><td>212085.500000</td><td>3.000000</td><td>0.000000</td></tr><tr><th>75%</th><td>318127.750000</td><td>4.000000</td><td>1.000000</td></tr><tr><th>max</th><td>424170.000000</td><td>8.000000</td><td>2.000000</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_log.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>user_id</th><th>item_id</th><th>cat_id</th><th>seller_id</th><th>brand_id</th><th>time_stamp</th><th>action_type</th></tr></thead><tbody><tr><th>count</th><td>5.492533e+07</td><td>5.492533e+07</td><td>5.492533e+07</td><td>5.492533e+07</td><td>5.483432e+07</td><td>5.492533e+07</td><td>5.492533e+07</td></tr><tr><th>mean</th><td>2.121568e+05</td><td>5.538613e+05</td><td>8.770308e+02</td><td>2.470941e+03</td><td>4.153348e+03</td><td>9.230953e+02</td><td>2.854458e-01</td></tr><tr><th>std</th><td>1.222872e+05</td><td>3.221459e+05</td><td>4.486269e+02</td><td>1.473310e+03</td><td>2.397679e+03</td><td>1.954305e+02</td><td>8.075806e-01</td></tr><tr><th>min</th><td>1.000000e+00</td><td>1.000000e+00</td><td>1.000000e+00</td><td>1.000000e+00</td><td>1.000000e+00</td><td>5.110000e+02</td><td>0.000000e+00</td></tr><tr><th>25%</th><td>1.063360e+05</td><td>2.731680e+05</td><td>5.550000e+02</td><td>1.151000e+03</td><td>2.027000e+03</td><td>7.300000e+02</td><td>0.000000e+00</td></tr><tr><th>50%</th><td>2.126540e+05</td><td>5.555290e+05</td><td>8.210000e+02</td><td>2.459000e+03</td><td>4.065000e+03</td><td>1.010000e+03</td><td>0.000000e+00</td></tr><tr><th>75%</th><td>3.177500e+05</td><td>8.306890e+05</td><td>1.252000e+03</td><td>3.760000e+03</td><td>6.196000e+03</td><td>1.109000e+03</td><td>0.000000e+00</td></tr><tr><th>max</th><td>4.241700e+05</td><td>1.113166e+06</td><td>1.671000e+03</td><td>4.995000e+03</td><td>8.477000e+03</td><td>1.112000e+03</td><td>3.000000e+00</td></tr></tbody></table></div><h3 id="查看正负样本的分布并可视化">3.2查看正负样本的分布并可视化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">label_gp = train_data.groupby(<span class="hljs-string">&#x27;label&#x27;</span>)[<span class="hljs-string">&#x27;user_id&#x27;</span>].count()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正负样本的数量：\n&#x27;</span>,label_gp)<br>_,axe = plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">6</span>))<br>train_data.label.value_counts().plot(kind=<span class="hljs-string">&#x27;pie&#x27;</span>,autopct=<span class="hljs-string">&#x27;%1.1f%%&#x27;</span>,shadow=<span class="hljs-literal">True</span>,explode=[<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>],ax=axe[<span class="hljs-number">0</span>])<br>sns.countplot(x=<span class="hljs-string">&#x27;label&#x27;</span>,data=train_data,ax=axe[<span class="hljs-number">1</span>],)<br></code></pre></td></tr></table></figure><pre><code class="hljs">正负样本的数量： label0    2449121     15952Name: user_id, dtype: int64&lt;AxesSubplot:xlabel=&#39;label&#39;, ylabel=&#39;count&#39;&gt;</code></pre><p><img src="/img/天猫重复购买预测-02数据探索/output_37_2.png" /></p><p>从上图可以看出，样本的分布不均衡，需要采取一定的措施处理样本不均衡的问题：</p><ul><li>类似欠采样,将一份正样本和多分负样本组合成多分训练集,训练多个模型后求平均</li><li>调整模型的权重</li></ul><h4 id="代码解释">代码解释</h4><ol type="1"><li><code>_, axe = plt.subplots(1, 2, figsize=(12, 6))</code>: 创建一个包含两个子图的画布，并将其返回给 <code>_</code> 和 <code>axe</code>。这里使用了 <code>plt.subplots()</code> 方法创建画布，参数 <code>1, 2</code> 表示子图的行数和列数，<code>figsize=(12, 6)</code> 设置了画布的大小为 12x6。</li></ol><p><code>plt.subplots()</code> 方法返回一个包含子图的画布对象和子图对象的元组。<code>_</code> 是用来忽略画布对象的变量名，而 <code>axe</code> 是用来存储子图对象的变量名。通常情况下，我们只对子图对象进行操作和引用，因此将其赋值给 <code>axe</code> 变量以便后续使用。</p><ol start="2" type="1"><li><code>train_data.label.value_counts().plot(kind='pie', autopct='%1.1f%%', shadow=True, explode=[0, 0.1], ax=axe[0])</code>: 针对 <code>train_data</code> 数据集中的 <code>label</code> 列进行计数，并生成一个饼图。<code>value_counts()</code> 方法用于计算每个 label 的出现次数，<code>plot()</code> 方法用于绘制饼图。<code>kind='pie'</code> 设置图表类型为饼图，<code>autopct='%1.1f%%'</code> 设置饼图中每个部分的百分比显示格式，<code>shadow=True</code> 添加阴影效果，<code>explode=[0, 0.1]</code> 表示将第二个 label 分割出来以突出显示，<code>ax=axe[0]</code> 指定绘制在第一个子图上。</li></ol><p><code>explode=[0, 0.1]</code> 是设置饼图中各个扇形分离的程度的参数。<code>explode</code> 参数是一个列表，其中每个元素代表对应扇形与圆心的距离（以半径为单位）。具体来说，<code>[0, 0.1]</code> 表示第一个扇形不分离（与圆心距离为0），而第二个扇形与圆心分离出一个相对半径为0.1的距离。通过设置不同的 <code>explode</code> 参数，可以实现突出显示某些扇形的效果，使其凸出或分离出来以强调重要性或区分度。在这段代码中，通过 <code>explode=[0, 0.1]</code> 的设定，使得饼图中的第二个 label 扇形相对于圆心稍微分离出来。</p><ol start="3" type="1"><li><code>sns.countplot('label', data=train_data, ax=axe[1])</code>: 使用 seaborn 库的 <code>countplot()</code> 方法绘制柱状图。该方法用于显示某个变量（在这里是 <code>label</code> 列）的频数。<code>'label'</code> 是指定要绘制的变量名称，<code>data=train_data</code> 指定数据来源为 <code>train_data</code> 数据集，<code>ax=axe[1]</code> 指定绘制在第二个子图上。</li></ol><h2 id="探查影响复购的各种因素">4 探查影响复购的各种因素</h2><p>探查店铺、用户、性别以及年龄对复购的影响</p><h3 id="对店铺分析">4.1 对店铺分析</h3><p><strong>（1）分析不同店铺与复购关系，并可视化展示</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;选取top5店铺\n店铺\t购买次数&#x27;</span>)<br><span class="hljs-built_in">print</span>(train_data.merchant_id.value_counts().head(<span class="hljs-number">5</span>))<br>train_data_merchant = train_data.copy()<br>train_data_merchant[<span class="hljs-string">&#x27;TOP5&#x27;</span>] = train_data_merchant[<span class="hljs-string">&#x27;merchant_id&#x27;</span>].<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">4044</span>,<span class="hljs-number">3828</span>,<span class="hljs-number">4173</span>,<span class="hljs-number">1102</span>,<span class="hljs-number">4976</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<br>train_data_merchant = train_data_merchant[train_data_merchant[<span class="hljs-string">&#x27;TOP5&#x27;</span>]==<span class="hljs-number">1</span>]<br>plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>))<br>plt.title(<span class="hljs-string">&#x27;Merchant VS Label&#x27;</span>)<br>ax = sns.countplot(x=<span class="hljs-string">&#x27;merchant_id&#x27;</span>,hue=<span class="hljs-string">&#x27;label&#x27;</span>,data=train_data_merchant)<br><span class="hljs-comment">#for p in ax.patches:</span><br>    <span class="hljs-comment">#height = p.get_height()</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">选取top5店铺店铺  购买次数4044    33793828    32544173    25421102    24834976    1925Name: merchant_id, dtype: int64</code></pre><p><img src="/img/天猫重复购买预测-02数据探索/output_43_1.png" /></p><p>从图可以看出不同店铺有不同复购率，可能与不同店铺售卖的商品有关，以及店铺的运营有关。</p><h4 id="代码解释-1">代码解释</h4><p>1、</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data_merchant[<span class="hljs-string">&#x27;TOP5&#x27;</span>] = train_data_merchant[<span class="hljs-string">&#x27;merchant_id&#x27;</span>].<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">4044</span>, <span class="hljs-number">3828</span>, <span class="hljs-number">4173</span>, <span class="hljs-number">1102</span>, <span class="hljs-number">4976</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ul><li><code>train_data_merchant['TOP5']</code>：使用 <code>train_data_merchant</code> 数据集的索引操作符 <code>[]</code>，选择 <code>train_data_merchant</code> 数据集的列 <code>'TOP5'</code>。</li><li><code>train_data_merchant['merchant_id']</code>：选择 <code>train_data_merchant</code> 数据集中的 <code>'merchant_id'</code> 列。</li><li><code>.map(lambda x: 1 if x in [4044, 3828, 4173, 1102, 4976] else 0)</code>：使用 <code>map()</code> 函数对 <code>'merchant_id'</code> 列中的每个值应用 lambda 函数进行映射。如果该值在 <code>[4044, 3828, 4173, 1102, 4976]</code> 中，则映射为 1，否则为 0。</li><li>最后，将得到的映射结果赋值给 <code>'TOP5'</code> 列，从而实现了对 <code>train_data_merchant</code> 数据集的新列的添加。</li></ul><p>2、<code>lambda</code></p><ol type="1"><li><p><code>lambda x:</code>：表示创建匿名函数，而 <code>x</code> 是匿名函数的参数。在本例中，<code>x</code> 用于表示 <code>merchant_id</code> 列中的每个值。</p></li><li><p><code>1 if x in [4044, 3828, 4173, 1102, 4976] else 0</code>：这是一个条件表达式，它根据 <code>x</code> 是否在 <code>[4044, 3828, 4173, 1102, 4976]</code> 列表中返回相应的值。</p><ul><li><p>如果 <code>x</code> 的值在列表 <code>[4044, 3828, 4173, 1102, 4976]</code> 中，条件成立，返回结果为 1。</p></li><li><p>如果 <code>x</code> 的值不在列表中，条件不成立，返回结果为 0。</p></li></ul></li><li><p><code>train_data_merchant['merchant_id'].map(lambda x: 1 if x in [4044, 3828, 4173, 1102, 4976] else 0)</code>：这行代码将 <code>lambda</code> 函数应用于 <code>merchant_id</code> 列中的每个值，并通过 <code>map()</code> 函数将映射结果赋值给 <code>TOP5</code> 列。</p><ul><li><p>对于 <code>merchant_id</code> 列中的每个值 <code>x</code>，<code>lambda</code> 函数根据条件表达式返回相应结果。</p></li><li><p>最终， <code>TOP5</code> 列将包含相应的映射结果，1 表示 <code>merchant_id</code> 值在 <code>[4044, 3828, 4173, 1102, 4976]</code> 中，0 表示不在其中。</p></li></ul></li></ol><p><strong>（2）查看店铺复购概率分布</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">merchant_repeat_buy = [ rate <span class="hljs-keyword">for</span> rate <span class="hljs-keyword">in</span> train_data.groupby([<span class="hljs-string">&#x27;merchant_id&#x27;</span>])[<span class="hljs-string">&#x27;label&#x27;</span>].mean() <span class="hljs-keyword">if</span> rate &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> rate &gt; <span class="hljs-number">0</span>] <br><br>plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))<br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>sns.distplot(merchant_repeat_buy, fit=stats.norm)<br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>res = stats.probplot(merchant_repeat_buy, plot=plt)<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/天猫重复购买预测-02数据探索/output_48_0.png" /> ​</p><p>这两幅图分别是概率密度图和概率图，反映了店铺的复购概率分布情况。可以看出不同店铺有不同复购率，大致在0-0.3之间</p><p>其中，概率密度图反映了复购概率的分布形态，以及是否满足正态分布假设。如果概率密度图接近正态分布曲线，则说明复购概率分布符合正态分布假设，否则说明分布形态可能存在偏差或者异常值。</p><p>概率图则反映了复购概率的数值范围和分布情况，包括四分位数、中位数、最大值、最小值等信息，可以帮助我们更直观地了解店铺复购概率的整体情况和分布特征。同时，通过比较不同店铺的概率图，可以看出不同店铺的复购概率分布情况是否存在明显差异。</p><h4 id="代码解释-2">代码解释</h4><p><code>train_data.groupby(['merchant_id'])['label'].mean()</code></p><p>这行代码对 <code>train_data</code> 数据集进行了分组操作，并计算了每个 <code>merchant_id</code> 对应的 <code>label</code> 列的均值。</p><ol type="1"><li><p><code>train_data.groupby(['merchant_id'])</code>：这部分代码使用 <code>groupby()</code> 函数将数据集按照 <code>merchant_id</code> 列进行分组。</p><ul><li><p><code>groupby()</code> 用于按照指定的列对数据进行分组。</p></li><li><p><code>['merchant_id']</code> 参数指定根据哪一列进行分组。</p></li></ul></li><li><p><code>['label'].mean()</code>：这部分代码在分组后的结果上，选择了 <code>label</code> 列，并调用 <code>mean()</code> 方法计算了均值。</p><ul><li><p><code>['label']</code> 表示从分组结果中选择了 <code>label</code> 列。</p></li><li><p><code>.mean()</code> 是 pandas 的一个方法，计算了选定列的均值。</p></li></ul></li></ol><p>最终，这行代码将返回一个以 <code>merchant_id</code> 为索引的 Series 对象，其中包含每个 <code>merchant_id</code> 对应的 <code>label</code> 列的均值。</p><p>例如，如果有以下数据：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">merchant_id</span>   label<br>    <span class="hljs-attribute">M1</span>          <span class="hljs-number">1</span><br>    <span class="hljs-attribute">M1</span>          <span class="hljs-number">0</span><br>    <span class="hljs-attribute">M2</span>          <span class="hljs-number">0</span><br>    <span class="hljs-attribute">M2</span>          <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>那么执行 <code>train_data.groupby(['merchant_id'])['label'].mean()</code> 的结果将是：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang">merchant_id<br>    M1       <span class="hljs-number">0.5</span><br>    M2       <span class="hljs-number">0.5</span><br>    ...<br></code></pre></td></tr></table></figure><p>其中，<code>M1</code> 对应的均值为 <code>0.5</code>，<code>M2</code> 对应的均值也为 <code>0.5</code>。</p><h3 id="对用户分析">4.2 对用户分析</h3><p>查看用户复购率分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">user_repeat_buy = [rate <span class="hljs-keyword">for</span> rate <span class="hljs-keyword">in</span> train_data.groupby([<span class="hljs-string">&#x27;user_id&#x27;</span>])[<span class="hljs-string">&#x27;label&#x27;</span>].mean() <span class="hljs-keyword">if</span> rate &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> rate &gt; <span class="hljs-number">0</span>] <br><br>plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>))<br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>sns.distplot(user_repeat_buy, fit=stats.norm)<br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>res = stats.probplot(user_repeat_buy, plot=plt)<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/天猫重复购买预测-02数据探索/output_53_0.png" /> ​</p><p>可以看出近6个月，用户复购率很小，基本买一次为主</p><h3 id="对用户性别分析">4.3 对用户性别分析</h3><p><strong>（1）分析用户性别与复购的关系</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data_user_info = train_data.merge(user_info,on=[<span class="hljs-string">&#x27;user_id&#x27;</span>],how=<span class="hljs-string">&#x27;left&#x27;</span>)<br><br>plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>))<br>plt.title(<span class="hljs-string">&#x27;Gender VS Label&#x27;</span>)<br>ax = sns.countplot(x=<span class="hljs-string">&#x27;gender&#x27;</span>,hue=<span class="hljs-string">&#x27;label&#x27;</span>,data=train_data_user_info)<br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ax.patches:<br>    height = p.get_height()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/天猫重复购买预测-02数据探索/output_57_0.png" /> ​</p><h4 id="代码解释-3">代码解释</h4><p><code>train_data_user_info = train_data.merge(user_info,on=['user_id'],how='left')</code></p><p>将 <code>train_data</code> 数据集和 <code>user_info</code> 用户信息数据集按照 <code>user_id</code> 进行左连接（left join）操作，将两个数据集中的所有行按照 <code>user_id</code> 进行匹配，将匹配成功的行合并到一起。</p><p>其中 <code>train_data</code> 和 <code>user_info</code> 分别表示要进行连接的两个数据集，<code>on=['user_id']</code> 指定连接键为 <code>user_id</code> 列，<code>how='left'</code> 指定连接方式为左连接（即以 <code>train_data</code> 数据集为基础进行连接，将 <code>user_info</code> 数据集中匹配不上的行填充为缺失值）。最终，该代码将新生成一个包含用户信息的 <code>train_data_user_info</code> 数据集。</p><p><strong>(2)查看用户性别复购的分布</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">repeat_buy = [rate <span class="hljs-keyword">for</span> rate <span class="hljs-keyword">in</span> train_data_user_info.groupby([<span class="hljs-string">&#x27;gender&#x27;</span>])[<span class="hljs-string">&#x27;label&#x27;</span>].mean()] <br><br>plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))<br><br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>sns.distplot(repeat_buy, fit=stats.norm)<br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>res = stats.probplot(repeat_buy, plot=plt)<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/天猫重复购买预测-02数据探索/output_61_0.png" /> ​</p><p>可以看出男女的复购率不一样</p><p>​</p><h3 id="对用户年龄分析">4.3 对用户年龄分析</h3><p><strong>（1）查看用户年龄与复购的关系</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>))<br>plt.title(<span class="hljs-string">&#x27;Age VS Label&#x27;</span>)<br>ax = sns.countplot(x=<span class="hljs-string">&#x27;age_range&#x27;</span>,hue=<span class="hljs-string">&#x27;label&#x27;</span>,data=train_data_user_info)<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/天猫重复购买预测-02数据探索/output_65_0.png" /> ​</p><p><strong>(2)查看用户年龄复购的分布</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">repeat_buy = [rate <span class="hljs-keyword">for</span> rate <span class="hljs-keyword">in</span> train_data_user_info.groupby([<span class="hljs-string">&#x27;age_range&#x27;</span>])[<span class="hljs-string">&#x27;label&#x27;</span>].mean()] <br><br>plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))<br><br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>sns.distplot(repeat_buy, fit=stats.norm)<br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>res = stats.probplot(repeat_buy, plot=plt)<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/天猫重复购买预测-02数据探索/output_68_0.png" /> ​</p><p>可以看出不同年龄段，复购概率不同</p>]]></content>
    
    
    <categories>
      
      <category>机器学习实战入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工业蒸汽预测-赛题完整代码分享</title>
    <link href="/2023/09/28/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-%E8%B5%9B%E9%A2%98%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%88%86%E4%BA%AB/"/>
    <url>/2023/09/28/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-%E8%B5%9B%E9%A2%98%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.rcParams.update(&#123;<span class="hljs-string">&#x27;figure.max_open_warning&#x27;</span>: <span class="hljs-number">0</span>&#125;)<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><br><span class="hljs-comment"># modelling</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV, RepeatedKFold, cross_val_score,cross_val_predict,KFold<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> make_scorer,mean_squared_error<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression, Lasso, Ridge, ElasticNet<br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> LinearSVR, SVR<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor, GradientBoostingRegressor,AdaBoostRegressor<br><span class="hljs-keyword">from</span> xgboost <span class="hljs-keyword">import</span> XGBRegressor<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> PolynomialFeatures,MinMaxScaler,StandardScaler<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#load_dataset</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/kaggle/input/industrial-steam/zhengqi_train.txt&quot;</span>)  <span class="hljs-keyword">as</span> fr: <span class="hljs-comment"># /kaggle/input/industrial-steam/zhengqi_train.txt</span><br>    data_train=pd.read_table(fr,sep=<span class="hljs-string">&quot;\t&quot;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/kaggle/input/industrial-steam/zhengqi_test.txt&quot;</span>) <span class="hljs-keyword">as</span> fr_test:<br>    data_test=pd.read_table(fr_test,sep=<span class="hljs-string">&quot;\t&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#merge train_set and test_set</span><br>data_train[<span class="hljs-string">&quot;oringin&quot;</span>]=<span class="hljs-string">&quot;train&quot;</span><br>data_test[<span class="hljs-string">&quot;oringin&quot;</span>]=<span class="hljs-string">&quot;test&quot;</span><br>data_all=pd.concat([data_train,data_test],axis=<span class="hljs-number">0</span>,ignore_index=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">#View data</span><br>data_all.head()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Explore feature distibution </span><br><span class="hljs-comment">#fig = plt.figure(figsize=(6, 6))</span><br><span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> data_all.columns[<span class="hljs-number">0</span>:-<span class="hljs-number">2</span>]:<br>    g = sns.kdeplot(data_all[column][(data_all[<span class="hljs-string">&quot;oringin&quot;</span>] == <span class="hljs-string">&quot;train&quot;</span>)], color=<span class="hljs-string">&quot;Red&quot;</span>, shade = <span class="hljs-literal">True</span>)<br>    g = sns.kdeplot(data_all[column][(data_all[<span class="hljs-string">&quot;oringin&quot;</span>] == <span class="hljs-string">&quot;test&quot;</span>)], ax =g, color=<span class="hljs-string">&quot;Blue&quot;</span>, shade= <span class="hljs-literal">True</span>)<br>    g.set_xlabel(column)<br>    g.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    g = g.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br>    plt.show()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">fig = plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data_all.columns)-<span class="hljs-number">2</span>):<br>    g = sns.FacetGrid(data_all, col=<span class="hljs-string">&#x27;oringin&#x27;</span>)<br>    g = g.<span class="hljs-built_in">map</span>(sns.distplot, data_all.columns[i])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#删除特征&quot;V5&quot;,&quot;V9&quot;,&quot;V11&quot;,&quot;V17&quot;,&quot;V22&quot;,&quot;V28&quot;，训练集和测试集分布不均</span><br><span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;V5&quot;</span>,<span class="hljs-string">&quot;V9&quot;</span>,<span class="hljs-string">&quot;V11&quot;</span>,<span class="hljs-string">&quot;V17&quot;</span>,<span class="hljs-string">&quot;V22&quot;</span>,<span class="hljs-string">&quot;V28&quot;</span>]:<br>    g = sns.kdeplot(data_all[column][(data_all[<span class="hljs-string">&quot;oringin&quot;</span>] == <span class="hljs-string">&quot;train&quot;</span>)], color=<span class="hljs-string">&quot;Red&quot;</span>, shade = <span class="hljs-literal">True</span>)<br>    g = sns.kdeplot(data_all[column][(data_all[<span class="hljs-string">&quot;oringin&quot;</span>] == <span class="hljs-string">&quot;test&quot;</span>)], ax =g, color=<span class="hljs-string">&quot;Blue&quot;</span>, shade= <span class="hljs-literal">True</span>)<br>    g.set_xlabel(column)<br>    g.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    g = g.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br>    plt.show()<br><br>data_all.drop([<span class="hljs-string">&quot;V5&quot;</span>,<span class="hljs-string">&quot;V9&quot;</span>,<span class="hljs-string">&quot;V11&quot;</span>,<span class="hljs-string">&quot;V17&quot;</span>,<span class="hljs-string">&quot;V22&quot;</span>,<span class="hljs-string">&quot;V28&quot;</span>],axis=<span class="hljs-number">1</span>,inplace=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># figure parameters</span><br>data_train1=data_all[data_all[<span class="hljs-string">&quot;oringin&quot;</span>]==<span class="hljs-string">&quot;train&quot;</span>].drop(<span class="hljs-string">&quot;oringin&quot;</span>,axis=<span class="hljs-number">1</span>)<br><br>fcols = <span class="hljs-number">2</span><br>frows = <span class="hljs-built_in">len</span>(data_train.columns)<br>plt.figure(figsize=(<span class="hljs-number">5</span>*fcols,<span class="hljs-number">4</span>*frows))<br><br>i=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> data_train1.columns:<br>    i+=<span class="hljs-number">1</span><br>    ax=plt.subplot(frows,fcols,i)<br>    sns.regplot(x=col, y=<span class="hljs-string">&#x27;target&#x27;</span>, data=data_train, ax=ax, <br>                scatter_kws=&#123;<span class="hljs-string">&#x27;marker&#x27;</span>:<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;alpha&#x27;</span>:<span class="hljs-number">0.3</span>&#125;,<br>                line_kws=&#123;<span class="hljs-string">&#x27;color&#x27;</span>:<span class="hljs-string">&#x27;k&#x27;</span>&#125;);<br>    plt.xlabel(col)<br>    plt.ylabel(<span class="hljs-string">&#x27;target&#x27;</span>)<br>    <br>    i+=<span class="hljs-number">1</span><br>    ax=plt.subplot(frows,fcols,i)<br>    sns.distplot(data_train[col].dropna() , fit=stats.norm)<br>    plt.xlabel(col)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找出相关程度</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">16</span>))  <span class="hljs-comment"># 指定绘图对象宽度和高度</span><br>colnm = data_train1.columns.tolist()  <span class="hljs-comment"># 列表头</span><br>mcorr = data_train1[colnm].corr(method=<span class="hljs-string">&quot;spearman&quot;</span>)  <span class="hljs-comment"># 相关系数矩阵，即给出了任意两个变量之间的相关系数</span><br>mask = np.zeros_like(mcorr, dtype=np.<span class="hljs-built_in">bool</span>)  <span class="hljs-comment"># 构造与mcorr同维数矩阵 为bool型</span><br>mask[np.triu_indices_from(mask)] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 角分线右侧为True</span><br>cmap = sns.diverging_palette(<span class="hljs-number">220</span>, <span class="hljs-number">10</span>, as_cmap=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 返回matplotlib colormap对象</span><br>g = sns.heatmap(mcorr, mask=mask, cmap=cmap, square=<span class="hljs-literal">True</span>, annot=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">&#x27;0.2f&#x27;</span>)  <span class="hljs-comment"># 热力图（看两两相似度）</span><br>plt.show()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Threshold for removing correlated variables</span><br>threshold = <span class="hljs-number">0.1</span><br><br><span class="hljs-comment"># Absolute value correlation matrix</span><br>corr_matrix = data_train1.corr().<span class="hljs-built_in">abs</span>()<br>drop_col=corr_matrix[corr_matrix[<span class="hljs-string">&quot;target&quot;</span>]&lt;threshold].index<br>data_all.drop(drop_col,axis=<span class="hljs-number">1</span>,inplace=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># normalise numeric columns</span><br>cols_numeric=<span class="hljs-built_in">list</span>(data_all.columns)<br>cols_numeric.remove(<span class="hljs-string">&quot;oringin&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">scale_minmax</span>(<span class="hljs-params">col</span>):<br>    <span class="hljs-keyword">return</span> (col-col.<span class="hljs-built_in">min</span>())/(col.<span class="hljs-built_in">max</span>()-col.<span class="hljs-built_in">min</span>())<br>scale_cols = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> cols_numeric <span class="hljs-keyword">if</span> col!=<span class="hljs-string">&#x27;target&#x27;</span>]<br>data_all[scale_cols] = data_all[scale_cols].apply(scale_minmax,axis=<span class="hljs-number">0</span>)<br>data_all[scale_cols].describe()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Check effect of Box-Cox transforms on distributions of continuous variables</span><br><br>fcols = <span class="hljs-number">6</span><br>frows = <span class="hljs-built_in">len</span>(cols_numeric)-<span class="hljs-number">1</span><br>plt.figure(figsize=(<span class="hljs-number">4</span>*fcols,<span class="hljs-number">4</span>*frows))<br>i=<span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> cols_numeric:<br>    <span class="hljs-keyword">if</span> var!=<span class="hljs-string">&#x27;target&#x27;</span>:<br>        dat = data_all[[var, <span class="hljs-string">&#x27;target&#x27;</span>]].dropna()<br>        <br>        i+=<span class="hljs-number">1</span><br>        plt.subplot(frows,fcols,i)<br>        sns.distplot(dat[var] , fit=stats.norm);<br>        plt.title(var+<span class="hljs-string">&#x27; Original&#x27;</span>)<br>        plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>        i+=<span class="hljs-number">1</span><br>        plt.subplot(frows,fcols,i)<br>        _=stats.probplot(dat[var], plot=plt)<br>        plt.title(<span class="hljs-string">&#x27;skew=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stats.skew(dat[var])))<br>        plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        plt.ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>        i+=<span class="hljs-number">1</span><br>        plt.subplot(frows,fcols,i)<br>        plt.plot(dat[var], dat[<span class="hljs-string">&#x27;target&#x27;</span>],<span class="hljs-string">&#x27;.&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>        plt.title(<span class="hljs-string">&#x27;corr=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(dat[var], dat[<span class="hljs-string">&#x27;target&#x27;</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))<br> <br>        i+=<span class="hljs-number">1</span><br>        plt.subplot(frows,fcols,i)<br>        trans_var, lambda_var = stats.boxcox(dat[var].dropna()+<span class="hljs-number">1</span>)<br>        trans_var = scale_minmax(trans_var)      <br>        sns.distplot(trans_var , fit=stats.norm);<br>        plt.title(var+<span class="hljs-string">&#x27; Tramsformed&#x27;</span>)<br>        plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>        i+=<span class="hljs-number">1</span><br>        plt.subplot(frows,fcols,i)<br>        _=stats.probplot(trans_var, plot=plt)<br>        plt.title(<span class="hljs-string">&#x27;skew=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stats.skew(trans_var)))<br>        plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        plt.ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>        i+=<span class="hljs-number">1</span><br>        plt.subplot(frows,fcols,i)<br>        plt.plot(trans_var, dat[<span class="hljs-string">&#x27;target&#x27;</span>],<span class="hljs-string">&#x27;.&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>        plt.title(<span class="hljs-string">&#x27;corr=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(trans_var,dat[<span class="hljs-string">&#x27;target&#x27;</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">cols_transform=data_all.columns[<span class="hljs-number">0</span>:-<span class="hljs-number">2</span>]<br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> cols_transform:   <br>    <span class="hljs-comment"># transform column</span><br>    data_all.loc[:,col], _ = stats.boxcox(data_all.loc[:,col]+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(data_all.target.describe())<br><br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>))<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>sns.distplot(data_all.target.dropna() , fit=stats.norm);<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>_=stats.probplot(data_all.target.dropna(), plot=plt)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Log Transform SalePrice to improve normality</span><br>sp = data_train.target<br>data_train.target1 =np.power(<span class="hljs-number">1.5</span>,sp)<br><span class="hljs-built_in">print</span>(data_train.target1.describe())<br><br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>))<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>sns.distplot(data_train.target1.dropna(),fit=stats.norm);<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>_=stats.probplot(data_train.target1.dropna(), plot=plt)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> data_all.columns[<span class="hljs-number">0</span>:-<span class="hljs-number">2</span>]:<br>    g = sns.kdeplot(data_all[column][(data_all[<span class="hljs-string">&quot;oringin&quot;</span>] == <span class="hljs-string">&quot;train&quot;</span>)], color=<span class="hljs-string">&quot;Red&quot;</span>, shade = <span class="hljs-literal">True</span>)<br>    g = sns.kdeplot(data_all[column][(data_all[<span class="hljs-string">&quot;oringin&quot;</span>] == <span class="hljs-string">&quot;test&quot;</span>)], ax =g, color=<span class="hljs-string">&quot;Blue&quot;</span>, shade= <span class="hljs-literal">True</span>)<br>    g.set_xlabel(column)<br>    g.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    g = g.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br>    plt.show()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># function to get training samples</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_training_data</span>():<br>    <span class="hljs-comment"># extract training samples</span><br>    <span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>    df_train = data_all[data_all[<span class="hljs-string">&quot;oringin&quot;</span>]==<span class="hljs-string">&quot;train&quot;</span>]<br>    df_train[<span class="hljs-string">&quot;label&quot;</span>]=data_train.target1<br>    <span class="hljs-comment"># split SalePrice and features</span><br>    y = df_train.target<br>    X = df_train.drop([<span class="hljs-string">&quot;oringin&quot;</span>,<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;label&quot;</span>],axis=<span class="hljs-number">1</span>)<br>    X_train,X_valid,y_train,y_valid=train_test_split(X,y,test_size=<span class="hljs-number">0.3</span>,random_state=<span class="hljs-number">100</span>)<br>    <span class="hljs-keyword">return</span> X_train,X_valid,y_train,y_valid<br><br><span class="hljs-comment"># extract test data (without SalePrice)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_test_data</span>():<br>    df_test = data_all[data_all[<span class="hljs-string">&quot;oringin&quot;</span>]==<span class="hljs-string">&quot;test&quot;</span>].reset_index(drop=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> df_test.drop([<span class="hljs-string">&quot;oringin&quot;</span>,<span class="hljs-string">&quot;target&quot;</span>],axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> make_scorer<br><span class="hljs-comment"># metric for evaluation</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rmse</span>(<span class="hljs-params">y_true, y_pred</span>):<br>    diff = y_pred - y_true<br>    sum_sq = <span class="hljs-built_in">sum</span>(diff**<span class="hljs-number">2</span>)    <br>    n = <span class="hljs-built_in">len</span>(y_pred)   <br>    <br>    <span class="hljs-keyword">return</span> np.sqrt(sum_sq/n)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mse</span>(<span class="hljs-params">y_ture,y_pred</span>):<br>    <span class="hljs-keyword">return</span> mean_squared_error(y_ture,y_pred)<br><br><span class="hljs-comment"># scorer to be used in sklearn model fitting</span><br>rmse_scorer = make_scorer(rmse, greater_is_better=<span class="hljs-literal">False</span>)<br>mse_scorer = make_scorer(mse, greater_is_better=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># function to detect outliers based on the predictions of a model</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_outliers</span>(<span class="hljs-params">model, X, y, sigma=<span class="hljs-number">3</span></span>):<br><br>    <span class="hljs-comment"># predict y values using model</span><br>    <span class="hljs-keyword">try</span>:<br>        y_pred = pd.Series(model.predict(X), index=y.index)<br>    <span class="hljs-comment"># if predicting fails, try fitting the model first</span><br>    <span class="hljs-keyword">except</span>:<br>        model.fit(X,y)<br>        y_pred = pd.Series(model.predict(X), index=y.index)<br>        <br>    <span class="hljs-comment"># calculate residuals between the model prediction and true y values</span><br>    resid = y - y_pred<br>    mean_resid = resid.mean()<br>    std_resid = resid.std()<br><br>    <span class="hljs-comment"># calculate z statistic, define outliers to be where |z|&gt;sigma</span><br>    z = (resid - mean_resid)/std_resid    <br>    outliers = z[<span class="hljs-built_in">abs</span>(z)&gt;sigma].index<br>    <br>    <span class="hljs-comment"># print and plot the results</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;R2=&#x27;</span>,model.score(X,y))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;rmse=&#x27;</span>,rmse(y, y_pred))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mse=&quot;</span>,mean_squared_error(y,y_pred))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;---------------------------------------&#x27;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;mean of residuals:&#x27;</span>,mean_resid)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;std of residuals:&#x27;</span>,std_resid)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;---------------------------------------&#x27;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(outliers),<span class="hljs-string">&#x27;outliers:&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(outliers.tolist())<br><br>    plt.figure(figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">5</span>))<br>    ax_131 = plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)<br>    plt.plot(y,y_pred,<span class="hljs-string">&#x27;.&#x27;</span>)<br>    plt.plot(y.loc[outliers],y_pred.loc[outliers],<span class="hljs-string">&#x27;ro&#x27;</span>)<br>    plt.legend([<span class="hljs-string">&#x27;Accepted&#x27;</span>,<span class="hljs-string">&#x27;Outlier&#x27;</span>])<br>    plt.xlabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;y_pred&#x27;</span>);<br><br>    ax_132=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br>    plt.plot(y,y-y_pred,<span class="hljs-string">&#x27;.&#x27;</span>)<br>    plt.plot(y.loc[outliers],y.loc[outliers]-y_pred.loc[outliers],<span class="hljs-string">&#x27;ro&#x27;</span>)<br>    plt.legend([<span class="hljs-string">&#x27;Accepted&#x27;</span>,<span class="hljs-string">&#x27;Outlier&#x27;</span>])<br>    plt.xlabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;y - y_pred&#x27;</span>);<br><br>    ax_133=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<br>    z.plot.hist(bins=<span class="hljs-number">50</span>,ax=ax_133)<br>    z.loc[outliers].plot.hist(color=<span class="hljs-string">&#x27;r&#x27;</span>,bins=<span class="hljs-number">50</span>,ax=ax_133)<br>    plt.legend([<span class="hljs-string">&#x27;Accepted&#x27;</span>,<span class="hljs-string">&#x27;Outlier&#x27;</span>])<br>    plt.xlabel(<span class="hljs-string">&#x27;z&#x27;</span>)<br>    <br>    plt.savefig(<span class="hljs-string">&#x27;outliers.png&#x27;</span>)<br>    <br>    <span class="hljs-keyword">return</span> outliers<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># get training data</span><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridge<br>X_train, X_valid,y_train,y_valid = get_training_data()<br>test=get_test_data()<br><br><span class="hljs-comment"># find and remove outliers using a Ridge model</span><br>outliers = find_outliers(Ridge(), X_train, y_train)<br><br><span class="hljs-comment"># permanently remove these outliers from the data</span><br><span class="hljs-comment">#df_train = data_all[data_all[&quot;oringin&quot;]==&quot;train&quot;]</span><br><span class="hljs-comment">#df_train[&quot;label&quot;]=data_train.target1</span><br><span class="hljs-comment">#df_train=df_train.drop(outliers)</span><br>X_outliers=X_train.loc[outliers]<br>y_outliers=y_train.loc[outliers]<br>X_t=X_train.drop(outliers)<br>y_t=y_train.drop(outliers)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_trainning_data_omitoutliers</span>():<br>    y1=y_t.copy()<br>    X1=X_t.copy()<br>    <span class="hljs-keyword">return</span> X1,y1<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_model</span>(<span class="hljs-params">model, param_grid=[], X=[], y=[], </span><br><span class="hljs-params">                splits=<span class="hljs-number">5</span>, repeats=<span class="hljs-number">5</span></span>):<br><br>    <span class="hljs-comment"># get unmodified training data, unless data to use already specified</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(y)==<span class="hljs-number">0</span>:<br>        X,y = get_trainning_data_omitoutliers()<br>        <span class="hljs-comment">#poly_trans=PolynomialFeatures(degree=2)</span><br>        <span class="hljs-comment">#X=poly_trans.fit_transform(X)</span><br>        <span class="hljs-comment">#X=MinMaxScaler().fit_transform(X)</span><br>    <br>    <span class="hljs-comment"># create cross-validation method</span><br>    rkfold = RepeatedKFold(n_splits=splits, n_repeats=repeats)<br>    <br>    <span class="hljs-comment"># perform a grid search if param_grid given</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(param_grid)&gt;<span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># setup grid search parameters</span><br>        gsearch = GridSearchCV(model, param_grid, cv=rkfold,<br>                               scoring=<span class="hljs-string">&quot;neg_mean_squared_error&quot;</span>,<br>                               verbose=<span class="hljs-number">1</span>, return_train_score=<span class="hljs-literal">True</span>)<br><br>        <span class="hljs-comment"># search the grid</span><br>        gsearch.fit(X,y)<br><br>        <span class="hljs-comment"># extract best model from the grid</span><br>        model = gsearch.best_estimator_        <br>        best_idx = gsearch.best_index_<br><br>        <span class="hljs-comment"># get cv-scores for best model</span><br>        grid_results = pd.DataFrame(gsearch.cv_results_)       <br>        cv_mean = <span class="hljs-built_in">abs</span>(grid_results.loc[best_idx,<span class="hljs-string">&#x27;mean_test_score&#x27;</span>])<br>        cv_std = grid_results.loc[best_idx,<span class="hljs-string">&#x27;std_test_score&#x27;</span>]<br><br>    <span class="hljs-comment"># no grid search, just cross-val score for given model    </span><br>    <span class="hljs-keyword">else</span>:<br>        grid_results = []<br>        cv_results = cross_val_score(model, X, y, scoring=<span class="hljs-string">&quot;neg_mean_squared_error&quot;</span>, cv=rkfold)<br>        cv_mean = <span class="hljs-built_in">abs</span>(np.mean(cv_results))<br>        cv_std = np.std(cv_results)<br>    <br>    <span class="hljs-comment"># combine mean and std cv-score in to a pandas series</span><br>    cv_score = pd.Series(&#123;<span class="hljs-string">&#x27;mean&#x27;</span>:cv_mean,<span class="hljs-string">&#x27;std&#x27;</span>:cv_std&#125;)<br><br>    <span class="hljs-comment"># predict y using the fitted model</span><br>    y_pred = model.predict(X)<br>    <br>    <span class="hljs-comment"># print stats on model performance         </span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;----------------------&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(model)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;----------------------&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;score=&#x27;</span>,model.score(X,y))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;rmse=&#x27;</span>,rmse(y, y_pred))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;mse=&#x27;</span>,mse(y, y_pred))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;cross_val: mean=&#x27;</span>,cv_mean,<span class="hljs-string">&#x27;, std=&#x27;</span>,cv_std)<br>    <br>    <span class="hljs-comment"># residual plots</span><br>    y_pred = pd.Series(y_pred,index=y.index)<br>    resid = y - y_pred<br>    mean_resid = resid.mean()<br>    std_resid = resid.std()<br>    z = (resid - mean_resid)/std_resid    <br>    n_outliers = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">abs</span>(z)&gt;<span class="hljs-number">3</span>)<br>    <br>    plt.figure(figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">5</span>))<br>    ax_131 = plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)<br>    plt.plot(y,y_pred,<span class="hljs-string">&#x27;.&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;y_pred&#x27;</span>);<br>    plt.title(<span class="hljs-string">&#x27;corr = &#123;:.3f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(y,y_pred)[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))<br>    ax_132=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br>    plt.plot(y,y-y_pred,<span class="hljs-string">&#x27;.&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;y - y_pred&#x27;</span>);<br>    plt.title(<span class="hljs-string">&#x27;std resid = &#123;:.3f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(std_resid))<br>    <br>    ax_133=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<br>    z.plot.hist(bins=<span class="hljs-number">50</span>,ax=ax_133)<br>    plt.xlabel(<span class="hljs-string">&#x27;z&#x27;</span>)<br>    plt.title(<span class="hljs-string">&#x27;&#123;:.0f&#125; samples with z&gt;3&#x27;</span>.<span class="hljs-built_in">format</span>(n_outliers))<br><br>    <span class="hljs-keyword">return</span> model, cv_score, grid_results<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># places to store optimal models and scores</span><br>opt_models = <span class="hljs-built_in">dict</span>()<br>score_models = pd.DataFrame(columns=[<span class="hljs-string">&#x27;mean&#x27;</span>,<span class="hljs-string">&#x27;std&#x27;</span>])<br><br><span class="hljs-comment"># no. k-fold splits</span><br>splits=<span class="hljs-number">5</span><br><span class="hljs-comment"># no. k-fold iterations</span><br>repeats=<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;Ridge&#x27;</span><br><br>opt_models[model] = Ridge()<br>alph_range = np.arange(<span class="hljs-number">0.25</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0.25</span>)<br>param_grid = &#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: alph_range&#125;<br><br>opt_models[model],cv_score,grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=repeats)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br><br>plt.figure()<br>plt.errorbar(alph_range, <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;mean_test_score&#x27;</span>]),<br>             <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;std_test_score&#x27;</span>])/np.sqrt(splits*repeats))<br>plt.xlabel(<span class="hljs-string">&#x27;alpha&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;score&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;Lasso&#x27;</span><br><br>opt_models[model] = Lasso()<br>alph_range = np.arange(<span class="hljs-number">1e-4</span>,<span class="hljs-number">1e-3</span>,<span class="hljs-number">4e-5</span>)<br>param_grid = &#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: alph_range&#125;<br><br>opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=repeats)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br><br>plt.figure()<br>plt.errorbar(alph_range, <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;mean_test_score&#x27;</span>]),<span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;std_test_score&#x27;</span>])/np.sqrt(splits*repeats))<br>plt.xlabel(<span class="hljs-string">&#x27;alpha&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;score&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model =<span class="hljs-string">&#x27;ElasticNet&#x27;</span><br>opt_models[model] = ElasticNet()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: np.arange(<span class="hljs-number">1e-4</span>,<span class="hljs-number">1e-3</span>,<span class="hljs-number">1e-4</span>),<br>              <span class="hljs-string">&#x27;l1_ratio&#x27;</span>: np.arange(<span class="hljs-number">0.1</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">0.1</span>),<br>              <span class="hljs-string">&#x27;max_iter&#x27;</span>:[<span class="hljs-number">100000</span>]&#125;<br><br>opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">model=<span class="hljs-string">&#x27;LinearSVR&#x27;</span><br>opt_models[model] = LinearSVR()<br><br>crange = np.arange(<span class="hljs-number">0.1</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">0.1</span>)<br>param_grid = &#123;<span class="hljs-string">&#x27;C&#x27;</span>:crange,<br>             <span class="hljs-string">&#x27;max_iter&#x27;</span>:[<span class="hljs-number">1000</span>]&#125;<br><br>opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=repeats)<br><br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br><br>plt.figure()<br>plt.errorbar(crange, <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;mean_test_score&#x27;</span>]),<span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;std_test_score&#x27;</span>])/np.sqrt(splits*repeats))<br>plt.xlabel(<span class="hljs-string">&#x27;C&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;score&#x27;</span>)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;KNeighbors&#x27;</span><br>opt_models[model] = KNeighborsRegressor()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;n_neighbors&#x27;</span>:np.arange(<span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>)&#125;<br><br>opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br><br>plt.figure()<br>plt.errorbar(np.arange(<span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>), <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;mean_test_score&#x27;</span>]),<span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;std_test_score&#x27;</span>])/np.sqrt(splits*<span class="hljs-number">1</span>))<br>plt.xlabel(<span class="hljs-string">&#x27;n_neighbors&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;score&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;GradientBoosting&#x27;</span><br>opt_models[model] = GradientBoostingRegressor()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;n_estimators&#x27;</span>:[<span class="hljs-number">150</span>,<span class="hljs-number">250</span>,<span class="hljs-number">350</span>],<br>              <span class="hljs-string">&#x27;max_depth&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>              <span class="hljs-string">&#x27;min_samples_split&#x27;</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]&#125;<br><br>opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;XGB&#x27;</span><br>opt_models[model] = XGBRegressor()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;n_estimators&#x27;</span>:[<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">500</span>],<br>              <span class="hljs-string">&#x27;max_depth&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>             &#125;<br><br>opt_models[model], cv_score,grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;RandomForest&#x27;</span><br>opt_models[model] = RandomForestRegressor()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;n_estimators&#x27;</span>:[<span class="hljs-number">100</span>,<span class="hljs-number">150</span>,<span class="hljs-number">200</span>],<br>              <span class="hljs-string">&#x27;max_features&#x27;</span>:[<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span>,<span class="hljs-number">20</span>,<span class="hljs-number">24</span>],<br>              <span class="hljs-string">&#x27;min_samples_split&#x27;</span>:[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]&#125;<br><br>opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=<span class="hljs-number">5</span>, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">model_predict</span>(<span class="hljs-params">test_data,test_y=[],stack=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-comment">#poly_trans=PolynomialFeatures(degree=2)</span><br>    <span class="hljs-comment">#test_data1=poly_trans.fit_transform(test_data)</span><br>    <span class="hljs-comment">#test_data=MinMaxScaler().fit_transform(test_data)</span><br>    i=<span class="hljs-number">0</span><br>    y_predict_total=np.zeros((test_data.shape[<span class="hljs-number">0</span>],))<br>    <span class="hljs-keyword">if</span> stack:<br>        <span class="hljs-keyword">for</span> model <span class="hljs-keyword">in</span> metal_models.keys():<br>            y_predict=metal_models[model].predict(test_data)<br>            y_predict_total+=y_predict<br>            i+=<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(test_y)&gt;<span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;_mse:&quot;</span>.<span class="hljs-built_in">format</span>(model),mean_squared_error(y_predict,test_y))<br>        y_predict_mean=np.<span class="hljs-built_in">round</span>(y_predict_total/i,<span class="hljs-number">3</span>)  <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(test_y)&gt;<span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mean_mse:&quot;</span>,mean_squared_error(y_predict_mean,test_y))<br>        <span class="hljs-keyword">else</span>:<br>            y_metal_mean=pd.Series(y_predict_mean)<br>            <span class="hljs-keyword">return</span> y_metal_mean <br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> model <span class="hljs-keyword">in</span> opt_models.keys():<br>            <span class="hljs-keyword">if</span> model!=<span class="hljs-string">&quot;LinearSVR&quot;</span> <span class="hljs-keyword">and</span> model!=<span class="hljs-string">&quot;KNeighbors&quot;</span>:<br>                y_predict=opt_models[model].predict(test_data)<br>                y_predict_total+=y_predict<br>                i+=<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(test_y)&gt;<span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;_mse:&quot;</span>.<span class="hljs-built_in">format</span>(model),mean_squared_error(y_predict,test_y))<br>        y_predict_mean=np.<span class="hljs-built_in">round</span>(y_predict_total/i,<span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(test_y)&gt;<span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mean_mse:&quot;</span>,mean_squared_error(y_predict_mean,test_y))<br>        <span class="hljs-keyword">else</span>:<br>            y_predict_mean=pd.Series(y_predict_mean)<br>            <span class="hljs-keyword">return</span> y_predict_mean<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model_predict(X_valid,y_valid)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_stack_features</span>(<span class="hljs-params">test_data</span>):<br>    features=&#123;&#125;<br>    columns=[]<br>    <span class="hljs-keyword">for</span> model <span class="hljs-keyword">in</span> opt_models.keys():<br>        columns.append(model)<br>        features[model]=opt_models[model].predict(test_data)<br>    stack_feature=pd.DataFrame(features,columns=columns)<br>    <span class="hljs-keyword">return</span> stack_feature<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#load metal data</span><br>metal_x_train=create_stack_features(X_t)<br>metal_y_train=pd.Series(y_t.values)<br>metal_x_valid=create_stack_features(X_valid)<br>metal_y_valid=pd.Series(y_valid.values)<br>metal_x_test=create_stack_features(test)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># places to store metal models and scores</span><br>metal_models = <span class="hljs-built_in">dict</span>()<br>score_models = pd.DataFrame(columns=[<span class="hljs-string">&#x27;mean&#x27;</span>,<span class="hljs-string">&#x27;std&#x27;</span>])<br><br><span class="hljs-comment"># no. k-fold splits</span><br>splits=<span class="hljs-number">5</span><br><span class="hljs-comment"># no. k-fold iterations</span><br>repeats=<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;Ridge&#x27;</span><br><br>metal_models[model] = Ridge()<br>alph_range = np.arange(<span class="hljs-number">0.25</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0.25</span>)<br>param_grid = &#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: alph_range&#125;<br><br>metal_models[model],cv_score,grid_results = train_model(metal_models[model], param_grid=param_grid, X=metal_x_train,y=metal_y_train,<br>                                              splits=splits, repeats=repeats)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br><br>plt.figure()<br>plt.errorbar(alph_range, <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;mean_test_score&#x27;</span>]),<br>             <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;std_test_score&#x27;</span>])/np.sqrt(splits*repeats))<br>plt.xlabel(<span class="hljs-string">&#x27;alpha&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;score&#x27;</span>)<br></code></pre></td></tr></table></figure><p>若报错：AttributeError: 'DataFrame' object has no attribute 'append'</p><p>解决方案：</p><p>pandas版本较新，新版本将append改为了_append</p><p><code>dataframe = dataframe._append()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;Lasso&#x27;</span><br><br>metal_models[model] = Lasso()<br>alph_range = np.arange(<span class="hljs-number">1e-4</span>,<span class="hljs-number">1e-3</span>,<span class="hljs-number">4e-5</span>)<br>param_grid = &#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: alph_range&#125;<br><br>metal_models[model], cv_score, grid_results = train_model(metal_models[model], param_grid=param_grid, X=metal_x_train,y=metal_y_train,<br>                                              splits=splits, repeats=repeats)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br><br>plt.figure()<br>plt.errorbar(alph_range, <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;mean_test_score&#x27;</span>]),<span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;std_test_score&#x27;</span>])/np.sqrt(splits*repeats))<br>plt.xlabel(<span class="hljs-string">&#x27;alpha&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;score&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model =<span class="hljs-string">&#x27;ElasticNet&#x27;</span><br>metal_models[model] = ElasticNet()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: np.arange(<span class="hljs-number">1e-4</span>,<span class="hljs-number">1e-3</span>,<span class="hljs-number">1e-4</span>),<br>              <span class="hljs-string">&#x27;l1_ratio&#x27;</span>: np.arange(<span class="hljs-number">0.1</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">0.1</span>),<br>              <span class="hljs-string">&#x27;max_iter&#x27;</span>:[<span class="hljs-number">100000</span>]&#125;<br><br>metal_models[model], cv_score, grid_results = train_model(metal_models[model], param_grid=param_grid, X=metal_x_train,y=metal_y_train,<br>                                              splits=splits, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;XGB&#x27;</span><br>metal_models[model] = XGBRegressor()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;n_estimators&#x27;</span>:[<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">500</span>],<br>              <span class="hljs-string">&#x27;max_depth&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>             &#125;<br><br>metal_models[model], cv_score,grid_results = train_model(metal_models[model], param_grid=param_grid, X=metal_x_train,y=metal_train_y_train,<br>                                              splits=splits, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;GradientBoosting&#x27;</span><br>metal_models[model] = GradientBoostingRegressor()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;n_estimators&#x27;</span>:[<span class="hljs-number">150</span>,<span class="hljs-number">250</span>,<span class="hljs-number">350</span>],<br>              <span class="hljs-string">&#x27;max_depth&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>              <span class="hljs-string">&#x27;min_samples_split&#x27;</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]&#125;<br><br>metal_models[model], cv_score, grid_results = train_model(metal_models[model], param_grid=param_grid, X=metal_x_train,y=metal_y_train,<br>                                              splits=splits, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;RandomForest&#x27;</span><br>metal_models[model] = RandomForestRegressor()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;n_estimators&#x27;</span>:[<span class="hljs-number">100</span>,<span class="hljs-number">150</span>,<span class="hljs-number">200</span>],<br>              <span class="hljs-string">&#x27;max_features&#x27;</span>:[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],<br>              <span class="hljs-string">&#x27;min_samples_split&#x27;</span>:[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]&#125;<br><br>metal_models[model], cv_score, grid_results = train_model(metal_models[model], param_grid=param_grid,  X=metal_x_train,y=metal_y_train,<br>                                              splits=<span class="hljs-number">5</span>, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model_predict(metal_x_valid,metal_y_valid,stack=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习实战入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工业蒸汽预测-07模型融合</title>
    <link href="/2023/09/19/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-07%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88/"/>
    <url>/2023/09/19/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-07%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="基础步骤">1 基础步骤</h1><h2 id="导包">1.1 导包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.rcParams.update(&#123;<span class="hljs-string">&#x27;figure.max_open_warning&#x27;</span>: <span class="hljs-number">0</span>&#125;)<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><br><span class="hljs-comment"># modelling</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV, RepeatedKFold, cross_val_score,cross_val_predict,KFold<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> make_scorer,mean_squared_error<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression, Lasso, Ridge, ElasticNet<br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> LinearSVR, SVR<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor, GradientBoostingRegressor,AdaBoostRegressor<br><span class="hljs-keyword">from</span> xgboost <span class="hljs-keyword">import</span> XGBRegressor<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> PolynomialFeatures,MinMaxScaler,StandardScaler<br></code></pre></td></tr></table></figure><h2 id="导入数据">1.2 导入数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#load_dataset</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./data/zhengqi_train.txt&quot;</span>)  <span class="hljs-keyword">as</span> fr:<br>    data_train=pd.read_table(fr,sep=<span class="hljs-string">&quot;\t&quot;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./data/zhengqi_test.txt&quot;</span>) <span class="hljs-keyword">as</span> fr_test:<br>    data_test=pd.read_table(fr_test,sep=<span class="hljs-string">&quot;\t&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="合并数据">1.3 合并数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#merge train_set and test_set</span><br>data_train[<span class="hljs-string">&quot;oringin&quot;</span>]=<span class="hljs-string">&quot;train&quot;</span><br>data_test[<span class="hljs-string">&quot;oringin&quot;</span>]=<span class="hljs-string">&quot;test&quot;</span><br>data_all=pd.concat([data_train,data_test],axis=<span class="hljs-number">0</span>,ignore_index=<span class="hljs-literal">True</span>)<br>data_all<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th><th>oringin</th></tr></thead><tbody><tr><th>0</th><td>0.566</td><td>0.016</td><td>-0.143</td><td>0.407</td><td>0.452</td><td>-0.901</td><td>-1.812</td><td>-2.360</td><td>-0.436</td><td>-2.114</td><td>...</td><td>0.109</td><td>-0.615</td><td>0.327</td><td>-4.627</td><td>-4.789</td><td>-5.101</td><td>-2.608</td><td>-3.508</td><td>0.175</td><td>train</td></tr><tr><th>1</th><td>0.968</td><td>0.437</td><td>0.066</td><td>0.566</td><td>0.194</td><td>-0.893</td><td>-1.566</td><td>-2.360</td><td>0.332</td><td>-2.114</td><td>...</td><td>0.124</td><td>0.032</td><td>0.600</td><td>-0.843</td><td>0.160</td><td>0.364</td><td>-0.335</td><td>-0.730</td><td>0.676</td><td>train</td></tr><tr><th>2</th><td>1.013</td><td>0.568</td><td>0.235</td><td>0.370</td><td>0.112</td><td>-0.797</td><td>-1.367</td><td>-2.360</td><td>0.396</td><td>-2.114</td><td>...</td><td>0.361</td><td>0.277</td><td>-0.116</td><td>-0.843</td><td>0.160</td><td>0.364</td><td>0.765</td><td>-0.589</td><td>0.633</td><td>train</td></tr><tr><th>3</th><td>0.733</td><td>0.368</td><td>0.283</td><td>0.165</td><td>0.599</td><td>-0.679</td><td>-1.200</td><td>-2.086</td><td>0.403</td><td>-2.114</td><td>...</td><td>0.417</td><td>0.279</td><td>0.603</td><td>-0.843</td><td>-0.065</td><td>0.364</td><td>0.333</td><td>-0.112</td><td>0.206</td><td>train</td></tr><tr><th>4</th><td>0.684</td><td>0.638</td><td>0.260</td><td>0.209</td><td>0.337</td><td>-0.454</td><td>-1.073</td><td>-2.086</td><td>0.314</td><td>-2.114</td><td>...</td><td>1.078</td><td>0.328</td><td>0.418</td><td>-0.843</td><td>-0.215</td><td>0.364</td><td>-0.280</td><td>-0.028</td><td>0.384</td><td>train</td></tr><tr><th>...</th><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr><th>4808</th><td>-1.362</td><td>-1.553</td><td>-3.096</td><td>-0.444</td><td>0.381</td><td>1.375</td><td>-4.854</td><td>-5.331</td><td>-4.074</td><td>-3.838</td><td>...</td><td>-4.488</td><td>-5.793</td><td>-4.050</td><td>-1.187</td><td>-0.852</td><td>-2.131</td><td>-2.564</td><td>0.597</td><td>NaN</td><td>test</td></tr><tr><th>4809</th><td>-2.698</td><td>-3.452</td><td>-3.620</td><td>-1.066</td><td>-1.385</td><td>1.378</td><td>-4.927</td><td>-5.103</td><td>-4.393</td><td>-1.683</td><td>...</td><td>-0.613</td><td>-7.698</td><td>-0.674</td><td>-1.187</td><td>-0.852</td><td>-2.131</td><td>-2.564</td><td>1.215</td><td>NaN</td><td>test</td></tr><tr><th>4810</th><td>-2.615</td><td>-3.564</td><td>-3.402</td><td>-0.422</td><td>-1.272</td><td>1.121</td><td>-4.223</td><td>-4.315</td><td>-5.196</td><td>-3.407</td><td>...</td><td>0.125</td><td>-6.111</td><td>0.275</td><td>-1.851</td><td>-1.548</td><td>-1.537</td><td>-2.544</td><td>1.612</td><td>NaN</td><td>test</td></tr><tr><th>4811</th><td>-2.661</td><td>-3.646</td><td>-3.271</td><td>-0.699</td><td>-1.270</td><td>1.116</td><td>-3.716</td><td>-3.809</td><td>-4.735</td><td>-2.976</td><td>...</td><td>1.086</td><td>-5.268</td><td>0.683</td><td>-1.645</td><td>-1.471</td><td>-1.537</td><td>-2.549</td><td>1.431</td><td>NaN</td><td>test</td></tr><tr><th>4812</th><td>-2.321</td><td>-3.037</td><td>-3.214</td><td>-1.594</td><td>-0.910</td><td>1.259</td><td>-3.616</td><td>-3.747</td><td>-4.368</td><td>-2.976</td><td>...</td><td>-0.774</td><td>-5.211</td><td>1.618</td><td>-1.703</td><td>-1.471</td><td>-1.537</td><td>-1.123</td><td>1.988</td><td>NaN</td><td>test</td></tr></tbody></table><p>4813 rows × 40 columns</p></div><h2 id="删除相关特征">1.4 删除相关特征</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">data_all.drop([<span class="hljs-string">&quot;V5&quot;</span>,<span class="hljs-string">&quot;V9&quot;</span>,<span class="hljs-string">&quot;V11&quot;</span>,<span class="hljs-string">&quot;V17&quot;</span>,<span class="hljs-string">&quot;V22&quot;</span>,<span class="hljs-string">&quot;V28&quot;</span>],axis=<span class="hljs-number">1</span>,inplace=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h2 id="数据归一化">1.5 数据归一化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># normalise numeric columns</span><br>cols_numeric=<span class="hljs-built_in">list</span>(data_all.columns)<br>cols_numeric.remove(<span class="hljs-string">&quot;oringin&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">scale_minmax</span>(<span class="hljs-params">col</span>):<br>    <span class="hljs-keyword">return</span> (col-col.<span class="hljs-built_in">min</span>())/(col.<span class="hljs-built_in">max</span>()-col.<span class="hljs-built_in">min</span>())<br>scale_cols = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> cols_numeric <span class="hljs-keyword">if</span> col!=<span class="hljs-string">&#x27;target&#x27;</span>]<br>data_all[scale_cols] = data_all[scale_cols].apply(scale_minmax,axis=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="画图探查特征和标签相关信息">1.6 画图：探查特征和标签相关信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Check effect of Box-Cox transforms on distributions of continuous variables</span><br><br>fcols = <span class="hljs-number">6</span><br>frows = <span class="hljs-built_in">len</span>(cols_numeric)-<span class="hljs-number">1</span><br>plt.figure(figsize=(<span class="hljs-number">4</span>*fcols,<span class="hljs-number">4</span>*frows))<br>i=<span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> cols_numeric:<br>    <span class="hljs-keyword">if</span> var!=<span class="hljs-string">&#x27;target&#x27;</span>:<br>        dat = data_all[[var, <span class="hljs-string">&#x27;target&#x27;</span>]].dropna() <span class="hljs-comment"># 获取var列和target列。双重方括号[[  ]]用于选择多个列。</span><br>        <br>        i+=<span class="hljs-number">1</span><br>        plt.subplot(frows,fcols,i)<br>        sns.distplot(dat[var] , fit=stats.norm);<br>        plt.title(var+<span class="hljs-string">&#x27; Original&#x27;</span>)<br>        plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>        i+=<span class="hljs-number">1</span><br>        plt.subplot(frows,fcols,i)<br>        _=stats.probplot(dat[var], plot=plt)<br>        plt.title(<span class="hljs-string">&#x27;skew=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stats.skew(dat[var])))<br>        plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        plt.ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>        i+=<span class="hljs-number">1</span><br>        plt.subplot(frows,fcols,i)<br>        plt.plot(dat[var], dat[<span class="hljs-string">&#x27;target&#x27;</span>],<span class="hljs-string">&#x27;.&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>        plt.title(<span class="hljs-string">&#x27;corr=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(dat[var], dat[<span class="hljs-string">&#x27;target&#x27;</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))<br> <br>        i+=<span class="hljs-number">1</span><br>        plt.subplot(frows,fcols,i)<br>        trans_var, lambda_var = stats.boxcox(dat[var].dropna()+<span class="hljs-number">1</span>)<br>        trans_var = scale_minmax(trans_var)      <br>        sns.distplot(trans_var , fit=stats.norm);<br>        plt.title(var+<span class="hljs-string">&#x27; Tramsformed&#x27;</span>)<br>        plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>        i+=<span class="hljs-number">1</span><br>        plt.subplot(frows,fcols,i)<br>        _=stats.probplot(trans_var, plot=plt)<br>        plt.title(<span class="hljs-string">&#x27;skew=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stats.skew(trans_var)))<br>        plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        plt.ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>        i+=<span class="hljs-number">1</span><br>        plt.subplot(frows,fcols,i)<br>        plt.plot(trans_var, dat[<span class="hljs-string">&#x27;target&#x27;</span>],<span class="hljs-string">&#x27;.&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>        plt.title(<span class="hljs-string">&#x27;corr=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(trans_var,dat[<span class="hljs-string">&#x27;target&#x27;</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><p><img src="/img/工业蒸汽预测-07模型融合/output_11_0.png" /></p><h2 id="box-cox变换">1.7 Box-Cox变换</h2><p>对特征进行Box-Cox变换，使其满足正态性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">cols_transform=data_all.columns[<span class="hljs-number">0</span>:-<span class="hljs-number">2</span>]<br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> cols_transform:   <br>    <span class="hljs-comment"># transform column</span><br>    data_all.loc[:,col], _ = stats.boxcox(data_all.loc[:,col]+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="代码解释">代码解释</h4><ol type="1"><li><p><code>cols_transform = data_all.columns[0:-2]</code>：获取<code>data_all</code>数据集中的所有列名，并使用切片操作<code>[0:-2]</code>选择从第一列到倒数第三列的所有列。</p></li><li><p><code>data_all.loc[:, col], _ = stats.boxcox(data_all.loc[:, col] + 1)</code>：应用了Box-Cox变换来转换指定的列<code>col</code>。<code>data_all.loc[:, col]</code>用于选择DataFrame中的特定列。<code>stats.boxcox()</code>接受一个一维数组作为输入，并返回Box-Cox变换后的结果和变换参数。在这里，原始列的值会先加1（避免零值），然后应用Box-Cox变换。转换后的结果会更新到<code>data_all</code>中的相应列，而下划线<code>_</code>表示不需要使用的变换参数则被忽略。</p></li></ol><h2 id="分位数计算和绘图">1.8 分位数计算和绘图</h2><p>标签数据统计转换后的数据，计算分位数画图展示（基于正态分布）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(data_all.target.describe())<br><br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>))<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>sns.distplot(data_all.target.dropna() , fit=stats.norm);<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>_=stats.probplot(data_all.target.dropna(), plot=plt)<br></code></pre></td></tr></table></figure><pre><code class="hljs">count    2888.000000mean        0.126353std         0.983966min        -3.04400025%        -0.35025050%         0.31300075%         0.793250max         2.538000Name: target, dtype: float64</code></pre><p><img src="/img/工业蒸汽预测-07模型融合/output_17_1-169517575505519.png" /></p><h2 id="标签数据对数变换">1.9 标签数据对数变换</h2><p>标签数据对数变换数据，使数据更符合正态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Log Transform SalePrice to improve normality</span><br>sp = data_train.target<br>data_train.target1 =np.power(<span class="hljs-number">1.5</span>,sp)<br><span class="hljs-built_in">print</span>(data_train.target1.describe())<br><br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>))<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>sns.distplot(data_train.target1.dropna(),fit=stats.norm);<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>_=stats.probplot(data_train.target1.dropna(), plot=plt)<br></code></pre></td></tr></table></figure><pre><code class="hljs">count    2888.000000mean        1.129957std         0.394110min         0.29105725%         0.86760950%         1.13531575%         1.379382max         2.798463Name: target, dtype: float64</code></pre><p><img src="/img/工业蒸汽预测-07模型融合/output_19_1-169517575505520.png" /></p><h4 id="代码解释-1">代码解释</h4><ol type="1"><li><p><code>sp = data_train.target</code>：将<code>data_train</code>中的目标变量列赋值给变量<code>sp</code>。</p></li><li><p><code>data_train.target1 = np.power(1.5, sp)</code>：将对数变换应用于目标变量<code>sp</code>，使用了<code>np.power()</code>函数来计算1.5的<code>sp</code>次方，也就是对目标变量进行了一个指数转换。转换后的结果存储在<code>data_train</code>数据集中一个名为<code>target1</code>的新列中。</p></li><li><p><code>print(data_train.target1.describe())</code>：打印转换后的目标变量<code>target1</code>的描述统计信息，包括均值、标准差和分位数等。</p></li><li><p><code>plt.figure(figsize=(12,4))</code>：创建一个图形窗口，设置大小为（12,4）。</p></li><li><p><code>plt.subplot(1,2,1)</code>：在图形窗口中创建一个子图，总共有1行2列，当前子图位于第1个位置。</p></li><li><p><code>sns.distplot(data_train.target1.dropna(), fit=stats.norm)</code>：绘制直方图和核密度估计图，其中<code>data_train.target1.dropna()</code>是转换后的目标变量数据，<code>fit=stats.norm</code>表示通过正态分布拟合曲线来比较数据的分布情况。</p></li><li><p><code>plt.subplot(1,2,2)</code>：在图形窗口中创建一个子图，总共有1行2列，当前子图位于第2个位置。</p></li><li><p><code>_=stats.probplot(data_train.target1.dropna(), plot=plt)</code>：使用<code>stats.probplot()</code>函数绘制Q-Q图，用于检验数据是否服从正态分布。<code>data_train.target1.dropna()</code>是转换后的目标变量数据，<code>plot=plt</code>表示将Q-Q图绘制在指定的子图上。</p></li></ol><h1 id="获取训练和测试数据">2 获取训练和测试数据</h1><p>原先将训练集和测试集进行合并处理，现在进行拆分。使用简单交叉验证方法对模型进行验证，划为训练数据为70%，验证数据为30%</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># function to get training samples</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_training_data</span>():<br>    <span class="hljs-comment"># extract training samples</span><br>    <span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>    df_train = data_all[data_all[<span class="hljs-string">&quot;oringin&quot;</span>]==<span class="hljs-string">&quot;train&quot;</span>]<br>    df_train[<span class="hljs-string">&quot;label&quot;</span>]=data_train.target1<br>    <span class="hljs-comment"># split SalePrice and features</span><br>    y = df_train.target<br>    X = df_train.drop([<span class="hljs-string">&quot;oringin&quot;</span>,<span class="hljs-string">&quot;target&quot;</span>,<span class="hljs-string">&quot;label&quot;</span>],axis=<span class="hljs-number">1</span>)<br>    X_train,X_valid,y_train,y_valid=train_test_split(X,y,test_size=<span class="hljs-number">0.3</span>,random_state=<span class="hljs-number">100</span>)<br>    <span class="hljs-keyword">return</span> X_train,X_valid,y_train,y_valid<br><br><span class="hljs-comment"># extract test data (without SalePrice)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_test_data</span>():<br>    df_test = data_all[data_all[<span class="hljs-string">&quot;oringin&quot;</span>]==<span class="hljs-string">&quot;test&quot;</span>].reset_index(drop=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> df_test.drop([<span class="hljs-string">&quot;oringin&quot;</span>,<span class="hljs-string">&quot;target&quot;</span>],axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="模型评价函数">3 模型评价函数</h1><p>将RMSE和MSE作为模型性能的评价指标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> make_scorer<br><span class="hljs-comment"># metric for evaluation 自定义</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rmse</span>(<span class="hljs-params">y_true, y_pred</span>):<br>    diff = y_pred - y_true<br>    sum_sq = <span class="hljs-built_in">sum</span>(diff**<span class="hljs-number">2</span>)    <br>    n = <span class="hljs-built_in">len</span>(y_pred)   <br>    <span class="hljs-keyword">return</span> np.sqrt(sum_sq/n)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mse</span>(<span class="hljs-params">y_ture,y_pred</span>):<br>    <span class="hljs-keyword">return</span> mean_squared_error(y_ture,y_pred)<br><br><span class="hljs-comment"># scorer to be used in sklearn model fitting</span><br>rmse_scorer = make_scorer(rmse, greater_is_better=<span class="hljs-literal">False</span>) <span class="hljs-comment"># greater_is_better=False 意味着rmse越小越好</span><br>mse_scorer = make_scorer(mse, greater_is_better=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h1 id="处理异常数据">4 处理异常数据</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># function to detect outliers based on the predictions of a model</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_outliers</span>(<span class="hljs-params">model, X, y, sigma=<span class="hljs-number">3</span></span>):<br><br>    <span class="hljs-comment"># predict y values using model</span><br>    <span class="hljs-keyword">try</span>:<br>        y_pred = pd.Series(model.predict(X), index=y.index)<br>    <span class="hljs-comment"># if predicting fails, try fitting the model first</span><br>    <span class="hljs-keyword">except</span>:<br>        model.fit(X,y)<br>        y_pred = pd.Series(model.predict(X), index=y.index)<br>        <br>    <span class="hljs-comment"># calculate residuals between the model prediction and true y values</span><br>    resid = y - y_pred<br>    mean_resid = resid.mean()<br>    std_resid = resid.std()<br><br>    <span class="hljs-comment"># calculate z statistic, define outliers to be where |z|&gt;sigma</span><br>    z = (resid - mean_resid)/std_resid    <br>    outliers = z[<span class="hljs-built_in">abs</span>(z)&gt;sigma].index<br>    <br>    <span class="hljs-comment"># print and plot the results</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;R2=&#x27;</span>,model.score(X,y))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;rmse=&#x27;</span>,rmse(y, y_pred))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mse=&quot;</span>,mean_squared_error(y,y_pred))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;---------------------------------------&#x27;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;mean of residuals:&#x27;</span>,mean_resid)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;std of residuals:&#x27;</span>,std_resid)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;---------------------------------------&#x27;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(outliers),<span class="hljs-string">&#x27;outliers:&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(outliers.tolist())<br><br>    plt.figure(figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">5</span>))<br>    ax_131 = plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)<br>    plt.plot(y,y_pred,<span class="hljs-string">&#x27;.&#x27;</span>)<br>    plt.plot(y.loc[outliers],y_pred.loc[outliers],<span class="hljs-string">&#x27;ro&#x27;</span>)<br>    plt.legend([<span class="hljs-string">&#x27;Accepted&#x27;</span>,<span class="hljs-string">&#x27;Outlier&#x27;</span>])<br>    plt.xlabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;y_pred&#x27;</span>);<br><br>    ax_132=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br>    plt.plot(y,y-y_pred,<span class="hljs-string">&#x27;.&#x27;</span>)<br>    plt.plot(y.loc[outliers],y.loc[outliers]-y_pred.loc[outliers],<span class="hljs-string">&#x27;ro&#x27;</span>)<br>    plt.legend([<span class="hljs-string">&#x27;Accepted&#x27;</span>,<span class="hljs-string">&#x27;Outlier&#x27;</span>])<br>    plt.xlabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;y - y_pred&#x27;</span>);<br><br>    ax_133=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<br>    z.plot.hist(bins=<span class="hljs-number">50</span>,ax=ax_133)<br>    z.loc[outliers].plot.hist(color=<span class="hljs-string">&#x27;r&#x27;</span>,bins=<span class="hljs-number">50</span>,ax=ax_133)<br>    plt.legend([<span class="hljs-string">&#x27;Accepted&#x27;</span>,<span class="hljs-string">&#x27;Outlier&#x27;</span>])<br>    plt.xlabel(<span class="hljs-string">&#x27;z&#x27;</span>)<br>    <br>    plt.savefig(<span class="hljs-string">&#x27;outliers.png&#x27;</span>)<br>    <br>    <span class="hljs-keyword">return</span> outliers<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># get training data</span><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridge<br>X_train, X_valid,y_train,y_valid = get_training_data()<br>test=get_test_data()<br><br><span class="hljs-comment"># find and remove outliers using a Ridge model</span><br>outliers = find_outliers(Ridge(), X_train, y_train)<br><br><span class="hljs-comment"># permanently remove these outliers from the data</span><br><span class="hljs-comment">#df_train = data_all[data_all[&quot;oringin&quot;]==&quot;train&quot;]</span><br><span class="hljs-comment">#df_train[&quot;label&quot;]=data_train.target1</span><br><span class="hljs-comment">#df_train=df_train.drop(outliers)</span><br>X_outliers=X_train.loc[outliers]<br>y_outliers=y_train.loc[outliers]<br>X_t=X_train.drop(outliers)<br>y_t=y_train.drop(outliers)<br></code></pre></td></tr></table></figure><pre><code class="hljs">R2= 0.8794138468263233rmse= 0.34510338853546346mse= 0.11909634877865903---------------------------------------mean of residuals: -2.96425702171071e-16std of residuals: 0.3451887995969211---------------------------------------23 outliers:[2655, 2159, 1164, 2863, 1145, 2697, 2528, 2645, 691, 1085, 1874, 2647, 776, 2625, 884, 2696, 2668, 1310, 1901, 2769, 2002, 2669, 1040]</code></pre><p><img src="/img/工业蒸汽预测-07模型融合/output_27_1-169517575505521.png" /></p><h1 id="网格搜索训练模型">5 网格搜索训练模型</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_trainning_data_omitoutliers</span>():<br>    y1=y_t.copy()<br>    X1=X_t.copy()<br>    <span class="hljs-keyword">return</span> X1,y1<br></code></pre></td></tr></table></figure><p>使用网格搜索训练模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_model</span>(<span class="hljs-params">model, param_grid=[], X=[], y=[], </span><br><span class="hljs-params">                splits=<span class="hljs-number">5</span>, repeats=<span class="hljs-number">5</span></span>):<br><br>    <span class="hljs-comment"># get unmodified training data, unless data to use already specified </span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(y)==<span class="hljs-number">0</span>:<br>        X,y = get_trainning_data_omitoutliers()<br>        <span class="hljs-comment">#poly_trans=PolynomialFeatures(degree=2)</span><br>        <span class="hljs-comment">#X=poly_trans.fit_transform(X)</span><br>        <span class="hljs-comment">#X=MinMaxScaler().fit_transform(X)</span><br>    <br>    <span class="hljs-comment"># create cross-validation method</span><br>    rkfold = RepeatedKFold(n_splits=splits, n_repeats=repeats)<br>    <br>    <span class="hljs-comment"># perform a grid search if param_grid given</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(param_grid)&gt;<span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># setup grid search parameters</span><br>        gsearch = GridSearchCV(model, param_grid, cv=rkfold,<br>                               scoring=<span class="hljs-string">&quot;neg_mean_squared_error&quot;</span>,<br>                               verbose=<span class="hljs-number">1</span>, return_train_score=<span class="hljs-literal">True</span>)<br><br>        <span class="hljs-comment"># search the grid</span><br>        gsearch.fit(X,y)<br><br>        <span class="hljs-comment"># extract best model from the grid</span><br>        model = gsearch.best_estimator_        <br>        best_idx = gsearch.best_index_ <span class="hljs-comment"># 获取最佳模型的索引</span><br> <br>        <span class="hljs-comment"># get cv-scores for best model</span><br>        grid_results = pd.DataFrame(gsearch.cv_results_) <span class="hljs-comment"># .cv_results_ 每个参数组合的得分、标准差等信息       </span><br>        cv_mean = <span class="hljs-built_in">abs</span>(grid_results.loc[best_idx,<span class="hljs-string">&#x27;mean_test_score&#x27;</span>])<br>        cv_std = grid_results.loc[best_idx,<span class="hljs-string">&#x27;std_test_score&#x27;</span>]<br><br>    <span class="hljs-comment"># no grid search, just cross-val score for given model    </span><br>    <span class="hljs-keyword">else</span>:<br>        grid_results = []<br>        cv_results = cross_val_score(model, X, y, scoring=<span class="hljs-string">&quot;neg_mean_squared_error&quot;</span>, cv=rkfold)<br>        cv_mean = <span class="hljs-built_in">abs</span>(np.mean(cv_results))<br>        cv_std = np.std(cv_results)<br>    <br>    <span class="hljs-comment"># combine mean and std cv-score in to a pandas series</span><br>    cv_score = pd.Series(&#123;<span class="hljs-string">&#x27;mean&#x27;</span>:cv_mean,<span class="hljs-string">&#x27;std&#x27;</span>:cv_std&#125;)<br><br>    <span class="hljs-comment"># predict y using the fitted model</span><br>    y_pred = model.predict(X)<br>    <br>    <span class="hljs-comment"># print stats on model performance         </span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;----------------------&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(model)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;----------------------&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;score=&#x27;</span>,model.score(X,y))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;rmse=&#x27;</span>,rmse(y, y_pred))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;mse=&#x27;</span>,mse(y, y_pred))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;cross_val: mean=&#x27;</span>,cv_mean,<span class="hljs-string">&#x27;, std=&#x27;</span>,cv_std)<br>    <br>    <span class="hljs-comment"># residual plots</span><br>    y_pred = pd.Series(y_pred,index=y.index)<br>    resid = y - y_pred<br>    mean_resid = resid.mean()<br>    std_resid = resid.std()<br>    z = (resid - mean_resid)/std_resid    <br>    n_outliers = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">abs</span>(z)&gt;<span class="hljs-number">3</span>)<br>    <br>    plt.figure(figsize=(<span class="hljs-number">15</span>,<span class="hljs-number">5</span>))<br>    ax_131 = plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)<br>    plt.plot(y,y_pred,<span class="hljs-string">&#x27;.&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;y_pred&#x27;</span>);<br>    plt.title(<span class="hljs-string">&#x27;corr = &#123;:.3f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(y,y_pred)[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))<br>    ax_132=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br>    plt.plot(y,y-y_pred,<span class="hljs-string">&#x27;.&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;y - y_pred&#x27;</span>);<br>    plt.title(<span class="hljs-string">&#x27;std resid = &#123;:.3f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(std_resid))<br>    <br>    ax_133=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<br>    z.plot.hist(bins=<span class="hljs-number">50</span>,ax=ax_133)<br>    plt.xlabel(<span class="hljs-string">&#x27;z&#x27;</span>)<br>    plt.title(<span class="hljs-string">&#x27;&#123;:.0f&#125; samples with z&gt;3&#x27;</span>.<span class="hljs-built_in">format</span>(n_outliers))<br><br>    <span class="hljs-keyword">return</span> model, cv_score, grid_results<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># places to store optimal models and scores</span><br>opt_models = <span class="hljs-built_in">dict</span>()<br>score_models = pd.DataFrame(columns=[<span class="hljs-string">&#x27;mean&#x27;</span>,<span class="hljs-string">&#x27;std&#x27;</span>])<br><br><span class="hljs-comment"># no. k-fold splits</span><br>splits=<span class="hljs-number">5</span><br><span class="hljs-comment"># no. k-fold iterations</span><br>repeats=<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h1 id="单一模型训练">6 单一模型训练</h1><h2 id="岭回归">6.1 岭回归</h2><p>使用岭回归模型对数据进行预测，采用RMSE,MSE等指标对模型性能进行评价</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;Ridge&#x27;</span><br><br>opt_models[model] = Ridge()<br>alph_range = np.arange(<span class="hljs-number">0.25</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0.25</span>)<br>param_grid = &#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: alph_range&#125;<br><br>opt_models[model],cv_score,grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=repeats)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br><br>plt.figure()<br>plt.errorbar(alph_range, <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;mean_test_score&#x27;</span>]),<br>             <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;std_test_score&#x27;</span>])/np.sqrt(splits*repeats))<br>plt.xlabel(<span class="hljs-string">&#x27;alpha&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;score&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Fitting 25 folds for each of 23 candidates, totalling 575 fits----------------------Ridge(alpha=0.25)----------------------score= 0.8963563380306225rmse= 0.31899649233050603mse= 0.1017587621191668cross_val: mean= 0.10644934256965052 , std= 0.005302313654798051Text(0, 0.5, &#39;score&#39;)</code></pre><p>​<br /><img src="/img/工业蒸汽预测-07模型融合/output_34_2.png" /> ​</p><p><img src="/img/工业蒸汽预测-07模型融合/output_34_3-169517575505523.png" /></p><p>上面的图形主要反映了模型预测的准确度及拟合情况，后面的模型也将进行类似的可视化分析。这里对图形展示的信息进行介绍，从左至右依次如下：</p><pre><code class="hljs">(1)真实值（横轴：y)与模型预测值（竖轴：y pred)的散点图，图形上方显示了相关性数值，其越接近1越好。对于岭回归模型，相关性数值为0.947，预测值与真实值比较一致。(2)其为在交叉验证训练模型时，真实值（横轴：y)与模型预测值和真实值的残差（竖轴：y-y_pred)的散点图，图形上方显示了方差，其越小说明模型越稳定。可以看到，对于岭回归模型，在真实值y=-3附近的预测值有较大的偏差，同时，方差为0.319，较为稳定。(3)图是由模型预测值和真实值的残差（横轴：z=(resid-mean resid)/std resid)与落在按z轴划分区间的频率（竖轴：频数）所画的直方图，图形上方显示了预测值与真实值的残差大于三倍标准差的数，其越小越好，越大说明预测中有些样本的偏差很大。对于岭回归模型，预测值与真实值的残差大于三倍标准差的数为5个，模型对偏差大的数据有较好的包容性。(4)岭回归模型的参数（横轴：alpha)与模型的评价指标MSE(竖轴：score)的误差棒图。可以看出，对于岭回归模型，随着alpha的增大，评价指标MSE的数值也越来越大，其模型的方差也逐渐增大。</code></pre><p>​</p><h4 id="代码解释-2">代码解释</h4><ol type="1"><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">cv_score.name = model<br>score_models = score_models.append(cv_score)<br>````<br><br>```python<br><span class="hljs-built_in">print</span>(cv_score.name)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-------&quot;</span>)<br><span class="hljs-built_in">print</span>(score_models)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 结果</span><br>Ridge<br>-------<br>           mean       std<br>Ridge  <span class="hljs-number">0.106211</span>  <span class="hljs-number">0.007446</span><br></code></pre></td></tr></table></figure><hr /><ol start="2" type="1"><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.errorbar(alph_range, <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;mean_test_score&#x27;</span>]),<br>             <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;std_test_score&#x27;</span>])/np.sqrt(splits*repeats))<br></code></pre></td></tr></table></figure><p>代码根据给定的数据点集合在图表上绘制条形图，并添加以标准误差为高度的误差线。</p><ul><li><code>errorbar()</code> 用于绘制带有误差线的条形图。</li></ul><p>参数解释:</p><ul><li><code>alph_range</code> 是 x 轴上的数据点集合，它表示自变量的取值范围。</li><li><code>abs(grid_results['mean_test_score'])</code> 是 y 轴上的数据点集合，它表示不同自变量取值下的平均测试分数的绝对值。</li><li><code>abs(grid_results['std_test_score'])/np.sqrt(splits*repeats)</code> 是误差条的高度。<code>grid_results['std_test_score']</code> 表示测试分数的标准差，而 <code>splits</code> 和 <code>repeats</code> 是进行交叉验证时划分数据集的折数和重复次数，通过除以sqrt(splits*repeats) 来将标准差转换为标准误差。</li></ul><p>​</p><h2 id="lasso回归">6.2 Lasso回归</h2><p>使用Lasso回归模型对数据进行预测，采用RMSE,MSE等指标对模型性能进行评价</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;Lasso&#x27;</span><br><br>opt_models[model] = Lasso()<br>alph_range = np.arange(<span class="hljs-number">1e-4</span>,<span class="hljs-number">1e-3</span>,<span class="hljs-number">4e-5</span>)<br>param_grid = &#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: alph_range&#125;<br><br>opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=repeats)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br><br>plt.figure()<br>plt.errorbar(alph_range, <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;mean_test_score&#x27;</span>]),<span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;std_test_score&#x27;</span>])/np.sqrt(splits*repeats))<br>plt.xlabel(<span class="hljs-string">&#x27;alpha&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;score&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Fitting 25 folds for each of 23 candidates, totalling 575 fits----------------------Lasso(alpha=0.0001)----------------------score= 0.8965376022911505rmse= 0.3187174209135977mse= 0.10158079439381539cross_val: mean= 0.1062923603647315 , std= 0.007051871077111589Text(0, 0.5, &#39;score&#39;)</code></pre><p>​<br /><img src="/img/工业蒸汽预测-07模型融合/output_40_2.png" /> ​</p><p><img src="/img/工业蒸汽预测-07模型融合/output_40_3-169517575505525.png" /></p><h2 id="elasticnet-回归">6.3 ElasticNet 回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model =<span class="hljs-string">&#x27;ElasticNet&#x27;</span><br>opt_models[model] = ElasticNet()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: np.arange(<span class="hljs-number">1e-4</span>,<span class="hljs-number">1e-3</span>,<span class="hljs-number">1e-4</span>),<br>              <span class="hljs-string">&#x27;l1_ratio&#x27;</span>: np.arange(<span class="hljs-number">0.1</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">0.1</span>),<br>              <span class="hljs-string">&#x27;max_iter&#x27;</span>:[<span class="hljs-number">100000</span>]&#125;<br><br>opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Fitting 5 folds for each of 81 candidates, totalling 405 fits----------------------ElasticNet(alpha=0.0001, l1_ratio=0.9, max_iter=100000)----------------------score= 0.8965268226984906rmse= 0.3187340238271355mse= 0.10159137794503677cross_val: mean= 0.10558612445735098 , std= 0.006931804612280223</code></pre><p><img src="/img/工业蒸汽预测-07模型融合/output_42_1-169517575505526.png" /></p><h2 id="svr回归">6.4 SVR回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">model=<span class="hljs-string">&#x27;LinearSVR&#x27;</span><br>opt_models[model] = LinearSVR()<br><br>crange = np.arange(<span class="hljs-number">0.1</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">0.1</span>)<br>param_grid = &#123;<span class="hljs-string">&#x27;C&#x27;</span>:crange,<br>             <span class="hljs-string">&#x27;max_iter&#x27;</span>:[<span class="hljs-number">1000</span>]&#125;<br><br>opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=repeats)<br><br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br><br>plt.figure()<br>plt.errorbar(crange, <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;mean_test_score&#x27;</span>]),<span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;std_test_score&#x27;</span>])/np.sqrt(splits*repeats))<br>plt.xlabel(<span class="hljs-string">&#x27;C&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;score&#x27;</span>)<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">Fitting 25 folds for each of 9 candidates, totalling 225 fits----------------------LinearSVR(C=0.4)----------------------score= 0.30645151350483657rmse= 0.8251880824335185mse= 0.680935371390307cross_val: mean= 0.9136545268818084 , std= 0.5904526473477509Text(0, 0.5, &#39;score&#39;)</code></pre><p>​<br /><img src="/img/工业蒸汽预测-07模型融合/output_44_2.png" /> ​</p><p><img src="/img/工业蒸汽预测-07模型融合/output_44_3-169517575505529.png" /></p><h2 id="k近邻">6.5 K近邻</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;KNeighbors&#x27;</span><br>opt_models[model] = KNeighborsRegressor()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;n_neighbors&#x27;</span>:np.arange(<span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>)&#125;<br><br>opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br><br>plt.figure()<br>plt.errorbar(np.arange(<span class="hljs-number">3</span>,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>), <span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;mean_test_score&#x27;</span>]),<span class="hljs-built_in">abs</span>(grid_results[<span class="hljs-string">&#x27;std_test_score&#x27;</span>])/np.sqrt(splits*<span class="hljs-number">1</span>))<br>plt.xlabel(<span class="hljs-string">&#x27;n_neighbors&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;score&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Fitting 5 folds for each of 8 candidates, totalling 40 fits----------------------KNeighborsRegressor(n_neighbors=10)----------------------score= 0.7188007679386812rmse= 0.5254381453364182mse= 0.27608524457457456cross_val: mean= 0.35006829225711783 , std= 0.04461643597140863Text(0, 0.5, &#39;score&#39;)</code></pre><p>​<br /><img src="/img/工业蒸汽预测-07模型融合/output_46_2.png" /> ​</p><p><img src="/img/工业蒸汽预测-07模型融合/output_46_3-169517575505530.png" /></p><h1 id="模型融合-boosting方法">7 模型融合 Boosting方法</h1><p>把n个比较弱的模型，组合成一个比较强的模型。类似于随机森林。</p><h2 id="gbdt-模型">7.1 GBDT 模型</h2><p>使用 Gradient Boosting模型对数据进行预测，采用RMSE,MSE等指标对模型性能进行评价</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;GradientBoosting&#x27;</span><br>opt_models[model] = GradientBoostingRegressor()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;n_estimators&#x27;</span>:[<span class="hljs-number">150</span>,<span class="hljs-number">250</span>,<span class="hljs-number">350</span>],<br>              <span class="hljs-string">&#x27;max_depth&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>              <span class="hljs-string">&#x27;min_samples_split&#x27;</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]&#125;<br><br>opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Fitting 5 folds for each of 27 candidates, totalling 135 fits----------------------GradientBoostingRegressor(min_samples_split=6, n_estimators=250)----------------------score= 0.9677208586746097rmse= 0.17802275580033733mse= 0.03169210158274656cross_val: mean= 0.09849105444854306 , std= 0.014499755846113458</code></pre><p><img src="/img/工业蒸汽预测-07模型融合/output_48_1.png" /></p><h2 id="xgboost模型">7.2 XGBoost模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;XGB&#x27;</span><br>opt_models[model] = XGBRegressor()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;n_estimators&#x27;</span>:[<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">500</span>],<br>              <span class="hljs-string">&#x27;max_depth&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>             &#125;<br><br>opt_models[model], cv_score,grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=splits, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Fitting 5 folds for each of 15 candidates, totalling 75 fits----------------------XGBRegressor(base_score=0.5, booster=&#39;gbtree&#39;, callbacks=None,             colsample_bylevel=1, colsample_bynode=1, colsample_bytree=1,             early_stopping_rounds=None, enable_categorical=False,             eval_metric=None, gamma=0, gpu_id=-1, grow_policy=&#39;depthwise&#39;,             importance_type=None, interaction_constraints=&#39;&#39;,             learning_rate=0.300000012, max_bin=256, max_cat_to_onehot=4,             max_delta_step=0, max_depth=3, max_leaves=0, min_child_weight=1,             missing=nan, monotone_constraints=&#39;()&#39;, n_estimators=100, n_jobs=0,             num_parallel_tree=1, predictor=&#39;auto&#39;, random_state=0, reg_alpha=0,             reg_lambda=1, ...)----------------------score= 0.9702586237542838rmse= 0.1708815062712164mse= 0.029200489185519693cross_val: mean= 0.10472580078722642 , std= 0.006953064644267524</code></pre><p><img src="/img/工业蒸汽预测-07模型融合/output_50_1.png" /></p><h2 id="随机森林模型">7.3 随机森林模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model = <span class="hljs-string">&#x27;RandomForest&#x27;</span><br>opt_models[model] = RandomForestRegressor()<br><br>param_grid = &#123;<span class="hljs-string">&#x27;n_estimators&#x27;</span>:[<span class="hljs-number">100</span>,<span class="hljs-number">150</span>,<span class="hljs-number">200</span>],<br>              <span class="hljs-string">&#x27;max_features&#x27;</span>:[<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span>,<span class="hljs-number">20</span>,<span class="hljs-number">24</span>],<br>              <span class="hljs-string">&#x27;min_samples_split&#x27;</span>:[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]&#125;<br><br>opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid, <br>                                              splits=<span class="hljs-number">5</span>, repeats=<span class="hljs-number">1</span>)<br><br>cv_score.name = model<br>score_models = score_models.append(cv_score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Fitting 5 folds for each of 45 candidates, totalling 225 fits----------------------RandomForestRegressor(max_features=16, n_estimators=150)----------------------score= 0.9856162598758819rmse= 0.11883666269492393mse= 0.01412215240046713cross_val: mean= 0.10239417326207083 , std= 0.006602546408163406</code></pre><p><img src="/img/工业蒸汽预测-07模型融合/output_52_1.png" /></p><h1 id="多模型预测-bagging方法">8 多模型预测 Bagging方法</h1><p>Bagging 通常对分类任务使用简单投票法，对回归任务使用简单平均法.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">model_predict</span>(<span class="hljs-params">test_data,test_y=[],stack=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-comment">#poly_trans=PolynomialFeatures(degree=2)</span><br>    <span class="hljs-comment">#test_data1=poly_trans.fit_transform(test_data)</span><br>    <span class="hljs-comment">#test_data=MinMaxScaler().fit_transform(test_data)</span><br>    i=<span class="hljs-number">0</span><br>    y_predict_total=np.zeros((test_data.shape[<span class="hljs-number">0</span>],))<br>    <span class="hljs-keyword">for</span> model <span class="hljs-keyword">in</span> opt_models.keys():<br>        <span class="hljs-keyword">if</span> model!=<span class="hljs-string">&quot;LinearSVR&quot;</span> <span class="hljs-keyword">and</span> model!=<span class="hljs-string">&quot;KNeighbors&quot;</span>:<br>            y_predict=opt_models[model].predict(test_data)<br>            y_predict_total+=y_predict<br>            i+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(test_y)&gt;<span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;_mse:&quot;</span>.<span class="hljs-built_in">format</span>(model),mean_squared_error(y_predict,test_y))<br>    y_predict_mean=np.<span class="hljs-built_in">round</span>(y_predict_total/i,<span class="hljs-number">3</span>) <span class="hljs-comment"># 模型融合的mean</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(test_y)&gt;<span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mean_mse:&quot;</span>,mean_squared_error(y_predict_mean,test_y))<br>    <span class="hljs-keyword">else</span>:<br>        y_predict_mean=pd.Series(y_predict_mean)<br>        <span class="hljs-keyword">return</span> y_predict_mean<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model_predict(X_valid,y_valid)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Ridge_mse: 0.137671879096647Lasso_mse: 0.13786142881850508ElasticNet_mse: 0.1378268557408619LinearSVR_mse: 0.1378268557408619KNeighbors_mse: 0.1378268557408619GradientBoosting_mse: 0.1345410925334943XGB_mse: 0.14010339249433112RandomForest_mse: 0.13880263283624247mean_mse: 0.12569497923875433</code></pre><h4 id="代码解释-3">代码解释</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">model_predict</span>(<span class="hljs-params">test_data, test_y=[], stack=<span class="hljs-literal">False</span></span>):<br>    i = <span class="hljs-number">0</span><br>    y_predict_total = np.zeros((test_data.shape[<span class="hljs-number">0</span>],))<br></code></pre></td></tr></table></figure><p>这里定义了一个名为 <code>model_predict</code> 的函数，它接受三个参数：<code>test_data</code>（待预测的测试数据），<code>test_y</code>（可选的真实标签），<code>stack</code>（是否进行堆叠）。函数中初始化了变量 <code>i</code> 和 <code>y_predict_total</code>，其中 <code>i</code> 用于计算参与预测的模型数量，<code>y_predict_total</code> 是一个形状与 <code>test_data</code> 行数相同的全零数组，用于累加每个模型的预测结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> model <span class="hljs-keyword">in</span> opt_models.keys():<br>    <span class="hljs-keyword">if</span> model != <span class="hljs-string">&quot;LinearSVR&quot;</span> <span class="hljs-keyword">and</span> model != <span class="hljs-string">&quot;KNeighbors&quot;</span>:<br>        y_predict = opt_models[model].predict(test_data)<br>        y_predict_total += y_predict<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(test_y) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;_mse:&quot;</span>.<span class="hljs-built_in">format</span>(model), mean_squared_error(y_predict, test_y))<br></code></pre></td></tr></table></figure><p>这部分使用 <code>for</code> 循环遍历 <code>opt_models</code> 字典的键。这个字典存储了优化后的模型。在循环中，根据特定的条件判断，跳过了特定的两个模型（"LinearSVR" 和 "KNeighbors"）。然后，使用对应模型 <code>model</code> 对测试数据 <code>test_data</code> 进行预测，并将预测结果累加到 <code>y_predict_total</code> 中。同时，更新 <code>i</code> 的值。如果提供了真实标签 <code>test_y</code>，则计算并输出该模型的均方误差（MSE）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">y_predict_mean = np.<span class="hljs-built_in">round</span>(y_predict_total / i, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>这里计算了平均预测结果 <code>y_predict_mean</code>，通过将 <code>y_predict_total</code> 除以 <code>i</code> 得到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(test_y) &gt; <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mean_mse:&quot;</span>, mean_squared_error(y_predict_mean, test_y))<br><span class="hljs-keyword">else</span>:<br>    y_predict_mean = pd.Series(y_predict_mean)<br>    <span class="hljs-keyword">return</span> y_predict_mean<br></code></pre></td></tr></table></figure><p>这部分首先判断是否提供了真实标签 <code>test_y</code>。如果提供了，计算并输出平均预测结果 <code>y_predict_mean</code> 和真实标签之间的均方误差（MSE）。如果没有提供真实标签，则将 <code>y_predict_mean</code> 转换为 Pandas Series 对象并返回。</p><p>代码的整体思路是：</p><ul><li>遍历存储了优化后模型的字典 <code>opt_models</code> 的键。</li><li>对于每个模型，根据特定条件进行预测，然后将预测结果累加到 <code>y_predict_total</code> 中。</li><li>计算平均预测结果并返回或输出与真实标签的均方误差（如果提供了真实标签）。</li></ul><p>目的是对一组模型进行预测，并计算它们的平均预测结果或与真实标签的均方误差。如果没有提供真实标签，它将返回一个包含平均预测结果的 Pandas Series 对象。</p><p>可以看到，模型融合预测的MSE最小，预测性能最优。</p><h1 id="多模型融合-stacking方法">9 多模型融合 Stacking方法</h1><p>https://blog.csdn.net/m0_47256162/article/details/119979540</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib.gridspec <span class="hljs-keyword">as</span> gridspec <span class="hljs-comment"># 创建多维子图网格的模块</span><br><span class="hljs-keyword">import</span> itertools<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><br><span class="hljs-comment">##主要使用pip install mlxtend安装mlxtend</span><br><span class="hljs-keyword">from</span> mlxtend.classifier <span class="hljs-keyword">import</span> EnsembleVoteClassifier<br><span class="hljs-keyword">from</span> mlxtend.data <span class="hljs-keyword">import</span> iris_data<br><span class="hljs-keyword">from</span> mlxtend.plotting <span class="hljs-keyword">import</span> plot_decision_regions<br>%matplotlib inline<br><br><span class="hljs-comment"># Initializing Classifiers</span><br>clf1 = LogisticRegression(random_state=<span class="hljs-number">0</span>)<br>clf2 = RandomForestClassifier(random_state=<span class="hljs-number">0</span>)<br>clf3 = SVC(random_state=<span class="hljs-number">0</span>, probability=<span class="hljs-literal">True</span>)<br>eclf = EnsembleVoteClassifier(clfs=[clf1, clf2, clf3], weights=[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], voting=<span class="hljs-string">&#x27;soft&#x27;</span>)<br><br><span class="hljs-comment"># Loading some example data</span><br>X, y = iris_data()<br>X = X[:,[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]]<br><br><span class="hljs-comment"># Plotting Decision Regions</span><br>gs = gridspec.GridSpec(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>fig = plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br><br><span class="hljs-keyword">for</span> clf, lab, grd <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>([clf1, clf2, clf3, eclf],<br>                         [<span class="hljs-string">&#x27;Logistic Regression&#x27;</span>, <span class="hljs-string">&#x27;Random Forest&#x27;</span>, <span class="hljs-string">&#x27;RBF kernel SVM&#x27;</span>, <span class="hljs-string">&#x27;Ensemble&#x27;</span>],<br>                         itertools.product([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], repeat=<span class="hljs-number">2</span>)):<br>    clf.fit(X, y)<br>    ax = plt.subplot(gs[grd[<span class="hljs-number">0</span>], grd[<span class="hljs-number">1</span>]])<br>    fig = plot_decision_regions(X=X, y=y, clf=clf, legend=<span class="hljs-number">2</span>)<br>    plt.title(lab)<br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-07模型融合/output_59_0.png" /> ​</p><h4 id="代码解释-4">代码解释</h4><p><code>EnsembleVoteClassifier()</code></p><p>用于创建集成投票分类器。它可以将多个基分类器的预测结果进行投票，从而得到集成分类器的最终预测结果。</p><p>参数包括：</p><ul><li><code>clfs</code>：一个列表，包含要集成的基分类器对象。</li><li><code>voting</code>：设置投票方式，可选的取值为<code>'hard'</code>或<code>'soft'</code>，分别表示硬投票和软投票。硬投票是指根据少数服从多数的原则选择最多数量的类别作为预测结果，而软投票则是根据分类器预测的概率进行加权计算，并选择概率加权总和最大的类别作为预测结果。</li><li><code>weights</code>：一个可选的列表，用于指定每个基分类器的权重。如果未指定，则默认所有分类器的权重相等。</li></ul><hr /><ol type="1"><li><p><code>for clf, lab, grd in zip([clf1, clf2, clf3, eclf], ['Logistic Regression', 'Random Forest', 'RBF kernel SVM', 'Ensemble'], itertools.product([0, 1], repeat=2)):</code>：</p><ul><li><code>zip([clf1, clf2, clf3, eclf], ['Logistic Regression', 'Random Forest', 'RBF kernel SVM', 'Ensemble'], itertools.product([0, 1], repeat=2))</code>将分类器列表、标签列表和网格坐标的笛卡尔积打包在一起，返回一个迭代器。每次迭代返回一个元组<code>(clf, lab, grd)</code>，其中<code>clf</code>表示分类器对象，<code>lab</code>表示标签，<code>grd</code>表示网格坐标。</li><li><code>for clf, lab, grd in ...:</code>遍历迭代器中的每个元组，依次赋值给变量<code>clf</code>、<code>lab</code>和<code>grd</code>。</li></ul></li><li><p><code>clf.fit(X, y)</code>：使用当前分类器<code>clf</code>拟合数据集<code>X</code>和目标变量<code>y</code>，即进行训练。</p></li><li><p><code>ax = plt.subplot(gs[grd[0], grd[1]])</code>：在网格规则对象<code>gs</code>上创建一个子图对象，并将其赋值给变量<code>ax</code>。通过索引<code>grd[0]</code>和<code>grd[1]</code>，选择网格规则中的坐标位置。</p></li><li><p><code>fig = plot_decision_regions(X=X, y=y, clf=clf, legend=2)</code>：使用<code>mlxtend.plotting</code>模块的<code>plot_decision_regions</code>函数，在当前子图上绘制决策边界。传入参数包括输入数据集<code>X</code>、目标变量<code>y</code>、当前分类器<code>clf</code>，以及将图例放置的位置<code>legend=2</code>。绘制结果会返回一个图形对象，将其赋值给变量<code>fig</code>。</p></li><li><p><code>plt.title(lab)</code>：设置当前子图的标题为相应的标签<code>lab</code>。</p></li><li><p>最后一行<code>plt.show()</code>：显示整个图形，包含所有子图和决策边界。</p></li></ol><p>通过这段代码，可以实现对每个分类器的训练和决策边界的绘制，并在同一个图形中进行比较和展示。每个分类器都会有一个独立的子图，显示相应的决策边界和标签。最后，通过<code>plt.show()</code>将整个图形显示出来。</p><h1 id="工业蒸汽赛题多模型融合-stacking方法">10工业蒸汽赛题多模型融合 stacking方法</h1><h2 id="基础代码">10.1 基础代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> sparse<br><span class="hljs-keyword">import</span> xgboost<br><span class="hljs-keyword">import</span> lightgbm<br><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor,AdaBoostRegressor,GradientBoostingRegressor,ExtraTreesRegressor<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br><br><br><span class="hljs-comment"># 针对于一个模型进行K折交叉验证的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">stacking_reg</span>(<span class="hljs-params">clf,train_x,train_y,test_x,clf_name,kf,label_split=<span class="hljs-literal">None</span></span>):<br>    train=np.zeros((train_x.shape[<span class="hljs-number">0</span>],<span class="hljs-number">1</span>))<br>    test=np.zeros((test_x.shape[<span class="hljs-number">0</span>],<span class="hljs-number">1</span>))<br>    test_pre=np.empty((folds,test_x.shape[<span class="hljs-number">0</span>],<span class="hljs-number">1</span>)) <span class="hljs-comment"># 对话详解</span><br>    cv_scores=[]<br>    <span class="hljs-keyword">for</span> i,(train_index,test_index) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(kf.split(train_x,label_split)):       <br>        tr_x=train_x[train_index]<br>        tr_y=train_y[train_index]<br>        te_x=train_x[test_index]<br>        te_y = train_y[test_index]<br>        <span class="hljs-keyword">if</span> clf_name <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;rf&quot;</span>,<span class="hljs-string">&quot;ada&quot;</span>,<span class="hljs-string">&quot;gb&quot;</span>,<span class="hljs-string">&quot;et&quot;</span>,<span class="hljs-string">&quot;lr&quot;</span>,<span class="hljs-string">&quot;lsvc&quot;</span>,<span class="hljs-string">&quot;knn&quot;</span>]:<br>            clf.fit(tr_x,tr_y)<br>            pre=clf.predict(te_x).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-comment"># 对话详解</span><br>            train[test_index]=pre<br>            test_pre[i,:]=clf.predict(test_x).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>            cv_scores.append(mean_squared_error(te_y, pre))<br>        <span class="hljs-keyword">elif</span> clf_name <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;xgb&quot;</span>]:<br>            train_matrix = clf.DMatrix(tr_x, label=tr_y, missing=-<span class="hljs-number">1</span>) <span class="hljs-comment"># 对话详解</span><br>            test_matrix = clf.DMatrix(te_x, label=te_y, missing=-<span class="hljs-number">1</span>)<br>            z = clf.DMatrix(test_x, label=te_y, missing=-<span class="hljs-number">1</span>)<br>            params = &#123;<span class="hljs-string">&#x27;booster&#x27;</span>: <span class="hljs-string">&#x27;gbtree&#x27;</span>,<br>                      <span class="hljs-string">&#x27;eval_metric&#x27;</span>: <span class="hljs-string">&#x27;rmse&#x27;</span>,<br>                      <span class="hljs-string">&#x27;gamma&#x27;</span>: <span class="hljs-number">1</span>,<br>                      <span class="hljs-string">&#x27;min_child_weight&#x27;</span>: <span class="hljs-number">1.5</span>,<br>                      <span class="hljs-string">&#x27;max_depth&#x27;</span>: <span class="hljs-number">5</span>,<br>                      <span class="hljs-string">&#x27;lambda&#x27;</span>: <span class="hljs-number">10</span>,<br>                      <span class="hljs-string">&#x27;subsample&#x27;</span>: <span class="hljs-number">0.7</span>,<br>                      <span class="hljs-string">&#x27;colsample_bytree&#x27;</span>: <span class="hljs-number">0.7</span>,<br>                      <span class="hljs-string">&#x27;colsample_bylevel&#x27;</span>: <span class="hljs-number">0.7</span>,<br>                      <span class="hljs-string">&#x27;eta&#x27;</span>: <span class="hljs-number">0.03</span>,<br>                      <span class="hljs-string">&#x27;tree_method&#x27;</span>: <span class="hljs-string">&#x27;exact&#x27;</span>,<br>                      <span class="hljs-string">&#x27;seed&#x27;</span>: <span class="hljs-number">2017</span>,<br>                      <span class="hljs-string">&#x27;nthread&#x27;</span>: <span class="hljs-number">12</span><br>                      &#125;<br>            num_round = <span class="hljs-number">10000</span><br>            early_stopping_rounds = <span class="hljs-number">100</span><br>            watchlist = [(train_matrix, <span class="hljs-string">&#x27;train&#x27;</span>),<br>                         (test_matrix, <span class="hljs-string">&#x27;eval&#x27;</span>)<br>                         ]<br>            <span class="hljs-keyword">if</span> test_matrix:<br>                model = clf.train(params, train_matrix, num_boost_round=num_round,evals=watchlist,<br>                                  early_stopping_rounds=early_stopping_rounds<br>                                  )<br>                pre= model.predict(test_matrix,ntree_limit=model.best_ntree_limit).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>                train[test_index]=pre<br>                test_pre[i, :]= model.predict(z, ntree_limit=model.best_ntree_limit).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>                cv_scores.append(mean_squared_error(te_y, pre))<br><br>        <span class="hljs-keyword">elif</span> clf_name <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;lgb&quot;</span>]:<br>            train_matrix = clf.Dataset(tr_x, label=tr_y)<br>            test_matrix = clf.Dataset(te_x, label=te_y)<br>            <span class="hljs-comment">#z = clf.Dataset(test_x, label=te_y)</span><br>            <span class="hljs-comment">#z=test_x</span><br>            params = &#123;<br>                      <span class="hljs-string">&#x27;boosting_type&#x27;</span>: <span class="hljs-string">&#x27;gbdt&#x27;</span>,<br>                      <span class="hljs-string">&#x27;objective&#x27;</span>: <span class="hljs-string">&#x27;regression_l2&#x27;</span>,<br>                      <span class="hljs-string">&#x27;metric&#x27;</span>: <span class="hljs-string">&#x27;mse&#x27;</span>,<br>                      <span class="hljs-string">&#x27;min_child_weight&#x27;</span>: <span class="hljs-number">1.5</span>,<br>                      <span class="hljs-string">&#x27;num_leaves&#x27;</span>: <span class="hljs-number">2</span>**<span class="hljs-number">5</span>,<br>                      <span class="hljs-string">&#x27;lambda_l2&#x27;</span>: <span class="hljs-number">10</span>,<br>                      <span class="hljs-string">&#x27;subsample&#x27;</span>: <span class="hljs-number">0.7</span>,<br>                      <span class="hljs-string">&#x27;colsample_bytree&#x27;</span>: <span class="hljs-number">0.7</span>,<br>                      <span class="hljs-string">&#x27;colsample_bylevel&#x27;</span>: <span class="hljs-number">0.7</span>,<br>                      <span class="hljs-string">&#x27;learning_rate&#x27;</span>: <span class="hljs-number">0.03</span>,<br>                      <span class="hljs-string">&#x27;tree_method&#x27;</span>: <span class="hljs-string">&#x27;exact&#x27;</span>,<br>                      <span class="hljs-string">&#x27;seed&#x27;</span>: <span class="hljs-number">2017</span>,<br>                      <span class="hljs-string">&#x27;nthread&#x27;</span>: <span class="hljs-number">12</span>,<br>                      <span class="hljs-string">&#x27;silent&#x27;</span>: <span class="hljs-literal">True</span>,<br>                      &#125;<br>            num_round = <span class="hljs-number">10000</span><br>            callbacks=[lightgbm.log_evaluation(period=<span class="hljs-number">100</span>), lightgbm.early_stopping(stopping_rounds=<span class="hljs-number">100</span>)]<br>            <span class="hljs-keyword">if</span> test_matrix:<br>                model = clf.train(params, train_matrix,num_round,valid_sets=test_matrix,<br>                                  callbacks = callbacks<br>                                  )<br>                pre= model.predict(te_x,num_iteration=model.best_iteration).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>                train[test_index]=pre<br>                test_pre[i, :]= model.predict(test_x, num_iteration=model.best_iteration).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>                cv_scores.append(mean_squared_error(te_y, pre))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> IOError(<span class="hljs-string">&quot;Please add new clf.&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s now score is:&quot;</span>%clf_name,cv_scores)<br>    test[:]=test_pre.mean(axis=<span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s_score_list:&quot;</span>%clf_name,cv_scores)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s_score_mean:&quot;</span>%clf_name,np.mean(cv_scores))<br>    <span class="hljs-keyword">return</span> train.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),test.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><br><br></code></pre></td></tr></table></figure><h4 id="代码详解">代码详解</h4><p>这段代码是一个用于堆叠（stacking）回归模型的函数。下面是对每一行代码的逐行解释：</p><ol type="1"><li><p><code>def stacking_reg(clf,train_x,train_y,test_x,clf_name,kf,label_split=None):</code> 这个函数定义了一个堆叠回归模型的函数，它接受以下参数：</p><ul><li><code>clf</code>: 使用的基础回归模型</li><li><code>train_x</code>: 训练集的特征数据</li><li><code>train_y</code>: 训练集的目标数据</li><li><code>test_x</code>: 测试集的特征数据</li><li><code>clf_name</code>: 基础回归模型的名称</li><li><code>kf</code>: 交叉验证的迭代器</li><li><code>label_split</code>（可选）: 标签的分割方式</li></ul></li><li><p><code>train=np.zeros((train_x.shape[0],1))</code> 创建一个形状为<code>(训练集样本数, 1)</code>的全零数组，并将其赋值给变量<code>train</code>。这个数组用于存储训练集在基础模型上的预测结果。</p></li><li><p><code>test=np.zeros((test_x.shape[0],1))</code> 创建一个形状为<code>(测试集样本数, 1)</code>的全零数组，并将其赋值给变量<code>test</code>。这个数组用于存储测试集在基础模型上的预测结果。</p></li><li><p><code>test_pre=np.empty((folds,test_x.shape[0],1))</code> 创建一个形状为<code>(folds, 测试集样本数, 1)</code>的空数组，并将其赋值给变量<code>test_pre</code>。这个数组用于存储每次交叉验证中测试集在基础模型上的预测结果。</p></li><li><p><code>cv_scores=[]</code> 创建一个空列表，并将其赋值给变量<code>cv_scores</code>。这个列表用于存储每次交叉验证的均方误差（MSE）。</p></li><li><p><code>for i,(train_index,test_index) in enumerate(kf.split(train_x,label_split)):</code><br />遍历交叉验证迭代器<code>kf</code>生成的训练集和验证集的索引。每次迭代中，会得到一个训练集的索引和一个验证集的索引。</p></li><li><p><code>tr_x=train_x[train_index]</code> 根据索引从训练集中获取相应的特征数据，并赋值给变量<code>tr_x</code>。</p></li><li><p><code>tr_y=train_y[train_index]</code> 根据索引从训练集中获取相应的目标数据，并赋值给变量<code>tr_y</code>。</p></li><li><p><code>te_x=train_x[test_index]</code> 根据索引从训练集中获取相应的特征数据，并赋值给变量<code>te_x</code>。</p></li><li><p><code>te_y=train_y[test_index]</code> 根据索引从训练集中获取相应的目标数据，并赋值给变量<code>te_y</code>。</p></li></ol><p>15-62. 基于不同的基础回归模型进行训练和预测，并计算均方误差（MSE）：</p><ul><li>如果<code>clf_name</code>在<code>["rf","ada","gb","et","lr","lsvc","knn"]</code>中，使用<code>clf.fit()</code>方法进行训练，然后使用<code>clf.predict()</code>方法进行预测，并将预测结果存储在相应的变量中。</li><li>如果<code>clf_name</code>是<code>"xgb"</code>，则使用XGBoost库进行训练和预测。具体的参数设置和训练过程与XGBoost相关。</li><li>如果<code>clf_name</code>是<code>"lgb"</code>，则使用LightGBM库进行训练和预测。具体的参数设置和训练过程与LightGBM相关。</li></ul><ol start="64" type="1"><li><p><code>raise IOError("Please add new clf.")</code> 如果<code>clf_name</code>不属于任何已定义的模型名称，则抛出一个错误。</p></li><li><p><code>print("%s now score is:"%clf_name,cv_scores)</code> 打印当前基础回归模型的均方误差。</p></li><li><p><code>test[:]=test_pre.mean(axis=0)</code> 计算所有交叉验证模型的预测结果的平均值，并将结果赋值给<code>test</code>变量。</p></li></ol><p>70-71. 分别打印基础回归模型的均方误差列表和均值。</p><ol start="73" type="1"><li><code>return train.reshape(-1,1),test.reshape(-1,1)</code> 返回训练集和测试集的预测结果，其中预测结果的形状为<code>(样本数, 1)</code>。</li></ol><hr /><p>15-62.代码是一个用于训练和评估XGBoost或LightGBM模型的逻辑。我将逐行解释代码的功能：</p><ol type="1"><li><p><code>train_matrix = clf.DMatrix(tr_x, label=tr_y, missing=-1)</code>: 使用XGBoost库的<code>DMatrix</code>方法创建训练数据矩阵，其中<code>tr_x</code>是特征数据，<code>tr_y</code>是目标数据，<code>missing=-1</code>表示缺失值的表示方式。</p></li><li><p><code>test_matrix = clf.DMatrix(te_x, label=te_y, missing=-1)</code>: 使用XGBoost库的<code>DMatrix</code>方法创建测试数据矩阵，其中<code>te_x</code>是特征数据，<code>te_y</code>是目标数据，<code>missing=-1</code>表示缺失值的表示方式。</p></li><li><p><code>z = clf.DMatrix(test_x, label=te_y, missing=-1)</code>: 使用XGBoost库的<code>DMatrix</code>方法创建用于预测的数据矩阵，其中<code>test_x</code>是特征数据，<code>te_y</code>是目标数据，<code>missing=-1</code>表示缺失值的表示方式。</p></li><li><p><code>params = &#123;...&#125;</code>: 设置XGBoost模型的参数，包括树的深度、学习率、正则化等。</p></li><li><p><code>num_round = 10000</code>: 设置迭代轮数。</p></li><li><p><code>early_stopping_rounds = 100</code>: 设置在验证集上早停的轮数。</p></li><li><p><code>watchlist = [(train_matrix, 'train'), (test_matrix, 'eval')]</code>: 创建监控列表用于跟踪训练和测试集上的性能。</p></li><li><p><code>model = clf.train(params, train_matrix, num_boost_round=num_round,evals=watchlist,early_stopping_rounds=early_stopping_rounds)</code>: 使用XGBoost库的<code>train</code>方法训练模型，其中<code>params</code>是模型参数，<code>train_matrix</code>是训练数据矩阵，<code>num_boost_round</code>是迭代轮数，<code>evals</code>是监控列表，<code>early_stopping_rounds</code>是早停的轮数。</p></li><li><p><code>pre = model.predict(test_matrix,ntree_limit=model.best_ntree_limit).reshape(-1,1)</code>: 对测试数据进行预测，并将结果重塑为一列。</p></li><li><p><code>train[test_index] = pre</code>: 将对测试集的预测结果保存在训练集的相应位置。</p></li><li><p><code>test_pre[i, :] = model.predict(z, ntree_limit=model.best_ntree_limit).reshape(-1,1)</code>: 对预测数据进行预测，并将结果保存在<code>test_pre</code>数组的第i行。</p></li><li><p><code>cv_scores.append(mean_squared_error(te_y, pre))</code>: 将平均均方误差（MSE）添加到交叉验证分数列表中。</p></li><li><p><code>train_matrix = clf.Dataset(tr_x, label=tr_y)</code>: 使用LightGBM库的<code>Dataset</code>方法创建训练数据集。</p></li><li><p><code>test_matrix = clf.Dataset(te_x, label=te_y)</code>: 使用LightGBM库的<code>Dataset</code>方法创建测试数据集。</p></li><li><p><code>params = &#123;...&#125;</code>: 设置LightGBM模型的参数，包括树的深度、学习率、正则化等。</p></li><li><p><code>model = clf.train(params, train_matrix,num_round,valid_sets=test_matrix,early_stopping_rounds=early_stopping_rounds)</code>: 使用LightGBM库的<code>train</code>方法训练模型，其中<code>params</code>是模型参数，<code>train_matrix</code>是训练数据集，<code>num_round</code>是迭代轮数，<code>valid_sets</code>是用于验证的数据集，<code>early_stopping_rounds</code>是早停的轮数。</p></li><li><p><code>pre = model.predict(te_x,num_iteration=model.best_iteration).reshape(-1,1)</code>: 对测试数据进行预测，并将结果重塑为一列。</p></li><li><p><code>train[test_index] = pre</code>: 将对测试集的预测结果保存在训练集的相应位置。</p></li><li><p><code>test_pre[i, :] = model.predict(test_x, num_iteration=model.best_iteration).reshape(-1,1)</code>: 对预测数据进行预测，并将结果保存在<code>test_pre</code>数组的第i行。</p></li><li><p><code>cv_scores.append(mean_squared_error(te_y, pre))</code>: 将平均均方误差（MSE）添加到交叉验证分数列表中。</p></li></ol><h4 id="代码整体思路">代码整体思路</h4><ol type="1"><li><p>创建一些空数组和变量，包括<code>train</code>（训练集预测结果）、<code>test</code>（测试集预测结果）、<code>test_pre</code>（测试集在各折交叉验证下的预测结果）和<code>cv_scores</code>（交叉验证得分列表）。</p></li><li><p>对于交叉验证的每一折，进行以下操作：</p><ul><li>根据当前折的索引，获取训练集的索引和测试集的索引。</li><li>根据索引从训练集和标签中抽取对应的样本和标签。</li><li>如果分类器名称在['rf'、'ada'、'gb'、'et'、'lr'、'lsvc'、'knn']中，则使用分类器训练模型，进行预测，并将预测结果存储在相应的数组中。</li><li>如果分类器名称为'xgb'，则使用XGBoost训练模型，进行预测，并将预测结果存储在相应的数组中。</li><li>如果分类器名称为'lgb'，则使用LightGBM训练模型，进行预测，并将预测结果存储在相应的数组中。</li><li>计算当前折的均方误差得分，并将其添加到cv_scores列表中。</li></ul></li><li><p>计算所有折的平均预测结果，并将其存储在test数组中。</p></li><li><p>打印分类器名称、交叉验证得分列表和平均得分。</p></li><li><p>将train和test数组重新整形为列向量，并返回它们作为函数的输出。</p></li></ol><h2 id="模型融合stacking基学习器">10.2 模型融合stacking基学习器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rf_reg</span>(<span class="hljs-params">x_train, y_train, x_valid, kf, label_split=<span class="hljs-literal">None</span></span>):<br>    randomforest = RandomForestRegressor(n_estimators=<span class="hljs-number">600</span>, max_depth=<span class="hljs-number">20</span>, n_jobs=-<span class="hljs-number">1</span>, random_state=<span class="hljs-number">2017</span>, max_features=<span class="hljs-string">&quot;auto&quot;</span>,verbose=<span class="hljs-number">1</span>)<br>    rf_train, rf_test = stacking_reg(randomforest, x_train, y_train, x_valid, <span class="hljs-string">&quot;rf&quot;</span>, kf, label_split=label_split)<br>    <span class="hljs-keyword">return</span> rf_train, rf_test,<span class="hljs-string">&quot;rf_reg&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ada_reg</span>(<span class="hljs-params">x_train, y_train, x_valid, kf, label_split=<span class="hljs-literal">None</span></span>):<br>    adaboost = AdaBoostRegressor(n_estimators=<span class="hljs-number">30</span>, random_state=<span class="hljs-number">2017</span>, learning_rate=<span class="hljs-number">0.01</span>)<br>    ada_train, ada_test = stacking_reg(adaboost, x_train, y_train, x_valid, <span class="hljs-string">&quot;ada&quot;</span>, kf, label_split=label_split)<br>    <span class="hljs-keyword">return</span> ada_train, ada_test,<span class="hljs-string">&quot;ada_reg&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gb_reg</span>(<span class="hljs-params">x_train, y_train, x_valid, kf, label_split=<span class="hljs-literal">None</span></span>):<br>    gbdt = GradientBoostingRegressor(learning_rate=<span class="hljs-number">0.04</span>, n_estimators=<span class="hljs-number">100</span>, subsample=<span class="hljs-number">0.8</span>, random_state=<span class="hljs-number">2017</span>,max_depth=<span class="hljs-number">5</span>,verbose=<span class="hljs-number">1</span>)<br>    gbdt_train, gbdt_test = stacking_reg(gbdt, x_train, y_train, x_valid, <span class="hljs-string">&quot;gb&quot;</span>, kf, label_split=label_split)<br>    <span class="hljs-keyword">return</span> gbdt_train, gbdt_test,<span class="hljs-string">&quot;gb_reg&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">et_reg</span>(<span class="hljs-params">x_train, y_train, x_valid, kf, label_split=<span class="hljs-literal">None</span></span>):<br>    extratree = ExtraTreesRegressor(n_estimators=<span class="hljs-number">600</span>, max_depth=<span class="hljs-number">35</span>, max_features=<span class="hljs-string">&quot;auto&quot;</span>, n_jobs=-<span class="hljs-number">1</span>, random_state=<span class="hljs-number">2017</span>,verbose=<span class="hljs-number">1</span>)<br>    et_train, et_test = stacking_reg(extratree, x_train, y_train, x_valid, <span class="hljs-string">&quot;et&quot;</span>, kf, label_split=label_split)<br>    <span class="hljs-keyword">return</span> et_train, et_test,<span class="hljs-string">&quot;et_reg&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lr_reg</span>(<span class="hljs-params">x_train, y_train, x_valid, kf, label_split=<span class="hljs-literal">None</span></span>):<br>    lr_reg=LinearRegression(n_jobs=-<span class="hljs-number">1</span>)<br>    lr_train, lr_test = stacking_reg(lr_reg, x_train, y_train, x_valid, <span class="hljs-string">&quot;lr&quot;</span>, kf, label_split=label_split)<br>    <span class="hljs-keyword">return</span> lr_train, lr_test, <span class="hljs-string">&quot;lr_reg&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xgb_reg</span>(<span class="hljs-params">x_train, y_train, x_valid, kf, label_split=<span class="hljs-literal">None</span></span>):<br>    xgb_train, xgb_test = stacking_reg(xgboost, x_train, y_train, x_valid, <span class="hljs-string">&quot;xgb&quot;</span>, kf, label_split=label_split)<br>    <span class="hljs-keyword">return</span> xgb_train, xgb_test,<span class="hljs-string">&quot;xgb_reg&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lgb_reg</span>(<span class="hljs-params">x_train, y_train, x_valid, kf, label_split=<span class="hljs-literal">None</span></span>):<br>    lgb_train, lgb_test = stacking_reg(lightgbm, x_train, y_train, x_valid, <span class="hljs-string">&quot;lgb&quot;</span>, kf, label_split=label_split)<br>    <span class="hljs-keyword">return</span> lgb_train, lgb_test,<span class="hljs-string">&quot;lgb_reg&quot;</span><br></code></pre></td></tr></table></figure><h4 id="代码解释-5">代码解释</h4><ol type="1"><li><p><code>rf_reg</code> 函数：</p><ul><li>首先，使用随机森林回归器 <code>RandomForestRegressor</code> 创建一个随机森林模型。设置了一些参数，如树的数量(<code>n_estimators</code>)、最大深度(<code>max_depth</code>)、并行运算的CPU核数(<code>n_jobs</code>)等。</li><li>接下来，调用 <code>stacking_reg</code> 函数，将创建的随机森林模型作为基学习器进行堆叠集成学习。该函数的作用是对训练数据 <code>x_train</code> 进行 K 折交叉验证，并返回基学习器在训练集和验证集上的预测结果。</li><li>最后，返回训练集的预测结果 <code>rf_train</code>、验证集的预测结果 <code>rf_test</code> 和标识符字符串 <code>"rf_reg"</code>。</li></ul></li><li><p><code>ada_reg</code> 函数：</p><ul><li>首先，使用 AdaBoost 回归器 <code>AdaBoostRegressor</code> 创建一个 AdaBoost 模型。设置了一些参数，如基学习器的数量(<code>n_estimators</code>)、学习率(<code>learning_rate</code>)等。</li><li>接下来，调用 <code>stacking_reg</code> 函数，将创建的 AdaBoost 模型作为基学习器进行堆叠集成学习。该函数的作用和上述相同，对训练数据 <code>x_train</code> 进行 K 折交叉验证，并返回基学习器在训练集和验证集上的预测结果。</li><li>最后，返回训练集的预测结果 <code>ada_train</code>、验证集的预测结果 <code>ada_test</code> 和标识符字符串 <code>"ada_reg"</code>。</li></ul></li></ol><p>······</p><p>代码的目的是创建不同的基学习器，并将其作为基础模型进行堆叠集成学习。通过堆叠集成学习，可以利用各个基学习器的优势，提高整体模型的预测性能。最后，返回训练集和验证集上的预测结果以及标识符字符串。</p><h2 id="定义模型融合stacking预测函数">10.3 定义模型融合stacking预测函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">stacking_pred</span>(<span class="hljs-params">x_train, y_train, x_valid, kf, clf_list, label_split=<span class="hljs-literal">None</span>, clf_fin=<span class="hljs-string">&quot;lgb&quot;</span>, if_concat_origin=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-comment"># 第一层-结果为train test</span><br>    <span class="hljs-keyword">for</span> k, clf_list <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(clf_list):<br>        clf_list = [clf_list]<br>        column_list = []<br>        train_data_list=[]<br>        test_data_list=[]<br>        <span class="hljs-keyword">for</span> clf <span class="hljs-keyword">in</span> clf_list:<br>            train_data,test_data,clf_name=clf(x_train, y_train, x_valid, kf, label_split=label_split)<br>            train_data_list.append(train_data)<br>            test_data_list.append(test_data)<br>            column_list.append(<span class="hljs-string">&quot;clf_%s&quot;</span> % (clf_name))<br>    train = np.concatenate(train_data_list, axis=<span class="hljs-number">1</span>)<br>    test = np.concatenate(test_data_list, axis=<span class="hljs-number">1</span>)<br>     <br>    <span class="hljs-comment"># 是否选择原始特征拼接</span><br>    <span class="hljs-keyword">if</span> if_concat_origin:<br>        train = np.concatenate([x_train, train], axis=<span class="hljs-number">1</span>)<br>        test = np.concatenate([x_valid, test], axis=<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(x_train.shape)<br>    <span class="hljs-built_in">print</span>(train.shape)<br>    <span class="hljs-built_in">print</span>(clf_name)<br>    <span class="hljs-built_in">print</span>(clf_name <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;lgb&quot;</span>])<br>    <span class="hljs-comment"># 第二层</span><br>    <span class="hljs-keyword">if</span> clf_fin <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;rf&quot;</span>,<span class="hljs-string">&quot;ada&quot;</span>,<span class="hljs-string">&quot;gb&quot;</span>,<span class="hljs-string">&quot;et&quot;</span>,<span class="hljs-string">&quot;lr&quot;</span>,<span class="hljs-string">&quot;lsvc&quot;</span>,<span class="hljs-string">&quot;knn&quot;</span>]:<br>        <span class="hljs-keyword">if</span> clf_fin <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;rf&quot;</span>]:<br>            clf = RandomForestRegressor(n_estimators=<span class="hljs-number">600</span>, max_depth=<span class="hljs-number">20</span>, n_jobs=-<span class="hljs-number">1</span>, random_state=<span class="hljs-number">2017</span>, max_features=<span class="hljs-string">&quot;auto&quot;</span>,verbose=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">elif</span> clf_fin <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;ada&quot;</span>]:<br>            clf = AdaBoostRegressor(n_estimators=<span class="hljs-number">30</span>, random_state=<span class="hljs-number">2017</span>, learning_rate=<span class="hljs-number">0.01</span>)<br>        <span class="hljs-keyword">elif</span> clf_fin <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;gb&quot;</span>]:<br>            clf = GradientBoostingRegressor(learning_rate=<span class="hljs-number">0.04</span>, n_estimators=<span class="hljs-number">100</span>, subsample=<span class="hljs-number">0.8</span>, random_state=<span class="hljs-number">2017</span>,max_depth=<span class="hljs-number">5</span>,verbose=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">elif</span> clf_fin <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;et&quot;</span>]:<br>            clf = ExtraTreesRegressor(n_estimators=<span class="hljs-number">600</span>, max_depth=<span class="hljs-number">35</span>, max_features=<span class="hljs-string">&quot;auto&quot;</span>, n_jobs=-<span class="hljs-number">1</span>, random_state=<span class="hljs-number">2017</span>,verbose=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">elif</span> clf_fin <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;lr&quot;</span>]:<br>            clf = LinearRegression(n_jobs=-<span class="hljs-number">1</span>)<br>        clf.fit(train, y_train)<br>        pre = clf.predict(test).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> pred<br>    <span class="hljs-keyword">elif</span> clf_fin <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;xgb&quot;</span>]:<br>        clf = xgboost<br>        train_matrix = clf.DMatrix(train, label=y_train, missing=-<span class="hljs-number">1</span>)<br>        test_matrix = clf.DMatrix(train, label=y_train, missing=-<span class="hljs-number">1</span>)<br>        params = &#123;<span class="hljs-string">&#x27;booster&#x27;</span>: <span class="hljs-string">&#x27;gbtree&#x27;</span>,<br>                  <span class="hljs-string">&#x27;eval_metric&#x27;</span>: <span class="hljs-string">&#x27;rmse&#x27;</span>,<br>                  <span class="hljs-string">&#x27;gamma&#x27;</span>: <span class="hljs-number">1</span>,<br>                  <span class="hljs-string">&#x27;min_child_weight&#x27;</span>: <span class="hljs-number">1.5</span>,<br>                  <span class="hljs-string">&#x27;max_depth&#x27;</span>: <span class="hljs-number">5</span>,<br>                  <span class="hljs-string">&#x27;lambda&#x27;</span>: <span class="hljs-number">10</span>,<br>                  <span class="hljs-string">&#x27;subsample&#x27;</span>: <span class="hljs-number">0.7</span>,<br>                  <span class="hljs-string">&#x27;colsample_bytree&#x27;</span>: <span class="hljs-number">0.7</span>,<br>                  <span class="hljs-string">&#x27;colsample_bylevel&#x27;</span>: <span class="hljs-number">0.7</span>,<br>                  <span class="hljs-string">&#x27;eta&#x27;</span>: <span class="hljs-number">0.03</span>,<br>                  <span class="hljs-string">&#x27;tree_method&#x27;</span>: <span class="hljs-string">&#x27;exact&#x27;</span>,<br>                  <span class="hljs-string">&#x27;seed&#x27;</span>: <span class="hljs-number">2017</span>,<br>                  <span class="hljs-string">&#x27;nthread&#x27;</span>: <span class="hljs-number">12</span><br>                  &#125;<br>        num_round = <span class="hljs-number">10000</span><br>        <span class="hljs-comment">#early_stopping_rounds = 100</span><br>        callbacks=[lightgbm.log_evaluation(period=<span class="hljs-number">100</span>), lightgbm.early_stopping(stopping_rounds=<span class="hljs-number">100</span>)]<br>        watchlist = [(train_matrix, <span class="hljs-string">&#x27;train&#x27;</span>),<br>                     (test_matrix, <span class="hljs-string">&#x27;eval&#x27;</span>)<br>                     ]<br>        model = clf.train(params, train_matrix, num_boost_round=num_round,evals=watchlist,<br>                          <span class="hljs-comment">#early_stopping_rounds=early_stopping_rounds</span><br>                          callbacks=callbacks<br>                          )<br>        pre = model.predict(test,ntree_limit=model.best_ntree_limit).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> pre<br>    <span class="hljs-keyword">elif</span> clf_fin <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;lgb&quot;</span>]:<br>        <span class="hljs-built_in">print</span>(clf_name)<br>        clf = lightgbm<br>        train_matrix = clf.Dataset(train, label=y_train)<br>        test_matrix = clf.Dataset(train, label=y_train)<br>        params = &#123;<br>                  <span class="hljs-string">&#x27;boosting_type&#x27;</span>: <span class="hljs-string">&#x27;gbdt&#x27;</span>,<br>                  <span class="hljs-string">&#x27;objective&#x27;</span>: <span class="hljs-string">&#x27;regression_l2&#x27;</span>,<br>                  <span class="hljs-string">&#x27;metric&#x27;</span>: <span class="hljs-string">&#x27;mse&#x27;</span>,<br>                  <span class="hljs-string">&#x27;min_child_weight&#x27;</span>: <span class="hljs-number">1.5</span>,<br>                  <span class="hljs-string">&#x27;num_leaves&#x27;</span>: <span class="hljs-number">2</span>**<span class="hljs-number">5</span>,<br>                  <span class="hljs-string">&#x27;lambda_l2&#x27;</span>: <span class="hljs-number">10</span>,<br>                  <span class="hljs-string">&#x27;subsample&#x27;</span>: <span class="hljs-number">0.7</span>,<br>                  <span class="hljs-string">&#x27;colsample_bytree&#x27;</span>: <span class="hljs-number">0.7</span>,<br>                  <span class="hljs-string">&#x27;colsample_bylevel&#x27;</span>: <span class="hljs-number">0.7</span>,<br>                  <span class="hljs-string">&#x27;learning_rate&#x27;</span>: <span class="hljs-number">0.03</span>,<br>                  <span class="hljs-string">&#x27;tree_method&#x27;</span>: <span class="hljs-string">&#x27;exact&#x27;</span>,<br>                  <span class="hljs-string">&#x27;seed&#x27;</span>: <span class="hljs-number">2017</span>,<br>                  <span class="hljs-string">&#x27;nthread&#x27;</span>: <span class="hljs-number">12</span>,<br>                  <span class="hljs-string">&#x27;silent&#x27;</span>: <span class="hljs-literal">True</span>,<br>                  &#125;<br>        num_round = <span class="hljs-number">10000</span><br>        <span class="hljs-comment">#early_stopping_rounds = 100</span><br>        callbacks=[lightgbm.log_evaluation(period=<span class="hljs-number">100</span>), lightgbm.early_stopping(stopping_rounds=<span class="hljs-number">100</span>)]<br>        model = clf.train(params, train_matrix,num_round,valid_sets=test_matrix,<br>                          <span class="hljs-comment">#early_stopping_rounds=early_stopping_rounds</span><br>                          callbacks=callbacks<br>                          )<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;pred&#x27;</span>)<br>        pre = model.predict(test,num_iteration=model.best_iteration).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(pre)<br>        <span class="hljs-keyword">return</span> pre<br></code></pre></td></tr></table></figure><h2 id="使用lr_reg和lgb_reg进行融合预测">10.4 使用lr_reg和lgb_reg进行融合预测</h2><p>加载数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># load_dataset</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./data/zhengqi_train.txt&quot;</span>)  <span class="hljs-keyword">as</span> fr:<br>    data_train=pd.read_table(fr,sep=<span class="hljs-string">&quot;\t&quot;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./data/zhengqi_test.txt&quot;</span>) <span class="hljs-keyword">as</span> fr_test:<br>    data_test=pd.read_table(fr_test,sep=<span class="hljs-string">&quot;\t&quot;</span>)<br>    <br></code></pre></td></tr></table></figure><p>K折交叉验证</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># K折交叉验证</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> StratifiedKFold, KFold<br><br>folds = <span class="hljs-number">5</span><br>seed = <span class="hljs-number">1</span><br>kf = KFold(n_splits=<span class="hljs-number">5</span>, shuffle=<span class="hljs-literal">True</span>, random_state=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>训练集和测试集数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练集</span><br>x_train = data_train[data_test.columns].values<br>y_train = data_train[<span class="hljs-string">&#x27;target&#x27;</span>].values<br><span class="hljs-comment"># 测试集</span><br>x_valid = data_test[data_test.columns].values<br></code></pre></td></tr></table></figure><p>使用lr_reg和lgb_reg进行融合预测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">clf_list = [lr_reg, lgb_reg]<br><br><span class="hljs-comment">##很容易过拟合</span><br>pred = stacking_pred(x_train, y_train, x_valid, kf, clf_list, label_split=<span class="hljs-literal">None</span>, clf_fin=<span class="hljs-string">&quot;lgb&quot;</span>, if_concat_origin=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>预测结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pred<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[ 0.41700189],       [ 0.37101204],       [ 0.1479981 ],       ...,       [-2.48570445],       [-2.4264629 ],       [-2.48367665]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将pred转换为一维数组</span><br>pred_flat = pred.flatten()<br><br><span class="hljs-comment"># 保存为文本文件</span><br>np.savetxt(<span class="hljs-string">&#x27;pred.txt&#x27;</span>, pred_flat)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习实战入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工业蒸汽预测-06特征优化</title>
    <link href="/2023/09/15/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-06%E7%89%B9%E5%BE%81%E4%BC%98%E5%8C%96/"/>
    <url>/2023/09/15/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-06%E7%89%B9%E5%BE%81%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="赛题特征优化">赛题特征优化</h1><h1 id="导入数据">1 导入数据</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>train_data_file = <span class="hljs-string">&quot;./data/zhengqi_train.txt&quot;</span><br>test_data_file =  <span class="hljs-string">&quot;./data/zhengqi_test.txt&quot;</span><br><br>train_data = pd.read_csv(train_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>test_data = pd.read_csv(test_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="定义特征构造方法">2 定义特征构造方法</h1><p>定义特征构造方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">epsilon=<span class="hljs-number">1e-5</span><br><br><span class="hljs-comment">#组交叉特征，可以自行定义，如增加： x*x/y, log(x)/y 等等。</span><br>func_dict = &#123;<br>            <span class="hljs-string">&#x27;add&#x27;</span>: <span class="hljs-keyword">lambda</span> x,y: x+y,<br>            <span class="hljs-string">&#x27;mins&#x27;</span>: <span class="hljs-keyword">lambda</span> x,y: x-y,<br>            <span class="hljs-string">&#x27;div&#x27;</span>: <span class="hljs-keyword">lambda</span> x,y: x/(y+epsilon),<br>            <span class="hljs-string">&#x27;multi&#x27;</span>: <span class="hljs-keyword">lambda</span> x,y: x*y<br>            &#125;<br></code></pre></td></tr></table></figure><h4 id="代码解释">代码解释</h4><p><code>epsilon</code> 经常用作一个非常小的正数，用于避免在计算中出现除以零的情况。</p><p>该代码中的 <code>epsilon</code> 被用作分母在除法运算中的修正因子。当分母接近零时，加上一个非常小的正数 <code>epsilon</code> 可以确保避免出现除以零的错误，同时保持数值计算的准确性。</p><p><code>epsilon</code> 被定义为 <code>1e-5</code>，即 0.00001。在执行诸如 <code>div</code> 函数的除法运算时，分母会加上 <code>epsilon</code>，从而避免除以零的情况。这样可以确保在进行组交叉特征计算时，不会出现除以零的错误，并保持计算的稳定性和准确性。</p><h1 id="定义特征构造函数">3 定义特征构造函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">auto_features_make</span>(<span class="hljs-params">train_data,test_data,func_dict,col_list</span>):<br>    train_data, test_data = train_data.copy(), test_data.copy()<br>    <br>    <span class="hljs-keyword">for</span> col_i <span class="hljs-keyword">in</span> col_list:<br>        <span class="hljs-keyword">for</span> col_j <span class="hljs-keyword">in</span> col_list:<br>            <span class="hljs-keyword">for</span> func_name, func <span class="hljs-keyword">in</span> func_dict.items():<br>                <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> [train_data,test_data]:<br>                    func_features = func(data[col_i],data[col_j])<br>                    col_func_features = <span class="hljs-string">&#x27;-&#x27;</span>.join([col_i,func_name,col_j])<br>                    data[col_func_features] = func_features<br>                    <br>    <span class="hljs-keyword">return</span> train_data,test_data<br><br></code></pre></td></tr></table></figure><h4 id="代码解释-1">代码解释</h4><p>函数的作用是在给定的数据集 <code>train_data</code> 和 <code>test_data</code> 上生成自动特征。</p><ol type="1"><li><p>拷贝 <code>train_data</code> 和 <code>test_data</code> 数据集。</p></li><li><p>使用嵌套的循环<code>for col_i in col_list:</code> 和 <code>for col_j in col_list:</code> 遍历 <code>col_list</code> 中的每一对列名 <code>col_i</code> 和 <code>col_j</code>,例如<code>[V1 V0    ]</code>，<code>[V1 V1]</code>。</p></li><li><p>在内部的循环中，遍历 <code>func_dict</code> 中的每个函数，这些函数以函数名 <code>func_name</code> 和对应的函数对象 <code>func</code> 表示。</p></li><li><p>对于每个数据集（<code>train_data</code> 和 <code>test_data</code>），将 <code>col_i</code> 和 <code>col_j</code> 列的值作为参数传递给当前迭代的函数 <code>func</code>，并计算得到新的特征值 <code>func_features</code>。</p></li><li><p>创建一个新的特征列名 <code>col_func_features</code>，使用 <code>-</code> 连接 <code>col_i</code>、<code>func_name</code> 和 <code>col_j</code>。</p></li><li><p>将计算得到的新特征值 <code>func_features</code> 存储在对应的特征列 <code>col_func_features</code> 中。</p></li><li><p>重复步骤 4-6，直到遍历完所有的列和函数组合。</p></li><li><p>最后，返回生成新特征后的 <code>train_data</code> 和 <code>test_data</code>。</p></li></ol><h2 id="对训练集和测试集数据进行特征构造">对训练集和测试集数据进行特征构造</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data2, test_data2 = auto_features_make(train_data,test_data,func_dict,col_list=test_data.columns)<br></code></pre></td></tr></table></figure><pre><code class="hljs">D:\Development\anaconda3\envs\ml\lib\site-packages\ipykernel_launcher.py:10: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`  # Remove the CWD from sys.path while we load stuff.</code></pre><h4 id="代码解释-2">代码解释</h4><p>警告提示数据集可能存在严重的碎片化问题，即内存中的 DataFrame 对象非常分散。这通常是由于多次调用 DataFrame.insert 方法导致的，而 insert 方法的性能较差。</p><h1 id="特征降维处理">4 特征降维处理</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA   <span class="hljs-comment">#主成分分析法</span><br><br><span class="hljs-comment">#PCA方法降维</span><br>pca = PCA(n_components=<span class="hljs-number">500</span>)<br><span class="hljs-comment"># train_data2_pca = pca.fit_transform(train_data2.iloc[:,0:-1]) # 有误 target列并不在最后一列</span><br>train_data2_pca = pca.fit_transform(train_data2.drop([<span class="hljs-string">&#x27;target&#x27;</span>], axis=<span class="hljs-number">1</span>)) <span class="hljs-comment"># 提取特征列</span><br>test_data2_pca = pca.transform(test_data2)<br><br>train_data2_pca = pd.DataFrame(train_data2_pca)<br>test_data2_pca = pd.DataFrame(test_data2_pca)<br><br>train_data2_pca[<span class="hljs-string">&#x27;target&#x27;</span>] = train_data2[<span class="hljs-string">&#x27;target&#x27;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X_train2 = train_data2[test_data2.columns].values<br>y_train = train_data2[<span class="hljs-string">&#x27;target&#x27;</span>]<br></code></pre></td></tr></table></figure><h1 id="模型训练和评估">5 模型训练和评估</h1><p>使用lightgbm模型对新构造的特征进行模型训练和评估。注意运行时间长 二十多分钟。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ls_validation i</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> KFold<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br><span class="hljs-keyword">import</span> lightgbm <span class="hljs-keyword">as</span> lgb<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 5折交叉验证</span><br>Folds=<span class="hljs-number">5</span><br>kf = KFold(n_splits=Folds, random_state=<span class="hljs-number">2019</span>, shuffle=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 记录训练和预测MSE</span><br>MSE_DICT = &#123;<br>    <span class="hljs-string">&#x27;train_mse&#x27;</span>:[],<br>    <span class="hljs-string">&#x27;test_mse&#x27;</span>:[]<br>&#125;<br><br><span class="hljs-comment"># 线下训练预测</span><br><span class="hljs-keyword">for</span> i, (train_index, test_index) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(kf.split(X_train2)):<br>    <span class="hljs-comment"># lgb树模型</span><br>    lgb_reg = lgb.LGBMRegressor(<br>        learning_rate=<span class="hljs-number">0.01</span>,<br>        max_depth=-<span class="hljs-number">1</span>,<br>        n_estimators=<span class="hljs-number">5000</span>,<br>        boosting_type=<span class="hljs-string">&#x27;gbdt&#x27;</span>,<br>        random_state=<span class="hljs-number">2019</span>,<br>        objective=<span class="hljs-string">&#x27;regression&#x27;</span>,<br>    )<br>   <br>    <span class="hljs-comment"># 切分训练集和预测集</span><br>    X_train_KFold, X_test_KFold = X_train2[train_index], X_train2[test_index]<br>    y_train_KFold, y_test_KFold = y_train[train_index], y_train[test_index]<br>    <br>    <span class="hljs-comment"># 训练模型</span><br>    lgb_reg.fit(<br>            X=X_train_KFold,y=y_train_KFold,<br>            eval_set=[(X_train_KFold, y_train_KFold),(X_test_KFold, y_test_KFold)],<br>            eval_names=[<span class="hljs-string">&#x27;Train&#x27;</span>,<span class="hljs-string">&#x27;Test&#x27;</span>],<br>            <span class="hljs-comment"># early_stopping_rounds=100,# 已弃用</span><br>            eval_metric=<span class="hljs-string">&#x27;MSE&#x27;</span>,<br>            <span class="hljs-comment"># verbose=50 # 已弃用</span><br>        callbacks=[lgb.log_evaluation(period=<span class="hljs-number">100</span>), lgb.early_stopping(stopping_rounds=<span class="hljs-number">100</span>)]<br>        )<br><br><br>    <span class="hljs-comment"># 训练集预测 测试集预测</span><br>    y_train_KFold_predict = lgb_reg.predict(X_train_KFold,num_iteration=lgb_reg.best_iteration_)<br>    y_test_KFold_predict = lgb_reg.predict(X_test_KFold,num_iteration=lgb_reg.best_iteration_) <br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第&#123;&#125;折 训练和预测 训练MSE 预测MSE&#x27;</span>.<span class="hljs-built_in">format</span>(i))<br>    train_mse = mean_squared_error(y_train_KFold_predict, y_train_KFold)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------\n&#x27;</span>, <span class="hljs-string">&#x27;训练MSE\n&#x27;</span>, train_mse, <span class="hljs-string">&#x27;\n------&#x27;</span>)<br>    test_mse = mean_squared_error(y_test_KFold_predict, y_test_KFold)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------\n&#x27;</span>, <span class="hljs-string">&#x27;预测MSE\n&#x27;</span>, test_mse, <span class="hljs-string">&#x27;\n------\n&#x27;</span>)<br>    <br>    MSE_DICT[<span class="hljs-string">&#x27;train_mse&#x27;</span>].append(train_mse)<br>    MSE_DICT[<span class="hljs-string">&#x27;test_mse&#x27;</span>].append(test_mse)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------\n&#x27;</span>, <span class="hljs-string">&#x27;训练MSE\n&#x27;</span>, MSE_DICT[<span class="hljs-string">&#x27;train_mse&#x27;</span>], <span class="hljs-string">&#x27;\n&#x27;</span>, np.mean(MSE_DICT[<span class="hljs-string">&#x27;train_mse&#x27;</span>]), <span class="hljs-string">&#x27;\n------&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------\n&#x27;</span>, <span class="hljs-string">&#x27;预测MSE\n&#x27;</span>, MSE_DICT[<span class="hljs-string">&#x27;test_mse&#x27;</span>], <span class="hljs-string">&#x27;\n&#x27;</span>, np.mean(MSE_DICT[<span class="hljs-string">&#x27;test_mse&#x27;</span>]), <span class="hljs-string">&#x27;\n------&#x27;</span>)<br></code></pre></td></tr></table></figure><p>将代码运行得到的5折交叉验证的各折叠训练MSE、预测MSE及平均MSE,与上一节中未做特征优化的结果对比，可以发现MSE得到进一步降低。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习实战入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言10-自定义数据类型-结构体123</title>
    <link href="/2023/09/14/C%E8%AF%AD%E8%A8%8010-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E7%BB%93%E6%9E%84%E4%BD%93123/"/>
    <url>/2023/09/14/C%E8%AF%AD%E8%A8%8010-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E7%BB%93%E6%9E%84%E4%BD%93123/</url>
    
    <content type="html"><![CDATA[<p>本章重点 1. 结构体 2. 结构体类型的声明 3. 结构的自引用 4. 结构体变量的定义和初始化 5. 结构体内存对齐 6. 结构体传参</p><h1 id="结构的基础知识">1 结构的基础知识</h1><p>结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。 # 2 结构的声明 例如描述一个学生： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span></span><br><span class="hljs-class">&#123;</span><br>member-<span class="hljs-built_in">list</span>;<br>&#125;variable-<span class="hljs-built_in">list</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<span class="hljs-comment">//名字</span><br><span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄</span><br><span class="hljs-type">char</span> sex[<span class="hljs-number">5</span>];<span class="hljs-comment">//性别</span><br><span class="hljs-type">char</span> id[<span class="hljs-number">20</span>];<span class="hljs-comment">//学号</span><br>&#125;; <span class="hljs-comment">//分号不能丢</span><br></code></pre></td></tr></table></figure></p><h1 id="特殊的声明">3 特殊的声明</h1><p>在声明结构的时候，可以不完全的声明。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">char</span> b;<br><span class="hljs-type">float</span> c;<br>&#125;x;<br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">char</span> b;<br><span class="hljs-type">float</span> c;<br>&#125;*p;<br></code></pre></td></tr></table></figure> 上面的两个结构在声明的时候省略掉了结构体标签（tag）。但是 <code>p = &amp;x;</code> 是非法的，编译器会把上面的两个声明当成完全不同的两个类型。</p><h1 id="结构的自引用">4 结构的自引用</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//代码1</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> <span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-comment">// 可以这样自引用吗？</span><br><span class="hljs-comment">// 如果可以，那sizeof(struct Node)是多少？</span><br></code></pre></td></tr></table></figure><p>正确的自引用方式： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//代码2</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure></p><p>注意： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//代码3</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> data;<br>Node* next;<br>&#125;Node;<br><span class="hljs-comment">//这样写代码可以吗？</span><br></code></pre></td></tr></table></figure></p><p>不声明标签自引用是错误的，正确的引用方法为： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;Node;<br></code></pre></td></tr></table></figure></p><h1 id="结构体变量的定义和初始化">5 结构体变量的定义和初始化</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br>&#125;p1; <span class="hljs-comment">//声明类型的同时定义变量p1</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> <span class="hljs-title">p2</span>;</span> <span class="hljs-comment">//定义结构体变量p2</span><br><br><span class="hljs-comment">//初始化：定义变量的同时赋初值。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> <span class="hljs-title">p3</span> =</span> &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span> //类型声明</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">15</span>];<span class="hljs-comment">//名字</span><br><span class="hljs-type">int</span> age; <span class="hljs-comment">//年龄</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span> <span class="hljs-title">s</span> =</span> &#123; <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">20</span> &#125;;<span class="hljs-comment">//初始化</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> <span class="hljs-title">p</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;n1 = &#123; <span class="hljs-number">10</span>, &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;, <span class="hljs-literal">NULL</span> &#125;; <span class="hljs-comment">//结构体嵌套初始化</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> <span class="hljs-title">n2</span> =</span> &#123; <span class="hljs-number">20</span>, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;, <span class="hljs-literal">NULL</span> &#125;;<span class="hljs-comment">//结构体嵌套初始化</span><br></code></pre></td></tr></table></figure><h1 id="结构体内存对齐">6 结构体内存对齐</h1><p>计算结构体的大小： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> c1;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">char</span> c2;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> c1;<br><span class="hljs-type">char</span> c2;<br><span class="hljs-type">int</span> i;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> S2)); <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> S1)); <span class="hljs-comment">// 12</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>如何计算大小？</strong> 首先得掌握结构体的对齐规则： 1. 第一个成员在与结构体变量偏移量为0的地址处。</p><ol start="2" type="1"><li><p>其他成员变量要对齐到对齐数的整数倍的地址处。对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。</p><ul><li>VS中默认的值为8</li><li>Linux中没有默认对齐数，对齐数就是成员自身的大小</li></ul></li><li><p>结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。</p></li><li><p>如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。</p><p><strong>为什么存在内存对齐?</strong></p><ol type="1"><li>平台原因(移植原因)： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li></ol></li><li><p>性能原因： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p></li></ol><p><strong>结构体的内存对齐是拿空间来换取时间的做法。</strong></p><p>我们既要满足对齐，又要节省空间，那在设让占用空间小的成员尽量集中在一起。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//例如：</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> c1;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">char</span> c2;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> c1;<br><span class="hljs-type">char</span> c2;<br><span class="hljs-type">int</span> i;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="修改默认对齐数">7 修改默认对齐数</h1><p>使用<code>#pragma</code> 这个预处理指令，可以改变默认对齐数。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(8)<span class="hljs-comment">//设置默认对齐数为8</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> c1;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">char</span> c2;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()<span class="hljs-comment">//取消设置的默认对齐数，还原为默认</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)<span class="hljs-comment">//设置默认对齐数为1</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> c1;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">char</span> c2;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()<span class="hljs-comment">//取消设置的默认对齐数，还原为默认</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> S1)); <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> S2)); <span class="hljs-comment">// 6</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> &gt; 结构在对齐方式不合适的时候，我们可以自己更改默认对齐数。</p><h1 id="结构体传参">8 结构体传参</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> data[<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> num;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> <span class="hljs-title">s</span> =</span> &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;, <span class="hljs-number">1000</span>&#125;;<br><span class="hljs-comment">//结构体传参</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print1</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> S s)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s.num);<br>&#125;<br><span class="hljs-comment">//结构体地址传参</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print2</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> S* ps)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ps-&gt;num);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>print1(s); <span class="hljs-comment">//传结构体</span><br>print2(&amp;s); <span class="hljs-comment">//传地址</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首选print2函数。</p><p>函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。 如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。</p><p>但是使用print2函数在可能会误修改结构体中的值，我们可以使用 <code>const</code> 来修饰 <code>struct S* ps</code> ，使之不可修改。</p>]]></content>
    
    
    <categories>
      
      <category>C语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言09-指针详解1</title>
    <link href="/2023/09/14/C%E8%AF%AD%E8%A8%8009-%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A31/"/>
    <url>/2023/09/14/C%E8%AF%AD%E8%A8%8009-%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A31/</url>
    
    <content type="html"><![CDATA[<p>在初始指针中学到： 1. 指针就是个变量，用来存放地址，地址唯一标识一块内存空间。 2. 指针的大小是固定的4/8个字节（32位平台/64位平台）。 3. 指针是有类型，指针的类型决定了指针的+-整数的步长，指针解引用操作的时候的权限。 4. 指针的运算。</p><h1 id="字符指针">1 字符指针</h1><p>字符指针<code>char*</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* pstr = <span class="hljs-string">&quot;hello world&quot;</span>;<span class="hljs-comment">//这里是把一个字符串放到pstr指针变量里了吗？</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, pstr);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把字符串<code>hello world</code> 首字符的地址放到了pstr中。即把一个常量字符串的首字符<code>h</code>的地址存放到指针变量<code>pstr</code> 中。</p><p>面试题： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str3 = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str4 = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-keyword">if</span> (str1 == str2)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str1 and str2 are same\n&quot;</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str1 and str2 are not same\n&quot;</span>);<br><span class="hljs-keyword">if</span> (str3 == str4)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str3 and str4 are same\n&quot;</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str3 and str4 are not same\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 结果为： <img src="/img/C语言09-指针详解1/C语言09-指针详解1.png" /> 这里str3和str4指向的是一个同一个常量字符串。C/C++会把常量字符串存储到单独的一个内存区域，当几个指针 指向同一个字符串的时候，他们实际会指向同一块内存。但是用相同的常量字符串去初始化不同的数组的时候就会 开辟出不同的内存块。所以str1和str2不同，str3和str4相同。</p>]]></content>
    
    
    <categories>
      
      <category>C语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言08-数据的存储</title>
    <link href="/2023/09/14/C%E8%AF%AD%E8%A8%8008-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <url>/2023/09/14/C%E8%AF%AD%E8%A8%8008-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>本章重点 1. 数据类型详细介绍 2. 整形在内存中的存储：原码、反码、补码 3. 大小端字节序介绍及判断 4. 浮点型在内存中的存储解析</p><h1 id="数据类型介绍">1 数据类型介绍</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 基本的内置类型：</span><br><span class="hljs-type">char</span> <span class="hljs-comment">//字符数据类型</span><br><span class="hljs-type">short</span> <span class="hljs-comment">//短整型</span><br><span class="hljs-type">int</span> <span class="hljs-comment">//整形</span><br><span class="hljs-type">long</span> <span class="hljs-comment">//长整型</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-comment">//更长的整形</span><br><span class="hljs-type">float</span> <span class="hljs-comment">//单精度浮点数</span><br><span class="hljs-type">double</span> <span class="hljs-comment">//双精度浮点数</span><br></code></pre></td></tr></table></figure><p><strong>类型的意义：</strong> 1. 使用这个类型开辟内存空间的大小（大小决定了使用范围）。 2. 如何看待内存空间的视角。</p><h2 id="类型的基本归类">1.1 类型的基本归类</h2><p><strong>整形：</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span><br><span class="hljs-type">signed</span> <span class="hljs-type">char</span><br><span class="hljs-type">short</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> [<span class="hljs-type">int</span>]<br><span class="hljs-type">signed</span> <span class="hljs-type">short</span> [<span class="hljs-type">int</span>]<br><span class="hljs-type">int</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span><br><span class="hljs-type">signed</span> <span class="hljs-type">int</span><br><span class="hljs-type">long</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> [<span class="hljs-type">int</span>]<br><span class="hljs-type">signed</span> <span class="hljs-type">long</span> [<span class="hljs-type">int</span>]<br></code></pre></td></tr></table></figure></p><p><strong>浮点数:</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span><br><span class="hljs-type">double</span><br></code></pre></td></tr></table></figure></p><p><strong>构造类型：</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt; 数组类型<br>&gt; 结构体类型 <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&gt;</span> 枚举类型 <span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&gt;</span> 联合类型 <span class="hljs-class"><span class="hljs-keyword">union</span></span><br></code></pre></td></tr></table></figure></p><p><strong>指针类型:</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *pi;<br><span class="hljs-type">char</span> *pc;<br><span class="hljs-type">float</span>* pf;<br><span class="hljs-type">void</span>* pv;<br></code></pre></td></tr></table></figure></p><p><strong>空类型：</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> 表示空类型（无类型）<br>通常应用于函数的返回类型、函数的参数、指针类型。<br></code></pre></td></tr></table></figure></p><h1 id="整形在内存中的存储">2 整形在内存中的存储</h1><h2 id="原码反码补码">2.1 原码、反码、补码</h2><p>计算机中的整数有三种2进制表示方法，即原码、反码和补码。 三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”。 对于数值位正数和负数的表示不同：</p><p><strong>正数</strong> ： 原、反、补码都相同。</p><p><strong>负整数的三种表示方法各不相同：</strong> &gt; <strong>原码</strong> &gt; 直接将数值按照正负数的形式翻译成二进制就可以得到原码。</p><blockquote><p><strong>反码</strong> 将原码的符号位不变，其他位依次按位取反就可以得到反码。</p></blockquote><blockquote><p><strong>补码</strong> 反码+1就得到补码。</p></blockquote><p><strong>对于整形来说：数据存放内存中其实存放的是补码。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//00000000 00000000 00000000 00010100 - 补码</span><br><span class="hljs-comment">//0x00 00 00 14 - 16进制 </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/C语言08-数据的存储/C语言08-数据的存储.png" /> 我们可以看到对于a和b分别存储的是补码。但是我们发现顺序有点不对。 这是又为什么？</p><h2 id="大小端介绍">2.2 大小端介绍</h2><p><strong>什么大端小端：</strong> &gt; 大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中； &gt; &gt; <strong>小端</strong>（存储）模式，是指数据的<strong>低位</strong>保存在内存的<strong>低地址</strong>中，而数据的<strong>高位</strong>,，保存在内存的<strong>高地址</strong>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">// 小端</span><br><span class="hljs-comment">// 14 00 00 00</span><br><br><span class="hljs-comment">// 大端</span><br><span class="hljs-comment">// 00 00 00 14</span><br></code></pre></td></tr></table></figure><p><strong>为什么有大端和小端：</strong> 这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8 bit。但是在C语言中除了8 bit的char之外，还有16 bit的short型，32 bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。</p><h3 id="练习1">练习1</h3><blockquote><p>请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">check_sys</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span>* p = (<span class="hljs-type">char</span>*)&amp;a;<br><span class="hljs-keyword">if</span> (*p ==<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> ret = check_sys();<br><span class="hljs-comment">//返回1，小端</span><br><span class="hljs-comment">//返回0，大端</span><br><span class="hljs-keyword">if</span>(ret == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;小端\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;大端\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">check_sys</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span>* p = (<span class="hljs-type">char</span>*)&amp;a;<br><span class="hljs-comment">//返回1，小端</span><br><span class="hljs-comment">//返回0，大端</span><br><span class="hljs-keyword">return</span> *p;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>再优化： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">check_sys</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> (*(<span class="hljs-type">char</span>*)&amp;a);<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="练习2">练习2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//输出什么？</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> a= <span class="hljs-number">-1</span>;<br><span class="hljs-type">signed</span> <span class="hljs-type">char</span> b=<span class="hljs-number">-1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c=<span class="hljs-number">-1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d,b=%d,c=%d&quot;</span>,a,b,c);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：-1 -1 255</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs txt">char a = -1;<br>10000000 00000000 00000000 00000001 - 原码<br>11111111 11111111 11111111 11111110 - 反码<br>11111111 11111111 11111111 11111111 - 补码<br><br>因为char是1字节，所以只能存8bit：<br>11111111<br><br>要求打印的类型为int类型（%d），所以需要整形提升：<br>11111111 11111111 11111111 11111111 - 反码<br><br>接着转换成原码打印：<br>10000000 00000000 00000000 00000001 - 原码<br><br>所以，最终结果为-1<br></code></pre></td></tr></table></figure><p>同理，对于<code>a</code> 和<code>b</code> 为有符号位整形提升,高位补充符号位。<code>c</code> 无符号整形提升，高位补0。</p><h3 id="练习3">练习3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 代码1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> a = <span class="hljs-number">-128</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>,a);<br><span class="hljs-comment">//%d-打印十进制的有符号数字</span><br><span class="hljs-comment">//%u-打印十进制的无符号数字</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 代码2</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> a = <span class="hljs-number">128</span>; <span class="hljs-comment">// = 127+1 = -128</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码1和代码2结果相同。 <img src="/img/C语言08-数据的存储/C语言08-数据的存储_D01.png" /></p><p><img src="/img/C语言08-数据的存储/C语言08-数据的存储_D02.png" /></p><h3 id="练习4">练习4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i= <span class="hljs-number">-20</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i+j); <span class="hljs-comment">// -10</span><br><span class="hljs-comment">//按照补码的形式进行运算，最后格式化成为有符号整数</span><br></code></pre></td></tr></table></figure><h3 id="练习5">练习5</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">9</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>,i);<br>&#125;<br></code></pre></td></tr></table></figure><p>死循环，因为i为无符号整形，永远大于等于0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> a[<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000</span>; i++)<br>&#123;<br>a[i] = <span class="hljs-number">-1</span>-i;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">strlen</span>(a));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：255 char取值范围为-128到127，所以 <code>char a[1000]</code> 中存的为 <code>-1 -2 -3 ··· -128 127 126 ··· 1 0</code> ,又因为 <code>strlen()</code> 求得是<code>0</code> 前边的长度，所以结果为255</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">255</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>死循环。因为 <code>unsigned char</code> 取值范围为0-255，永远小于等于255。</p><h1 id="浮点型在内存中的存储">3 浮点型在内存中的存储</h1><h2 id="示例">3.1 示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">9</span>;<br><span class="hljs-type">float</span> *pFloat = (<span class="hljs-type">float</span> *)&amp;n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n的值为：%d\n&quot;</span>,n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);<br>*pFloat = <span class="hljs-number">9.0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num的值为：%d\n&quot;</span>,n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为： <img src="/img/C语言08-数据的存储/C语言08-数据的存储_1.png" /></p><p><code>num</code> 和<code>*pFloat</code> 在内存中明明是同一个数，为什么浮点数和整数的解读结果会差别这么大？</p><h2 id="浮点数存储规则">3.2 浮点数存储规则</h2><p>根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式： - (-1)^S * M * 2^E - (-1)^S表示符号位，当S=0，V为正数；当S=1，V为负数。 - M表示有效数字，大于等于1，小于2。 - 2^E表示指数位。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">9.0</span><br><span class="hljs-number">1001.0</span><br>(<span class="hljs-number">-1</span>)^<span class="hljs-number">0</span> * <span class="hljs-number">1.001</span> * <span class="hljs-number">2</span>^<span class="hljs-number">3</span><br>(<span class="hljs-number">-1</span>)^s * M     * <span class="hljs-number">2</span>^E<br><br>S<span class="hljs-number">-0</span><br>M<span class="hljs-number">-1.001</span><br>E<span class="hljs-number">-3</span><br></code></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">-5.0</span><br><span class="hljs-number">-101.0</span><br>(<span class="hljs-number">-1</span>)^<span class="hljs-number">1</span> * <span class="hljs-number">1.01</span> * <span class="hljs-number">2</span>^<span class="hljs-number">2</span><br><br>S=<span class="hljs-number">1</span><br>M=<span class="hljs-number">1.01</span><br>E=<span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure><p><strong>IEEE 754规定：</strong> 对于32位的浮点数，最高的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M。 <img src="/img/C语言08-数据的存储/C语言08-数据的存储_2.png" /></p><p>对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。 <img src="/img/C语言08-数据的存储/C语言08-数据的存储_3.png" /></p><p><strong>IEEE 754对有效数字M和指数E，还有一些特别规定。</strong></p><p><strong>对于M：</strong> 前面说过， <code>1≤M&lt;2</code> ，也就是说，M可以写成<code>1.xxxxxx</code> 的形式，其中<code>xxxxxx</code>表示小数部分。</p><p>IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的<code>xxxxxx</code>部分。比如保存<code>1.01</code>的时候，只保存<code>01</code>，等到读取的时候，再把第一位的1加上去。</p><p>这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效字。</p><p><strong>对于E:</strong> <strong>首先，E为一个无符号整数（unsigned int）</strong> 这意味着，如果E为8位，它的取值范围为0<sub>255；如果E为11位，它的取值范围为0</sub>2047。</p><p>但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。</p><p>比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即<code>10001001</code>。</p><p>然后，指数E从内存中取出还可以再分成三种情况：</p><p><strong>E不全为0或不全为1</strong> &gt; 指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。</p><p>比如： <code>0.5（1/2）</code>的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为<code>1.0*2^(-1)</code>，其阶码为<code>-1+127=126</code>，表示为<code>01111110</code>，而尾数1.0去掉整数部分为0，补齐0到23位<code>00000000000000000000000</code>，则其二进制表示形式为: <code>0 01111110 00000000000000000000000</code></p><p><strong>E全为0</strong> &gt; 这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。</p><p><strong>E全为1</strong> &gt; 这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）</p>]]></content>
    
    
    <categories>
      
      <category>C语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言07-初识结构体</title>
    <link href="/2023/09/12/C%E8%AF%AD%E8%A8%8007-%E5%88%9D%E8%AF%86%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2023/09/12/C%E8%AF%AD%E8%A8%8007-%E5%88%9D%E8%AF%86%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>本章重点：</p><ul><li>结构体类型的声明</li><li>结构体初始化</li><li>结构体成员访问</li><li>结构体传参</li></ul><h1 id="结构体的声明">1 结构体的声明</h1><p>结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。</p><h2 id="结构体的声明-1">1.1 结构体的声明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span></span><br><span class="hljs-class">&#123;</span><br>member-<span class="hljs-built_in">list</span>;<br>&#125;variable-<span class="hljs-built_in">list</span>;<br></code></pre></td></tr></table></figure><p>例如描述一个学生： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<span class="hljs-comment">//名字</span><br><span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄</span><br><span class="hljs-type">char</span> sex[<span class="hljs-number">5</span>];<span class="hljs-comment">//性别</span><br><span class="hljs-type">char</span> id[<span class="hljs-number">20</span>];<span class="hljs-comment">//学号</span><br>&#125;;<span class="hljs-comment">//分号不能丢</span><br></code></pre></td></tr></table></figure></p><p>可以将 struct Stu 重命名为Stu <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<span class="hljs-comment">//名字</span><br><span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄</span><br><span class="hljs-type">char</span> sex[<span class="hljs-number">5</span>];<span class="hljs-comment">//性别</span><br><span class="hljs-type">char</span> id[<span class="hljs-number">20</span>];<span class="hljs-comment">//学号</span><br>&#125;Stu；<span class="hljs-comment">//分号不能丢</span><br></code></pre></td></tr></table></figure></p><p>结构的成员可以是标量、数组、指针，甚至是其他结构体。</p><h2 id="结构体变量的定义和初始化">1.2 结构体变量的定义和初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br>&#125;p1; <span class="hljs-comment">//声明类型的同时定义变量p1</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> <span class="hljs-title">p2</span>;</span> <span class="hljs-comment">//定义结构体变量p2</span><br><br><span class="hljs-comment">//初始化：定义变量的同时赋初值。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> <span class="hljs-title">p3</span> =</span> &#123;x, y&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span> //类型声明</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">15</span>];<span class="hljs-comment">//名字</span><br><span class="hljs-type">int</span> age; <span class="hljs-comment">//年龄</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span> <span class="hljs-title">s</span> =</span> &#123;<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">20</span>&#125;;<span class="hljs-comment">//初始化</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> <span class="hljs-title">p</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;n1 = &#123;<span class="hljs-number">10</span>, &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;, <span class="hljs-literal">NULL</span>&#125;; <span class="hljs-comment">//结构体嵌套初始化</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> <span class="hljs-title">n2</span> =</span> &#123;<span class="hljs-number">20</span>, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;, <span class="hljs-literal">NULL</span>&#125;;<span class="hljs-comment">//结构体嵌套初始化</span><br></code></pre></td></tr></table></figure><h1 id="结构体成员的访问">2 结构体成员的访问</h1><h2 id="结构体变量访问成员">2.1 结构体变量访问成员</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> <span class="hljs-title">s</span> =</span> &#123;<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">20</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,s.name)<br></code></pre></td></tr></table></figure><h2 id="结构体指针访问指向变量的成员">2.2 结构体指针访问指向变量的成员</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Stu* ps)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name = %s age = %d\n&quot;</span>, (*ps).name, (*ps).age);<br><span class="hljs-comment">//使用结构体指针访问指向对象的成员</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name = %s age = %d\n&quot;</span>, ps-&gt;name, ps-&gt;age);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span> <span class="hljs-title">s</span> =</span> &#123;<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">20</span>&#125;;<br>print(&amp;s);<span class="hljs-comment">//结构体地址传参</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结构体传参">3 结构体传参</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> data[<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> num;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> <span class="hljs-title">s</span> =</span> &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;, <span class="hljs-number">1000</span>&#125;;<br><br><span class="hljs-comment">//结构体传参</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print1</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> S s)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s.num);<br>&#125;<br><br><span class="hljs-comment">//结构体地址传参</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print2</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> S* ps)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ps-&gt;num);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>print1(s); <span class="hljs-comment">//传结构体</span><br>print2(&amp;s); <span class="hljs-comment">//传地址</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首选<code>print2</code>函数。因为，函数传参的时候，参数是需要压栈的。如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。</p><p><strong>结论：</strong> 结构体传参的时候，要传结构体的地址。</p>]]></content>
    
    
    <categories>
      
      <category>C语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言06-初识指针12</title>
    <link href="/2023/09/12/C%E8%AF%AD%E8%A8%8006-%E5%88%9D%E8%AF%86%E6%8C%87%E9%92%8812/"/>
    <url>/2023/09/12/C%E8%AF%AD%E8%A8%8006-%E5%88%9D%E8%AF%86%E6%8C%87%E9%92%8812/</url>
    
    <content type="html"><![CDATA[<p>本章重点： 1. 指针是什么 2. 指针和指针类型 3. 野指针 4. 指针运算 5. 指针和数组 6. 二级指针 7. 指针数组 # 1 指针是什么？ 指针是变量，变量里存放的是地址，即指针就是地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-comment">//在内存中开辟一块空间</span><br><span class="hljs-type">int</span> *p = &amp;a;<span class="hljs-comment">//这里我们对变量a，取出它的地址，可以使用&amp;操作符。</span><br><span class="hljs-comment">//a变量占用4个字节的空间，这里是将a的4个字节的第一个字节的地址存放在p变量中，p就是一个之指针变量。</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong> - 指针变量是用来存放地址的，地址是唯一标示一个内存单元的。 - 指针的大小在32位平台是4个字节，在64位平台是8个字节。</p><h1 id="指针和指针类型">2 指针和指针类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *pc = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> *pi = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">short</span> *ps = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">long</span> *pl = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">float</span> *pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">double</span> *pd = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p><code>char*</code> 类型的指针是为了存放 <code>char</code> 类型变量的地址。 <code>short*</code> 类型的指针是为了存放 <code>short</code> 类型变量的地址。 <code>int*</code> 类型的指针是为了存放 <code>int</code> 类型变量的地址。</p><p>指针的大小都是4字节，或者8字节，大小都一样，那么为什么要分不同的类型，那指针类型的意义是什么？</p><h2 id="指针的解引用">2.1 指针的解引用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0x11223344</span>;<br><span class="hljs-type">char</span> *pc = &amp;n;<br><span class="hljs-type">int</span> *pi = &amp;n;<br>*pc = <span class="hljs-number">0</span>; <span class="hljs-comment">//在调试的过程中观察内存的变化。</span><br>*pi = <span class="hljs-number">0</span>; <span class="hljs-comment">//在调试的过程中观察内存的变化。</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong> 指针的类型决定了，对指针解引用的时候有多大的权限（能操作几个字节）。 比如： <code>char*</code>的指针解引用就只能访问一个字节，而<code>int*</code> 的指针的解引用就能访问四个字节。</p><h2 id="指针-整数">2.2 指针+-整数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-type">char</span> *pc = &amp;n;<br><span class="hljs-type">int</span> *pi = &amp;n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, pc);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, pc+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, pi);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, pi+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong> 指针的类型决定了指针向前或者向后走一步有多大（距离）。</p><h1 id="野指针">3 野指针</h1><blockquote><p>野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</p></blockquote><h2 id="野指针成因">3.1 野指针成因</h2><ol type="1"><li><p>指针未初始化 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> *p;<span class="hljs-comment">//局部变量指针未初始化，默认为随机值</span><br>*p = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>指针越界访问 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> *p = arr;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">11</span>; i++)<br>&#123;<br><span class="hljs-comment">//当指针指向的范围超出数组arr的范围时，p就是野指针</span><br>*p = i;<br>p++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>指针指向的空间释放 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">test</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a <span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> &amp;a;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span>* p =  test();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*p);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></p></li></ol><h2 id="如何规避野指针">3.2 如何规避野指针</h2><ol type="1"><li>指针初始化</li><li>小心指针越界</li><li>指针指向空间释放，及时置NULL</li><li>避免返回局部变量的地址</li><li>指针使用之前检查有效性</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> *p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">//....</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>p = &amp;a;<br><span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)<br>&#123;<br>*p = <span class="hljs-number">20</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="指针的运算">4 指针的运算</h1><ul><li>指针+- 整数</li><li>指针-指针</li><li>指针的关系运算</li></ul><h2 id="指针--整数">4.1 指针+- 整数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N_VALUES 5</span><br><span class="hljs-type">float</span> values[N_VALUES];<br><span class="hljs-type">float</span> *vp;<br><span class="hljs-comment">//指针+-整数；指针的关系运算</span><br><span class="hljs-keyword">for</span> (vp = &amp;values[<span class="hljs-number">0</span>]; vp &lt; &amp;values[N_VALUES];)<br>&#123;<br>*vp++ = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="指针-指针">4.2 指针-指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">my_strlen</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span><br>&#123;<br><span class="hljs-type">char</span>* start = str;<br><span class="hljs-type">char</span>* end = str;<br><span class="hljs-keyword">while</span>(*end != <span class="hljs-string">&#x27;\0&#x27;</span> )<br>&#123;<br>end++;<br>&#125;<br><span class="hljs-keyword">return</span> end-str;<br>&#125;<br></code></pre></td></tr></table></figure><p>指针－指针表示的是长度</p><h2 id="指针的关系运算">4.3 指针的关系运算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(vp = &amp;values[N_VALUES]; vp &gt; &amp;values[<span class="hljs-number">0</span>];)<br>&#123;<br>*--vp = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。</p><h1 id="指针和数组">5 指针和数组</h1><p>通过指针来访问数组 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span>* p = arr;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>*(p + i) = i;<br>&#125;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *(p + i));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="二级数组">6 二级数组</h1><p>指针变量也是变量，是变量就有地址，那指针变量的地址存放在的地方就是二级指针。 <img src="/img/C语言06-初始指针/C语言06-初始指针_D01.png" /></p><p><code>int**</code> 最右边<code>*</code> 代表 <code>ppa</code> 是一个指针，左部分<code>int*</code> 表示 <code>ppa</code> 指向的对象是一个指针。</p><h1 id="指针数组">7 指针数组</h1><p>指针数组是数组，是存放指针的数组。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> c = <span class="hljs-number">30</span>;<br><br><span class="hljs-type">int</span>* arr[<span class="hljs-number">3</span>] = &#123;&amp;a,&amp;b,&amp;c&#125;;<span class="hljs-comment">// 指针数组</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*(arr[i]));<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>C语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言05-操作符12</title>
    <link href="/2023/09/10/C%E8%AF%AD%E8%A8%8005-%E6%93%8D%E4%BD%9C%E7%AC%A612/"/>
    <url>/2023/09/10/C%E8%AF%AD%E8%A8%8005-%E6%93%8D%E4%BD%9C%E7%AC%A612/</url>
    
    <content type="html"><![CDATA[<h1 id="移位操作符">1 移位操作符</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">&lt;&lt; 左移操作符<br>&gt;&gt; 右移操作符<br>注：移位操作符的操作数只能是整数<br></code></pre></td></tr></table></figure><h2 id="左移操作符">1.1 左移操作符</h2><blockquote><p>左边抛弃、右边补0 <img src="/img/C语言05-操作符12/C语言05-操作符12.png" /> ## 1.2 右移操作符 1. 逻辑移位 左边用0填充，右边丢弃 2. 算术移位（常用） 左边用原该值的符号位填充，右边丢弃 <img src="/img/C语言05-操作符12/C语言05-操作符12_1.png" /> # 2 位操作</p></blockquote><table><thead><tr class="header"><th>符号</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr class="odd"><td>&amp;</td><td>按位与</td><td>两个位都为1时，结果才为1</td></tr><tr class="even"><td>|</td><td>按位或</td><td>两个位都为0时，结果才为0</td></tr><tr class="odd"><td>^</td><td>按位异或</td><td>两个位相同为0，相异为1</td></tr><tr class="even"><td>注：他们的操作数必须是整数。</td><td></td><td></td></tr></tbody></table><h2 id="练习1">练习1</h2><blockquote><p>不能创建临时变量（第三个变量），实现两个数的交换。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>a = a^b;<br>b = a^b;<br>a = a^b;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d b = %d\n&quot;</span>, a, b);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote><h2 id="练习2">练习2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//计数</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">32</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span>( <span class="hljs-number">1</span>==((num&gt;&gt;i)&amp;<span class="hljs-number">1</span>) )<br>count++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;二进制中1的个数 = %d\n&quot;</span>,count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单目操作符">3 单目操作符</h1><p><code>sizeof</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(a));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span> a);<span class="hljs-comment">//可以</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span> <span class="hljs-type">int</span>);<span class="hljs-comment">//不可以</span><br></code></pre></td></tr></table></figure><p><code>sizeof</code> 后面是类型时不可以省略括号。</p><p><code>~</code> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">11</span>;<br><span class="hljs-comment">// 00000000 00000000 00000000 00001011</span><br><span class="hljs-comment">// 将倒数第三位改成1：或1上去</span><br><span class="hljs-comment">// 00000000 00000000 00000000 00000100</span><br><span class="hljs-comment">// 00000000 00000000 00000000 00001111</span><br><br><span class="hljs-comment">// 00000000 00000000 00000000 00000100 可以是1向左移动两位（1&lt;&lt;2）</span><br>a = a|(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>); <span class="hljs-comment">//15</span><br><br><br><span class="hljs-comment">// 00000000 00000000 00000000 00001111 </span><br><span class="hljs-comment">// 将到时第三位变成0：按位与0</span><br><span class="hljs-comment">// 11111111 11111111 11111111 11111011</span><br><span class="hljs-comment">// 00000000 00000000 00000000 00001011</span><br><br><span class="hljs-comment">// 11111111 11111111 11111111 11111011可以是00000000 00000000 00000000 00000100 按位取反得到，00000000 00000000 00000000 00000100 可以是1向左移动两位（1&lt;&lt;2）</span><br><br>a = a&amp;(~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>)); <span class="hljs-comment">//11</span><br></code></pre></td></tr></table></figure></p><h1 id="逻辑操作符">4 逻辑操作符</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">&amp;&amp; 逻辑与<br>|| 逻辑或<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,a=<span class="hljs-number">0</span>,b=<span class="hljs-number">2</span>,c =<span class="hljs-number">3</span>,d=<span class="hljs-number">4</span>;<br>i = a++ &amp;&amp; ++b &amp;&amp; d++;<br><span class="hljs-comment">//i = a++||++b||d++;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n b = %d\n c = %d\nd = %d\n&quot;</span>, a, b, c, d);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果： 1 2 3 4 <code>a++</code> 先试用后加加，所以 <code>a++ &amp;&amp; ++b &amp;&amp; d++</code> 中 <code>a++</code> 为0，<code>&amp;&amp;</code> 左边为0 右边不管什么数都为假，不算了 ，所以<code>++b</code> 和 <code>d++</code> 都没有运算。<code>a++</code> 自增后变为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>,c =<span class="hljs-number">3</span>,d=<span class="hljs-number">4</span>;<br>i = a++||++b||d++;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n b = %d\n c = %d\nd = %d\n&quot;</span>, a, b, c, d);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果 2 2 3 4</p><h1 id="逗号表达式">5 逗号表达式</h1><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">exp1, exp2, exp3, …expN<br></code></pre></td></tr></table></figure><p>逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> c = (a&gt;b, a=b+<span class="hljs-number">10</span>, a, b=a+<span class="hljs-number">1</span>);<span class="hljs-comment">//逗号表达式</span><br></code></pre></td></tr></table></figure><p>结果 13</p><h1 id="函数调用操作符">6 函数调用操作符( )</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">get_max</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><br>&#123;<br><span class="hljs-keyword">return</span> x&gt;y?x:y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a =<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b =<span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> max = get_max(a,b);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>调用</strong>函数时候的 <code>()</code> 就是函数调用操作符,该函数操作数有三个，为<code>get_max</code> <code>a</code> <code>b</code></p><h1 id="访问一个结构的成员">7 访问一个结构的成员</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">. 结构体.成员名<br>-&gt; 结构体指针-&gt;成员名<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">char</span> id[<span class="hljs-number">20</span>];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//使用struct Stu这个类型创建了一个学生对象stu,并初始化</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span> <span class="hljs-title">stu</span> =</span> &#123;<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;20210304&quot;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stu</span>* <span class="hljs-title">ps</span> =</span> &amp;stu;<span class="hljs-comment">//结构成员访问</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,stu.name);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,ps-&gt;name);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,(*ps).name); <span class="hljs-comment">// 与ps-&gt;name相同</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言04-数组12</title>
    <link href="/2023/09/09/C%E8%AF%AD%E8%A8%8004-%E6%95%B0%E7%BB%8412/"/>
    <url>/2023/09/09/C%E8%AF%AD%E8%A8%8004-%E6%95%B0%E7%BB%8412/</url>
    
    <content type="html"><![CDATA[<h1 id="一维数组">1 一维数组</h1><h2 id="数组的创建">1.1 数组的创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">type_t</span> arr_name [const_n];<br><span class="hljs-comment">//type_t 是指数组的元素类型</span><br><span class="hljs-comment">//const_n 是一个常量表达式，用来指定数组的大小</span><br></code></pre></td></tr></table></figure><h2 id="数组的初始化">1.2 数组的初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr1[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;; <span class="hljs-comment">// 不完全初始化，剩下的元素默认为0</span><br><span class="hljs-type">int</span> arr2[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> arr3[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span>&#125;；<br><br><span class="hljs-type">char</span> arr4[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">98</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-type">char</span> arr5[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-type">char</span> arr6[] = <span class="hljs-string">&quot;abcdef&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> arr1[] = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span> arr2[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(arr1)); <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(arr2)); <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strlen</span>(arr1)); <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strlen</span>(arr2)); <span class="hljs-comment">// 随机值</span><br></code></pre></td></tr></table></figure><p><img src="/img/C语言04-数组12/C语言04-数组12_D1.png" /> <code>sizeof</code> 计算大小；<code>strlen</code> 求字符串对的长度，遇到<code>\0</code> 才停止，求得是 <code>\0</code> 前的长度。</p><h2 id="一维数组的使用">1.3 一维数组的使用</h2><p>使用下标访问 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>,arr[<span class="hljs-number">3</span>]); <span class="hljs-comment">//c</span><br></code></pre></td></tr></table></figure> ## 1.4 一维数组的存储 ==数组在内存中是连续存放的== <img src="/img/C语言04-数组12/C语言04-数组12_D2.png" /></p><h1 id="二维数组">2 二维数组</h1><h2 id="二维数组的创建">2.1 二维数组的创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]; <span class="hljs-comment">// 3行4列</span><br></code></pre></td></tr></table></figure><h2 id="二维数组的初始化">2.2 二维数组的初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;&#125;;<br><span class="hljs-type">int</span> arr[][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;&#125;;<span class="hljs-comment">//二维数组如果有初始化，行可以省略，列不能省略</span><br></code></pre></td></tr></table></figure><h2 id="二维数组的使用">2.3 二维数组的使用</h2><p>使用下标访问 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123; &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125; &#125;;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (b = <span class="hljs-number">0</span>; b &lt; <span class="hljs-number">4</span>; b++) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i][b]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="二维数组的存储">2.4 二维数组的存储</h2><p><img src="/img/C语言04-数组12/C语言04-数组12_D3.png" /></p><h1 id="数组作为函数参数">3 数组作为函数参数</h1><p>当数组传参的时候，实际上只是把数组的首元素的地址传递过去了。 所以即使在函数参数部分写成数组的形式：<code>int arr[]</code> 表示的依然是一个指针：<code>int *arr</code> 。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 冒泡排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> sz)</span><span class="hljs-comment">//参数接收数组元素个数</span><br>&#123;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; sz - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; sz - i - <span class="hljs-number">1</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-type">int</span> tmp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = tmp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span> &#125;;<br><span class="hljs-type">int</span> sz = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>bubble_sort(arr, sz);<span class="hljs-comment">//是否可以正常排序？</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; sz; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>当数组本来就是按升序的顺序，但是程序还是会一个一个比较，如何优化？使用标签判断数组是否为升序得顺序。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> sz)</span><span class="hljs-comment">//参数接收数组元素个数</span><br>&#123;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; sz - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>; <span class="hljs-comment">// 假设这一趟要排序的数据已经有序</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; sz - i - <span class="hljs-number">1</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-type">int</span> tmp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = tmp;<br>flag = <span class="hljs-number">0</span>; <span class="hljs-comment">// 本趟排序的数据其实不完全有序</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="数组名是什么">4 数组名是什么</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>，<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, arr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;arr[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *arr);<br><span class="hljs-comment">//输出结果相同</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>数组名是数组首元素的地址。但有两个例外</p><ol type="1"><li>sizeof(数组名)，计算整个数组的大小，sizeof内部单独放一个数组名，数组名表示整个数组。</li><li>&amp;数组名，取出的是整个数组的地址。&amp;数组名，数组名表示整个数组。 除此1,2两种情况之外，所有的数组名都表示数组首元素的地址。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工业蒸汽预测-05-2赛题模型验证</title>
    <link href="/2023/09/04/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-05-2%E8%B5%9B%E9%A2%98%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81/"/>
    <url>/2023/09/04/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-05-2%E8%B5%9B%E9%A2%98%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="1-模型过拟合与欠拟合"><a href="#1-模型过拟合与欠拟合" class="headerlink" title="1 模型过拟合与欠拟合"></a>1 模型过拟合与欠拟合</h1><h2 id="1-1-基础代码"><a href="#1-1-基础代码" class="headerlink" title="1.1 基础代码"></a>1.1 基础代码</h2><p>导入工具包，用于模型验证和数据处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns <span class="hljs-comment"># 可视化 用于创建各种类型的统计图形</span><br><br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats <span class="hljs-comment"># 用于统计分析</span><br><br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)<br><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression  <span class="hljs-comment">#线性回归</span><br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor  <span class="hljs-comment">#K近邻回归</span><br><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeRegressor     <span class="hljs-comment">#决策树回归</span><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor <span class="hljs-comment">#随机森林回归</span><br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVR  <span class="hljs-comment">#支持向量回归</span><br><span class="hljs-keyword">import</span> lightgbm <span class="hljs-keyword">as</span> lgb <span class="hljs-comment">#lightGbm模型</span><br><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split <span class="hljs-comment"># 切分数据</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error <span class="hljs-comment">#评价指标</span><br><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> SGDRegressor <span class="hljs-comment"># 随机梯度下降线性回归</span><br></code></pre></td></tr></table></figure><p>读取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data_file = <span class="hljs-string">&quot;./data/zhengqi_train.txt&quot;</span><br>test_data_file =  <span class="hljs-string">&quot;./data/zhengqi_test.txt&quot;</span><br><br>train_data = pd.read_csv(train_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>test_data = pd.read_csv(test_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>V0</th>      <th>V1</th>      <th>V2</th>      <th>V3</th>      <th>V4</th>      <th>V5</th>      <th>V6</th>      <th>V7</th>      <th>V8</th>      <th>V9</th>      <th>...</th>      <th>V29</th>      <th>V30</th>      <th>V31</th>      <th>V32</th>      <th>V33</th>      <th>V34</th>      <th>V35</th>      <th>V36</th>      <th>V37</th>      <th>target</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0.566</td>      <td>0.016</td>      <td>-0.143</td>      <td>0.407</td>      <td>0.452</td>      <td>-0.901</td>      <td>-1.812</td>      <td>-2.360</td>      <td>-0.436</td>      <td>-2.114</td>      <td>...</td>      <td>0.136</td>      <td>0.109</td>      <td>-0.615</td>      <td>0.327</td>      <td>-4.627</td>      <td>-4.789</td>      <td>-5.101</td>      <td>-2.608</td>      <td>-3.508</td>      <td>0.175</td>    </tr>    <tr>      <th>1</th>      <td>0.968</td>      <td>0.437</td>      <td>0.066</td>      <td>0.566</td>      <td>0.194</td>      <td>-0.893</td>      <td>-1.566</td>      <td>-2.360</td>      <td>0.332</td>      <td>-2.114</td>      <td>...</td>      <td>-0.128</td>      <td>0.124</td>      <td>0.032</td>      <td>0.600</td>      <td>-0.843</td>      <td>0.160</td>      <td>0.364</td>      <td>-0.335</td>      <td>-0.730</td>      <td>0.676</td>    </tr>    <tr>      <th>2</th>      <td>1.013</td>      <td>0.568</td>      <td>0.235</td>      <td>0.370</td>      <td>0.112</td>      <td>-0.797</td>      <td>-1.367</td>      <td>-2.360</td>      <td>0.396</td>      <td>-2.114</td>      <td>...</td>      <td>-0.009</td>      <td>0.361</td>      <td>0.277</td>      <td>-0.116</td>      <td>-0.843</td>      <td>0.160</td>      <td>0.364</td>      <td>0.765</td>      <td>-0.589</td>      <td>0.633</td>    </tr>    <tr>      <th>3</th>      <td>0.733</td>      <td>0.368</td>      <td>0.283</td>      <td>0.165</td>      <td>0.599</td>      <td>-0.679</td>      <td>-1.200</td>      <td>-2.086</td>      <td>0.403</td>      <td>-2.114</td>      <td>...</td>      <td>0.015</td>      <td>0.417</td>      <td>0.279</td>      <td>0.603</td>      <td>-0.843</td>      <td>-0.065</td>      <td>0.364</td>      <td>0.333</td>      <td>-0.112</td>      <td>0.206</td>    </tr>    <tr>      <th>4</th>      <td>0.684</td>      <td>0.638</td>      <td>0.260</td>      <td>0.209</td>      <td>0.337</td>      <td>-0.454</td>      <td>-1.073</td>      <td>-2.086</td>      <td>0.314</td>      <td>-2.114</td>      <td>...</td>      <td>0.183</td>      <td>1.078</td>      <td>0.328</td>      <td>0.418</td>      <td>-0.843</td>      <td>-0.215</td>      <td>0.364</td>      <td>-0.280</td>      <td>-0.028</td>      <td>0.384</td>    </tr>  </tbody></table><p>5 rows × 39 columns</p></div><p>归一化处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> preprocessing <br><span class="hljs-comment"># 1读取特征名</span><br>features_columns = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> train_data.columns <span class="hljs-keyword">if</span> col <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;target&#x27;</span>]]<br><span class="hljs-comment"># 2实例化</span><br>min_max_scaler = preprocessing.MinMaxScaler()<br><span class="hljs-comment"># 3训练集fit拟合</span><br>min_max_scaler = min_max_scaler.fit(train_data[features_columns])<br><span class="hljs-comment"># 4transform</span><br>train_data_scaler = min_max_scaler.transform(train_data[features_columns])<br>test_data_scaler = min_max_scaler.transform(test_data[features_columns])<br><span class="hljs-comment"># 5转dataframe-设特征列名</span><br>train_data_scaler = pd.DataFrame(train_data_scaler)<br>train_data_scaler.columns = features_columns<br><br>test_data_scaler = pd.DataFrame(test_data_scaler)<br>test_data_scaler.columns = features_columns<br><span class="hljs-comment"># 6添回target列</span><br>train_data_scaler[<span class="hljs-string">&#x27;target&#x27;</span>] = train_data[<span class="hljs-string">&#x27;target&#x27;</span>]<br></code></pre></td></tr></table></figure><p>PCA处理，特征降维</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA   <span class="hljs-comment">#主成分分析法</span><br><br><span class="hljs-comment">#PCA方法降维</span><br><span class="hljs-comment">#保留16个主成分</span><br>pca = PCA(n_components=<span class="hljs-number">16</span>)<br>new_train_pca_16 = pca.fit_transform(train_data_scaler.iloc[:,<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>])<br>new_test_pca_16 = pca.transform(test_data_scaler)<br>new_train_pca_16 = pd.DataFrame(new_train_pca_16)<br>new_test_pca_16 = pd.DataFrame(new_test_pca_16)<br>new_train_pca_16[<span class="hljs-string">&#x27;target&#x27;</span>] = train_data_scaler[<span class="hljs-string">&#x27;target&#x27;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#采用 pca 保留16维特征的数据</span><br>new_train_pca_16 = new_train_pca_16.fillna(<span class="hljs-number">0</span>)<br>train = new_train_pca_16[new_test_pca_16.columns]<br>target = new_train_pca_16[<span class="hljs-string">&#x27;target&#x27;</span>]<br><br><span class="hljs-comment"># 切分数据 训练数据80% 验证数据20%</span><br>train_data,test_data,train_target,test_target=train_test_split(train,target,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="1-2-欠拟合"><a href="#1-2-欠拟合" class="headerlink" title="1.2 欠拟合"></a>1.2 欠拟合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">clf = SGDRegressor(max_iter=<span class="hljs-number">500</span>, tol=<span class="hljs-number">1e-2</span>) <br>clf.fit(train_data, train_target)<br>score_train = mean_squared_error(train_target, clf.predict(train_data))<br>score_test = mean_squared_error(test_target, clf.predict(test_data))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor train MSE:   &quot;</span>, score_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor test MSE:   &quot;</span>, score_test)<br></code></pre></td></tr></table></figure><pre><code class="hljs">SGDRegressor train MSE:    0.15181384379355015SGDRegressor test MSE:    0.15618692974276552</code></pre><h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><p>SGDRegressor 是一种基于梯度下降的线性回归模型，使用随机梯度下降算法进行参数估计适用于大规模数据集和高维特征。<br>与传统的批量梯度下降不同，随机梯度下降每次迭代只使用一个样本或一小批样本来更新模型参数，从而减少了内存消耗和计算复杂度。</p><p>主要参数：</p><ul><li>loss: 损失函数的类型。可选参数有 ‘squared_loss’（平方损失，默认）、’huber’（Huber 损失）、’epsilon_insensitive’（ϵ-insensitive 损失）等。</li><li>penalty: 正则化项的类型。可选参数有 ‘l2’（L2 正则化，默认）、’l1’（L1 正则化）、’elasticnet’（弹性网正则化）等。</li><li>alpha: 正则化项的惩罚力度。默认为0.0001。</li><li>max_iter: 最大迭代次数。默认为1000。</li><li>learning_rate: 学习率的类型或大小。可选参数有 ‘constant’（恒定学习率）、’optimal’（最优学习率）、’invscaling’（逆标度学习率）等。</li><li>eta0: 初始学习率。默认为0.01。</li></ul><p>主要方法：</p><ul><li>fit(X, y): 使用训练数据训练模型。</li><li>predict(X): 对新的输入数据进行预测。</li><li>score(X, y): 返回模型在给定测试数据上的 R^2 分数。</li></ul><p>在 SGDRegressor 中，<code>tol</code> 是用来控制迭代的停止条件的参数。tol（tolerance）表示容忍度，即当损失函数的变化小于 tol 时，算法会停止迭代。<code>tol=1e-2</code> 表示容忍度为 0.01。也就是说，当连续两次迭代的损失函数值之差小于 0.01 时，算法会认为模型已经收敛，并且提前结束迭代，不再继续优化。</p><h2 id="1-3-过拟合"><a href="#1-3-过拟合" class="headerlink" title="1.3 过拟合"></a>1.3 过拟合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> PolynomialFeatures <span class="hljs-comment"># 用于进行多项式特征转换。</span><br>poly = PolynomialFeatures(<span class="hljs-number">5</span>)<br>train_data_poly = poly.fit_transform(train_data)<br>test_data_poly = poly.transform(test_data)<br>clf = SGDRegressor(max_iter=<span class="hljs-number">1000</span>, tol=<span class="hljs-number">1e-3</span>) <br>clf.fit(train_data_poly, train_target)<br>score_train = mean_squared_error(train_target, clf.predict(train_data_poly))<br>score_test = mean_squared_error(test_target, clf.predict(test_data_poly))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor train MSE:   &quot;</span>, score_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor test MSE:   &quot;</span>, score_test)<br></code></pre></td></tr></table></figure><pre><code class="hljs">SGDRegressor train MSE:    0.13208128238186503SGDRegressor test MSE:    0.14458655217709998</code></pre><h2 id="1-4正常拟合"><a href="#1-4正常拟合" class="headerlink" title="1.4正常拟合"></a>1.4正常拟合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> PolynomialFeatures<br>poly = PolynomialFeatures(<span class="hljs-number">3</span>)<br>train_data_poly = poly.fit_transform(train_data)<br>test_data_poly = poly.transform(test_data)<br>clf = SGDRegressor(max_iter=<span class="hljs-number">1000</span>, tol=<span class="hljs-number">1e-3</span>) <br>clf.fit(train_data_poly, train_target)<br>score_train = mean_squared_error(train_target, clf.predict(train_data_poly))<br>score_test = mean_squared_error(test_target, clf.predict(test_data_poly))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor train MSE:   &quot;</span>, score_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor test MSE:   &quot;</span>, score_test)<br></code></pre></td></tr></table></figure><pre><code class="hljs">SGDRegressor train MSE:    0.13419513490030407SGDRegressor test MSE:    0.14274747547356217</code></pre><h4 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h4><p><code>PolynomialFeatures</code> 是 scikit-learn（sklearn）库中的一个预处理类，用于生成多项式特征。它可以将原始特征转换为高阶多项式特征，从而扩展特征空间，使模型能够更好地拟合非线性关系。</p><p><code>PolynomialFeatures</code> 的主要作用是通过对原始特征进行多项式扩展，引入多项式交互项，从而增加模型的表示能力。对于给定的一组原始特征 x1, x2, …, xn，<code>PolynomialFeatures</code> 将创建由这些特征的所有可能的多项式组合组成的新特征矩阵。</p><p><code>PolynomialFeatures</code> 可以生成包括以下几种特征的多项式：</p><ul><li>指数项：x^d （d 为指定的度数）</li><li>交叉项：x1^i <em> x2^j </em> … * xn^k （i + j + … + k 不大于指定的度数）</li></ul><p>使用 <code>PolynomialFeatures</code> 的步骤如下：</p><ol><li>创建 <code>PolynomialFeatures</code> 实例，并指定所需的度数。</li><li>使用 <code>fit_transform</code> 方法将原始特征数据集转换为多项式特征数据集。</li></ol><h1 id="2-模型正则化"><a href="#2-模型正则化" class="headerlink" title="2 模型正则化"></a>2 模型正则化</h1><p>正则化(Regularization)是给需要训练的目标函数加上一些规则（限制），目的是为了防止过拟合。</p><h2 id="2-1-L2范数正则化"><a href="#2-1-L2范数正则化" class="headerlink" title="2.1 L2范数正则化"></a>2.1 L2范数正则化</h2><script type="math/tex; mode=display">\parallel x\parallel_2=\left(\sum_{i=1}^n\mid x_i\mid^2\right)^{\frac{1}{2}}</script><p>又叫欧几里得(Euclid)范数，即向量元素绝对值平方和再进行开方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">poly = PolynomialFeatures(<span class="hljs-number">3</span>)<br>train_data_poly = poly.fit_transform(train_data)<br>test_data_poly = poly.transform(test_data)<br>clf = SGDRegressor(max_iter=<span class="hljs-number">1000</span>, tol=<span class="hljs-number">1e-3</span>, penalty= <span class="hljs-string">&#x27;L2&#x27;</span>, alpha=<span class="hljs-number">0.0001</span>) <br>clf.fit(train_data_poly, train_target)<br>score_train = mean_squared_error(train_target, clf.predict(train_data_poly))<br>score_test = mean_squared_error(test_target, clf.predict(test_data_poly))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor train MSE:   &quot;</span>, score_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor test MSE:   &quot;</span>, score_test)<br></code></pre></td></tr></table></figure><pre><code class="hljs">SGDRegressor train MSE:    0.13432119501674716SGDRegressor test MSE:    0.1426776204742311</code></pre><h2 id="2-2-L1范数正则化"><a href="#2-2-L1范数正则化" class="headerlink" title="2.2 L1范数正则化"></a>2.2 L1范数正则化</h2><script type="math/tex; mode=display">\parallel x\parallel_1=\sum_{i=1}^N\mid x_i\mid</script><p>即向量元素绝对值之和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">poly = PolynomialFeatures(<span class="hljs-number">3</span>)<br>train_data_poly = poly.fit_transform(train_data)<br>test_data_poly = poly.transform(test_data)<br>clf = SGDRegressor(max_iter=<span class="hljs-number">1000</span>, tol=<span class="hljs-number">1e-3</span>, penalty= <span class="hljs-string">&#x27;L1&#x27;</span>, alpha=<span class="hljs-number">0.00001</span>) <br>clf.fit(train_data_poly, train_target)<br>score_train = mean_squared_error(train_target, clf.predict(train_data_poly))<br>score_test = mean_squared_error(test_target, clf.predict(test_data_poly))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor train MSE:   &quot;</span>, score_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor test MSE:   &quot;</span>, score_test)<br></code></pre></td></tr></table></figure><pre><code class="hljs">SGDRegressor train MSE:    0.133943411262935SGDRegressor test MSE:    0.14229842600351</code></pre><h2 id="2-3-ElasticNet-联合-L1和L2范数加权正则化"><a href="#2-3-ElasticNet-联合-L1和L2范数加权正则化" class="headerlink" title="2.3 ElasticNet 联合 L1和L2范数加权正则化"></a>2.3 ElasticNet 联合 L1和L2范数加权正则化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">poly = PolynomialFeatures(<span class="hljs-number">3</span>)<br>train_data_poly = poly.fit_transform(train_data)<br>test_data_poly = poly.transform(test_data)<br>clf = SGDRegressor(max_iter=<span class="hljs-number">1000</span>, tol=<span class="hljs-number">1e-3</span>, penalty= <span class="hljs-string">&#x27;elasticnet&#x27;</span>, l1_ratio=<span class="hljs-number">0.9</span>, alpha=<span class="hljs-number">0.00001</span>) <br>clf.fit(train_data_poly, train_target)<br>score_train = mean_squared_error(train_target, clf.predict(train_data_poly))<br>score_test = mean_squared_error(test_target, clf.predict(test_data_poly))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor train MSE:   &quot;</span>, score_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor test MSE:   &quot;</span>, score_test)<br></code></pre></td></tr></table></figure><pre><code class="hljs">SGDRegressor train MSE:    0.13408335184518458SGDRegressor test MSE:    0.1427094727208378</code></pre><h4 id="代码解释-2"><a href="#代码解释-2" class="headerlink" title="代码解释"></a>代码解释</h4><ol><li><p><code>elasticnet</code>：是 <code>SGDRegressor</code> 的正则化方法之一。Elastic Net 是一种结合了 L1 正则化（Lasso）和 L2 正则化（Ridge）的线性回归模型正则化方法。通过引入两种正则化项，Elastic Net 可以在处理高维数据时具有特征选择的能力，并且可以克服 Lasso 存在的某些限制。默认情况下，<code>penalty</code> 参数被设置为 <code>&#39;l2&#39;</code>，即使用 L2 正则化；而设置为 <code>&#39;elasticnet&#39;</code> 则表示同时使用 L1 和 L2 正则化。</p></li><li><p><code>l1_ratio</code>：这是 Elastic Net 的混合参数，取值范围为 0 到 1 之间。它控制着 L1 正则化在 Elastic Net 中的比例。当 <code>l1_ratio</code> 为 0 时，相当于只使用 L2 正则化，而当 <code>l1_ratio</code> 为 1 时，相当于只使用 L1 正则化。在 0 和 1 之间的值表示混合使用两种正则化方法。在给定的示例中，<code>l1_ratio=0.9</code> 表示 Elastic Net 正则化主要使用 L1 正则化，较少使用 L2 正则化。</p></li></ol><h1 id="3-模型交叉验证"><a href="#3-模型交叉验证" class="headerlink" title="3 模型交叉验证"></a>3 模型交叉验证</h1><h2 id="3-1-简单交叉验证-Hold-out-menthod"><a href="#3-1-简单交叉验证-Hold-out-menthod" class="headerlink" title="3.1 简单交叉验证 Hold-out-menthod"></a>3.1 简单交叉验证 Hold-out-menthod</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 简单交叉验证</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split <span class="hljs-comment"># 切分数据</span><br><span class="hljs-comment"># 切分数据 训练数据80% 验证数据20%</span><br>train_data,test_data,train_target,test_target=train_test_split(train,target,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">0</span>)<br><br>clf = SGDRegressor(max_iter=<span class="hljs-number">1000</span>, tol=<span class="hljs-number">1e-3</span>) <br>clf.fit(train_data, train_target)<br>score_train = mean_squared_error(train_target, clf.predict(train_data))<br>score_test = mean_squared_error(test_target, clf.predict(test_data))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor train MSE:   &quot;</span>, score_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SGDRegressor test MSE:   &quot;</span>, score_test)<br></code></pre></td></tr></table></figure><pre><code class="hljs">SGDRegressor train MSE:    0.1415940546797717SGDRegressor test MSE:    0.14689229408278165</code></pre><h2 id="3-2-K折交叉验证-K-fold-CV"><a href="#3-2-K折交叉验证-K-fold-CV" class="headerlink" title="3.2 K折交叉验证 K-fold CV"></a>3.2 K折交叉验证 K-fold CV</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 5折交叉验证</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> KFold<br><br>kf = KFold(n_splits=<span class="hljs-number">5</span>)<br><span class="hljs-keyword">for</span> k, (train_index, test_index) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(kf.split(train)):<br>    train_data,test_data,train_target,test_target = train.values[train_index],train.values[test_index],target[train_index],target[test_index]<br>    clf = SGDRegressor(max_iter=<span class="hljs-number">1000</span>, tol=<span class="hljs-number">1e-3</span>) <br>    clf.fit(train_data, train_target)<br>    score_train = mean_squared_error(train_target, clf.predict(train_data))<br>    score_test = mean_squared_error(test_target, clf.predict(test_data))<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-string">&quot; 折&quot;</span>, <span class="hljs-string">&quot;SGDRegressor train MSE:   &quot;</span>, score_train)<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-string">&quot; 折&quot;</span>, <span class="hljs-string">&quot;SGDRegressor test MSE:   &quot;</span>, score_test, <span class="hljs-string">&#x27;\n&#x27;</span>)  <br></code></pre></td></tr></table></figure><pre><code class="hljs">0  折 SGDRegressor train MSE:    0.14991376582970440  折 SGDRegressor test MSE:    0.1065473927176582 1  折 SGDRegressor train MSE:    0.133570245500077481  折 SGDRegressor test MSE:    0.1816447571392363 2  折 SGDRegressor train MSE:    0.146459817485191072  折 SGDRegressor test MSE:    0.13268383953043347 3  折 SGDRegressor train MSE:    0.14064258830208853  折 SGDRegressor test MSE:    0.16206427864796086 4  折 SGDRegressor train MSE:    0.13877779624613174  折 SGDRegressor test MSE:    0.16600911704035512 </code></pre><p>​    </p><h4 id="代码详解-KFold函数"><a href="#代码详解-KFold函数" class="headerlink" title="代码详解 -KFold函数"></a>代码详解 -<code>KFold</code>函数</h4><p><code>KFold</code> 是 scikit-learn 库中的一个交叉验证方法，用于划分数据集为 k 折，并生成相应的训练集和测试集索引。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sklearn.model_selection.KFold(n_splits, shuffle=<span class="hljs-literal">False</span>, random_state=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>n_splits</code>：表示将数据集划分为几个折（即 k 值），默认为 5。</li><li><code>shuffle</code>（可选）：表示是否在划分之前对数据进行洗牌，默认为 False。如果设置为 True，则会在划分之前对数据进行洗牌以打乱顺序。</li><li><code>random_state</code>（可选）：表示随机数种子，用于指定洗牌时的随机性。设置相同的随机数种子可以保证每次划分的结果一致。</li></ul><p>常用方法和属性：</p><ul><li><code>split(X[, y, groups])</code>：返回一个生成器对象，用于生成每个折的训练集和测试集索引。</li><li><code>get_n_splits([X, y, groups])</code>：返回划分的折数（即 k 值）。</li></ul><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> KFold<br><br><span class="hljs-comment"># 创建一个 KFold 对象</span><br>kf = KFold(n_splits=<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 模拟一个数据集</span><br>data = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>])<br><br><span class="hljs-comment"># 使用 KFold 进行划分</span><br><span class="hljs-keyword">for</span> train_index, test_index <span class="hljs-keyword">in</span> kf.split(data):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Train:&quot;</span>, train_index, <span class="hljs-string">&quot;Test:&quot;</span>, test_index)<br>    <br><span class="hljs-keyword">for</span> train_i,test_i <span class="hljs-keyword">in</span> kf.split(data):<br>    <span class="hljs-built_in">print</span>(data[train_i],data[test_i])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---------&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tap">Train: [2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>6<span class="hljs-number"> 7 </span>8 9] Test: [0 1]<br>Train: [0<span class="hljs-number"> 1 </span>4<span class="hljs-number"> 5 </span>6<span class="hljs-number"> 7 </span>8 9] Test: [2 3]<br>Train: [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>6<span class="hljs-number"> 7 </span>8 9] Test: [4 5]<br>Train: [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>8 9] Test: [6 7]<br>Train: [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>6 7] Test: [8 9]<br><br>[3 <span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span>10] [1 2]<br>------<span class="language-yaml"><span class="hljs-meta">---</span></span><br><span class="language-yaml">[<span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span>] [<span class="hljs-number">3</span> <span class="hljs-number">4</span>]</span><br><span class="language-yaml"><span class="hljs-string">---------</span></span><br><span class="language-yaml">[<span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span>] [<span class="hljs-number">5</span> <span class="hljs-number">6</span>]</span><br><span class="language-yaml"><span class="hljs-string">---------</span></span><br><span class="language-yaml">[<span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span>] [<span class="hljs-number">7</span> <span class="hljs-number">8</span>]</span><br><span class="language-yaml"><span class="hljs-string">---------</span></span><br><span class="language-yaml">[<span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>] [<span class="hljs-number">9</span> <span class="hljs-number">10</span>]</span><br><span class="language-yaml"><span class="hljs-string">---------</span></span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们先创建了一个 <code>KFold</code> 对象 <code>kf</code>，将数据集 <code>data</code> 划分为 5 折交叉验证。然后，在循环中，我们使用 <code>kf.split(data)</code> 生成了每个折的训练集索引 <code>train_index</code> 和测试集索引 <code>test_index</code>。通过打印这些索引，我们可以看到每个折的训练集和测试集索引。</p><h4 id="代码详解-enumerate函数"><a href="#代码详解-enumerate函数" class="headerlink" title="代码详解 -enumerate函数"></a>代码详解 -<code>enumerate</code>函数</h4><p>用于将一个可迭代对象转换为一个枚举对象。它返回一个包含索引和元素的元组的迭代器。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">enumerate</span>(iterable, start=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ul><li><code>iterable</code>：表示要进行枚举的可迭代对象，可以是列表、元组、字符串、集合等。</li><li><code>start</code>（可选）：表示索引的起始值，默认为 0。</li></ul><p>当对一个可迭代对象使用 <code>enumerate</code> 函数时，它会返回一个生成器对象，每次迭代都会产生一个元组 <code>(index, element)</code>，其中 <code>index</code> 是当前元素的索引，从 <code>start</code> 开始递增，<code>element</code> 是对应的元素。</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>]<br><br><span class="hljs-keyword">for</span> index, fruit <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fruits):<br>    <span class="hljs-built_in">print</span>(index, fruit)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>apple<br><span class="hljs-symbol">1 </span>banana<br><span class="hljs-symbol">2 </span>orange<br></code></pre></td></tr></table></figure><p>在例子中，我们使用 <code>enumerate</code> 对列表 <code>fruits</code> 进行枚举。在每次迭代中，<code>index</code> 表示元素的索引，<code>fruit</code> 表示对应的水果名称。通过打印 <code>index</code> 和 <code>fruit</code>，我们可以看到每个元素的索引和对应的水果名称。</p><h2 id="3-3-留一法-LOO-CV"><a href="#3-3-留一法-LOO-CV" class="headerlink" title="3.3 留一法 LOO CV"></a>3.3 留一法 LOO CV</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> LeaveOneOut<br>loo = LeaveOneOut()<br><span class="hljs-comment"># num = 100</span><br><span class="hljs-keyword">for</span> k, (train_index, test_index) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(loo.split(train)):<br>    train_data,test_data,train_target,test_target = train.values[train_index],train.values[test_index],target[train_index],target[test_index]<br>    clf = SGDRegressor(max_iter=<span class="hljs-number">1000</span>, tol=<span class="hljs-number">1e-3</span>) <br>    clf.fit(train_data, train_target)<br>    score_train = mean_squared_error(train_target, clf.predict(train_data))<br>    score_test = mean_squared_error(test_target, clf.predict(test_data))<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-string">&quot; 个&quot;</span>, <span class="hljs-string">&quot;SGDRegressor train MSE:   &quot;</span>, score_train)<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-string">&quot; 个&quot;</span>, <span class="hljs-string">&quot;SGDRegressor test MSE:   &quot;</span>, score_test, <span class="hljs-string">&#x27;\n&#x27;</span>) <br>    <span class="hljs-keyword">if</span> k &gt;= <span class="hljs-number">9</span>: <span class="hljs-comment"># k 大于等于 9时停止迭代</span><br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0  个 SGDRegressor train MSE:    0.141546780867300240  个 SGDRegressor test MSE:    0.012065815413407692 1  个 SGDRegressor train MSE:    0.141553108073661451  个 SGDRegressor test MSE:    0.1284070906104496 2  个 SGDRegressor train MSE:    0.14161468832938472  个 SGDRegressor test MSE:    0.039426047577402645 3  个 SGDRegressor train MSE:    0.14158636002829943  个 SGDRegressor test MSE:    0.003415838580474376 4  个 SGDRegressor train MSE:    0.141625299307162144  个 SGDRegressor test MSE:    0.011115946286888823 5  个 SGDRegressor train MSE:    0.14158816415152145  个 SGDRegressor test MSE:    0.13704136603528533 6  个 SGDRegressor train MSE:    0.141575967999929086  个 SGDRegressor test MSE:    0.02376598173602542 7  个 SGDRegressor train MSE:    0.141562272727730787  个 SGDRegressor test MSE:    0.0007635271707761818 8  个 SGDRegressor train MSE:    0.141506806047967958  个 SGDRegressor test MSE:    0.08992065000952423 9  个 SGDRegressor train MSE:    0.14160090754879879  个 SGDRegressor test MSE:    0.05042063473393335 </code></pre><p>​    </p><h2 id="3-4-留P法-LPO-CV"><a href="#3-4-留P法-LPO-CV" class="headerlink" title="3.4 留P法 LPO CV"></a>3.4 留P法 LPO CV</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> LeavePOut<br>lpo = LeavePOut(p=<span class="hljs-number">10</span>)<br><span class="hljs-comment"># num = 100</span><br><span class="hljs-keyword">for</span> k, (train_index, test_index) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lpo.split(train)):<br>    train_data,test_data,train_target,test_target = train.values[train_index],train.values[test_index],target[train_index],target[test_index]<br>    clf = SGDRegressor(max_iter=<span class="hljs-number">1000</span>, tol=<span class="hljs-number">1e-3</span>) <br>    clf.fit(train_data, train_target)<br>    score_train = mean_squared_error(train_target, clf.predict(train_data))<br>    score_test = mean_squared_error(test_target, clf.predict(test_data))<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-string">&quot; 10个&quot;</span>, <span class="hljs-string">&quot;SGDRegressor train MSE:   &quot;</span>, score_train)<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-string">&quot; 10个&quot;</span>, <span class="hljs-string">&quot;SGDRegressor test MSE:   &quot;</span>, score_test, <span class="hljs-string">&#x27;\n&#x27;</span>) <br>    <span class="hljs-keyword">if</span> k &gt;= <span class="hljs-number">9</span>: <span class="hljs-comment"># k 大于等于 9时停止迭代。</span><br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0  10个 SGDRegressor train MSE:    0.141889978413670930  10个 SGDRegressor test MSE:    0.04891057028963159 1  10个 SGDRegressor train MSE:    0.141926144064349341  10个 SGDRegressor test MSE:    0.04448387541119956 2  10个 SGDRegressor train MSE:    0.142041560405937432  10个 SGDRegressor test MSE:    0.046971875220281685 3  10个 SGDRegressor train MSE:    0.141955287285203123  10个 SGDRegressor test MSE:    0.05454716320716613 4  10个 SGDRegressor train MSE:    0.141800440486467734  10个 SGDRegressor test MSE:    0.06895314629502325 5  10个 SGDRegressor train MSE:    0.142028464701305375  10个 SGDRegressor test MSE:    0.04503516030552096 6  10个 SGDRegressor train MSE:    0.14197201266374076  10个 SGDRegressor test MSE:    0.04910967979051496 7  10个 SGDRegressor train MSE:    0.142012173758312077  10个 SGDRegressor test MSE:    0.052842266808938575 8  10个 SGDRegressor train MSE:    0.141904218140746778  10个 SGDRegressor test MSE:    0.04721338466918536 9  10个 SGDRegressor train MSE:    0.142054682505133349  10个 SGDRegressor test MSE:    0.045801703647200806 </code></pre><p>​    </p><h4 id="留P交叉验证-和-K折交叉验证"><a href="#留P交叉验证-和-K折交叉验证" class="headerlink" title="留P交叉验证 和 K折交叉验证"></a>留P交叉验证 和 K折交叉验证</h4><p>区别和特点如下：</p><ul><li>样本划分：留 P 交叉验证按照固定数量 P 的样本划分为测试集，剩余的样本为训练集；K 折交叉验证按照 K 个折的划分将数据集划分为测试集和训练集。</li><li>迭代次数：留 P 交叉验证的迭代次数取决于样本组合的可能性，通常较大；K 折交叉验证的迭代次数为 K，通常较小。</li><li>样本重复：留 P 交叉验证每个样本只出现一次作为测试集，可能会有样本重复出现在训练集中；K 折交叉验证每个样本会被分到不同的训练集和测试集中，避免了样本的重复。</li></ul><h1 id="4模型超参空间及调参"><a href="#4模型超参空间及调参" class="headerlink" title="4模型超参空间及调参"></a>4模型超参空间及调参</h1><h2 id="4-1穷举网格搜索"><a href="#4-1穷举网格搜索" class="headerlink" title="4.1穷举网格搜索"></a>4.1穷举网格搜索</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用数据训练随机森林模型，采用网格搜索方法调参</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV <span class="hljs-comment"># 网格搜索</span><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split <span class="hljs-comment"># 切分数据</span><br><span class="hljs-comment"># 切分数据 训练数据80% 验证数据20%</span><br>train_data,test_data,train_target,test_target=train_test_split(train,target,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">0</span>)<br><br>randomForestRegressor = RandomForestRegressor()<br>parameters = &#123;<br>              <span class="hljs-string">&#x27;n_estimators&#x27;</span>:[<span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>],<br>              <span class="hljs-string">&#x27;max_depth&#x27;</span>:[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>        &#125;<br><br>clf = GridSearchCV(randomForestRegressor, parameters, cv=<span class="hljs-number">5</span>) <span class="hljs-comment"># cv对train_data使用 5 折交叉验证</span><br>clf.fit(train_data, train_target)<br><br>score_test = mean_squared_error(test_target, clf.predict(test_data))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;RandomForestRegressor GridSearchCV test MSE:   &quot;</span>, score_test)<br><span class="hljs-built_in">sorted</span>(clf.cv_results_.keys())<br></code></pre></td></tr></table></figure><pre><code class="hljs">RandomForestRegressor GridSearchCV test MSE:    0.2580339125452081[&#39;mean_fit_time&#39;, &#39;mean_score_time&#39;, &#39;mean_test_score&#39;, &#39;param_max_depth&#39;, &#39;param_n_estimators&#39;, &#39;params&#39;, &#39;rank_test_score&#39;, &#39;split0_test_score&#39;, &#39;split1_test_score&#39;, &#39;split2_test_score&#39;, &#39;split3_test_score&#39;, &#39;split4_test_score&#39;, &#39;std_fit_time&#39;, &#39;std_score_time&#39;, &#39;std_test_score&#39;]</code></pre><h4 id="代码解释-3"><a href="#代码解释-3" class="headerlink" title="代码解释"></a>代码解释</h4><ol><li>GridSearchCV()</li></ol><p><code>GridSearchCV</code> 是一个用于进行网格搜索的类，可以用于参数调优和模型选择。</p><p>网格搜索是指将所有可能的参数组合都尝试一遍，并对每组参数进行评估。通过设置参数范围和步长等信息，我们可以控制参数搜索的规模。</p><p>下面是使用 <code>GridSearchCV</code> 的一般流程：</p><ol><li>导入 <code>GridSearchCV</code> 类和要使用的模型类。</li><li>定义要搜索的参数空间（通常是一个字典）。</li><li>创建模型对象。</li><li>创建 <code>GridSearchCV</code> 对象，传入模型对象、参数空间和其他参数（例如交叉验证的折数）。</li><li>使用 <code>fit</code> 方法拟合数据，并进行网格搜索和交叉验证。</li><li>可以通过 <code>best_params_</code> 属性查看最佳参数组合。</li><li>可以通过 <code>best_score_</code> 属性查看最佳参数组合的得分。</li><li>可以通过 <code>cv_results_</code> 属性查看所有参数组合的详细结果。</li></ol><hr><ol><li><code>clf.cv_results_.keys()</code> </li></ol><p>是一个列表，该列表返回字典 <code>clf.cv_results_</code> 中所有的键。<code>clf.cv_results_</code> 包含了网格搜索过程中的详细结果，包括每组参数组合的得分、训练时间等信息。</p><p>通过执行 <code>clf.cv_results_.keys()</code>，你将会得到一个列表，其中包含了所有的键。这个列表提供了一个快速查看可用键的方式。</p><p>常见的一些键可能包括：</p><ul><li><code>&#39;mean_fit_time&#39;</code>：每个参数组合的平均训练时间。</li><li><code>&#39;mean_score_time&#39;</code>：每个参数组合的平均预测时间。</li><li><code>&#39;mean_test_score&#39;</code>：每个参数组合在交叉验证的测试集上的平均得分。</li><li><code>&#39;param_XXX&#39;</code>：参数 <code>XXX</code> 的值（例如，如果有参数 <code>&#39;n_estimators&#39;</code>，则会出现 <code>&#39;param_n_estimators&#39;</code>）。</li><li><code>&#39;rank_test_score&#39;</code>：每个参数组合在交叉验证中的得分排名。</li><li><code>&#39;splitX_test_score&#39;</code>：第 X 折交叉验证中每个参数组合的得分。</li></ul><p>这些指标在模型分析中十分重要，可以查找到整个建模过程中可能的异常</p><p><code>sorted(clf.cv_results_.keys())</code> 按字母顺序排序并打印出 clf.cv<em>results</em> 字典中的键.</p><h2 id="4-2-随机参数优化"><a href="#4-2-随机参数优化" class="headerlink" title="4.2 随机参数优化"></a>4.2 随机参数优化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用数据训练随机森林模型，采用随机参数优化方法调参</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> RandomizedSearchCV<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split <span class="hljs-comment"># 切分数据</span><br><span class="hljs-comment"># 切分数据 训练数据80% 验证数据20%</span><br>train_data,test_data,train_target,test_target=train_test_split(train,target,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">0</span>)<br><br>randomForestRegressor = RandomForestRegressor()<br>parameters = &#123;<br>              <span class="hljs-string">&#x27;n_estimators&#x27;</span>:[<span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>],<br>              <span class="hljs-string">&#x27;max_depth&#x27;</span>:[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>        &#125;<br><br>clf = RandomizedSearchCV(randomForestRegressor, parameters, cv=<span class="hljs-number">5</span>)<br>clf.fit(train_data, train_target)<br><br>score_test = mean_squared_error(test_target, clf.predict(test_data))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;RandomForestRegressor RandomizedSearchCV test MSE:   &quot;</span>, score_test)<br><span class="hljs-built_in">sorted</span>(clf.cv_results_.keys())<br></code></pre></td></tr></table></figure><pre><code class="hljs">RandomForestRegressor RandomizedSearchCV test MSE:    0.19466233629207197[&#39;mean_fit_time&#39;, &#39;mean_score_time&#39;, &#39;mean_test_score&#39;, &#39;param_max_depth&#39;, &#39;param_n_estimators&#39;, &#39;params&#39;, &#39;rank_test_score&#39;, &#39;split0_test_score&#39;, &#39;split1_test_score&#39;, &#39;split2_test_score&#39;, &#39;split3_test_score&#39;, &#39;split4_test_score&#39;, &#39;std_fit_time&#39;, &#39;std_score_time&#39;, &#39;std_test_score&#39;]</code></pre><h4 id="代码解释-4"><a href="#代码解释-4" class="headerlink" title="代码解释"></a>代码解释</h4><p><code>RandomizedSearchCV</code> 是一个用于进行随机搜索的类，与 <code>GridSearchCV</code> 类似，它也可以用于参数调优和模型选择。</p><p>与网格搜索不同的是，随机搜索并不尝试所有可能的参数组合。相反，它从参数空间中随机抽样一组参数，并对每组参数进行评估。通过设置抽样的次数，我们可以控制随机搜索的规模。</p><p>下面是使用 <code>RandomizedSearchCV</code> 的一般流程：</p><ol><li>导入 <code>RandomizedSearchCV</code> 类和要使用的模型类。</li><li>定义要搜索的参数空间。可以使用分布函数（如均匀分布、正态分布），也可以使用指定的参数列表。</li><li>创建模型对象。</li><li>创建 <code>RandomizedSearchCV</code> 对象，传入模型对象、参数空间和其他参数（例如交叉验证的折数）。</li><li>使用 <code>fit</code> 方法拟合数据，并进行随机搜索和交叉验证。</li><li>可以通过 <code>best_params_</code> 属性查看最佳参数组合。</li><li>可以通过 <code>best_score_</code> 属性查看最佳参数组合的得分。</li><li>可以通过 <code>cv_results_</code> 属性查看所有参数组合的详细结果。</li></ol><h2 id="4-3-Lgb-调参"><a href="#4-3-Lgb-调参" class="headerlink" title="4.3 Lgb 调参"></a>4.3 Lgb 调参</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用数据训练LGB模型，采用网格搜索方法调参</span><br><br>clf = lgb.LGBMRegressor(num_leaves=<span class="hljs-number">31</span>)<br><br>parameters = &#123;<br>  <br>    <span class="hljs-string">&#x27;learning_rate&#x27;</span>: [<span class="hljs-number">0.01</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1</span>],<br>    <span class="hljs-string">&#x27;n_estimators&#x27;</span>: [<span class="hljs-number">20</span>, <span class="hljs-number">40</span>]<br>    <br>&#125;<br><br>clf = GridSearchCV(clf, parameters, cv=<span class="hljs-number">5</span>)<br>clf.fit(train_data, train_target)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Best parameters found by grid search are:&#x27;</span>, clf.best_params_)<br>score_test = mean_squared_error(test_target, clf.predict(test_data))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LGBMRegressor RandomizedSearchCV test MSE:   &quot;</span>, score_test)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Best parameters found by grid search are: &#123;&#39;learning_rate&#39;: 0.1, &#39;n_estimators&#39;: 40&#125;LGBMRegressor RandomizedSearchCV test MSE:    0.1521115918778782</code></pre><h2 id="4-4-Lgb-线下验证"><a href="#4-4-Lgb-线下验证" class="headerlink" title="4.4 Lgb 线下验证"></a>4.4 Lgb 线下验证</h2><p>下面进行数据建模、5折交叉验证、划分数据、对LGB模型进行训练、计算MSE评价性能等流程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data2 = pd.read_csv(<span class="hljs-string">&#x27;./data/zhengqi_train.txt&#x27;</span>,sep=<span class="hljs-string">&#x27;\t&#x27;</span>)<br>test_data2 = pd.read_csv(<span class="hljs-string">&#x27;./data/zhengqi_test.txt&#x27;</span>,sep=<span class="hljs-string">&#x27;\t&#x27;</span>)<br><br>train_data2_feature = train_data2[test_data2.columns].values<br>train_data2_target = train_data2[<span class="hljs-string">&#x27;target&#x27;</span>].values<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># lgb 模型</span><br><span class="hljs-keyword">from</span> sklearn.model_selection  <span class="hljs-keyword">import</span> KFold<br><span class="hljs-keyword">import</span> lightgbm <span class="hljs-keyword">as</span> lgb<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-comment"># 5折交叉验证</span><br>Folds=<span class="hljs-number">5</span><br>kf = KFold( n_splits=Folds, random_state=<span class="hljs-number">100</span>, shuffle=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 记录训练和预测MSE</span><br>MSE_DICT = &#123;<br>    <span class="hljs-string">&#x27;train_mse&#x27;</span>:[],<br>    <span class="hljs-string">&#x27;test_mse&#x27;</span>:[]<br>&#125;<br><br><span class="hljs-comment"># 线下训练预测</span><br><span class="hljs-keyword">for</span> i, (train_index, test_index) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(kf.split(train_data2_feature)):<br>    <span class="hljs-comment"># lgb树模型</span><br>    lgb_reg = lgb.LGBMRegressor(<br>        learning_rate=<span class="hljs-number">0.01</span>,<br>        max_depth=-<span class="hljs-number">1</span>,<br>        n_estimators=<span class="hljs-number">100</span>,<br>        boosting_type=<span class="hljs-string">&#x27;gbdt&#x27;</span>,<br>        random_state=<span class="hljs-number">100</span>,<br>        objective=<span class="hljs-string">&#x27;regression&#x27;</span>,<br>    )<br>   <br>    <span class="hljs-comment"># 切分训练集和预测集</span><br>    X_train_KFold, X_test_KFold = train_data2_feature[train_index], train_data2_feature[test_index] <span class="hljs-comment"># 划分出训练集和测试集的特征</span><br>    y_train_KFold, y_test_KFold = train_data2_target[train_index], train_data2_target[test_index] <span class="hljs-comment"># 划分出训练集和测试集的标签</span><br>    <br>    <span class="hljs-comment"># 训练模型</span><br><span class="hljs-comment">#     reg.fit(X_train_KFold, y_train_KFold)</span><br>    lgb_reg.fit(<br>            X=X_train_KFold,y=y_train_KFold,<br>            eval_set=[(X_train_KFold, y_train_KFold),(X_test_KFold, y_test_KFold)],<br>            eval_names=[<span class="hljs-string">&#x27;Train&#x27;</span>,<span class="hljs-string">&#x27;Test&#x27;</span>],<br>            <span class="hljs-comment"># early_stopping_round=100, # 参数已弃用,通过“callbacks”参数传递回调</span><br>            <span class="hljs-comment"># verbose=50, # 参数已弃用,通过“callbacks”参数传递回调</span><br>            eval_metric=<span class="hljs-string">&#x27;MSE&#x27;</span>,<span class="hljs-comment"># 设置评估指标eval_metric，这里使用均方误差（MSE）</span><br>            callbacks=[lgb.log_evaluation(period=<span class="hljs-number">100</span>), lgb.early_stopping(stopping_rounds=<span class="hljs-number">50</span>)]<br>            <br>        )<br><br><br>    <span class="hljs-comment"># 训练集预测 测试集预测</span><br>    y_train_KFold_predict = lgb_reg.predict(X_train_KFold,num_iteration=lgb_reg.best_iteration_)<br>    y_test_KFold_predict = lgb_reg.predict(X_test_KFold,num_iteration=lgb_reg.best_iteration_) <br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第&#123;&#125;折 训练和预测 训练MSE 预测MSE&#x27;</span>.<span class="hljs-built_in">format</span>(i))<br>    train_mse = mean_squared_error(y_train_KFold_predict, y_train_KFold)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------\n&#x27;</span>, <span class="hljs-string">&#x27;训练MSE\n&#x27;</span>, train_mse, <span class="hljs-string">&#x27;\n------&#x27;</span>)<br>    test_mse = mean_squared_error(y_test_KFold_predict, y_test_KFold)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------\n&#x27;</span>, <span class="hljs-string">&#x27;预测MSE\n&#x27;</span>, test_mse, <span class="hljs-string">&#x27;\n------\n&#x27;</span>)<br>    <br>    MSE_DICT[<span class="hljs-string">&#x27;train_mse&#x27;</span>].append(train_mse)<br>    MSE_DICT[<span class="hljs-string">&#x27;test_mse&#x27;</span>].append(test_mse)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------\n&#x27;</span>, <span class="hljs-string">&#x27;训练MSE\n&#x27;</span>, MSE_DICT[<span class="hljs-string">&#x27;train_mse&#x27;</span>], <span class="hljs-string">&#x27;\n&#x27;</span>, np.mean(MSE_DICT[<span class="hljs-string">&#x27;train_mse&#x27;</span>]), <span class="hljs-string">&#x27;\n------&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------\n&#x27;</span>, <span class="hljs-string">&#x27;预测MSE\n&#x27;</span>, MSE_DICT[<span class="hljs-string">&#x27;test_mse&#x27;</span>], <span class="hljs-string">&#x27;\n&#x27;</span>, np.mean(MSE_DICT[<span class="hljs-string">&#x27;test_mse&#x27;</span>]), <span class="hljs-string">&#x27;\n------&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000650 seconds.You can set `force_col_wise=true` to remove the overhead.[LightGBM] [Info] Total Bins 8853[LightGBM] [Info] Number of data points in the train set: 2310, number of used features: 38[LightGBM] [Info] Start training from score 0.121817Training until validation scores don&#39;t improve for 50 rounds[100]    Train&#39;s l2: 0.223959    Test&#39;s l2: 0.247217Did not meet early stopping. Best iteration is:[100]    Train&#39;s l2: 0.223959    Test&#39;s l2: 0.247217第0折 训练和预测 训练MSE 预测MSE------ 训练MSE 0.22395910176815867 ------------ 预测MSE 0.24721747302378572 ------[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000492 seconds.You can set `force_col_wise=true` to remove the overhead.[LightGBM] [Info] Total Bins 8853[LightGBM] [Info] Number of data points in the train set: 2310, number of used features: 38[LightGBM] [Info] Start training from score 0.113222Training until validation scores don&#39;t improve for 50 rounds[100]    Train&#39;s l2: 0.221409    Test&#39;s l2: 0.25435Did not meet early stopping. Best iteration is:[100]    Train&#39;s l2: 0.221409    Test&#39;s l2: 0.25435第1折 训练和预测 训练MSE 预测MSE------ 训练MSE 0.22140920255015417 ------------ 预测MSE 0.2543498234383045 ------[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000771 seconds.You can set `force_col_wise=true` to remove the overhead.[LightGBM] [Info] Total Bins 8838[LightGBM] [Info] Number of data points in the train set: 2310, number of used features: 38[LightGBM] [Info] Start training from score 0.132497Training until validation scores don&#39;t improve for 50 rounds[100]    Train&#39;s l2: 0.221398    Test&#39;s l2: 0.256187Did not meet early stopping. Best iteration is:[100]    Train&#39;s l2: 0.221398    Test&#39;s l2: 0.256187第2折 训练和预测 训练MSE 预测MSE------ 训练MSE 0.22139783747290231 ------------ 预测MSE 0.25618731408519657 ------[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000471 seconds.You can set `force_col_wise=true` to remove the overhead.[LightGBM] [Info] Total Bins 8849[LightGBM] [Info] Number of data points in the train set: 2311, number of used features: 38[LightGBM] [Info] Start training from score 0.125889Training until validation scores don&#39;t improve for 50 rounds[100]    Train&#39;s l2: 0.225142    Test&#39;s l2: 0.250629Did not meet early stopping. Best iteration is:[100]    Train&#39;s l2: 0.225142    Test&#39;s l2: 0.250629第3折 训练和预测 训练MSE 预测MSE------ 训练MSE 0.22514211678664525 ------------ 预测MSE 0.2506288004181115 ------[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000387 seconds.You can set `force_col_wise=true` to remove the overhead.[LightGBM] [Info] Total Bins 8837[LightGBM] [Info] Number of data points in the train set: 2311, number of used features: 38[LightGBM] [Info] Start training from score 0.138334Training until validation scores don&#39;t improve for 50 rounds[100]    Train&#39;s l2: 0.2212    Test&#39;s l2: 0.256939Did not meet early stopping. Best iteration is:[100]    Train&#39;s l2: 0.2212    Test&#39;s l2: 0.256939第4折 训练和预测 训练MSE 预测MSE------ 训练MSE 0.22120001873881776 ------------ 预测MSE 0.2569386630797994 ------------ 训练MSE [0.22395910176815867, 0.22140920255015417, 0.22139783747290231, 0.22514211678664525, 0.22120001873881776]  0.22262165546333562 ------------ 预测MSE [0.24721747302378572, 0.2543498234383045, 0.25618731408519657, 0.2506288004181115, 0.2569386630797994]  0.2530644148090395 ------</code></pre><p> <img src="/img/工业蒸汽预测-05-2赛题模型验证/052_1.png" width = "300" height = "200" alt="" align=center /></p><h4 id="代码解释-5"><a href="#代码解释-5" class="headerlink" title="代码解释"></a>代码解释</h4><ol><li><code>eval_set</code> 参数<br>在训练过程中用于指定评估模型性能的数据集。可以提供一个或多个数据集用于监控模型的性能，并在训练过程中进行早停法（early stopping）等操作。</li></ol><p><code>eval_set</code>参数接受一个二维列表，每个元素都是一个包含特征和目标变量的元组。每个元组代表一个数据集，通常由特征数据和对应的目标变量组成。</p><p>例如，如果我们有一个训练数据集<code>(X_train, y_train)</code>和一个测试数据集<code>(X_test, y_test)</code>，可以将它们作为元组传递给<code>eval_set</code>参数，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">eval_set = [(X_train, y_train), (X_test, y_test)]<br></code></pre></td></tr></table></figure><p>在训练过程中，模型将使用这些数据集来计算训练误差和验证误差，并根据验证误差的变化来决定是否进行早停法。通常情况下，可以通过设置<code>early_stopping_rounds</code>参数来定义早停法的逻辑。</p><hr><ol><li><code>eval_names</code>参数<br><code>eval_names</code>参数用于为<code>eval_set</code>中的数据集指定名称，以便在输出结果中标识每个数据集的名称。</li></ol><hr><ol><li><code>callbacks</code> 参数</li></ol><p>参数输入要求<br><code>callbacks : list of callable, or None, optional (default=None)</code><br>入参是一个list，list中的对象都是callback方法。callbacks在官方文档中主要是四种方法</p><ul><li><p>early_stopping</p><ul><li>停止迭代</li></ul><p><code>lightgbm.early_stopping(stopping_rounds, first_metric_only=False, verbose=True, min_delta=0.0)</code></p></li></ul><ul><li><p>log_evaluation</p><ul><li>记录迭代过程的指标, 可以在日志中输出<br><code>lightgbm.log_evaluation(period=1, show_stdv=True)</code></li></ul></li></ul><ul><li>record_evaluation(eval_result)<ul><li>把迭代过程指标记录到输入的空字典中<br><code>lightgbm.record_evaluation(eval_result)</code> ;eval_result 可以为一个空字典<code>eval_result = &#123;&#125;</code></li></ul></li></ul><ul><li><p><code>reset_parameter(**kwargs)</code></p><ul><li><p>每次迭代更新数据</p><p>List of parameters for each boosting round or a callable that calculates the parameter in terms of current number of round</p></li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">eval_result = &#123;&#125;<br>lgb_model = lgb.train(lgb_param, train_set=tr_lgb_dt , valid_sets=[tr_lgb_dt, te_lgb_dt], <br>          verbose_eval=<span class="hljs-number">20</span>,<br>          callbacks=[lgb.log_evaluation, lgb.early_stopping(<span class="hljs-number">50</span>, first_metric_only=<span class="hljs-literal">True</span>), lgb.record_evaluation(eval_result)]<br>          )<br><br></code></pre></td></tr></table></figure><hr><ol><li><code>lgb_reg.predict</code>中<code>num_iteration</code>参数</li></ol><p><code>num_iteration</code> 参数用于指定预测时使用的树的迭代次数。在 LightGBM 中，模型训练过程中树的数量是逐步增加的，每一轮都会产生一个新的树。在预测时，可以选择使用模型训练过程中的某个迭代轮数的树来进行预测。</p><p>在训练模型时使用了早停功能，即设置了 <code>early_stopping_round</code> 参数，那么最佳迭代次数会自动选择并保存在 <code>lgb_reg.best_iteration_</code> 属性中。所以可以将其作为 <code>num_iteration</code> 参数传递给 <code>predict()</code> 方法，以便在预测时使用最佳迭代次数的树。</p><h1 id="5-学习曲线和验证曲线"><a href="#5-学习曲线和验证曲线" class="headerlink" title="5 学习曲线和验证曲线"></a>5 学习曲线和验证曲线</h1><h2 id="5-1-学习曲线"><a href="#5-1-学习曲线" class="headerlink" title="5.1 学习曲线"></a>5.1 学习曲线</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> model_selection <br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> SGDRegressor<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> learning_curve<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_learning_curve</span>(<span class="hljs-params">estimator, title, X, y, ylim=<span class="hljs-literal">None</span>, cv=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                        n_jobs=<span class="hljs-number">1</span>, train_sizes=np.linspace(<span class="hljs-params"><span class="hljs-number">.1</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">5</span></span>)</span>):<br>    <br>    plt.figure()<br>    plt.title(title)<br>    <span class="hljs-keyword">if</span> ylim <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        plt.ylim(*ylim)<br>    plt.xlabel(<span class="hljs-string">&quot;Training examples&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;Score&quot;</span>)<br>    train_sizes, train_scores, test_scores = learning_curve(<br>        estimator, X, y, cv=cv, n_jobs=n_jobs, train_sizes=train_sizes)<br>    train_scores_mean = np.mean(train_scores, axis=<span class="hljs-number">1</span>)<br>    train_scores_std = np.std(train_scores, axis=<span class="hljs-number">1</span>)<br>    test_scores_mean = np.mean(test_scores, axis=<span class="hljs-number">1</span>)<br>    test_scores_std = np.std(test_scores, axis=<span class="hljs-number">1</span>)<br>    plt.grid()<br><br>    plt.fill_between(train_sizes, train_scores_mean - train_scores_std,<br>                     train_scores_mean + train_scores_std, alpha=<span class="hljs-number">0.1</span>,<br>                     color=<span class="hljs-string">&quot;r&quot;</span>)<br>    plt.fill_between(train_sizes, test_scores_mean - test_scores_std,<br>                     test_scores_mean + test_scores_std, alpha=<span class="hljs-number">0.1</span>, color=<span class="hljs-string">&quot;g&quot;</span>)<br>    plt.plot(train_sizes, train_scores_mean, <span class="hljs-string">&#x27;o-&#x27;</span>, color=<span class="hljs-string">&quot;r&quot;</span>,<br>             label=<span class="hljs-string">&quot;Training score&quot;</span>)<br>    plt.plot(train_sizes, test_scores_mean, <span class="hljs-string">&#x27;o-&#x27;</span>, color=<span class="hljs-string">&quot;g&quot;</span>,<br>             label=<span class="hljs-string">&quot;Cross-validation score&quot;</span>)<br><br>    plt.legend(loc=<span class="hljs-string">&quot;best&quot;</span>)<br>    <span class="hljs-keyword">return</span> plt<br><br><br>X = train_data2[test_data2.columns].values<br>y = train_data2[<span class="hljs-string">&#x27;target&#x27;</span>].values<br><br><br>title = <span class="hljs-string">&quot;LinearRegression&quot;</span><br><span class="hljs-comment"># Cross validation with 100 iterations to get smoother mean test and train</span><br><span class="hljs-comment"># score curves, each time with 20% data randomly selected as a validation set.</span><br>cv = model_selection.ShuffleSplit(n_splits=<span class="hljs-number">100</span>,<br>                                   test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">0</span>)<br><br>estimator = SGDRegressor()<br>plot_learning_curve(estimator, title, X, y, ylim=(<span class="hljs-number">0.7</span>, <span class="hljs-number">1.01</span>), cv=cv, n_jobs=<span class="hljs-number">1</span>)<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;module &#39;matplotlib.pyplot&#39; from &#39;D:\\Development\\anaconda3\\envs\\ml\\lib\\site-packages\\matplotlib\\pyplot.py&#39;&gt;</code></pre><p>​<br><img src="/img/工业蒸汽预测-05-2赛题模型验证/output_53_1.png" alt=""><br>​    </p><h2 id="5-2-验证曲线"><a href="#5-2-验证曲线" class="headerlink" title="5.2 验证曲线"></a>5.2 验证曲线</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> SGDRegressor<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> validation_curve<br><br>X = train_data2[test_data2.columns].values<br>y = train_data2[<span class="hljs-string">&#x27;target&#x27;</span>].values<br><span class="hljs-comment"># max_iter=1000, tol=1e-3, penalty= &#x27;L1&#x27;, alpha=0.00001</span><br><br>param_range = [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.01</span>, <span class="hljs-number">0.001</span>, <span class="hljs-number">0.0001</span>, <span class="hljs-number">0.00001</span>, <span class="hljs-number">0.000001</span>]<br>train_scores, test_scores = validation_curve(<br>    SGDRegressor(max_iter=<span class="hljs-number">1000</span>, tol=<span class="hljs-number">1e-3</span>, penalty= <span class="hljs-string">&#x27;L1&#x27;</span>), X, y, param_name=<span class="hljs-string">&quot;alpha&quot;</span>, param_range=param_range,<br>    cv=<span class="hljs-number">10</span>, scoring=<span class="hljs-string">&#x27;r2&#x27;</span>, n_jobs=<span class="hljs-number">1</span>)<br>train_scores_mean = np.mean(train_scores, axis=<span class="hljs-number">1</span>)<br>train_scores_std = np.std(train_scores, axis=<span class="hljs-number">1</span>)<br>test_scores_mean = np.mean(test_scores, axis=<span class="hljs-number">1</span>)<br>test_scores_std = np.std(test_scores, axis=<span class="hljs-number">1</span>)<br><br>plt.title(<span class="hljs-string">&quot;Validation Curve with SGDRegressor&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;alpha&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Score&quot;</span>)<br>plt.ylim(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.1</span>)<br>plt.semilogx(param_range, train_scores_mean, label=<span class="hljs-string">&quot;Training score&quot;</span>, color=<span class="hljs-string">&quot;r&quot;</span>)<br>plt.fill_between(param_range, train_scores_mean - train_scores_std,<br>                 train_scores_mean + train_scores_std, alpha=<span class="hljs-number">0.2</span>, color=<span class="hljs-string">&quot;r&quot;</span>)<br>plt.semilogx(param_range, test_scores_mean, label=<span class="hljs-string">&quot;Cross-validation score&quot;</span>,<br>             color=<span class="hljs-string">&quot;g&quot;</span>)<br>plt.fill_between(param_range, test_scores_mean - test_scores_std,<br>                 test_scores_mean + test_scores_std, alpha=<span class="hljs-number">0.2</span>, color=<span class="hljs-string">&quot;g&quot;</span>)<br>plt.legend(loc=<span class="hljs-string">&quot;best&quot;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/img/工业蒸汽预测-05-2赛题模型验证/output_55_0.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>机器学习实战入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言03-函数和递归123</title>
    <link href="/2023/09/03/C%E8%AF%AD%E8%A8%8003-%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%92%E5%BD%92123/"/>
    <url>/2023/09/03/C%E8%AF%AD%E8%A8%8003-%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%92%E5%BD%92123/</url>
    
    <content type="html"><![CDATA[<h1 id="函数分类">1 函数分类</h1><h2 id="库函数">1.1 库函数</h2><p>库函数查询工具： www.cplusplus.com http://en.cppreference.com（英文版） http://zh.cppreference.com（中文版）</p><h2 id="自定义函数">1.2 自定义函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">ret_type <span class="hljs-title function_">fun_name</span><span class="hljs-params">(para1, * )</span><br>&#123;<br>statement;<span class="hljs-comment">//语句项</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ret_type 返回类型 fun_name 函数名 para1 函数参数</p><blockquote><p>写一个函数可以交换两个整形变量的内容。P12 1:16:10</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//实现成函数，但是不能完成任务</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Swap1</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br><span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>tmp = x;<br>x = y;<br>y = tmp;<br>&#125;<br><span class="hljs-comment">// x y 和 num1 num2是单独的地址，没有关系</span><br><br><span class="hljs-comment">//正确的版本</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Swap2</span><span class="hljs-params">(<span class="hljs-type">int</span>* px, <span class="hljs-type">int</span>* py)</span><br>&#123;<br><span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>tmp = *px;<br>*px = *py;<br>*py = tmp;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> num1 = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> num2 = <span class="hljs-number">2</span>;<br>Swap1(num1, num2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Swap1:num1 = %d num2 = %d\n&quot;</span>, num1, num2);<br>Swap2(&amp;num1, &amp;num2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Swap2:num1 = %d num2 = %d\n&quot;</span>, num1, num2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数的参数">2 函数的参数</h1><h2 id="实参">2.1 实参</h2><p>真实传给函数的参数，叫实参。 实参可以是：常量、变量、表达式、函数等。 无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形 参。</p><h2 id="形参">2.2 形参</h2><p>形式参数是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内 存单元），所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数 中有效。 上面<code>Swap1</code> 和<code>Swap2</code> 函数中的参数<code>x，y，px，py</code> 都是<strong>形式参数</strong>。 在main函数中传给<code>Swap1</code> 的<code>num1</code> ， <code>num2</code> 和传给<code>Swap2</code> 函数的<code>&amp;num1</code> ， <code>&amp;num2</code> 是<strong>实际参数</strong>。 这里我们对函数的实参和形参进行分析： <img src="/img/C语言03-函数和递归123/C语言03-函数和递归123.png" /> 代码对应的内存分配如下： <img src="/img/C语言03-函数和递归123/C语言03-函数和递归123_1.png" /> 这里可以看到<code>Swap1</code> 函数在调用的时候， <code>x</code> ，<code>y</code> 拥有自己的空间，同时拥有了和实参一模一样的内容。 当实参传给形参的时候，形参其实是实参的一份临时搓贝 ，对形参的修改是不会改变实参的。</p><h1 id="函数的调用">3 函数的调用</h1><h2 id="传值调用">3.1 传值调用</h2><p>函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参。</p><h2 id="传址调用">3.2 传址调用</h2><p>传址调用把变量的内存地址传递给函数参数。 这种传参方式可以让函数和函数外边的变量建立起真正的联系，也就是函数内部可以直接<strong>操作函数外部的变量</strong>。</p><h1 id="练习">3.3 练习</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 写一个函数，实现一个整形有序数组的二分查找。</span><br><span class="hljs-comment">// 找到返回下标。未找到返回-1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> size)</span><br>&#123;<br><br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> right = size - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> mind = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (left&lt;=right)<br>&#123;<br>mind = (left + right) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (arr[mind] &lt; n)<br>&#123;<br>left = mind+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mind] &gt; n)<br>&#123;<br>right = mind<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> mind;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> size = (<span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]));<br><span class="hljs-type">int</span> index = binarySearch(arr,n,size);<br><span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> != index)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找到了，下标为：%d\n&quot;</span>, index);<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;没找到&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> <code>int size = (sizeof(arr) / sizeof(arr[0]));</code> 要写在函数外。<code>mind = (left + right) / 2;</code> 要写在循环内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 写一个函数，每调用一次这个函数，就会将num 的值增加1。</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span><br>&#123;<br>(*p)++;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>Add(&amp;num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num = %d\n&quot;</span>, num);<br>Add(&amp;num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num = %d\n&quot;</span>, num);<br>Add(&amp;num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num = %d\n&quot;</span>, num);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong><code>(*p)++;</code> 不可写成 <code>*p++</code> ，因为<code>++</code> 级别较高 <code>*p++</code> 的话 <code>++</code> 是作用在 <code>p</code> 上的，不是作用在 <code>*P</code> 上的。</p><h1 id="函数的嵌套调用和链式访问">4 函数的嵌套调用和链式访问</h1><h2 id="嵌套调用">4.1 嵌套调用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">new_line</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hehe\n&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">three_line</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++)<br>&#123;<br>new_line();<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>three_line();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链式访问">4.2 链式访问</h2><blockquote><p>把一个函数的返回值作为另外一个函数的参数。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">43</span>)));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 结果：4321 注意：printf函数的返回值是打印在屏幕上字符的个数</p></blockquote><h1 id="函数的声明和定义">5 函数的声明和定义</h1><h2 id="函数的声明">5.1 函数的声明</h2><ol type="1"><li>告诉编译器有一个函数<strong>叫什么</strong>，<strong>参数</strong>是什么，<strong>返回类型</strong>是什么。但是具体是不是存在，函数声明决定不了。</li><li>函数的声明一般出现在函数的使用之前。要满足先声明后使用。</li><li>函数的声明一般要放在头文件中的。</li></ol><h2 id="函数的定义">5.2 函数的定义</h2><p>函数的定义是指函数的具体实现，交待函数的功能实现。</p><p><strong>注意：</strong> 函数的声明放在头文件中，定义放在单独的<code>.c</code> 文件中。 <img src="/img/C语言03-函数和递归123/C语言03-函数和递归123_2.png" /> 自己创建的函数需要引头文件，<code>#include "add.h"</code> 。 <code>#ifndef __ADD_H__</code> <code>#define __ADD_H__</code> <code>#define __ADD_H__</code> 是为了防止同一个头文件被引用多次。</p><h1 id="函数的递归">6 函数的递归</h1><h2 id="什么是递归">6.1 什么是递归</h2><p>程序调用自身的编程技巧称为递归（ recursion）</p><p>简单的递归： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hehe&quot;</span>)<br>main()<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>会报错：Stack overflow 栈溢出 <img src="/img/C语言03-函数和递归123/C语言03-函数和递归123_3.png" /></p><h2 id="递归的两个必要条件">6.2 递归的两个必要条件</h2><ul><li>存在限制条件，当满足这个限制条件的时候，递归便不再继续。</li><li>每次递归调用之后越来越接近这个限制条件。</li></ul><h2 id="练习-1">6.3 练习</h2><h2 id="练习1">练习1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 接受一个整型值（无符号），按照顺序打印它的每一位。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_num</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">9</span>) <br>&#123;<br>print_num(n / <span class="hljs-number">10</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, n % <span class="hljs-number">10</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>print_num(num);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="练习2">练习2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//编写函数不允许创建临时变量，求字符串的长度。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Strlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span><br>&#123;<br><span class="hljs-keyword">if</span> (*str == <span class="hljs-string">&#x27;\0&#x27;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Strlen(str + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span>* p = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">int</span> len = Strlen(p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, len);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/C语言03-函数和递归123/C语言03-函数和递归123_0.png" /></p><h2 id="递归与迭代">6.4 递归与迭代</h2><h3 id="练习3">6.4.1 练习3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 求n的阶乘</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Fac</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> n * Fac(n - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br><br>ret = Fac(num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ret);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="练习4">6.4.2 练习4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求第n个斐波那契数。（不考虑溢出）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但是：</strong> - 使用fib这个函数计算第50个斐波那契数字的时候特别耗费时间。 - 使用Fac 函数求10000的阶乘，程序会崩溃。</p><p><strong>为什么呢？</strong> 其实fib函数在调用的时候在一直重复计算。 我们来看一下计算了多少次，修改代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Fac</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-keyword">if</span> (n = <span class="hljs-number">3</span>)<br>count++;<br><span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> n * Fac(n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>结果中的count非常非常大。在调试Fac函数的时候，如果参数比较大，那就会报错： stack overflow（栈溢出） 因为，系统分配给程序的栈空间是有限的，如果出现了死循环，或者死递），这样有可能导致一直开辟栈空间，最终耗尽栈空间，这样的现象我们称为栈溢出。</p><p><strong>如何解决这种情况？</strong></p><ol type="1"><li>将递归改写成非递归。</li><li>使用static 对象替代nonstatic 局部对象（即栈对象）。这不仅可以减少每次递归调用和返回时产生和释放nonstatic 对象的开销，而且static 对象还可以保存递归调用的中间状态，并且可为各个调用层所访问。</li></ol><p>采用非递归的方法计算斐波那契数（P41 33:00）： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Fac</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> c = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">2</span>)<br>&#123;<br>c = a + b;<br>a = b;<br>b = c;<br>n--;<br>&#125;<br><span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure></p><ol type="1"><li>许多问题是以递归的形式进行解释的，这只是因为它比非递归的形式更为清晰。</li><li>但是这些问题的迭代实现往往比递归实现效率更高，虽然代码的可读性稍微差些。</li><li>当一个问题相当复杂，难以用迭代实现时，此时递归实现的简洁性便可以补偿它所带来的运行时开销。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言02-分支和循环12</title>
    <link href="/2023/09/02/C%E8%AF%AD%E8%A8%8002-%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF12/"/>
    <url>/2023/09/02/C%E8%AF%AD%E8%A8%8002-%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF12/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言02-分支和循环12"><a href="#C语言02-分支和循环12" class="headerlink" title="C语言02-分支和循环12"></a>C语言02-分支和循环12</h1><p>本章重点</p><p>分支语句</p><ul><li>if</li><li>switch</li></ul><p>循环语句</p><ul><li>while</li><li>for</li><li>do while</li></ul><p>goto语句</p><h1 id="1-分支语句"><a href="#1-分支语句" class="headerlink" title="1 分支语句"></a>1 分支语句</h1><h2 id="1-1-if语句"><a href="#1-1-if语句" class="headerlink" title="1.1 if语句"></a>1.1 if语句</h2><p>语法结构:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(表达式)<br>语句;<br><br><span class="hljs-keyword">if</span>(表达式)<br>语句<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>语句<span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//多分支</span><br><span class="hljs-keyword">if</span>(表达式<span class="hljs-number">1</span>)<br>语句<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(表达式<span class="hljs-number">2</span>)<br>语句<span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span><br>语句<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></p><h3 id="1-2-1-悬空else"><a href="#1-2-1-悬空else" class="headerlink" title="1.2.1 悬空else"></a>1.2.1 悬空else</h3><p>首先看一下代码，运行结果为什么：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span>(b == <span class="hljs-number">2</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hehe\n&quot;</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;haha\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>结果：结果为空</p><p>==注意：== <strong>else的匹配</strong>-else是和它离的最近的未匹配的if进行匹配。</p><p><img src="/img/C语言02-分支和循环12/C语言02-分支和循环12.png" alt=""></p><p>若想输出haha，则为一下写法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (b == <span class="hljs-number">2</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hehe\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;haha\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="1-2-2-if书写形式的对比"><a href="#1-2-2-if书写形式的对比" class="headerlink" title="1.2.2 if书写形式的对比"></a>1.2.2 if书写形式的对比</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//代码1</span><br><span class="hljs-keyword">if</span> (condition) &#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-keyword">return</span> y;<br><br><span class="hljs-comment">//代码2</span><br><span class="hljs-keyword">if</span> (condition)<br>&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> y;<br>&#125;<br><br><span class="hljs-comment">//代码3</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (num == <span class="hljs-number">5</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hehe\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//代码4</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">5</span> == num)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hehe\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码1，代码2都表示：条件成立返回x，不成立返回y，但是代码2格式更好。</p><p>代码3，代码4相同，但是代码4格式更好。因为，代码3中的 <code>num == 5</code> 有时候会误写成一个等号，为了避免这种错误，可将代码反过来写，写成 <code>5 == num</code> 。</p><h2 id="1-2-switch语句"><a href="#1-2-switch语句" class="headerlink" title="1.2 switch语句"></a>1.2 switch语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> day = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;day)<br><span class="hljs-keyword">switch</span> (day)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>：<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;星期一\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;星期二\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;星期三\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;星期四\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;星期五\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;星期六\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;星期天\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span>(整型表达式)<br>&#123;<br>语句项；<br>&#125;<br><br><span class="hljs-keyword">case</span> 整形常量表达式:<br>语句<br></code></pre></td></tr></table></figure><br>switch 后是<strong>整型</strong>表达式，case 后是<strong>整形常量</strong>表达式。</p><h3 id="1-2-1-case穿透"><a href="#1-2-1-case穿透" class="headerlink" title="1.2.1 case穿透"></a>1.2.1 case穿透</h3><p>有时候我们的需求变了：</p><ol><li>输入1-5，输出的是“工作日”;</li><li>输入6-7，输出“休息日”<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> day = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;day)<br><span class="hljs-keyword">switch</span> (day)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>：<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;工作日\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;休息日\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>在最后一个 case 语句的后面加上一条 break语句。（之所以这么写是可以避免出现在以前的最后一个 case 语句后面忘了添加 break语句）。</p></blockquote><h3 id="1-2-2-default字句"><a href="#1-2-2-default字句" class="headerlink" title="1.2.2 default字句"></a>1.2.2 default字句</h3><p>当 <code>switch</code> 表达式的值并不匹配所有<code>case</code> 标签的值时，这个<code>default</code> 子句后面的语句就会执行。<br>所以，每个<code>switch</code>语句中只能出现一条<code>default</code>子句。<br>但是它可以出现在语句列表的任何位置，而且语句流会像执行一个<code>case</code>标签一样执行<code>default</code>子句。</p><blockquote><p>在每个 switch 语句中都放一条default子句是个好习惯，甚至可以在后边再加一个 break 。</p></blockquote><h1 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2 循环语句"></a>2 循环语句</h1><h2 id="2-1-while循环"><a href="#2-1-while循环" class="headerlink" title="2.1 while循环"></a>2.1 while循环</h2><p>while语句执行的流程：<br><img src="/img/C语言02-分支和循环12/C语言02-分支和循环12_1.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i&lt;=<span class="hljs-number">10</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>i = i+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-1-while语句中的break和continue"><a href="#2-1-1-while语句中的break和continue" class="headerlink" title="2.1.1 while语句中的break和continue"></a>2.1.1 while语句中的break和continue</h3><h4 id="break介绍"><a href="#break介绍" class="headerlink" title="break介绍"></a>break介绍</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">10</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>)<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>i = i + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>结果： 1 2 3 4</p><p>总结：<br>其实在循环中只要遇到break，就<strong>停止</strong>后期的<strong>所有的循环</strong>，直接终止循环。<br>所以，while中的break是用于<strong>永久终止循环的</strong>。</p><h4 id="continue介绍"><a href="#continue介绍" class="headerlink" title="continue介绍"></a>continue介绍</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//continue 代码实例1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">10</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>i++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：1 2 3 4<br>但是此处死循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//continue 代码实例2</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">10</span>)<br>&#123;<br>i++;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：1 2 3 4 6 7 8 9 10 11</p><p><strong>总结：</strong><br>continue是用于终止本次循环的，也就是本次循环中continue<strong>后边的代码不会再执行</strong>，<br>而是<strong>直接跳转</strong>到<strong>while语句的判断部分</strong>。进行下一次循环的入口判断。</p><h3 id="2-1-3-清空缓冲区"><a href="#2-1-3-清空缓冲区" class="headerlink" title="2.1.3 清空缓冲区"></a>2.1.3 清空缓冲区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> ch = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> ((ch = getchar()) != <span class="hljs-string">&#x27;\n&#x27;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//代码1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> ch = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)<br><span class="hljs-built_in">putchar</span>(ch);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//这里的代码适当的修改是可以用来清理缓冲区的.</span><br><br><span class="hljs-comment">//代码2</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-keyword">while</span> ((ch = getchar()) != EOF)<br>&#123;<br><span class="hljs-keyword">if</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">putchar</span>(ch);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//这个代码的作用是：只打印数字字符，跳过其他字符的</span><br></code></pre></td></tr></table></figure></p><h2 id="2-2-for循环"><a href="#2-2-for循环" class="headerlink" title="2.2 for循环"></a>2.2 for循环</h2><h3 id="2-2-1-语法"><a href="#2-2-1-语法" class="headerlink" title="2.2.1 语法"></a>2.2.1 语法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (初始化语句;条件判断语句;条件控制语句) &#123;<br>循环体语句;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/C语言02-分支和循环12/C语言02-分支和循环12_2.png" alt=""></p><h3 id="2-2-2-break和continue在for循环中"><a href="#2-2-2-break和continue在for循环中" class="headerlink" title="2.2.2 break和continue在for循环中"></a>2.2.2 break和continue在for循环中</h3><p>for循环中break和continue的意义和在while循环中是一样的。<br>但是还是有些差异：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//代码1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//代码2</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>代码1结果：1234<br>代码2结果：1 2 3 4 6 7 8 9 10 但是没有死循环</p><h2 id="2-3-do…while-循环"><a href="#2-3-do…while-循环" class="headerlink" title="2.3 do…while()循环"></a>2.3 do…while()循环</h2><h3 id="2-3-1-语法"><a href="#2-3-1-语法" class="headerlink" title="2.3.1 语法"></a>2.3.1 语法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span><br>&#123;<br>循环语句;<br>&#125;<br><span class="hljs-keyword">while</span>(表达式);<br></code></pre></td></tr></table></figure><p><img src="/img/C语言02-分支和循环12/C语言02-分支和循环12_3.png" alt=""><br>循环至少执行一次，使用的场景有限，所以不是经常使用。</p><h3 id="2-3-2-do-while循环中的break和continue"><a href="#2-3-2-do-while循环中的break和continue" class="headerlink" title="2.3.2 do while循环中的break和continue"></a>2.3.2 do while循环中的break和continue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 代码1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">5</span> == i)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>i = i + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">10</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 代码2</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">5</span> == i)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>i = i + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">10</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码1结果：1 2 3 4<br>代码2结果：1 2 3 4 死循环</p><h1 id="3-练习"><a href="#3-练习" class="headerlink" title="3 练习"></a>3 练习</h1><h2 id="3-1-折半查找算法"><a href="#3-1-折半查找算法" class="headerlink" title="3.1 折半查找算法"></a>3.1 折半查找算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> right = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> key = <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> mid = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (left &lt;= right)<br>&#123;<br>mid = (left + right) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (arr[mid] &gt; key)<br>&#123;<br>right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; key)<br>&#123;<br>left = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (left &lt;= right)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找到了,下标是%d\n&quot;</span>, mid);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找不到\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工业蒸汽预测-05-1模型验证</title>
    <link href="/2023/09/01/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-05-1%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81/"/>
    <url>/2023/09/01/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-05-1%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="模型评估的概念和方法">1 模型评估的概念和方法</h1><h2 id="过拟合与欠拟合">1.1 过拟合与欠拟合</h2><h3 id="获取并绘制数据集">获取并绘制数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>%matplotlib inline<br><br>np.random.seed(<span class="hljs-number">666</span>)<br>x = np.random.uniform(-<span class="hljs-number">3.0</span>, <span class="hljs-number">3.0</span>, size=<span class="hljs-number">100</span>)<br>X = x.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>y = <span class="hljs-number">0.5</span> * x**<span class="hljs-number">2</span> + x + <span class="hljs-number">2</span> + np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, size=<span class="hljs-number">100</span>)<br><br>plt.scatter(x, y)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/img/工业蒸汽预测-05%201模型验证/output_3_0.png" /></p><h4 id="代码解释">代码解释</h4><ul><li><p><code>np.random.seed(666)</code>：设置随机数种子，这样可以确保每次运行代码时生成的随机数是一致的,仅是为了使随机结果可重现，它不直接与散点图有关。。</p></li><li><p><code>x = np.random.uniform(-3.0, 3.0, size=100)</code>：生成一个包含100个在-3.0到3.0之间均匀分布的随机数的一维数组。</p></li><li><p><code>X = x.reshape(-1, 1)</code>：将一维数组 <code>x</code> 转换（重塑reshape）为二维数组 <code>X</code>，其中一列是 <code>x</code> 的值，行数自动计算以匹配原始数据的维度。<code>reshape(-1, 1)</code> 的作用是将一维数组 x 转换为一个二维数组 X，其中 -1 表示自动计算该维度的大小，而 1 表示要创建的数组的列数为1。</p></li><li><p><code>y = 0.5 * x**2 + x + 2 + np.random.normal(0, 1, size=100)</code>：根据给定的二次函数关系生成 <code>y</code> 值，并添加均值为0，标准差为1的正态分布随机噪声。<code>np.random.normal(0, 1, size=100)</code> 是用于生成服从正态分布（高斯分布）的随机数的 NumPy 函数。</p><ul><li><code>0</code>：表示正态分布的均值（mean）为0，即随机数的平均值为0。</li><li><code>1</code>：表示正态分布的标准差（standard deviation）为1，即随机数的离散程度。</li><li><code>size=100</code>：表示要生成的随机数的数量为100。</li></ul><p>这个函数将生成一个包含100个元素的一维数组，其中的每个元素都是从均值为0、标准差为1的正态分布中抽取的随机数。在本例中，这些随机数表示了噪声，会被添加到二次曲线的计算结果中，用于在原始数据上引入一些随机性和波动。</p><p>最终，通过 <code>y = 0.5 * x**2 + x + 2 + np.random.normal(0, 1, size=100)</code> 这行代码，我们将按照二次函数关系生成的理想曲线上加入了服从正态分布的随机噪声，得到了最终的观测数据 <code>y</code>。噪声的作用是模拟现实世界中数据的波动性和随机性，使得数据更接近真实情况。</p></li><li><p><code>plt.scatter(x, y)</code>：创建散点图，将 <code>x</code> 和 <code>y</code> 的值传递给 <code>scatter()</code> 函数以绘制数据点。</p></li></ul><p>使用线性回归拟合数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><br>lin_reg = LinearRegression()<br>lin_reg.fit(X, y)<br>lin_reg.score(X, y)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.4953707811865009</code></pre><p>准确率为 0.495，比较低，直线拟合数据的程度较低。</p><h3 id="使用均方误差判断拟合程度">使用均方误差判断拟合程度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br><br>y_predict = lin_reg.predict(X)<br>mean_squared_error(y, y_predict)<br></code></pre></td></tr></table></figure><pre><code class="hljs">3.0750025765636577</code></pre><h3 id="绘制拟合结果">绘制拟合结果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">y_predict = lin_reg.predict(X)<br>plt.scatter(x, y)<br>plt.plot(np.sort(x), y_predict[np.argsort(x)], color=<span class="hljs-string">&#x27;r&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-05%201模型验证/output_10_0.png" /> ​</p><h4 id="代码解释-1">代码解释</h4><p><code>plt.plot(np.sort(x), y_predict[np.argsort(x)], color='r')</code> 用于在图形中绘制拟合直线。</p><ul><li><p><code>np.sort(x)</code>：将输入特征 <code>x</code> 进行升序排序，得到排序后的数组。这是因为 <code>x</code> 的顺序可能是乱序的，绘制拟合直线时需要按照从小到大的顺序连接数据点。</p></li><li><p><code>y_predict[np.argsort(x)]</code>：根据 <code>x</code> 的排序结果，对预测值 <code>y_predict</code> 进行重新排列。<code>np.argsort(x)</code> 返回的是 <code>x</code> 的索引按照升序排列的结果。通过使用这个索引数组对 <code>y_predict</code> 进行切片操作，可以按照相同的顺序重新排列预测值，使其与排序后的 <code>x</code> 相对应。</p></li><li><p><code>color='r'</code>：指定拟合直线的颜色为红色 ('r')。</p></li></ul><p>将排序后的输入特征 <code>x</code> 与重新排列的预测值 <code>y_predict</code> 作为参数传递给 <code>plot()</code> 函数，绘制拟合直线。通过按照从小到大的顺序连接数据点，可以在图形中展示出线性回归模型对原始数据的拟合程度。</p><h3 id="使用多项式回归拟合">使用多项式回归拟合</h3><ul><li>首先封装Pipeline管道，这样便于下一步灵活调整多项式回归模型参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> Pipeline <br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> PolynomialFeatures<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">PolynomialRegression</span>(<span class="hljs-params">degree</span>):<br>    <span class="hljs-keyword">return</span> Pipeline([<br>        (<span class="hljs-string">&#x27;poly&#x27;</span>, PolynomialFeatures(degree=degree)),<br>        (<span class="hljs-string">&#x27;std_scaler&#x27;</span>, StandardScaler()),<br>        (<span class="hljs-string">&#x27;lin_reg&#x27;</span>, LinearRegression())<br>    ])<br></code></pre></td></tr></table></figure><h4 id="代码解释-2">代码解释</h4><p>用于创建多项式回归模型的函数。使用sklearn库中的Pipeline类来构建一个机器学习工作流程，包括多项式特征转换、标准化和线性回归模型。</p><ul><li><p><code>from sklearn.pipeline import Pipeline</code>: Pipeline类，用于将多个数据处理步骤和机器学习模型封装在一起，形成一个流水线。</p></li><li><p><code>from sklearn.preprocessing import PolynomialFeatures</code>: PolynomialFeatures类，用于进行多项式特征转换。</p></li><li><p><code>from sklearn.preprocessing import StandardScaler</code>: StandardScaler类，用于进行特征标准化（特征缩放）。</p></li><li><p><code>def PolynomialRegression(degree)</code>: 定义PolynomialRegression函数，接受参数degree，表示多项式的次数。</p></li><li><p><code>return Pipeline([...])</code>: 使用Pipeline类创建一个机器学习工作流程并返回。Pipeline类接受一个由元组构成的列表作为参数，每个元组代表工作流程中的一个步骤。</p><ul><li><p><code>('poly', PolynomialFeatures(degree=degree))</code>: 多项式特征转换步骤，将输入特征转换为指定次数的多项式特征。使用PolynomialFeatures类，并将其实例命名为'poly'。</p></li><li><p><code>('std_scaler', StandardScaler())</code>: 标准化步骤，对多项式特征进行特征缩放，使特征的均值为0，标准差为1。使用StandardScaler类，并将其实例命名为'std_scaler'。</p></li><li><p><code>('lin_reg', LinearRegression())</code>: 线性回归模型步骤，用于拟合多项式特征和目标变量之间的关系。使用LinearRegression类，并将其实例命名为'lin_reg'。</p></li></ul></li></ul><p>创建一个多项式回归模型，通过使用多项式特征转换和标准化来提高模型的性能。可以根据需要选择不同的多项式次数，从而得到不同复杂度的模型。</p><ul><li>使用 Pipeline 拟合数据：degree = 2</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">poly2_reg = PolynomialRegression(degree=<span class="hljs-number">2</span>)<br>poly2_reg.fit(X, y)<br><br>y2_predict = poly2_reg.predict(X)<br><br><span class="hljs-comment"># 比较真值和预测值的均方误差</span><br>mean_squared_error(y, y2_predict)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.0987392142417858</code></pre><ul><li>绘制拟合结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.scatter(x, y)<br>plt.plot(np.sort(x), y2_predict[np.argsort(x)], color=<span class="hljs-string">&#x27;r&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-05%201模型验证/output_19_0.png" /> ​</p><ul><li>调整 degree = 10</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">poly10_reg = PolynomialRegression(degree=<span class="hljs-number">10</span>)<br>poly10_reg.fit(X, y)<br><br>y10_predict = poly10_reg.predict(X)<br><span class="hljs-built_in">print</span>(mean_squared_error(y, y10_predict))<br><br><br>plt.scatter(x, y)<br>plt.plot(np.sort(x), y10_predict[np.argsort(x)], color=<span class="hljs-string">&#x27;r&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.0508466763764126</code></pre><p><img src="/img/工业蒸汽预测-05%201模型验证/output_22_1.png" /></p><ul><li>调整 degree = 100</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">poly100_reg = PolynomialRegression(degree=<span class="hljs-number">100</span>)<br>poly100_reg.fit(X, y)<br><br>y100_predict = poly100_reg.predict(X)<br><span class="hljs-built_in">print</span>(mean_squared_error(y, y100_predict))<br><br><br>plt.scatter(x, y)<br>plt.plot(np.sort(x), y100_predict[np.argsort(x)], color=<span class="hljs-string">&#x27;r&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.6807802342342404</code></pre><p><img src="/img/工业蒸汽预测-05%201模型验证/output_25_1.png" /></p><ul><li>分析<ol type="1"><li>degree=2：均方误差为 1.0987392142417858；</li><li>degree=10：均方误差为 1.0508466763764126；</li><li>degree=100：均方误差为 0.6807802342342404；</li><li>degree 越大拟合的效果越好，因为样本点是一定的，我们总能找到一条曲线将所有的样本点拟合，也就是说将所有的样本点都完全落在这根曲线上，使得整体的均方误差为 0；</li><li>红色曲线并不是所计算出的拟合曲线，而此红色曲线只是原有的数据点对应的 y 的预测值连接出来的结果，而且有的地方没有数据点，因此连接的结果和原来的曲线不一样；</li></ol></li></ul><h2 id="交叉验证">1.2 交叉验证</h2><h3 id="交叉验证迭代器">1.2.1交叉验证迭代器</h3><p><strong>K折交叉验证</strong>：K-Fold Cross Validation,是将原始数据分成K组（一般是均分）,称为折叠 (fold)，然后将每个子集数据分别做一次验证集，其余的K-1组子集数据作为训练集，这样就会得到K个模型，将K个模型最终的验证集的分类准确率取平均值，作为K折交叉验证分类器的性能指标。通常设置K大于或等于3。</p><p><img src="/img/工业蒸汽预测-05%201模型验证/05_1.png" /></p><p><strong>K折重复多次</strong>： RepeatedKFold 重复 K-Fold n 次。当需要运行时可以使用它 KFold n 次，在每次重复中产生不同的分割。</p><p><strong>留一交叉验证</strong>： LeaveOneOut (或 LOO) 是一个简单的交叉验证。每个训练集都由除了一个样本以外的其余所有样本组成的，留下的一个样本组成检验集。 这样，对于 n 个样本，我们有 n 个不同的训练集和 n 个不同的测试集。因此LOO-CV会得到N个模型，用N个模型最终的验证集的分类准确率的平均数作为分类器的性能指标。这种交叉验证程序不会浪费太多数据，因为只有一个样本是从训练集中删除掉的。</p><p><img src="/img/工业蒸汽预测-05%201模型验证/05_2.png" /></p><p><strong>留P交叉验证</strong>： LeavePOut 与 LeaveOneOut 非常相似，因为它通过从整个集合中删除 p 个样本来创建所有可能的训练/测试集。对于 n 个样本，这产生了 (n,p) 个 训练-测试对。与 LeaveOneOut 和 KFold 不同，当 p &gt; 1 时，测试集会重叠。</p><p><strong>用户自定义数据集划分： ShuffleSplit</strong> 迭代器将会生成一个用户给定数量的独立的训练/测试数据划分。样例首先被打散然后划分为一对训练测试集合。</p><p><strong>设置每次生成的随机数相同</strong>： 可以通过设定明确的 random_state ，使得伪随机生成器的结果可以重复。</p><h3 id="基于类标签具有分层的交叉验证迭代器">1.2.2基于类标签、具有分层的交叉验证迭代器</h3><p>如何解决样本不平衡问题？ 使用StratifiedKFold和StratifiedShuffleSplit 分层抽样。 一些分类问题在目标类别的分布上可能表现出很大的不平衡性：例如，可能会出现比正样本多数倍的负样本。在这种情况下，建议采用如 StratifiedKFold 和 StratifiedShuffleSplit 中实现的分层抽样方法，确保相应的类别频率在每个训练和验证的折叠中大致得以保留。</p><p><strong>StratifiedKFold</strong>是 k-fold 的变种，会返回 stratified（分层） 的折叠：每个小集合中，各个类别的样例比例大致和完整数据集中相同。</p><p><strong>StratifiedShuffleSplit</strong>是 ShuffleSplit 的一个变种，会返回直接的划分，比如：创建一个划分，但是划分中每个类的比例和完整数据集中的相同。</p><h3 id="用于分组数据的交叉验证迭代器">1.2.3用于分组数据的交叉验证迭代器</h3><p>如何进一步测试模型的泛化能力？ 留出一组特定的不属于测试集和训练集的数据。有时我们想知道在一组特定的 groups 上训练的模型是否能很好地适用于看不见的新数据。为了衡量这一点，我们需要确保验证对象中的所有样本均未在配对训练折叠中出现过，采用的办法就是留出一组特定的不属于测试集和训练集的数据，常用的方法包括GroupKFold,LeaveOneGroupOut,LeavePGroupsOut,GroupShuffleSplit.</p><p><strong>GroupKFold</strong>是 k-fold 的变体，它确保同一个 group 在测试和训练集中都不被表示。 例如，如果数据是从不同的组获得的，每个组又有多个样本，并且如果模型足够灵活，能高度从指定的特征中学习，则可能存在很好地拟合训练的组，但不能很好地预测不存在于训练组中的样本，GroupKFold 可以检测到这种过拟合的情况。</p><p><strong>LeaveOneGroupOut</strong>是一个交叉验证方案，它根据用户提供的 array of integer groups （整数组的数组）来区别不同的组，以此来提供样本。这个组信息可以用来编码任意域特定的预定义交叉验证折叠。每个训练集都是由除特定组别以外的所有样本构成的。</p><p><strong>LeavePGroupsOut</strong>类似于 LeaveOneGroupOut ，但为每个训练/测试集删除与 P 组有关的样本。</p><p><strong>GroupShuffleSplit</strong>迭代器是 ShuffleSplit 和 LeavePGroupsOut 的组合，它生成一个随机划分分区的序列，其中为每个分组提供了一个组子集。</p><h3 id="时间序列分割">1.2.4 时间序列分割</h3><p><strong>TimeSeriesSplit</strong> 也是K-Fold的一个变种，首先返回K折作为训练数据集，把K+1折作为测试数据集。请注意，与标准的交叉验证方法不同，有关时间序列的样本切分必须保证时间上的顺序性，不能用未来的数据去验证现在数据的正确性，只能使用时间上之前一段的数据建模，而用后一段时间的数据来验证模型预测的效果，这也是时间序列数据在做模型验证划分数据时与其他常规数据切分的区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split,cross_val_score,cross_validate <span class="hljs-comment"># 交叉验证所需的函数</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> KFold,LeaveOneOut,LeavePOut,ShuffleSplit <span class="hljs-comment"># 交叉验证所需的子集划分方法</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> StratifiedKFold,StratifiedShuffleSplit <span class="hljs-comment"># 分层分割</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GroupKFold,LeaveOneGroupOut,LeavePGroupsOut,GroupShuffleSplit <span class="hljs-comment"># 分组分割</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> TimeSeriesSplit <span class="hljs-comment"># 时间序列分割</span><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets  <span class="hljs-comment"># 自带数据集</span><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> svm  <span class="hljs-comment"># SVM算法</span><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> preprocessing  <span class="hljs-comment"># 预处理模块</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> recall_score  <span class="hljs-comment"># 模型度量</span><br><br>iris = datasets.load_iris()  <span class="hljs-comment"># 加载数据集</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;样本集大小：&#x27;</span>,iris.data.shape,iris.target.shape)<br><br><span class="hljs-comment"># ===================================数据集划分,训练模型==========================</span><br>X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=<span class="hljs-number">0.4</span>, random_state=<span class="hljs-number">0</span>)  <span class="hljs-comment"># 交叉验证划分训练集和测试集.test_size为测试集所占的比例</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;训练集大小：&#x27;</span>,X_train.shape,y_train.shape)  <span class="hljs-comment"># 训练集样本大小</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试集大小：&#x27;</span>,X_test.shape,y_test.shape)  <span class="hljs-comment"># 测试集样本大小</span><br>clf = svm.SVC(kernel=<span class="hljs-string">&#x27;linear&#x27;</span>, C=<span class="hljs-number">1</span>).fit(X_train, y_train) <span class="hljs-comment"># 使用训练集训练模型</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;准确率：&#x27;</span>,clf.score(X_test, y_test))  <span class="hljs-comment"># 计算测试集的度量值（准确率）</span><br><br><br><span class="hljs-comment">#  如果涉及到归一化，则在测试集上也要使用训练集模型提取的归一化函数。</span><br>scaler = preprocessing.StandardScaler().fit(X_train)  <span class="hljs-comment"># 通过训练集获得归一化函数模型。（也就是先减几，再除以几的函数）。在训练集和测试集上都使用这个归一化函数</span><br>X_train_transformed = scaler.transform(X_train)<br>clf = svm.SVC(kernel=<span class="hljs-string">&#x27;linear&#x27;</span>, C=<span class="hljs-number">1</span>).fit(X_train_transformed, y_train) <span class="hljs-comment"># 使用训练集训练模型</span><br>X_test_transformed = scaler.transform(X_test)<br><span class="hljs-built_in">print</span>(clf.score(X_test_transformed, y_test))  <span class="hljs-comment"># 计算测试集的度量值（准确度）</span><br><br><span class="hljs-comment"># ===================================直接调用交叉验证评估模型==========================</span><br>clf = svm.SVC(kernel=<span class="hljs-string">&#x27;linear&#x27;</span>, C=<span class="hljs-number">1</span>)<br>scores = cross_val_score(clf, iris.data, iris.target, cv=<span class="hljs-number">5</span>)  <span class="hljs-comment">#cv为迭代次数。</span><br><span class="hljs-built_in">print</span>(scores)  <span class="hljs-comment"># 打印输出每次迭代的度量值（准确度）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy: %0.2f (+/- %0.2f)&quot;</span> % (scores.mean(), scores.std() * <span class="hljs-number">2</span>))  <span class="hljs-comment"># 获取置信区间。（也就是均值和方差）</span><br><br><span class="hljs-comment"># ===================================多种度量结果======================================</span><br>scoring = [<span class="hljs-string">&#x27;precision_macro&#x27;</span>, <span class="hljs-string">&#x27;recall_macro&#x27;</span>] <span class="hljs-comment"># precision_macro为精度（准确率），recall_macro为召回率</span><br>scores = cross_validate(clf, iris.data, iris.target, scoring=scoring,cv=<span class="hljs-number">5</span>, return_train_score=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">sorted</span>(scores.keys())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试结果：&#x27;</span>,scores)  <span class="hljs-comment"># scores类型为字典。包含训练得分，拟合次数， score-times （得分次数）</span><br><br><br><span class="hljs-comment"># ==================================K折交叉验证、留一交叉验证、留p交叉验证、随机排列交叉验证==========================================</span><br><span class="hljs-comment"># k折划分子集</span><br>kf = KFold(n_splits=<span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> train, test <span class="hljs-keyword">in</span> kf.split(iris.data):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;k折划分：%s %s&quot;</span> % (train.shape, test.shape))<br>    <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># 留一划分子集</span><br>loo = LeaveOneOut()<br><span class="hljs-keyword">for</span> train, test <span class="hljs-keyword">in</span> loo.split(iris.data):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;留一划分：%s %s&quot;</span> % (train.shape, test.shape))<br>    <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># 留p划分子集</span><br>lpo = LeavePOut(p=<span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> train, test <span class="hljs-keyword">in</span> loo.split(iris.data):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;留p划分：%s %s&quot;</span> % (train.shape, test.shape))<br>    <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># 随机排列划分子集</span><br>ss = ShuffleSplit(n_splits=<span class="hljs-number">3</span>, test_size=<span class="hljs-number">0.25</span>,random_state=<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> train_index, test_index <span class="hljs-keyword">in</span> ss.split(iris.data):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;随机排列划分：%s %s&quot;</span> % (train.shape, test.shape))<br>    <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># ==================================分层K折交叉验证、分层随机交叉验证==========================================</span><br>skf = StratifiedKFold(n_splits=<span class="hljs-number">3</span>)  <span class="hljs-comment">#各个类别的比例大致和完整数据集中相同</span><br><span class="hljs-keyword">for</span> train, test <span class="hljs-keyword">in</span> skf.split(iris.data, iris.target):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;分层K折划分：%s %s&quot;</span> % (train.shape, test.shape))<br>    <span class="hljs-keyword">break</span><br><br>skf = StratifiedShuffleSplit(n_splits=<span class="hljs-number">3</span>)  <span class="hljs-comment"># 划分中每个类的比例和完整数据集中的相同</span><br><span class="hljs-keyword">for</span> train, test <span class="hljs-keyword">in</span> skf.split(iris.data, iris.target):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;分层随机划分：%s %s&quot;</span> % (train.shape, test.shape))<br>    <span class="hljs-keyword">break</span><br><br><br><span class="hljs-comment"># ==================================组 k-fold交叉验证、留一组交叉验证、留 P 组交叉验证、Group Shuffle Split==========================================</span><br>X = [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">2.4</span>, <span class="hljs-number">2.3</span>, <span class="hljs-number">4.55</span>, <span class="hljs-number">5.8</span>, <span class="hljs-number">8.8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br>y = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]<br>groups = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment"># k折分组</span><br>gkf = GroupKFold(n_splits=<span class="hljs-number">3</span>)  <span class="hljs-comment"># 训练集和测试集属于不同的组</span><br><span class="hljs-keyword">for</span> train, test <span class="hljs-keyword">in</span> gkf.split(X, y, groups=groups):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;组 k-fold分割：%s %s&quot;</span> % (train, test))<br><br><span class="hljs-comment"># 留一分组</span><br>logo = LeaveOneGroupOut()<br><span class="hljs-keyword">for</span> train, test <span class="hljs-keyword">in</span> logo.split(X, y, groups=groups):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;留一组分割：%s %s&quot;</span> % (train, test))<br><br><span class="hljs-comment"># 留p分组</span><br>lpgo = LeavePGroupsOut(n_groups=<span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> train, test <span class="hljs-keyword">in</span> lpgo.split(X, y, groups=groups):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;留 P 组分割：%s %s&quot;</span> % (train, test))<br><br><span class="hljs-comment"># 随机分组</span><br>gss = GroupShuffleSplit(n_splits=<span class="hljs-number">4</span>, test_size=<span class="hljs-number">0.5</span>, random_state=<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> train, test <span class="hljs-keyword">in</span> gss.split(X, y, groups=groups):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;随机分割：%s %s&quot;</span> % (train, test))<br><br><br><span class="hljs-comment"># ==================================时间序列分割==========================================</span><br>tscv = TimeSeriesSplit(n_splits=<span class="hljs-number">3</span>)<br>TimeSeriesSplit(max_train_size=<span class="hljs-literal">None</span>, n_splits=<span class="hljs-number">3</span>)<br><span class="hljs-keyword">for</span> train, test <span class="hljs-keyword">in</span> tscv.split(iris.data):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;时间序列分割：%s %s&quot;</span> % (train, test))<br></code></pre></td></tr></table></figure><pre><code class="hljs">样本集大小： (150, 4) (150,)训练集大小： (90, 4) (90,)测试集大小： (60, 4) (60,)准确率： 0.96666666666666670.9333333333333333[0.96666667 1.         0.96666667 0.96666667 1.        ]Accuracy: 0.98 (+/- 0.03)测试结果： &#123;&#39;fit_time&#39;: array([0.00000000e+00, 1.00016594e-03, 1.00016594e-03, 4.05311584e-05,       0.00000000e+00]), &#39;score_time&#39;: array([0.00100017, 0.        , 0.00100017, 0.        , 0.        ]), &#39;test_precision_macro&#39;: array([0.96969697, 1.        , 0.96969697, 0.96969697, 1.        ]), &#39;train_precision_macro&#39;: array([0.97674419, 0.97674419, 0.99186992, 0.98412698, 0.98333333]), &#39;test_recall_macro&#39;: array([0.96666667, 1.        , 0.96666667, 0.96666667, 1.        ]), &#39;train_recall_macro&#39;: array([0.975     , 0.975     , 0.99166667, 0.98333333, 0.98333333])&#125;k折划分：(75,) (75,)留一划分：(149,) (1,)留p划分：(149,) (1,)随机排列划分：(149,) (1,)分层K折划分：(100,) (50,)分层随机划分：(135,) (15,)组 k-fold分割：[0 1 2 3 4 5] [6 7 8 9]组 k-fold分割：[0 1 2 6 7 8 9] [3 4 5]组 k-fold分割：[3 4 5 6 7 8 9] [0 1 2]留一组分割：[3 4 5 6 7 8 9] [0 1 2]留一组分割：[0 1 2 6 7 8 9] [3 4 5]留一组分割：[0 1 2 3 4 5] [6 7 8 9]留 P 组分割：[6 7 8 9] [0 1 2 3 4 5]留 P 组分割：[3 4 5] [0 1 2 6 7 8 9]留 P 组分割：[0 1 2] [3 4 5 6 7 8 9]随机分割：[0 1 2] [3 4 5 6 7 8 9]随机分割：[3 4 5] [0 1 2 6 7 8 9]随机分割：[3 4 5] [0 1 2 6 7 8 9]随机分割：[3 4 5] [0 1 2 6 7 8 9]时间序列分割：[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38] [39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75]时间序列分割：[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75] [ 76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108 109 110 111 112]时间序列分割：[  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108 109 110 111 112] [113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149]</code></pre><h1 id="模型调参">2 模型调参</h1><p>参数可分为两类：过程影响类参数和子模型影响类参数。</p><h2 id="网格搜索">2.1 网格搜索</h2><p>Grid Search：一种穷举搜索的调参手段；穷举搜索：在所有候选的参数选择中，通过循环遍历，尝试每一种可能性，表现最好的参数就是最终的结果。</p><h3 id="简单的网格搜索">简单的网格搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br>iris = load_iris()<br><br>X_train,X_test,y_train,y_test = train_test_split(iris.data,iris.target,random_state=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Size of training set:&#123;&#125; size of testing set:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(X_train.shape[<span class="hljs-number">0</span>],X_test.shape[<span class="hljs-number">0</span>]))<br><br><span class="hljs-comment">####   grid search start</span><br>best_score = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> gamma <span class="hljs-keyword">in</span> [<span class="hljs-number">0.001</span>,<span class="hljs-number">0.01</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>]:<br>    <span class="hljs-keyword">for</span> C <span class="hljs-keyword">in</span> [<span class="hljs-number">0.001</span>,<span class="hljs-number">0.01</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>]:<br>        svm = SVC(gamma=gamma,C=C)<span class="hljs-comment">#对于每种参数可能的组合，进行一次训练；</span><br>        svm.fit(X_train,y_train)<br>        score = svm.score(X_test,y_test)<br>        <span class="hljs-keyword">if</span> score &gt; best_score:<span class="hljs-comment">#找到表现最好的参数</span><br>            best_score = score<br>            best_parameters = &#123;<span class="hljs-string">&#x27;gamma&#x27;</span>:gamma,<span class="hljs-string">&#x27;C&#x27;</span>:C&#125;<br><span class="hljs-comment">####   grid search end</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Best score:&#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(best_score))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Best parameters:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(best_parameters))<br></code></pre></td></tr></table></figure><pre><code class="hljs">Size of training set:112 size of testing set:38Best score:0.97Best parameters:&#123;&#39;gamma&#39;: 0.001, &#39;C&#39;: 100&#125;</code></pre><h2 id="学习曲线和验证曲线">2.2 学习曲线和验证曲线</h2><h3 id="学习曲线">2.2.1 学习曲线</h3><p>通过学习曲线来绘制模型在训练集和交叉验证集上的准确率，观察模型在新数据上的表现进而判断模型的方差或偏差是否过高，以及增大训练集是否可以减小过拟合。 <img src="/img/工业蒸汽预测-05%201模型验证/05_3.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB <span class="hljs-comment"># 高斯朴素贝叶斯分类器</span><br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC <span class="hljs-comment"># 支持向量机（SVM）分类器</span><br><br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_digits <span class="hljs-comment"># 手写数字数据集</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> learning_curve <span class="hljs-comment"># 绘制学习曲线</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> ShuffleSplit <span class="hljs-comment"># 创建随机交叉验证策略</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 绘制学习曲线</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_learning_curve</span>(<span class="hljs-params">estimator, title, X, y, ylim=<span class="hljs-literal">None</span>, cv=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                        n_jobs=<span class="hljs-number">1</span>, train_sizes=np.linspace(<span class="hljs-params"><span class="hljs-number">.1</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">5</span></span>)</span>):<br>    plt.figure()<br>    plt.title(title)<br>    <span class="hljs-keyword">if</span> ylim <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        plt.ylim(*ylim)<br>    plt.xlabel(<span class="hljs-string">&quot;Training examples&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;Score&quot;</span>)<br>    train_sizes, train_scores, test_scores = learning_curve(<br>        estimator, X, y, cv=cv, n_jobs=n_jobs, train_sizes=train_sizes)<br>    train_scores_mean = np.mean(train_scores, axis=<span class="hljs-number">1</span>)<br>    train_scores_std = np.std(train_scores, axis=<span class="hljs-number">1</span>)<br>    test_scores_mean = np.mean(test_scores, axis=<span class="hljs-number">1</span>)<br>    test_scores_std = np.std(test_scores, axis=<span class="hljs-number">1</span>)<br>    plt.grid() <span class="hljs-comment"># 在绘图中添加网格线</span><br><br>    plt.fill_between(train_sizes, train_scores_mean - train_scores_std,<br>                     train_scores_mean + train_scores_std, alpha=<span class="hljs-number">0.1</span>,<br>                     color=<span class="hljs-string">&quot;r&quot;</span>)<br>    plt.fill_between(train_sizes, test_scores_mean - test_scores_std,<br>                     test_scores_mean + test_scores_std, alpha=<span class="hljs-number">0.1</span>, color=<span class="hljs-string">&quot;g&quot;</span>)<br>    plt.plot(train_sizes, train_scores_mean, <span class="hljs-string">&#x27;o-&#x27;</span>, color=<span class="hljs-string">&quot;r&quot;</span>,<br>             label=<span class="hljs-string">&quot;Training score&quot;</span>)<br>    plt.plot(train_sizes, test_scores_mean, <span class="hljs-string">&#x27;o-&#x27;</span>, color=<span class="hljs-string">&quot;g&quot;</span>,<br>             label=<span class="hljs-string">&quot;Cross-validation score&quot;</span>)<br><br>    plt.legend(loc=<span class="hljs-string">&quot;best&quot;</span>)<br>    <span class="hljs-keyword">return</span> plt <br></code></pre></td></tr></table></figure><h4 id="代码解释-3">代码解释</h4><p>定义 <code>plot_learning_curve</code> 的函数。该函数用于绘制学习曲线，评估模型在不同训练集大小下的性能表现。</p><p><strong>参数说明：</strong></p><ul><li><code>estimator</code>：要评估的分类器或回归器对象</li><li><code>title</code>：图形的标题</li><li><code>X</code>：特征矩阵</li><li><code>y</code>：目标变量</li><li><code>ylim</code>：y轴上的取值范围</li><li><code>cv</code>：交叉验证策略对象，默认为<code>None</code></li><li><code>n_jobs</code>：并行处理的工作进程数，默认为1</li><li><code>train_sizes</code>：可选的训练集大小，用于绘制学习曲线，默认为 <code>[0.1, 0.3, 0.5, 0.7, 0.9, 1.0]</code></li></ul><p><strong>函数内部的操作如下：</strong></p><ol type="1"><li>创建一个新的图形对象</li><li>设置图形的标题和轴标签</li><li>如果指定了 <code>ylim</code> 参数，则设置 y 轴上的取值范围</li><li>调用 <code>learning_curve</code> 方法计算训练集和测试集的得分 (<code>train_scores</code> 和 <code>test_scores</code>)，以及相应的均值 (<code>train_scores_mean</code> 和 <code>test_scores_mean</code>) 和标准差 (<code>train_scores_std</code> 和 <code>test_scores_std</code>)</li><li>绘制学习曲线图形：使用 <code>fill_between</code> 方法绘制训练集和测试集得分的区间范围，使用 <code>plot</code> 方法绘制训练集和测试集得分的均值</li><li>添加图例并显示网格线</li><li>返回图形对象</li></ol><p><strong>部分代码详解：</strong></p><ol type="1"><li><code>plt.ylim(*ylim)</code><ul><li><code>plt.ylim</code> 是 Matplotlib 库中的一个函数，用于设置 y 轴上的取值范围。该函数接受两个参数，表示 y 轴的下限和上限。在上述代码中，<code>plt.ylim(*ylim)</code> 表示将传入的 <code>ylim</code> 参数解包，并将解包后得到的两个值分别作为下限和上限传递给 <code>plt.ylim</code> 函数。</li><li><code>*ylim</code> 使用了 <code>*</code> 运算符，表示将 <code>ylim</code> 参数解包。当函数调用时，如果一个参数前面有 <code>*</code>，则表示将该参数解包为多个独立的值。在这里，<code>*ylim</code> 的作用是将 <code>ylim</code> 参数解包为两个值，以便传递给 <code>plt.ylim</code> 函数。解包后的第一个值将成为下限，第二个值将成为上限。</li></ul></li></ol><hr /><ol start="2" type="1"><li><code>learning_curve</code> 函数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> learning_curve<br><br>train_sizes, train_scores, test_scores = learning_curve(<br>    estimator, X, y, train_sizes=<span class="hljs-literal">None</span>, cv=<span class="hljs-literal">None</span>, scoring=<span class="hljs-literal">None</span>, n_jobs=<span class="hljs-literal">None</span>, <br>    shuffle=<span class="hljs-literal">True</span>, random_state=<span class="hljs-literal">None</span>, verbose=<span class="hljs-number">0</span>, error_score=<span class="hljs-string">&#x27;raise&#x27;</span>, **kwargs)<br></code></pre></td></tr></table></figure><pre><code class="hljs">参数说明： </code></pre><ul><li><code>estimator</code>: 所使用的分类或回归算法。</li><li><code>X</code>: 特征矩阵。</li><li><code>y</code>: 目标变量。</li><li><code>train_sizes</code>: 是否自定义训练集大小，如果指定为 <code>None</code>，则默认生成 5 个等间隔的训练集大小，最小大小为 0.1，最大大小为 1，即 <code>train_sizes=np.linspace(0.1, 1.0, 5)</code>。</li><li><code>cv</code>: 交叉验证策略对象，默认为 None。可以使用整数、用于指定折叠数量的交叉验证生成器，或者用于划分数据集的可迭代对象。</li><li><code>scoring</code>: 模型性能评估指标，可以选择预定义的性能评估指标字符串，或者自定义的评估函数。</li><li><code>n_jobs</code>: 并行处理的工作进程数，默认为 None，表示使用单个进程（如果设为 -1，则使用所有可用的CPU）。</li><li><code>shuffle</code>: 每次交叉验证时，是否对训练数据顺序进行随机洗牌。</li><li><code>random_state</code>: 用于生成随机数的种子，设定后可以保证每次运行都能得到相同的结果。</li><li><code>verbose</code>: 控制输出信息的详细程度。</li><li><code>error_score</code>: 如果某个参数设置导致模型无法有效的训练，则会产生一个错误分数。</li></ul><pre><code class="hljs">函数返回三个数组：</code></pre><ul><li><code>train_sizes</code>: 训练集大小的数组。</li><li><code>train_scores</code>: 每组训练集大小下模型在训练集上的得分的数组。</li><li><code>test_scores</code>: 每组训练集大小下模型在测试集上的得分的数组。</li></ul><hr /><ol start="3" type="1"><li><code>plt.fill_between()</code> 函数</li></ol><p>用于在两条曲线之间填充颜色或填充区域。它可以用于可视化误差范围、置信区间或数据集分布等情况。文中即在学习曲线图中填充了训练集得分均值的上下方差区域。具体来说，它将训练集得分均值减去标准差的结果和加上标准差的结果之间的区域进行填充，并指定了填充的颜色。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.fill_between(x, y1, y2=<span class="hljs-number">0</span>, where=<span class="hljs-literal">None</span>, interpolate=<span class="hljs-literal">False</span>, step=<span class="hljs-literal">None</span>, **kwargs)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>x</code>：表示 x 轴上的数据点。</li><li><code>y1</code>：表示第一条曲线的 y 值。</li><li><code>y2</code>：表示第二条曲线的 y 值，默认为 0。如果设置为数组，则必须和 <code>y1</code> 的长度相同，用于填充两条曲线之间的区域。</li><li><code>where</code>：一个条件数组或布尔表达式，指定应该填充区域的位置。默认为 None，表示在整个 x 范围内填充区域。</li><li><code>interpolate</code>：一个布尔值，指定是否对填充区域进行插值。默认为 False，表示不进行插值。</li><li><code>step</code>：一个字符串，指定填充区域的类型，可以是 "pre"、"post" 或者 "mid"。默认为 None，表示不进行任何变化。</li><li><code>**kwargs</code>：可选参数，用于指定填充区域的属性，例如填充颜色、透明度等。</li></ul><p>常用属性参数：</p><ul><li><code>color</code>：指定填充的颜色。</li><li><code>alpha</code>：指定填充颜色的透明度。</li><li><code>edgecolor</code>：指定边缘线的颜色。</li><li><code>linewidth</code>：指定边缘线的宽度。</li></ul><hr /><ol start="4" type="1"><li><code>plt.plot()</code> 函数 用于绘制线图。可以用来可视化数据集、绘制函数曲线等。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(x, y, fmt, **kwargs)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>x</code>：表示 x 轴上的数据点。</li><li><code>y</code>：表示 y 轴上的数据点。</li><li><code>fmt</code>：一个可选参数，用于指定线条的样式，包括颜色、线型和标记。例如，'b-' 表示蓝色实线；'g--' 表示绿色虚线；'ro' 表示红色圆点。参考下面的属性参数部分。</li><li><code>**kwargs</code>：可选参数，用于设置线条的其他属性，例如线宽、标签、透明度等。</li></ul><p>常用的属性参数：</p><ul><li><code>color</code>：指定线条的颜色，例如 'red'、'green'。</li><li><code>linestyle</code>：指定线条的样式，例如 '-'（实线）、'--'（虚线）。</li><li><code>marker</code>：指定标记类型，例如 'o'（圆点）、's'（方块）。</li><li><code>linewidth</code>：指定线条的宽度。</li><li><code>label</code>：指定线条的标签。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">digits = load_digits()<br>X, y = digits.data, digits.target<br><br><br>title = <span class="hljs-string">&quot;Learning Curves (Naive Bayes)&quot;</span><br><span class="hljs-comment"># Cross validation with 100 iterations to get smoother mean test and train</span><br><span class="hljs-comment"># score curves, each time with 20% data randomly selected as a validation set.</span><br>cv = ShuffleSplit(n_splits=<span class="hljs-number">100</span>, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">0</span>)<br><br>estimator = GaussianNB()<br>plot_learning_curve(estimator, title, X, y, ylim=(<span class="hljs-number">0.7</span>, <span class="hljs-number">1.01</span>), cv=cv, n_jobs=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;module &#39;matplotlib.pyplot&#39; from &#39;D:\\Development\\anaconda3\\envs\\ml\\lib\\site-packages\\matplotlib\\pyplot.py&#39;&gt;</code></pre><p>​<br /><img src="/img/工业蒸汽预测-05%201模型验证/output_39_1.png" /> ​</p><h4 id="代码解释-4">代码解释</h4><p><code>ShuffleSplit()</code> 用于生成随机划分的训练集和测试集。它在每次划分时都会对数据集进行洗牌（随机打乱），以确保训练集和测试集的划分是随机的。</p><p>两个主要作用：</p><ol type="1"><li>评估模型性能：通过多次随机划分数据集并在每个划分上训练和评估模型，可以得到模型在不同训练集和测试集上的性能指标，如准确率、回归的 R2 分数等。</li><li>参数调优：通过交叉验证评估模型的性能，可以帮助选择最优的模型参数。例如，在网格搜索调优中使用 <code>ShuffleSplit()</code> 可以评估不同参数组合下的模型性能。</li></ol><p>常用参数：</p><ul><li><code>n_splits</code>：指定将数据集划分为多少个不同的训练集和测试集的组合。</li><li><code>test_size</code>：指定测试集的大小。可以是一个整数（表示样本数量），也可以是一个浮点数（表示比例）。</li><li><code>train_size</code>：指定训练集的大小。可以是一个整数（表示样本数量），也可以是一个浮点数（表示比例）。与 <code>test_size</code> 二选一。</li><li><code>random_state</code>：指定随机种子。保持相同的 <code>random_state</code> 值会得到相同的随机结果。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">title = <span class="hljs-string">&quot;Learning Curves (SVM, RBF kernel, $\gamma=0.001$)&quot;</span><br><span class="hljs-comment"># SVC is more expensive so we do a lower number of CV iterations:</span><br>cv = ShuffleSplit(n_splits=<span class="hljs-number">10</span>, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">0</span>)<br>estimator = SVC(gamma=<span class="hljs-number">0.001</span>)<br>plot_learning_curve(estimator, title, X, y, (<span class="hljs-number">0.7</span>, <span class="hljs-number">1.01</span>), cv=cv, n_jobs=<span class="hljs-number">1</span>)<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;module &#39;matplotlib.pyplot&#39; from &#39;D:\\Development\\anaconda3\\envs\\ml\\lib\\site-packages\\matplotlib\\pyplot.py&#39;&gt;</code></pre><p>​<br /><img src="/img/工业蒸汽预测-05%201模型验证/output_41_1.png" /> ​</p><h3 id="验证曲线">2.2.2 验证曲线</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_digits<br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC<br><span class="hljs-keyword">from</span> sklearn. model_selection <span class="hljs-keyword">import</span> validation_curve<br><br>digits = load_digits()<br>X, y = digits.data, digits.target<br><br>param_range = np.logspace(-<span class="hljs-number">6</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>train_scores, test_scores = validation_curve(<br>    SVC(), X, y, param_name=<span class="hljs-string">&quot;gamma&quot;</span>, param_range=param_range,<br>    cv=<span class="hljs-number">10</span>, scoring=<span class="hljs-string">&quot;accuracy&quot;</span>, n_jobs=<span class="hljs-number">1</span>)<br>train_scores_mean = np.mean(train_scores, axis=<span class="hljs-number">1</span>)<br>train_scores_std = np.std(train_scores, axis=<span class="hljs-number">1</span>)<br>test_scores_mean = np.mean(test_scores, axis=<span class="hljs-number">1</span>)<br>test_scores_std = np.std(test_scores, axis=<span class="hljs-number">1</span>)<br><br>plt.title(<span class="hljs-string">&quot;Validation Curve with SVM&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;$\gamma$&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Score&quot;</span>)<br>plt.ylim(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.1</span>)<br>plt.semilogx(param_range, train_scores_mean, label=<span class="hljs-string">&quot;Training score&quot;</span>, color=<span class="hljs-string">&quot;r&quot;</span>)<br>plt.fill_between(param_range, train_scores_mean - train_scores_std,<br>                 train_scores_mean + train_scores_std, alpha=<span class="hljs-number">0.2</span>, color=<span class="hljs-string">&quot;r&quot;</span>)<br>plt.semilogx(param_range, test_scores_mean, label=<span class="hljs-string">&quot;Cross-validation score&quot;</span>,<br>             color=<span class="hljs-string">&quot;g&quot;</span>)<br>plt.fill_between(param_range, test_scores_mean - test_scores_std,<br>                 test_scores_mean + test_scores_std, alpha=<span class="hljs-number">0.2</span>, color=<span class="hljs-string">&quot;g&quot;</span>)<br>plt.legend(loc=<span class="hljs-string">&quot;best&quot;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-05%201模型验证/output_43_0.png" /> ​</p><h4 id="代码解释-5">代码解释</h4><ol type="1"><li><code>np.logspace()</code> 用于生成在对数刻度上均匀分布的数值序列。</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">np.logspace(start, stop, <span class="hljs-attribute">num</span>=50, <span class="hljs-attribute">endpoint</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">base</span>=10.0, <span class="hljs-attribute">dtype</span>=None)<br></code></pre></td></tr></table></figure><p>参数解释：</p><ul><li><code>start</code>：起始值，表示数列的起点。</li><li><code>stop</code>：结束值，表示数列的终点。</li><li><code>num</code>：要生成的数的个数，默认为 50。</li><li><code>endpoint</code>：是否包含终点值，默认为 True。如果为 False，则生成的数列不包含结束值。</li><li><code>base</code>：对数的底数，默认为 10.0。</li><li><code>dtype</code>：返回值的数据类型。</li></ul><p><code>np.logspace()</code> 函数将起始值和结束值在对数刻度上等分为指定个数的数列，并返回该数列。</p><p><code>param_range = np.logspace(-6, -1, 5)</code> 生成一个从 10 的 -6 次方到 10 的 -1 次方之间的等比数列，共包含 5 个值。</p><hr /><ol start="2" type="1"><li><code>validation_curve()</code>函数 用于绘制验证曲线（validation curve）。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sklearn.model_selection.validation_curve(estimator, X, y, param_name, param_range, cv=<span class="hljs-literal">None</span>, scoring=<span class="hljs-literal">None</span>, n_jobs=<span class="hljs-literal">None</span>, pre_dispatch=<span class="hljs-string">&quot;all&quot;</span>, verbose=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>参数解释：</p><ul><li><code>estimator</code>：用于训练和预测的模型对象。</li><li><code>X</code>：特征数据。</li><li><code>y</code>：目标数据。</li><li><code>param_name</code>：要调整的控制模型行为的参数名称。</li><li><code>param_range</code>：参数的取值范围。</li><li><code>cv</code>：交叉验证的折数，默认为 None。如果为整数，则表示 K 折交叉验证；如果为交叉验证生成器对象，则可以更灵活地定义交叉验证策略。</li><li><code>scoring</code>：评估指标，默认为 None。如果为 None，则使用模型的默认评估指标；如果为字符串或可调用对象，则使用指定的评估指标。</li><li><code>n_jobs</code>：并行运行的作业数，默认为 None，表示使用单个进程运行。</li><li><code>pre_dispatch</code>：控制并行运行的内部作业数量，默认为 "all"，表示并行运行所有作业。</li><li><code>verbose</code>：详细程度，默认为 0，表示不输出执行信息；大于 0 的值表示输出一些执行信息。</li></ul><p><code>validation_curve()</code> 函数通过在给定参数的不同取值上计算训练得分和验证得分，绘制了模型复杂度（参数）与性能之间的关系曲线。它有助于判断模型在不同参数取值下的过/欠拟合情况，并选择最佳参数取值。</p><p>返回值：</p><ul><li>返回一个包含训练得分和验证得分的元组 <code>(train_scores, test_scores)</code>。每个得分都是一个二维数组，行数表示不同参数取值，列数表示交叉验证的次数。</li></ul><p>本示例中，我们使用 SVM 模型对 iris 数据集进行训练。<code>param_name="gamma"</code> 表示将调整 gamma 参数的值。<code>param_range</code> 定义了 gamma 参数的取值范围。</p><p><code>cv=5</code> 表示进行 5 折交叉验证。<code>scoring="accuracy"</code> 表示评估指标为准确率。</p><hr /><ol start="3" type="1"><li><code>plt.semilogx()</code> 函数 在 x 轴为对数刻度的情况下，绘制曲线。</li></ol><p><code>plt.semilogx(param_range, train_scores_mean, label="Training score", color="r")</code> 中：</p><ul><li><code>param_range</code>：表示 x 轴上的数据点位置。</li><li><code>train_scores_mean</code>：表示 y 轴上的数据点位置。</li><li><code>label="Training score"</code>：指定图例中要显示的曲线名称为 "Training score"。</li><li><code>color="r"</code>：指定曲线的颜色为红色。</li></ul><hr /><ol start="4" type="1"><li><code>plt.legend()</code> 函数 用于添加图例。</li></ol><p><code>plt.legend(loc="best")</code> 的作用是根据已经标识的线条对应的标签名称，自动在最佳位置添加图例。其中 <code>loc</code> 参数指定了图例的位置，"best" 表示自动选择最佳位置，也可以通过具体的坐标系位置或字符串表示来指定固定的位置。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习实战入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言01-C语言的基础知识123</title>
    <link href="/2023/08/30/C%E8%AF%AD%E8%A8%8001-C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86123/"/>
    <url>/2023/08/30/C%E8%AF%AD%E8%A8%8001-C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86123/</url>
    
    <content type="html"><![CDATA[<h1 id="c语言01-c语言的基础知识123">C语言01-C语言的基础知识123</h1><p>本章重点</p><ul><li>第一个C语言程序</li><li>数据类型</li><li>变量、常量</li><li>字符串+转义字符+注释</li><li>选择语句</li><li>循环语句</li><li>函数</li><li>数组</li><li>操作符</li><li>常见关键字</li><li>define 定义常量和宏</li><li>指针</li></ul><h1 id="第一个c语言程序">1 第一个C语言程序</h1><ol type="1"><li><p>打开VS</p></li><li><p>创建项目 <img src="/img/C语言01-C语言的基础知识123/5.png" /></p></li><li><p>创建源文件</p></li></ol><p><img src="/img/C语言01-C语言的基础知识123/7.png" /></p><p><img src="/img/C语言01-C语言的基础知识123/8.png" /></p><ol start="4" type="1"><li>打印 hello word</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello word\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1、主函数</span><br><span class="hljs-comment">// c语言代码中一定要有main函数，主函数</span><br><span class="hljs-comment">// 主函数写法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 2、#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">// printf是一个库函数，专门用来打印数据的</span><br><span class="hljs-comment">// 不能直接用,需要包含&lt;stdio.h&gt;头文件，即：#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">// std - 标准</span><br><span class="hljs-comment">// i - input</span><br><span class="hljs-comment">// o - output</span><br><br><span class="hljs-comment">// 3、/n 换行 打印完换行</span><br><br><span class="hljs-comment">// 4、return 0;</span><br><span class="hljs-comment">// 代码正常运行，返回0，异常返回非0.</span><br><br><br></code></pre></td></tr></table></figure><h1 id="数据类型">2 数据类型</h1><table><thead><tr class="header"><th>数据类型</th><th style="text-align: left;">说明</th><th>字节</th></tr></thead><tbody><tr class="odd"><td>char</td><td style="text-align: left;">字符数据类型</td><td>1</td></tr><tr class="even"><td>short</td><td style="text-align: left;">短整型</td><td>2</td></tr><tr class="odd"><td>int</td><td style="text-align: left;">整形</td><td>4</td></tr><tr class="even"><td>long</td><td style="text-align: left;">长整型</td><td>4</td></tr><tr class="odd"><td>long long</td><td style="text-align: left;">更长的整形</td><td>8</td></tr><tr class="even"><td>float</td><td style="text-align: left;">单精度浮点数</td><td>4</td></tr><tr class="odd"><td>double</td><td style="text-align: left;">双精度浮点数</td><td>8</td></tr></tbody></table><h1 id="变量常量">3 变量、常量</h1><p>生活中的有些值是不变的（比如：圆周率，性别，身份证号码，血型等等） 有些值是可变的（比如：年龄，体重，薪资。 不变的值，C语言中用<strong>常量</strong>的概念来表示，变得值C语言中用<strong>变量</strong>来表示。</p><h2 id="变量定义方法">3.1 变量定义方法</h2><p>数据类型 变量名 = 值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> age = <span class="hljs-number">150</span>;<br></code></pre></td></tr></table></figure><h2 id="变量的使用">3.2 变量的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">// 1.初始化</span><br><span class="hljs-type">int</span> num1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> num2 = <span class="hljs-number">0</span>;<br> <br><span class="hljs-comment">// 输入两个整数</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;num1,&amp;num2); <span class="hljs-comment">// 按两个整型数值读取，读取后放入到num1 num2中，</span><br><span class="hljs-comment">// %d 占位符，两个整数。&amp;num，取地址，scanf需要地址，&amp;取地址。</span><br><span class="hljs-comment">// scanf安全问题解决,首行加入：#define _CRT_SECURE_NO_WARNINGS</span><br><br><span class="hljs-comment">// 2.求和</span><br><span class="hljs-type">int</span> sum = num1+num2;<br><br><span class="hljs-comment">// 3.输出</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变量的作用域和生命周期">3.3 变量的作用域和生命周期</h2><p><strong>作用域</strong></p><p>作用域（scope）是程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的,而限定这个名字的可用性的代码范围就是这个名字的作用域。</p><ol type="1"><li><p>局部变量的作用域是变量所在的局部范围。</p></li><li><p>全局变量的作用域是整个工程。</p></li></ol><p><strong>生命周期</strong></p><p>变量的生命周期指的是变量的创建到变量的销毁之间的一个时间段</p><ol type="1"><li><p>局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束。</p></li><li><p>全局变量的生命周期是：整个程序的生命周期。</p></li></ol><h2 id="常量">3.3 常量</h2><p>C语言中的常量和变量的定义的形式有所差异。</p><p>C语言中的常量分为以下四种：</p><ol type="1"><li>字面常量，自身就是常量，字面意义的常量</li><li>由 <code>const</code> 修饰的常变量</li><li>由 <code>#define</code> 定义的标识符常量</li><li>枚举常量</li></ol><h2 id="字面常量">3.1 字面常量</h2><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>  <br>&#123;  <br>    <span class="hljs-number">30</span>;<span class="hljs-comment">//数字常量  </span><br>    <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//字符常量  </span><br>    <span class="hljs-string">&#x27;abcd&#x27;</span>;<span class="hljs-comment">//字符串常量  </span><br>    <span class="hljs-comment">//以上常量可以直接输出  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;30,&#x27;a&#x27;,&#x27;abcd&#x27;&quot;</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="由-const-修饰的常变量">3.2 由 <code>const</code> 修饰的常变量</h2><p>定义常量方式：<code>const 数据类型 常量名 = 值;</code></p><p>由const定义的常变量本质上依旧为变量，但其具有==不可变==的属性 ;</p><p>首先变量可以修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n1=%d\n&quot;</span>,n);<br>n = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n2=%d\n&quot;</span>,n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用const定义后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n1=%d\n&quot;</span>, n);<br>n = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n2=%d\n&quot;</span>, n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>报错：</p><p><img src="/img/C语言01-C语言的基础知识123/1.jpg" /></p><p><strong>解释：</strong> 变量 n 的值是可以后续赋值改变的，但用const定义之后，编译器不允许修改其值，其值不可再改变，如果再次被赋值就会被报错。</p><p>在c语言中，const修饰的 n ,<strong>本质</strong>是变量，但是不能被修改，有常量的属性，同样因为是变量也不可用于数组的定义。</p><h2 id="由-define-定义的标识符常量">3.3 由 <code>#define</code> 定义的标识符常量</h2><p>定义方式：`<code>#define 常量名 值</code></p><p>由 <code>#define</code> 定义的标识符常量，可视为一般的字面常量，不可修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STR <span class="hljs-string">&quot;str&quot;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,MAX);<br><span class="hljs-type">int</span> a = MAX;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d&quot;</span>,a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,STR);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：<code>#define</code> 定义的不一定是整数类型的。</p><h2 id="枚举常量">3.4 枚举常量</h2><p>生活中有些值可以一 一列举出来的，比如性别（男、女），三原色（红、绿、蓝）等，将这些可能的取值枚举出来，未来可能的取值即为枚举常量。</p><p>看以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> // 声明变量(三原色)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">//未来可能的取值,即枚举常量</span><br>RED, <span class="hljs-comment">// 对应的值从0开始</span><br>GERRN,<br>BLUE<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> <span class="hljs-title">c</span> =</span> RED;<br><span class="hljs-comment">// RED = 10; // 报错，枚举常量不可修改</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="字符串转义字符注释">4 字符串+转义字符+注释</h1><h2 id="字符串">4.1 字符串</h2><ul><li><code>"abcdef"</code> 这种由双引号引起来的一串字符，称为字符串字面值，或者简称字符串。</li><li>字符串就是字符数组，好多个字符串起来的一组数据。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;c&#x27;</span>;<span class="hljs-comment">//定义了一个字符数据类型c</span><br><br><span class="hljs-string">&quot;abcdef&quot;</span> ;<span class="hljs-comment">// 这种由双引号引起来的一串字符称为字符串字面值，或者简称字符串。</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注：</strong> c语言中有字符类型没有字符串类型，若想存储需要放入字符数组中。</p><p>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;abcdef&quot;</span>; <span class="hljs-comment">// 存储字符串</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然字符串存储在字符数组中，那么数组中存储了哪些东西呢？</p><ol type="1"><li>在VS中按F10对代码进行调试，页面左端会显示黄色的小三角（如下图所示），三角号到哪行代码即运行到哪行，按一次F10 运行一行，直到运行到最后一行。</li></ol><p><img src="/img/C语言01-C语言的基础知识123/2.jpg" /></p><ol start="2" type="1"><li>调试后，点击 <code>调试-&gt;窗口-&gt;监视-&gt;监视(1)</code></li></ol><p><img src="/img/C语言01-C语言的基础知识123/3.jpg" /></p><ol start="3" type="1"><li>输入监视的对象，此文中为<code>arr</code> , 并展开。</li></ol><p><img src="/img/C语言01-C语言的基础知识123/4.jpg" /></p><p>我们发现数组<code>arr</code>大小为7并不是6，除了所要存储的 <code>abcdef</code> 外还另外放入了 <code>\0</code> ，说明还默认存储了一个 <code>\0</code> ，这个 <code>\0</code> 即为字符串的<strong>结束标志</strong>。</p><p><strong><code>\0</code> 作为字符串的结束标志非常重要</strong></p><p>为什么重要呢？</p><p>思考以下代码输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> arr1[] = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">char</span> arr2[] = &#123; <span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span> &#125;;<br><span class="hljs-type">char</span> arr3[] = &#123; <span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, arr1); <span class="hljs-comment">// %s 为输出字符串</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, arr2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, arr3);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby">abc<span class="hljs-keyword">def</span><br><span class="hljs-title function_">abcdef</span>烫烫烫烫烫abc<span class="hljs-keyword">def</span><br><span class="hljs-title function_">abcdef</span><br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol type="1"><li>首先查看一下 arr1 和 arr2 存储的内容</li></ol><p><img src="/img/C语言01-C语言的基础知识123/10.png" /></p><p>arr1用字符串初始化，编译系统会自动加入 <code>\0</code> ，所以arr1中有 <code>\0</code> ; 当我们主动给arr2中放入 <code>abcdef</code> ，数组中并没有 <code>\0</code> 。</p><ol start="2" type="1"><li>当我们用 <code>%s</code> 输出字符串时，输出结果为：</li></ol><p><img src="/img/C语言01-C语言的基础知识123/9.png" /></p><p>字符串作为一维数组存放在内存中，当程序遇到 <code>\0</code> 时判断字符串结束，如果没遇到，编译器自动向后打印直到遇见 <code>\0</code> 结束 。</p><p><strong>对于arr1</strong> <img src="/img/C语言01-C语言的基础知识123/11.png" /> 数组 arr1 从 <code>a</code> 开始输出，遇到 <code>\0</code> 结束，arr1是以字符串初始化，所以编译系统会默认加入 <code>\0</code> 。 在计算字符串长度的时候<code>\0</code> 是结束<strong>标志</strong>，不算作字符串内容，不打印。所以arr1打印结果为 <code>abcdef</code></p><p><strong>对于arr2</strong> <img src="/img/C语言01-C语言的基础知识123/12.png" /> 当我们主动给arr2中放入 <code>abcdef</code> ，编译系统并不会自动加入 <code>\0</code>。 数组arr2也是从 <code>a</code> 开始打印，但是不同的是 arr2 中并没有 <code>\0</code> ，而且arr2后面还有内存，内存中存储了其他内容，所以程序继续往后打印，直到遇到了一个 <code>\0</code> 结束打印，这就是为什么arr2会打印我们指定外的内容。</p><p><strong>对于arr3</strong> <img src="/img/C语言01-C语言的基础知识123/13.png" /> arr3中主动添加 <code>\0</code> 和arr1效果相同。</p><hr /><p>另一个案例：用 <code>strlen</code> 求字符串长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> arr1[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-type">char</span> arr2[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strlen</span>(arr1));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strlen</span>(arr2));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">arr1 随机<br>arr2 为<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>因为 <code>strlen</code> 是计算字符串的长度，arr1中没有 <code>\0</code> 所以不知道字符串什么时候截止，长度随机。</p><p>对于arr2，长度为4，但是只放入了3个值，为不完全初始化，未放入值的位置默认为 0 ，数字0对应的值为0，<code>\0</code> 对应的ASCII值也为0，这两个本质没有什么区别，所以编译器遇到了值0，就作为字符串的结束标志，所以arr2的字符串长度只有3。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0</span> - 数字零，值为<span class="hljs-number">0</span><br><span class="hljs-string">&#x27;0&#x27;</span> - 字符零，ASCII值为<span class="hljs-number">48</span><br><span class="hljs-string">&#x27;\0&#x27;</span> - 字符，ASCII值为<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>==总结：==</p><ul><li>c语言中没有字符串类型，若想存储需要放入字符数组中。</li><li>字符串的结束标志是一个 \0的转义字符。在计算字符串长度的时候 \0是结束标志，不算作字符串内容。</li></ul><h2 id="转义字符">4.2 转义字符</h2><h3 id="概念">4.2.1 概念</h3><p>C中定义了一些字母前加""来表示常见的那些不能显示的ASCII字符，如\0,\t,\n等，就称为转义字符。</p><table><thead><tr class="header"><th>转义字符</th><th>释义</th></tr></thead><tbody><tr class="odd"><td>\?</td><td>在书写连续多个问号时使用，防止他们被解析成三字母词</td></tr><tr class="even"><td>\`</td><td>用于表示字符常量`</td></tr><tr class="odd"><td>\"</td><td>用于表示一个字符产内部的双引号</td></tr><tr class="even"><td>\\</td><td>用于表示一个反斜杠，防止它被解释为一个转义序列符</td></tr><tr class="odd"><td>\a</td><td>警告字符，蜂鸣</td></tr><tr class="even"><td>\b</td><td>退格符</td></tr><tr class="odd"><td>\f</td><td>进纸符</td></tr><tr class="even"><td>\n</td><td>换行</td></tr><tr class="odd"><td>\r</td><td>回车</td></tr><tr class="even"><td>\t</td><td>水平制表符</td></tr><tr class="odd"><td>\v</td><td>垂直制表符</td></tr><tr class="even"><td>\ddd</td><td>ddd表示1~3个八进制的数字。如：\130</td></tr><tr class="odd"><td>\xdd</td><td>dd表示2个十六进制数字。如:\x30</td></tr></tbody></table><h3 id="详解">4.2.2 详解</h3><p><strong>1. <code>\?</code></strong></p><p>早期编译器会把三字母词 <code>??)</code> 解析成 <code>]</code> ；把三字母词 <code>??(</code> 解析成 <code>[</code> 。若不想这样解析，在问号前面加上 <code>\</code> ,此时的 <code>?</code> 不再是三字母词里的问号。目前编译器不在支持三字母词。</p><p><strong>2. <code>\'</code></strong></p><p>当想打印字符 <code>'</code> 时，按如下编写会报错。</p><p><img src="/img/C语言01-C语言的基础知识123/14.png" /></p><p>因为编译器把前两个单引号看成了一对，认为前两个单引号中间括了一个字符，最后一个单引号落单了，编译器无法解析。</p><p>在中间单引号前加 <code>\</code> 转义即可，让它单纯的就是一个单引号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. <code>\"</code></strong></p><p>当想打印字符 <code>"</code> 时，用 <code>\"</code>，与 <code>\'</code> 道理相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;\&quot;&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. <code>\\</code></strong></p><p>将 <code>\</code> 转义成单纯的斜杠。</p><p>当打印字符串 <code>abcd\0ef</code> 时只会输出 <code>abcd</code> ,因为遇到了字符串的结束标志\0，此时在 <code>\</code> 前在加一个 <code>\</code> ，把斜杠转移成普通的斜杠，不让<code>\0</code> 组成转义字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;abcd\\0ef&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 结果</span><br><span class="hljs-comment">// abcd\0ef</span><br></code></pre></td></tr></table></figure><p><strong>5. <code>\n</code> 和<code>\r</code></strong></p><p>\n : 对输出进行换行</p><p>\r : 对输出进行回车</p><p><strong>6. <code>\t</code></strong></p><p>和电脑的Tab键效果相同。</p><p><strong>7. <code>\ddd</code></strong></p><p>ddd表示1~3个八进制的数字。如：\130。130为八进制的数字（幺叄零），不是一百三。</p><p>当打印 \130 时打印出来的是大写的X</p><p><img src="/img/C语言01-C语言的基础知识123/15.png" /></p><p>因为 \ddd 表示的是8进制的ddd转换成10进制的数字，即8进制的130，转换成10进制的88， 而88在ASCII码上对应的即为大写的X，所以打印字符88，即打印88在ASCII码上对应的值X。</p><p><img src="/img/C语言01-C语言的基础知识123/16.png" /></p><p><strong>8. <code>\xdd</code></strong></p><p>dd表示2个十六进制数字。如:\x60 。<code>\x60</code> 是将60这个十六进制的数字转换成十进制的96。然后打印出96对应的ASCII码的值。</p><p>==总结：==</p><p>只需知道 <code>\?</code> <code>\'</code> <code>\"</code> <code>\\</code> <code>\n</code> <code>\r</code> <code>\t</code> <code>\ddd</code> <code>\xdd</code> 即可。</p><h2 id="注释">4.3 注释</h2><p>注释是对代码的解释和说明文字。</p><p>C语言中的注释分为两种：</p><h3 id="c风格的注释">4.3.1 C++风格的注释</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这是单行注释文字</span><br></code></pre></td></tr></table></figure><h3 id="c语言风格的注释">4.3.2 C语言风格的注释</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="使用的技巧">4.3.3 使用的技巧</h3><p>如果我们要对代码进行解释，那么就可以使用注释。</p><p>当注释的内容比较少，一行就写完了，可以用C++风格的注释。</p><p>如果注释的内容比较多，需要写在多行，那么可以使用C风格的注释。</p><h3 id="注意">4.3.4 注意</h3><p>注释的内容不会参与编译和运行的，仅仅是对代码的解释说明而已。</p><p>所以，不管在注释当中写什么内容，都不会影响代码运行的结果。</p><p>C语言风格的注释不能嵌套注释</p><p>C++风格的注释可以注释一行也可以注释多行</p><h1 id="选择语句">5 选择语句</h1><p>选择结构指的是进行逻辑判断，当满足与某些条件的时候才会执行某些语句。 C语言包括两类选择语句，if语句和switch语句。</p><h1 id="循环语句">6 循环语句</h1><p>C语言包括三类循环语句，while语句、for语句、do ... while语句。</p><h1 id="函数">7 函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> num1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> num2 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入两个操作数:&gt;&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);<br>sum = num1 + num2;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d\n&quot;</span>, sum);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 上述代码，写成函数如下：</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br><span class="hljs-type">int</span> z = x+y;<br><span class="hljs-keyword">return</span> z;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> num1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> num2 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入两个操作数:&gt;&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);<br>sum = Add(num1, num2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d\n&quot;</span>, sum);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>函数的特点就是简化代码，代码复用。</li></ul><h1 id="数组">8 数组</h1><ul><li>一组相同类型的集合</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>C语言规定：数组的每个元素都有一个下标，下标是从0开始的。 数组可以通过下标来访问的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,arr[<span class="hljs-number">0</span>])<br><br><span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><h1 id="操作符">9 操作符</h1><h2 id="算数操作符">算数操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">+ - * / %<br></code></pre></td></tr></table></figure><h2 id="移位操作符">移位操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;&gt; &lt;&lt;<br></code></pre></td></tr></table></figure><p>&lt;&lt;（左移）和&gt;&gt;（右移）。</p><p>左移运算是将一个二进制位的操作数按指定移动的位数向左移动，移出位被丢弃，右边移出的空位一律补 0 。</p><p>右移运算是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位一律补 0 ，或者补符号位，这由不同的机器而定。在使用补码作为机器数的机器中，正数的符号位为  0 ，负数的符号位为 1 。</p><h2 id="位操作符">位操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">&amp; ^ |<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>符号</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr class="odd"><td>&amp;</td><td>与</td><td>两个位都为1时，结果才为1</td></tr><tr class="even"><td>|</td><td>或</td><td>两个位都为0时，结果才为0</td></tr><tr class="odd"><td>^</td><td>异或</td><td>两个位相同为0，相异为1</td></tr><tr class="even"><td></td><td></td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> c = a &amp; b;<br><span class="hljs-type">int</span> d = a | b;<br><span class="hljs-type">int</span> e = a ^ b;<br><br><span class="hljs-comment">// a 011</span><br><span class="hljs-comment">// b 101</span><br><br><span class="hljs-comment">// c 001</span><br><span class="hljs-comment">// d 111</span><br><span class="hljs-comment">// e 110</span><br></code></pre></td></tr></table></figure><h2 id="赋值操作符">赋值操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">= += -= *= /= &amp;= ^= |= &gt;&gt;= &lt;&lt;= <br></code></pre></td></tr></table></figure><h2 id="单目操作符">单目操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">! 逻辑反操作<br><br>- 负值<br><br>+ 正值<br><br>&amp; 取地址<br><br><span class="hljs-keyword">sizeof</span> 操作数的类型长度（以字节为单位）<br><br>~ 对一个数的二进制按位取反<br><br>-- 前置、后置 --<br><br>++ 前置、后置++<br><br>* 间接访问操作符(解引用操作符)<br><br>(类型) 强制类型转换 <span class="hljs-type">int</span> a = (<span class="hljs-type">int</span>)<span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><p><strong>sizeof：</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//sizeof计算的是变星/类型所点交间的太小，单位是字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span> (a));<span class="hljs-comment">//4</span><br><span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;%din&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//4</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span> a);<span class="hljs-comment">//4</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span> <span class="hljs-type">int</span>);<span class="hljs-comment">//报错</span><br><br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span> (arr));<span class="hljs-comment">//40</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span> (arr)/<span class="hljs-keyword">sizeof</span> (arr[<span class="hljs-number">0</span>]));<span class="hljs-comment">//计算数组元素个数</span><br>&#125;<br><br></code></pre></td></tr></table></figure></p><p><strong>~：</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<span class="hljs-comment">//4字节 32bit位</span><br><span class="hljs-type">int</span> b = ~a;<span class="hljs-comment">//按(2进制)位取反</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,b);<span class="hljs-comment">// -1</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>原码、反码、补码是计算机中对数字的二进制表示方法。 只要是整数在内存中存储的都是二进制的补码，使用的、打印的是原码。</p><p>正数：原码，反码，补码相同 负数： 原码-直接按照正负写出的二进制序列 反码-原码的符号位不变，其他位按位取反 补码-反码+1</p><p>原码、反码、补码之间计算规则为： 1、正整数的原码、反码、补码完全一样，即符号位固定为0，数值位相同。</p><p>2、负整数的符号位固定为1，由原码变为补码时，规则如下：原码符号位1不变，整数的每一位二进制数位求反，得到反码；反码符号位1不变，反码数值位最低位加1，得到补码。</p><p>0的二进制： 00000000 00000000 00000000 00000000</p><p>对0按位取反：11111111 11111111 11111111 11111111</p><p>所以要想将b打印出来，需要将补码转换为原码，即为以下步骤： 补码减一得到反码，反码符号位不变其他为按位取反得到原码 补码：11111111 11111111 11111111 11111111 反码：11111111 11111111 11111111 11111110 原码：10000000 00000000 00000000 00000001</p><h2 id="关系操作符">关系操作符</h2><p>&gt; &gt;= &lt; &lt;= != ==</p><h2 id="逻辑操作符">逻辑操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">&amp;&amp;<br>||<br></code></pre></td></tr></table></figure><h2 id="条件操作符">条件操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">exp1 ? exp2 : exp3<br></code></pre></td></tr></table></figure><p>exp1为真，exp2执行 exp1为假，exp3执行</p><h2 id="逗号表达式">逗号表达式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">exp1, exp2, exp3, …expN<br></code></pre></td></tr></table></figure><h2 id="下标引用函数调用和结构成员">下标引用、函数调用和结构成员</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[] () . -&gt;<br></code></pre></td></tr></table></figure><h1 id="常见关键字">10 常见关键字</h1><p>C语言提供了丰富的关键字，这些关键字都是语言本身预先设定好的，用户自己是不能创造关键字的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> (省略不写) <span class="hljs-keyword">break</span> <span class="hljs-keyword">case</span> <span class="hljs-type">char</span> <span class="hljs-title function_">const</span><span class="hljs-params">(修饰变量、常属性)</span><br><span class="hljs-keyword">continue</span> <span class="hljs-title function_">default</span><span class="hljs-params">(<span class="hljs-keyword">switch</span> cause 中)</span> <span class="hljs-keyword">do</span> <span class="hljs-type">long</span> <span class="hljs-title function_">register</span><span class="hljs-params">(定义寄存器)</span> <span class="hljs-type">double</span> <span class="hljs-keyword">else</span> <span class="hljs-title function_">enum</span><span class="hljs-params">(枚举)</span> <span class="hljs-title function_">extern</span><span class="hljs-params">(声明外部符号)</span> <span class="hljs-type">float</span> <span class="hljs-keyword">for</span><br><span class="hljs-keyword">goto</span> <span class="hljs-keyword">if</span> <span class="hljs-type">int</span> <span class="hljs-keyword">return</span> <span class="hljs-type">short</span> <span class="hljs-type">signed</span> <span class="hljs-keyword">sizeof</span> <span class="hljs-type">static</span> <span class="hljs-title function_">struct</span><span class="hljs-params">(结构体)</span> <span class="hljs-keyword">switch</span> <span class="hljs-title function_">typedef</span><span class="hljs-params">(类型重命名)</span> <span class="hljs-keyword">union</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">void</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">while</span><br></code></pre></td></tr></table></figure><p><strong>typedf：</strong> 类型定义-类型重定义 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">typedf <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> u_int <span class="hljs-comment">//将无符号整形重命名为u_int</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num1 = <span class="hljs-number">20</span><br>u_int num2 = <span class="hljs-number">20</span> <span class="hljs-comment">// 两种定义方法相同</span><br></code></pre></td></tr></table></figure></p><p><strong>extern：</strong> 声明外部符号</p><p>test.c <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> g_val = <span class="hljs-number">2020</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><br>&#123;<br><span class="hljs-type">int</span> z = x+y;<br><span class="hljs-keyword">return</span> z;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>demo.c <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> g_val;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span>; <span class="hljs-comment">//声明外部函数 类似于import</span><br></code></pre></td></tr></table></figure></p><p><strong>static：</strong> 1、修饰局部变量 局部变量生命周期边长 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 无static</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>a++;<br><span class="hljs-built_in">printf</span>(a);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">5</span>)<br>&#123;<br>test();<br>i++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 结果：2 2 2 2 2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 有static</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>a++;<br><span class="hljs-built_in">printf</span>(a);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">5</span>)<br>&#123;<br>test();<br>i++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：2 3 4 5 6</p><p>2、修饰全局变量 改变了全局变量的作用域，让静态的全局变量只能在自己所在的源文件内部使用，出了源文件就没法再使用了</p><p>test.c <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> g_val1 = <span class="hljs-number">2023</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> g_val2 = <span class="hljs-number">2023</span>;<br></code></pre></td></tr></table></figure></p><p>demo.c <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, g_val1);<span class="hljs-comment">// 2023</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, g_val2);<span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>一个全局变量被static修饰，使得这个全局变量只能在本源文件内使用，不能在其他源文件内使用。</p><p>3、修饰函数 也是改变了函数的作用域-不准确 改变了函数的链接属性，外部链接属性变成内部链接属性</p><p>test.c <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">Add1</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br><span class="hljs-keyword">return</span> x+y;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Add2</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br><span class="hljs-keyword">return</span> x+y;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>demo.c <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, Add1(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<span class="hljs-comment">// 5</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, Add2(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>一个函数被static修饰，使得这个函数只能在本源文件内使用，不能在其他源文件内使用。</p><h1 id="define-定义常量和宏">11 define 定义常量和宏</h1><p><strong>定义常量：</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//define定义标识符常量,定义符号MAX，其值为100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1000</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = MAX;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>定义宏：</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//函数实现</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">MAX</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><br>&#123;<br><span class="hljs-keyword">if</span> (x&gt;y)<br><span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> y;<br>&#125;<br><br><span class="hljs-comment">//define定义宏</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(x, y) (x&gt;y?x:y)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">// 函数</span><br><span class="hljs-type">int</span> max = MAX(a, b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max = %d\n&quot;</span>, max);<br><br><span class="hljs-comment">// 宏的方式</span><br>max = MAX(a, b); <span class="hljs-comment">// max = (a&gt;b?a:b);</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max = %d\n&quot;</span>, max);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>#define MAX(x, y) (x&gt;y?x:y)</code> 将<code>MAX(x, y)</code> 替换成 <code>(x&gt;y?x:y)</code></p><h1 id="指针">12 指针</h1><h2 id="内存">12.1 内存</h2><p>内存是电脑上特别重要的存储器，计算机中程序的运行都是在内存中进行的 。 所以为了有效的使用内存，就把内存划分成一个个小的内存单元，每个内存单元的大小是1个字节。 为了能够有效的访问到内存的每个单元，就给内存单元进行了编号，这些编号被称为该内存单元的地址。 <img src="/img/C语言01-C语言的基础知识123/C语言01-C语言的基础知识123.png" /> 内存的地址是怎么产生的，一个内存单元是多大的空间？</p><p>电脑有32位的和64位的，队友32位的电脑，有32根地址线/数据线，每根线无非就是通电，不通电，两种情况。所以，一共有 <span class="math inline">\(2^{32}\)</span> 中情况，对应 <span class="math inline">\(2^{32}\)</span> 个地址。通常，一个内存单元可以存储一个字节（即8位）的数据，因此在大多数计算机系统中，一个内存单元的大小为 8 bit位或 1 字节。</p><p>变量是创建内存中的（在内存中分配空间的），每个内存单元都有地址，所以变量也是有地址的。取出变量地址如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br>&amp;num;<span class="hljs-comment">//取出num的地址</span><br><span class="hljs-comment">//注：这里num的4个字节，每个字节都有地址，取出的是第一个字节的地址（较小的地址）</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;num);<span class="hljs-comment">//打印地址，%p是以地址的形式打印</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure></p><p><img src="/img/C语言01-C语言的基础知识123/C语言01-C语言的基础知识123_1.png" /> 那如何存储地址，需要定义指针变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* p = &amp;num;<span class="hljs-comment">//p的类型为int*，p是整形指针变量</span><br></code></pre></td></tr></table></figure><p>p中存的是地址值，对p进行解引用操作 <code>*p</code> ,找到指向的对象<code>num</code> ,<code>*</code> 即为解引用操作符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* p = &amp;num;<br>*p = <span class="hljs-number">20</span>; <span class="hljs-comment">// 将p</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num = %d\n&quot;</span>,num) <span class="hljs-comment">// 20</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/C语言01-C语言的基础知识123/C语言01-C语言的基础知识123_2.png" /> 以整形指针举例，可以推广到其他类型，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;w&#x27;</span>;<br><span class="hljs-type">char</span>* pc = &amp;ch;<br>*pc = <span class="hljs-string">&#x27;q&#x27;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, ch);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="指针变量的大小">12.2 指针变量的大小</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//指针变量的大小取决于地址的大小</span><br><span class="hljs-comment">//32位平台下地址是32个bit位（即4个字节）</span><br><span class="hljs-comment">//64位平台下地址是64个bit位（即8个字节）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span> *));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">short</span> *));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span> *));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span> *));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结论：指针大小在32位平台是4个字节，64位平台是8个字节。</p>]]></content>
    
    
    <categories>
      
      <category>C语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工业蒸汽预测-04模型训练</title>
    <link href="/2023/08/01/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-04%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/"/>
    <url>/2023/08/01/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-04%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<h1 id="数据处理">数据处理</h1><p>数据按<code>02特征工程</code>处理，此处不在赘述</p><h2 id="导入数据">导入数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)<br> <br>%matplotlib inline<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data_file = <span class="hljs-string">&quot;./data/zhengqi_train.txt&quot;</span><br>test_data_file =  <span class="hljs-string">&quot;./data/zhengqi_test.txt&quot;</span><br><br>train_data = pd.read_csv(train_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>test_data = pd.read_csv(test_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="异常值分析">异常值分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">18</span>, <span class="hljs-number">10</span>))<br>plt.boxplot(x=train_data.values,labels=train_data.columns)<br>plt.hlines([-<span class="hljs-number">7.5</span>, <span class="hljs-number">7.5</span>], <span class="hljs-number">0</span>, <span class="hljs-number">40</span>, colors=<span class="hljs-string">&#x27;r&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/img/工业蒸汽预测-04模型训练/output_6_0.png" /></p><h2 id="删除异常值">删除异常值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data = train_data[train_data[<span class="hljs-string">&#x27;V9&#x27;</span>]&gt;-<span class="hljs-number">7.5</span>]<br><span class="hljs-comment"># print(train_data.describe())</span><br><span class="hljs-comment"># print(test_data.describe())</span><br></code></pre></td></tr></table></figure><h2 id="归一化">归一化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> preprocessing <br><br>features_columns = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> train_data.columns <span class="hljs-keyword">if</span> col <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;target&#x27;</span>]]<br><br>min_max_scaler = preprocessing.MinMaxScaler()<br><br>min_max_scaler = min_max_scaler.fit(train_data[features_columns])<br><br>train_data_scaler = min_max_scaler.transform(train_data[features_columns])<br>test_data_scaler = min_max_scaler.transform(test_data[features_columns])<br><br>train_data_scaler = pd.DataFrame(train_data_scaler)<br>train_data_scaler.columns = features_columns<br><br>test_data_scaler = pd.DataFrame(test_data_scaler)<br>test_data_scaler.columns = features_columns<br><br>train_data_scaler[<span class="hljs-string">&#x27;target&#x27;</span>] = train_data[<span class="hljs-string">&#x27;target&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="查看数据分布情况">查看数据分布情况</h2><p>查看特征'V5', 'V17', 'V28', 'V22', 'V11', 'V9'数据的数据分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">drop_col = <span class="hljs-number">6</span><br>drop_row = <span class="hljs-number">1</span><br><br>plt.figure(figsize=(<span class="hljs-number">5</span>*drop_col,<span class="hljs-number">5</span>*drop_row))<br><br><span class="hljs-keyword">for</span> i, col <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">&quot;V5&quot;</span>,<span class="hljs-string">&quot;V9&quot;</span>,<span class="hljs-string">&quot;V11&quot;</span>,<span class="hljs-string">&quot;V17&quot;</span>,<span class="hljs-string">&quot;V22&quot;</span>,<span class="hljs-string">&quot;V28&quot;</span>]):<br>    ax =plt.subplot(drop_row,drop_col,i+<span class="hljs-number">1</span>)<br>    ax = sns.kdeplot(train_data_scaler[col], color=<span class="hljs-string">&quot;Red&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax= sns.kdeplot(test_data_scaler[col], color=<span class="hljs-string">&quot;Blue&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax.set_xlabel(col)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    ax = ax.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br>plt.show()<br><br>data_train_scaler = train_data_scaler.drop([<span class="hljs-string">&#x27;V5&#x27;</span>,<span class="hljs-string">&#x27;V9&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>,<span class="hljs-string">&#x27;V17&#x27;</span>,<span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V28&#x27;</span>],axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/工业蒸汽预测-04模型训练/output_13_0.png" /></p><p>这几个特征下，训练集的数据和测试集的数据分布不一致，会影响模型的泛化能力，故删除这些特征</p><h2 id="特征相关性">特征相关性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">16</span>))  <br>column = train_data_scaler.columns.tolist()  <br>mcorr = train_data_scaler[column].corr(method=<span class="hljs-string">&quot;spearman&quot;</span>)  <br>mask = np.zeros_like(mcorr, dtype=np.<span class="hljs-built_in">bool</span>)  <br>mask[np.triu_indices_from(mask)] = <span class="hljs-literal">True</span>  <br>cmap = sns.diverging_palette(<span class="hljs-number">220</span>, <span class="hljs-number">10</span>, as_cmap=<span class="hljs-literal">True</span>)  <br>g = sns.heatmap(mcorr, mask=mask, cmap=cmap, square=<span class="hljs-literal">True</span>, annot=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">&#x27;0.2f&#x27;</span>)  <br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/img/工业蒸汽预测-04模型训练/output_16_0.png" /></p><h2 id="特征降维">特征降维</h2><h3 id="相关新分析">相关新分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">mcorr=mcorr.<span class="hljs-built_in">abs</span>()<br>numerical_corr=mcorr[mcorr[<span class="hljs-string">&#x27;target&#x27;</span>]&gt;<span class="hljs-number">0.1</span>][<span class="hljs-string">&#x27;target&#x27;</span>]<br><span class="hljs-built_in">print</span>(numerical_corr.sort_values(ascending=<span class="hljs-literal">False</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">target    1.000000V0        0.712403V31       0.711636V1        0.682909V8        0.679469V27       0.657398V2        0.585850V16       0.545793V3        0.501622V4        0.478683V12       0.460300V10       0.448682V36       0.425991V37       0.376443V24       0.305526V5        0.286076V6        0.280195V20       0.278381V11       0.234551V15       0.221290V29       0.190109V7        0.185321V19       0.180111V18       0.149741V13       0.149199V17       0.126262V22       0.112743V30       0.101378Name: target, dtype: float64</code></pre><h3 id="相关性初筛">相关性初筛</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">features_corr = numerical_corr.sort_values(ascending=<span class="hljs-literal">False</span>).reset_index()<br>features_corr.columns = [<span class="hljs-string">&#x27;features_and_target&#x27;</span>, <span class="hljs-string">&#x27;corr&#x27;</span>]<br>features_corr_select = features_corr[features_corr[<span class="hljs-string">&#x27;corr&#x27;</span>]&gt;<span class="hljs-number">0.3</span>] <span class="hljs-comment"># 筛选出大于相关性大于0.3的特征</span><br><span class="hljs-built_in">print</span>(features_corr_select)<br>select_features = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> features_corr_select[<span class="hljs-string">&#x27;features_and_target&#x27;</span>] <span class="hljs-keyword">if</span> col <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;target&#x27;</span>]]<br>new_train_data_corr_select = train_data_scaler[select_features+[<span class="hljs-string">&#x27;target&#x27;</span>]]<br>new_test_data_corr_select = test_data_scaler[select_features]<br></code></pre></td></tr></table></figure><pre><code class="hljs">   features_and_target      corr0               target  1.0000001                   V0  0.7124032                  V31  0.7116363                   V1  0.6829094                   V8  0.6794695                  V27  0.6573986                   V2  0.5858507                  V16  0.5457938                   V3  0.5016229                   V4  0.47868310                 V12  0.46030011                 V10  0.44868212                 V36  0.42599113                 V37  0.37644314                 V24  0.305526</code></pre><h3 id="多重共线性分析">多重共线性分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> statsmodels.stats.outliers_influence <span class="hljs-keyword">import</span> variance_inflation_factor <span class="hljs-comment">#多重共线性方差膨胀因子</span><br><br><span class="hljs-comment">#多重共线性</span><br>new_numerical=[<span class="hljs-string">&#x27;V0&#x27;</span>, <span class="hljs-string">&#x27;V2&#x27;</span>, <span class="hljs-string">&#x27;V3&#x27;</span>, <span class="hljs-string">&#x27;V4&#x27;</span>, <span class="hljs-string">&#x27;V5&#x27;</span>, <span class="hljs-string">&#x27;V6&#x27;</span>, <span class="hljs-string">&#x27;V10&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>, <br>                         <span class="hljs-string">&#x27;V13&#x27;</span>, <span class="hljs-string">&#x27;V15&#x27;</span>, <span class="hljs-string">&#x27;V16&#x27;</span>, <span class="hljs-string">&#x27;V18&#x27;</span>, <span class="hljs-string">&#x27;V19&#x27;</span>, <span class="hljs-string">&#x27;V20&#x27;</span>, <span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V24&#x27;</span>,<span class="hljs-string">&#x27;V30&#x27;</span>, <span class="hljs-string">&#x27;V31&#x27;</span>, <span class="hljs-string">&#x27;V37&#x27;</span>]<br>X=np.matrix(train_data_scaler[new_numerical])<br>VIF_list=[variance_inflation_factor(X, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(X.shape[<span class="hljs-number">1</span>])]<br>VIF_list<br></code></pre></td></tr></table></figure><pre><code class="hljs">[216.73387180903222, 114.38118723828812, 27.863778129686356, 201.96436579080174, 78.93722825798903, 151.06983667656212, 14.519604941508451, 82.69750284665385, 28.479378440614585, 27.759176471505945, 526.6483470743831, 23.50166642638334, 19.920315849901424, 24.640481765008683, 11.816055964845381, 4.958208708452915, 37.09877416736591, 298.26442986612767, 47.854002539887034]</code></pre><h3 id="pca降维">PCA降维</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA   <span class="hljs-comment">#主成分分析法</span><br><span class="hljs-comment">#PCA方法降维</span><br><span class="hljs-comment">#保留16个主成分</span><br>pca = PCA(n_components=<span class="hljs-number">16</span>)<br>new_train_pca_16 = pca.fit_transform(train_data_scaler.iloc[:,<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>])<br>new_test_pca_16 = pca.transform(test_data_scaler)<br>new_train_pca_16 = pd.DataFrame(new_train_pca_16)<br>new_test_pca_16 = pd.DataFrame(new_test_pca_16)<br>new_train_pca_16[<span class="hljs-string">&#x27;target&#x27;</span>] = train_data_scaler[<span class="hljs-string">&#x27;target&#x27;</span>]<br>new_train_pca_16.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2884.000000</td></tr><tr><th>mean</th><td>-8.309602e-17</td><td>-5.653059e-17</td><td>7.698662e-17</td><td>1.023282e-16</td><td>1.123303e-17</td><td>-2.096575e-17</td><td>1.186440e-16</td><td>2.303347e-17</td><td>-8.889286e-17</td><td>7.044204e-17</td><td>2.085635e-17</td><td>7.888604e-17</td><td>1.061271e-17</td><td>-8.522866e-17</td><td>-3.927472e-18</td><td>1.403527e-16</td><td>0.127274</td></tr><tr><th>std</th><td>3.998976e-01</td><td>3.500240e-01</td><td>2.938631e-01</td><td>2.728023e-01</td><td>2.077128e-01</td><td>1.951842e-01</td><td>1.877104e-01</td><td>1.607670e-01</td><td>1.512707e-01</td><td>1.443772e-01</td><td>1.368790e-01</td><td>1.286192e-01</td><td>1.193301e-01</td><td>1.149758e-01</td><td>1.133507e-01</td><td>1.019258e-01</td><td>0.983462</td></tr><tr><th>min</th><td>-1.071795e+00</td><td>-9.429479e-01</td><td>-9.948314e-01</td><td>-7.103085e-01</td><td>-7.703982e-01</td><td>-5.340293e-01</td><td>-5.993765e-01</td><td>-5.870824e-01</td><td>-6.282791e-01</td><td>-4.902512e-01</td><td>-6.340717e-01</td><td>-5.906511e-01</td><td>-4.174969e-01</td><td>-4.310403e-01</td><td>-4.170661e-01</td><td>-3.599371e-01</td><td>-3.044000</td></tr><tr><th>25%</th><td>-2.804085e-01</td><td>-2.613727e-01</td><td>-2.090798e-01</td><td>-1.945196e-01</td><td>-1.315622e-01</td><td>-1.264097e-01</td><td>-1.236367e-01</td><td>-1.016457e-01</td><td>-9.662180e-02</td><td>-9.297320e-02</td><td>-8.202288e-02</td><td>-7.721862e-02</td><td>-7.139615e-02</td><td>-7.473615e-02</td><td>-7.710889e-02</td><td>-6.599455e-02</td><td>-0.348500</td></tr><tr><th>50%</th><td>-1.417104e-02</td><td>-1.277241e-02</td><td>2.112159e-02</td><td>-2.337402e-02</td><td>-5.122768e-03</td><td>-1.355318e-02</td><td>-1.749546e-04</td><td>-4.655494e-03</td><td>2.574985e-03</td><td>-1.480464e-03</td><td>7.296441e-03</td><td>-5.733519e-03</td><td>-4.165757e-03</td><td>1.036940e-03</td><td>-1.762762e-03</td><td>-7.954922e-04</td><td>0.313000</td></tr><tr><th>75%</th><td>2.287306e-01</td><td>2.317720e-01</td><td>2.069571e-01</td><td>1.657590e-01</td><td>1.281659e-01</td><td>9.993165e-02</td><td>1.272086e-01</td><td>9.657155e-02</td><td>1.002626e-01</td><td>9.059782e-02</td><td>8.835004e-02</td><td>7.147987e-02</td><td>6.785346e-02</td><td>7.576130e-02</td><td>7.115629e-02</td><td>6.364658e-02</td><td>0.794250</td></tr><tr><th>max</th><td>1.597730e+00</td><td>1.382802e+00</td><td>1.010250e+00</td><td>1.448007e+00</td><td>1.034062e+00</td><td>1.358963e+00</td><td>6.191591e-01</td><td>7.370069e-01</td><td>6.449190e-01</td><td>5.839583e-01</td><td>6.404954e-01</td><td>6.780797e-01</td><td>5.156587e-01</td><td>4.977880e-01</td><td>4.675102e-01</td><td>4.571981e-01</td><td>2.538000</td></tr></tbody></table></div><h1 id="模型训练">模型训练</h1><h2 id="导入相关库">1 导入相关库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression  <span class="hljs-comment">#线性回归</span><br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor  <span class="hljs-comment">#K近邻回归</span><br><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeRegressor     <span class="hljs-comment">#决策树回归</span><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor <span class="hljs-comment">#随机森林回归</span><br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVR  <span class="hljs-comment">#支持向量回归</span><br><span class="hljs-keyword">import</span> lightgbm <span class="hljs-keyword">as</span> lgb <span class="hljs-comment">#lightGbm模型</span><br><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split <span class="hljs-comment"># 切分数据</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error <span class="hljs-comment">#评价指标</span><br><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> learning_curve<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> ShuffleSplit<br><br></code></pre></td></tr></table></figure><h2 id="切分数据">2 切分数据</h2><p>对训练集进行切分，得到80%的训练数据和20%的验证数据。用切分得到的训练数据训练模型，用切分得到的验证数据评估模型的性能优劣。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#采用 pca 保留16维特征的数据</span><br>new_train_pca_16 = new_train_pca_16.fillna(<span class="hljs-number">0</span>)<br>train = new_train_pca_16[new_test_pca_16.columns]<br>target = new_train_pca_16[<span class="hljs-string">&#x27;target&#x27;</span>]<br><br><span class="hljs-comment"># 切分数据 训练数据80% 验证数据20%</span><br>train_data,test_data,train_target,test_target=train_test_split(train,target,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="多元线性回归模型">3 多元线性回归模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">clf = LinearRegression()<br>clf.fit(train_data, train_target)<br>score = mean_squared_error(test_target, clf.predict(test_data))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LinearRegression:   &quot;</span>, score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">LinearRegression:    0.271697499977603</code></pre><p>优点：模型简单，部署方便，回归权重可以用于结果分析；训练快。</p><p>缺点：精度低，特征存在一定的共线性问题。</p><p>使用技巧：需要进行<strong>归一化</strong>处理，建议进行一定的特征选择，尽量避免高度相关的特征同时存在。</p><p>本题结果：效果一般，适合分析使用。</p><h2 id="k近邻回归">4 K近邻回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">clf = KNeighborsRegressor(n_neighbors=<span class="hljs-number">8</span>) <span class="hljs-comment"># 最近8个</span><br>clf.fit(train_data, train_target)<br>score = mean_squared_error(test_target, clf.predict(test_data))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;KNeighborsRegressor:   &quot;</span>, score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">KNeighborsRegressor:    0.2734753438581315</code></pre><p>优点：模型简单，易于理解，对于数据量小的情况方便快捷，可视化方便。</p><p>缺点：计算量大，不适合数据量大的情况：需要调参数。</p><p>使用技巧：特征需要<strong>归一化</strong>，重要的特征可以适当加一定比例的权重。</p><p>本题结果：效果一般。</p><h2 id="随机森林回归">5 随机森林回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">clf = RandomForestRegressor(n_estimators=<span class="hljs-number">200</span>) <span class="hljs-comment"># 200棵树模型</span><br>clf.fit(train_data, train_target)<br>score = mean_squared_error(test_target, clf.predict(test_data))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;RandomForestRegressor:   &quot;</span>, score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">RandomForestRegressor:    0.2477930646584775</code></pre><p>优点：使用方便，特征<strong>无须做过多变换</strong>；精度较高：模型并行训练快。</p><p>缺点：结果不容易解释。</p><p>使用技巧：参数调节，提高精度。</p><p>本题结果：比较适合。</p><h2 id="lgb模型回归">6 LGB模型回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># lgb回归模型</span><br>clf = lgb.LGBMRegressor(<br>        learning_rate=<span class="hljs-number">0.01</span>, <span class="hljs-comment"># 学习率</span><br>        max_depth=-<span class="hljs-number">1</span>, <span class="hljs-comment"># 树的最大深度。-1表示没有限制。</span><br>        n_estimators=<span class="hljs-number">5000</span>, <span class="hljs-comment"># 迭代次数，也就是基础模型（决策树）的数量。</span><br>        boosting_type=<span class="hljs-string">&#x27;gbdt&#x27;</span>, <span class="hljs-comment"># 提升类型，默认为&#x27;gbdt&#x27;，表示梯度提升决策树。</span><br>        random_state=<span class="hljs-number">2019</span>, <span class="hljs-comment"># 随机种子，用于重现结果。</span><br>        objective=<span class="hljs-string">&#x27;regression&#x27;</span>, <span class="hljs-comment"># 化目标，这里设置为&#x27;regression&#x27;表示回归问题。</span><br>    )<br><br><span class="hljs-comment"># 训练模型</span><br>clf.fit(<br>        X=train_data, y=train_target,<br>        eval_metric=<span class="hljs-string">&#x27;MSE&#x27;</span>, <span class="hljs-comment"># 设置评估指标eval_metric，这里使用均方误差（MSE）</span><br>        <span class="hljs-comment"># verbose=50 # 控制训练过程中的输出信息，50表示每50轮输出一次。</span><br>    )<br><br>score = mean_squared_error(test_target, clf.predict(test_data))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;lightGbm:   &quot;</span>, score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000303 seconds.You can set `force_col_wise=true` to remove the overhead.[LightGBM] [Info] Total Bins 4080[LightGBM] [Info] Number of data points in the train set: 2308, number of used features: 16[LightGBM] [Info] Start training from score 0.119128lightGbm:    0.2436390703800861</code></pre><p>优点：精度高。</p><p>缺点：训练时间长，模型复杂。</p><p>使用技巧：有效的验证集防止过拟合；参数搜索。</p><p>本题结果：适用。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习实战入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工业蒸汽预测-03特征工程</title>
    <link href="/2023/07/31/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-03%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    <url>/2023/07/31/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-03%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="导入数据分析工具包">1导入数据分析工具包</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)<br> <br>%matplotlib inline<br></code></pre></td></tr></table></figure><h1 id="数据读取">2数据读取</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data_file = <span class="hljs-string">&quot;./data/zhengqi_train.txt&quot;</span><br>test_data_file =  <span class="hljs-string">&quot;./data/zhengqi_test.txt&quot;</span><br><br>train_data = pd.read_csv(train_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>test_data = pd.read_csv(test_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="训练数据总览">3训练数据总览</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>...</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td></tr><tr><th>mean</th><td>0.123048</td><td>0.056068</td><td>0.289720</td><td>-0.067790</td><td>0.012921</td><td>-0.558565</td><td>0.182892</td><td>0.116155</td><td>0.177856</td><td>-0.169452</td><td>...</td><td>0.097648</td><td>0.055477</td><td>0.127791</td><td>0.020806</td><td>0.007801</td><td>0.006715</td><td>0.197764</td><td>0.030658</td><td>-0.130330</td><td>0.126353</td></tr><tr><th>std</th><td>0.928031</td><td>0.941515</td><td>0.911236</td><td>0.970298</td><td>0.888377</td><td>0.517957</td><td>0.918054</td><td>0.955116</td><td>0.895444</td><td>0.953813</td><td>...</td><td>1.061200</td><td>0.901934</td><td>0.873028</td><td>0.902584</td><td>1.006995</td><td>1.003291</td><td>0.985675</td><td>0.970812</td><td>1.017196</td><td>0.983966</td></tr><tr><th>min</th><td>-4.335000</td><td>-5.122000</td><td>-3.420000</td><td>-3.956000</td><td>-4.742000</td><td>-2.182000</td><td>-4.576000</td><td>-5.048000</td><td>-4.692000</td><td>-12.891000</td><td>...</td><td>-2.912000</td><td>-4.507000</td><td>-5.859000</td><td>-4.053000</td><td>-4.627000</td><td>-4.789000</td><td>-5.695000</td><td>-2.608000</td><td>-3.630000</td><td>-3.044000</td></tr><tr><th>25%</th><td>-0.297000</td><td>-0.226250</td><td>-0.313000</td><td>-0.652250</td><td>-0.385000</td><td>-0.853000</td><td>-0.310000</td><td>-0.295000</td><td>-0.159000</td><td>-0.390000</td><td>...</td><td>-0.664000</td><td>-0.283000</td><td>-0.170250</td><td>-0.407250</td><td>-0.499000</td><td>-0.290000</td><td>-0.202500</td><td>-0.413000</td><td>-0.798250</td><td>-0.350250</td></tr><tr><th>50%</th><td>0.359000</td><td>0.272500</td><td>0.386000</td><td>-0.044500</td><td>0.110000</td><td>-0.466000</td><td>0.388000</td><td>0.344000</td><td>0.362000</td><td>0.042000</td><td>...</td><td>-0.023000</td><td>0.053500</td><td>0.299500</td><td>0.039000</td><td>-0.040000</td><td>0.160000</td><td>0.364000</td><td>0.137000</td><td>-0.185500</td><td>0.313000</td></tr><tr><th>75%</th><td>0.726000</td><td>0.599000</td><td>0.918250</td><td>0.624000</td><td>0.550250</td><td>-0.154000</td><td>0.831250</td><td>0.782250</td><td>0.726000</td><td>0.042000</td><td>...</td><td>0.745250</td><td>0.488000</td><td>0.635000</td><td>0.557000</td><td>0.462000</td><td>0.273000</td><td>0.602000</td><td>0.644250</td><td>0.495250</td><td>0.793250</td></tr><tr><th>max</th><td>2.121000</td><td>1.918000</td><td>2.828000</td><td>2.457000</td><td>2.689000</td><td>0.489000</td><td>1.895000</td><td>1.918000</td><td>2.245000</td><td>1.335000</td><td>...</td><td>4.580000</td><td>2.689000</td><td>2.013000</td><td>2.395000</td><td>5.465000</td><td>5.110000</td><td>2.324000</td><td>5.238000</td><td>3.000000</td><td>2.538000</td></tr></tbody></table><p>8 rows × 39 columns</p></div><h1 id="特征工程">4特征工程</h1><h2 id="异常值分析箱型图">4.1异常值分析（箱型图）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">18</span>, <span class="hljs-number">10</span>))<br>plt.boxplot(x=train_data.values,labels=train_data.columns)<br>plt.hlines([-<span class="hljs-number">7.5</span>, <span class="hljs-number">7.5</span>], <span class="hljs-number">0</span>, <span class="hljs-number">40</span>, colors=<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-comment"># 0,40：水平线起始结束位置</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/img/工业蒸汽预测-03特征工程/output_8_0.png" /></p><p>从箱线图可以看出，有些特征存在明显的异常值、如V9变量。接下来分别把训练集和测试集中的异常值删除。</p><h4 id="代码详解">代码详解：</h4><ol type="1"><li><p><code>plt.boxplot(x=train_data.values,labels=train_data.columns)</code>：使用<code>boxplot</code>函数绘制箱线图。其中，<code>train_data.values</code>是要绘制箱线图的数据，<code>labels=train_data.columns</code>表示箱线图中每个箱子对应的标签是<code>train_data</code>数据集的列名。</p></li><li><p><code>plt.hlines([-7.5, 7.5], 0, 40, colors='r')</code>：使用<code>hlines</code>函数绘制水平线。<code>[-7.5, 7.5]</code>表示要绘制的水平线的位置，0和40分别表示水平线的起始和结束位置，<code>colors='r'</code>表示线条颜色为红色。</p></li></ol><p>该段代码使用matplotlib库绘制了一个箱线图，展示了<code>train_data</code>数据集中各个特征列的分布情况，并在图中添加了两条水平线（-7.5和7.5），用于标记异常值的阈值。</p><h3 id="删除异常值">4.1.1删除异常值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data = train_data[train_data[<span class="hljs-string">&#x27;V9&#x27;</span>]&gt;-<span class="hljs-number">7.5</span>] <span class="hljs-comment"># 保留大于-7.5的值</span><br>test_data = test_data[test_data[<span class="hljs-string">&#x27;V9&#x27;</span>]&gt;-<span class="hljs-number">7.5</span>]<br><br>display(train_data.describe())<br>display(test_data.describe())<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.00000</td><td>...</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td></tr><tr><th>mean</th><td>0.123725</td><td>0.056856</td><td>0.290340</td><td>-0.068364</td><td>0.012254</td><td>-0.558971</td><td>0.183273</td><td>0.116274</td><td>0.178138</td><td>-0.16213</td><td>...</td><td>0.097019</td><td>0.058619</td><td>0.127617</td><td>0.023626</td><td>0.008271</td><td>0.006959</td><td>0.198513</td><td>0.030099</td><td>-0.131957</td><td>0.127451</td></tr><tr><th>std</th><td>0.927984</td><td>0.941269</td><td>0.911231</td><td>0.970357</td><td>0.888037</td><td>0.517871</td><td>0.918211</td><td>0.955418</td><td>0.895552</td><td>0.91089</td><td>...</td><td>1.060824</td><td>0.894311</td><td>0.873300</td><td>0.896509</td><td>1.007175</td><td>1.003411</td><td>0.985058</td><td>0.970258</td><td>1.015666</td><td>0.983144</td></tr><tr><th>min</th><td>-4.335000</td><td>-5.122000</td><td>-3.420000</td><td>-3.956000</td><td>-4.742000</td><td>-2.182000</td><td>-4.576000</td><td>-5.048000</td><td>-4.692000</td><td>-7.07100</td><td>...</td><td>-2.912000</td><td>-4.507000</td><td>-5.859000</td><td>-4.053000</td><td>-4.627000</td><td>-4.789000</td><td>-5.695000</td><td>-2.608000</td><td>-3.630000</td><td>-3.044000</td></tr><tr><th>25%</th><td>-0.292000</td><td>-0.224250</td><td>-0.310000</td><td>-0.652750</td><td>-0.385000</td><td>-0.853000</td><td>-0.310000</td><td>-0.295000</td><td>-0.158750</td><td>-0.39000</td><td>...</td><td>-0.664000</td><td>-0.282000</td><td>-0.170750</td><td>-0.405000</td><td>-0.499000</td><td>-0.290000</td><td>-0.199750</td><td>-0.412750</td><td>-0.798750</td><td>-0.347500</td></tr><tr><th>50%</th><td>0.359500</td><td>0.273000</td><td>0.386000</td><td>-0.045000</td><td>0.109500</td><td>-0.466000</td><td>0.388500</td><td>0.345000</td><td>0.362000</td><td>0.04200</td><td>...</td><td>-0.023000</td><td>0.054500</td><td>0.299500</td><td>0.040000</td><td>-0.040000</td><td>0.160000</td><td>0.364000</td><td>0.137000</td><td>-0.186000</td><td>0.314000</td></tr><tr><th>75%</th><td>0.726000</td><td>0.599000</td><td>0.918750</td><td>0.623500</td><td>0.550000</td><td>-0.154000</td><td>0.831750</td><td>0.782750</td><td>0.726000</td><td>0.04200</td><td>...</td><td>0.745000</td><td>0.488000</td><td>0.635000</td><td>0.557000</td><td>0.462000</td><td>0.273000</td><td>0.602000</td><td>0.643750</td><td>0.493000</td><td>0.793750</td></tr><tr><th>max</th><td>2.121000</td><td>1.918000</td><td>2.828000</td><td>2.457000</td><td>2.689000</td><td>0.489000</td><td>1.895000</td><td>1.918000</td><td>2.245000</td><td>1.33500</td><td>...</td><td>4.580000</td><td>2.689000</td><td>2.013000</td><td>2.395000</td><td>5.465000</td><td>5.110000</td><td>2.324000</td><td>5.238000</td><td>3.000000</td><td>2.538000</td></tr></tbody></table><p>8 rows × 39 columns</p></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V28</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th></tr></thead><tbody><tr><th>count</th><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>...</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td></tr><tr><th>mean</th><td>-0.184404</td><td>-0.083912</td><td>-0.434762</td><td>0.101671</td><td>-0.019172</td><td>0.838049</td><td>-0.274092</td><td>-0.173971</td><td>-0.266709</td><td>0.255114</td><td>...</td><td>-0.206871</td><td>-0.146463</td><td>-0.083215</td><td>-0.191729</td><td>-0.030782</td><td>-0.011433</td><td>-0.009985</td><td>-0.296895</td><td>-0.046270</td><td>0.195735</td></tr><tr><th>std</th><td>1.073333</td><td>1.076670</td><td>0.969541</td><td>1.034925</td><td>1.147286</td><td>0.963043</td><td>1.054119</td><td>1.040101</td><td>1.085916</td><td>1.014394</td><td>...</td><td>1.064140</td><td>0.880593</td><td>1.126414</td><td>1.138454</td><td>1.130228</td><td>0.989732</td><td>0.995213</td><td>0.946896</td><td>1.040854</td><td>0.940599</td></tr><tr><th>min</th><td>-4.814000</td><td>-5.488000</td><td>-4.283000</td><td>-3.276000</td><td>-4.921000</td><td>-1.168000</td><td>-5.649000</td><td>-5.625000</td><td>-6.059000</td><td>-6.784000</td><td>...</td><td>-2.435000</td><td>-2.413000</td><td>-4.507000</td><td>-7.698000</td><td>-4.057000</td><td>-4.627000</td><td>-4.789000</td><td>-7.477000</td><td>-2.608000</td><td>-3.346000</td></tr><tr><th>25%</th><td>-0.664000</td><td>-0.451000</td><td>-0.978000</td><td>-0.644000</td><td>-0.497000</td><td>0.122000</td><td>-0.732000</td><td>-0.509000</td><td>-0.775000</td><td>-0.390000</td><td>...</td><td>-0.453000</td><td>-0.818000</td><td>-0.339000</td><td>-0.476000</td><td>-0.472000</td><td>-0.460000</td><td>-0.290000</td><td>-0.349000</td><td>-0.593000</td><td>-0.432000</td></tr><tr><th>50%</th><td>0.065000</td><td>0.195000</td><td>-0.267000</td><td>0.220000</td><td>0.118000</td><td>0.437000</td><td>-0.082000</td><td>0.018000</td><td>-0.004000</td><td>0.401000</td><td>...</td><td>-0.445000</td><td>-0.199000</td><td>0.010000</td><td>0.100000</td><td>0.155000</td><td>-0.040000</td><td>0.160000</td><td>-0.270000</td><td>0.083000</td><td>0.152000</td></tr><tr><th>75%</th><td>0.549000</td><td>0.589000</td><td>0.278000</td><td>0.793000</td><td>0.610000</td><td>1.928000</td><td>0.457000</td><td>0.515000</td><td>0.482000</td><td>0.904000</td><td>...</td><td>-0.434000</td><td>0.468000</td><td>0.447000</td><td>0.471000</td><td>0.627000</td><td>0.419000</td><td>0.273000</td><td>0.364000</td><td>0.651000</td><td>0.797000</td></tr><tr><th>max</th><td>2.100000</td><td>2.120000</td><td>1.946000</td><td>2.603000</td><td>4.475000</td><td>3.176000</td><td>1.528000</td><td>1.394000</td><td>2.408000</td><td>1.766000</td><td>...</td><td>4.656000</td><td>3.022000</td><td>3.139000</td><td>1.428000</td><td>2.299000</td><td>5.465000</td><td>5.110000</td><td>1.671000</td><td>2.861000</td><td>3.021000</td></tr></tbody></table><p>8 rows × 38 columns</p></div><h2 id="特征缩放最大最小值归一化">4.2特征缩放（最大最小值归一化）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> preprocessing <br><br>features_columns = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> train_data.columns <span class="hljs-keyword">if</span> col <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;target&#x27;</span>]]<br><br>min_max_scaler = preprocessing.MinMaxScaler()<br>min_max_scaler = min_max_scaler.fit(train_data[features_columns])<br><br>train_data_scaler = min_max_scaler.transform(train_data[features_columns])<br>test_data_scaler = min_max_scaler.transform(test_data[features_columns])<br><br>train_data_scaler = pd.DataFrame(train_data_scaler)<br>train_data_scaler.columns = features_columns<br><br>test_data_scaler = pd.DataFrame(test_data_scaler)<br>test_data_scaler.columns = features_columns<br><br>train_data_scaler[<span class="hljs-string">&#x27;target&#x27;</span>] = train_data[<span class="hljs-string">&#x27;target&#x27;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">display(train_data_scaler.describe())<br>display(test_data_scaler.describe())<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>...</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2884.000000</td></tr><tr><th>mean</th><td>0.690633</td><td>0.735633</td><td>0.593844</td><td>0.606212</td><td>0.639787</td><td>0.607649</td><td>0.735477</td><td>0.741354</td><td>0.702053</td><td>0.821897</td><td>...</td><td>0.401631</td><td>0.634466</td><td>0.760495</td><td>0.632231</td><td>0.459302</td><td>0.484489</td><td>0.734944</td><td>0.336235</td><td>0.527608</td><td>0.127274</td></tr><tr><th>std</th><td>0.143740</td><td>0.133703</td><td>0.145844</td><td>0.151311</td><td>0.119504</td><td>0.193887</td><td>0.141896</td><td>0.137154</td><td>0.129098</td><td>0.108362</td><td>...</td><td>0.141594</td><td>0.124279</td><td>0.110938</td><td>0.139037</td><td>0.099799</td><td>0.101365</td><td>0.122840</td><td>0.123663</td><td>0.153192</td><td>0.983462</td></tr><tr><th>min</th><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>...</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>-3.044000</td></tr><tr><th>25%</th><td>0.626239</td><td>0.695703</td><td>0.497759</td><td>0.515087</td><td>0.586328</td><td>0.497566</td><td>0.659249</td><td>0.682314</td><td>0.653489</td><td>0.794789</td><td>...</td><td>0.300053</td><td>0.587132</td><td>0.722593</td><td>0.565757</td><td>0.409037</td><td>0.454490</td><td>0.685279</td><td>0.279792</td><td>0.427036</td><td>-0.348500</td></tr><tr><th>50%</th><td>0.727153</td><td>0.766335</td><td>0.609155</td><td>0.609855</td><td>0.652873</td><td>0.642456</td><td>0.767192</td><td>0.774189</td><td>0.728557</td><td>0.846181</td><td>...</td><td>0.385611</td><td>0.633894</td><td>0.782330</td><td>0.634770</td><td>0.454518</td><td>0.499949</td><td>0.755580</td><td>0.349860</td><td>0.519457</td><td>0.313000</td></tr><tr><th>75%</th><td>0.783922</td><td>0.812642</td><td>0.694422</td><td>0.714096</td><td>0.712152</td><td>0.759266</td><td>0.835690</td><td>0.837030</td><td>0.781029</td><td>0.846181</td><td>...</td><td>0.488121</td><td>0.694136</td><td>0.824949</td><td>0.714950</td><td>0.504261</td><td>0.511365</td><td>0.785260</td><td>0.414447</td><td>0.621870</td><td>0.794250</td></tr><tr><th>max</th><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>...</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>2.538000</td></tr></tbody></table><p>8 rows × 39 columns</p></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V28</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th></tr></thead><tbody><tr><th>count</th><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>...</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td></tr><tr><th>mean</th><td>0.642905</td><td>0.715637</td><td>0.477791</td><td>0.632726</td><td>0.635558</td><td>1.130681</td><td>0.664798</td><td>0.699688</td><td>0.637926</td><td>0.871534</td><td>...</td><td>0.313556</td><td>0.369132</td><td>0.614756</td><td>0.719928</td><td>0.623793</td><td>0.457349</td><td>0.482778</td><td>0.673164</td><td>0.326501</td><td>0.577034</td></tr><tr><th>std</th><td>0.166253</td><td>0.152936</td><td>0.155176</td><td>0.161379</td><td>0.154392</td><td>0.360555</td><td>0.162899</td><td>0.149311</td><td>0.156540</td><td>0.120675</td><td>...</td><td>0.149752</td><td>0.117538</td><td>0.156533</td><td>0.144621</td><td>0.175284</td><td>0.098071</td><td>0.100537</td><td>0.118082</td><td>0.132661</td><td>0.141870</td></tr><tr><th>min</th><td>-0.074195</td><td>-0.051989</td><td>-0.138124</td><td>0.106035</td><td>-0.024088</td><td>0.379633</td><td>-0.165817</td><td>-0.082831</td><td>-0.197059</td><td>0.034142</td><td>...</td><td>0.000000</td><td>0.066604</td><td>0.000000</td><td>-0.233613</td><td>-0.000620</td><td>0.000000</td><td>0.000000</td><td>-0.222222</td><td>0.000000</td><td>0.042836</td></tr><tr><th>25%</th><td>0.568618</td><td>0.663494</td><td>0.390845</td><td>0.516451</td><td>0.571256</td><td>0.862598</td><td>0.594035</td><td>0.651593</td><td>0.564653</td><td>0.794789</td><td>...</td><td>0.278919</td><td>0.279498</td><td>0.579211</td><td>0.683816</td><td>0.555366</td><td>0.412901</td><td>0.454490</td><td>0.666667</td><td>0.256819</td><td>0.482353</td></tr><tr><th>50%</th><td>0.681537</td><td>0.755256</td><td>0.504641</td><td>0.651177</td><td>0.654017</td><td>0.980532</td><td>0.694483</td><td>0.727247</td><td>0.675796</td><td>0.888889</td><td>...</td><td>0.280045</td><td>0.362120</td><td>0.627710</td><td>0.756987</td><td>0.652605</td><td>0.454518</td><td>0.499949</td><td>0.676518</td><td>0.342977</td><td>0.570437</td></tr><tr><th>75%</th><td>0.756506</td><td>0.811222</td><td>0.591869</td><td>0.740527</td><td>0.720226</td><td>1.538750</td><td>0.777778</td><td>0.798593</td><td>0.745856</td><td>0.948727</td><td>...</td><td>0.281593</td><td>0.451148</td><td>0.688438</td><td>0.804116</td><td>0.725806</td><td>0.500000</td><td>0.511365</td><td>0.755580</td><td>0.415371</td><td>0.667722</td></tr><tr><th>max</th><td>0.996747</td><td>1.028693</td><td>0.858835</td><td>1.022766</td><td>1.240345</td><td>2.005990</td><td>0.943285</td><td>0.924777</td><td>1.023497</td><td>1.051273</td><td>...</td><td>0.997889</td><td>0.792045</td><td>1.062535</td><td>0.925686</td><td>0.985112</td><td>1.000000</td><td>1.000000</td><td>0.918568</td><td>0.697043</td><td>1.003167</td></tr></tbody></table><p>8 rows × 38 columns</p></div><h4 id="代码详解-1">代码详解：</h4><ol type="1"><li><p><code>features_columns = [col for col in train_data.columns if col not in ['target']]</code>：使用列表推导式创建一个列表<code>features_columns</code>，其中包含除了'target'列之外的所有训练数据的特征列。</p></li><li><p><code>min_max_scaler = preprocessing.MinMaxScaler()</code>：创建一个MinMaxScaler对象，用于进行特征缩放。</p></li><li><p><code>min_max_scaler = min_max_scaler.fit(train_data[features_columns])</code>：使用训练数据的特征列拟合（fit）MinMaxScaler对象，计算训练集中每个特征的最小值和最大值。</p></li><li><p><code>train_data_scaler = min_max_scaler.transform(train_data[features_columns])</code>：将训练数据的特征列使用MinMaxScaler进行缩放转换，得到缩放后的训练数据。</p></li><li><p><code>test_data_scaler = min_max_scaler.transform(test_data[features_columns])</code>：将测试数据的特征列使用相同的MinMaxScaler进行缩放转换，得到缩放后的测试数据。这里使用的是在训练数据上拟合的MinMaxScaler对象，保证了训练数据和测试数据的缩放方式一致。</p></li><li><p><code>train_data_scaler = pd.DataFrame(train_data_scaler)</code>：将缩放后的训练数据转换为DataFrame格式。</p></li><li><p><code>train_data_scaler.columns = features_columns</code>：将缩放后的训练数据的列名设置为原始特征列的列名，保持一致性。</p></li><li><p><code>test_data_scaler = pd.DataFrame(test_data_scaler)</code>：将缩放后的测试数据转换为DataFrame格式。</p></li><li><p><code>test_data_scaler.columns = features_columns</code>：将缩放后的测试数据的列名设置为原始特征列的列名，保持一致性。</p></li><li><p><code>train_data_scaler['target'] = train_data['target']</code>：将缩放后的训练数据中的'target'列设置为原始训练数据的'target'列，这样保留了目标变量。</p></li></ol><hr /><p><strong>fit与transform：</strong></p><ol type="1"><li>fit方法：<ul><li>fit方法用于从训练数据中学习模型的参数或数据转换所需的统计信息。</li><li>在fit方法中，模型会根据训练数据自动计算并确定转换所需的参数，例如均值、标准差等。</li><li>fit方法通常只针对训练数据集进行调用，以便使模型能够根据训练数据适应最佳的参数设置。</li></ul></li><li>transform方法：<ul><li>transform方法用于将原始数据转换为经过预处理后的数据。</li><li>在transform方法中，模型会根据之前学习到的参数或统计信息，对数据进行相应的转换操作。</li><li>transform方法通常在训练数据和测试数据上分别调用，以便将它们都转换为相同的预处理格式，保证数据的一致性。</li></ul></li></ol><p>fit和transform方法在不同的预处理类中具有相对应的方法名：</p><ul><li><p>MinMaxScaler类，fit方法用于计算每个特征的最小值和最大值，transform方法用于将数据缩放到给定的范围，默认为[0, 1]。</p></li><li><p>StandardScaler类，fit方法用于计算每个特征的均值和标准差，transform方法用于将数据进行标准化处理，使其均值为0，标准差为1。</p></li><li><p>OneHotEncoder类，fit方法用于确定类别特征的所有可能取值，并构建映射关系，transform方法用于将类别特征转换为二进制矩阵表示。</p></li></ul><p>fit方法用于从 ==训练数据== 中 ==学习== 模型的 ==参数== 或统计信息，transform方法用于将原始数据按照之前学习到的参数或统计信息进行转换。在实际应用中，通常先调用fit方法对模型进行训练，然后再调用transform方法对训练数据和测试数据进行相同的数据预处理操作。</p><p>使用MinMaxScaler对数据进行缩放时，通常将其fit在训练集上的原因是为了避免信息泄漏（information leakage）。</p><p>信息泄漏是指在数据预处理过程中，使用了不应该在当前步骤中可用的额外信息。这可能导致模型在实际应用中性能下降，因为会在测试集上产生过于乐观的估计。</p><p>将MinMaxScaler仅拟合（fit）于训练数据的优势有两个：</p><ul><li>模型只能使用训练集的信息进行训练和预测，这符合机器学习的基本原则。模型无法直接访问测试集的任何信息，以确保其在真实世界中的性能。</li><li>防止信息泄漏。如果将MinMaxScaler同时拟合于训练集和测试集，就相当于使用了测试集的信息来进行预处理，将测试集的信息引入到了训练过程中。这可能会导致过于乐观的结果。</li><li>测试集是用于评估模型性能的独立数据集。如果对测试集拟合（fit），则使用不同的预处理参数，那么测试集的数据范围和分布就会与训练集不一致，这可能导致模型在实际应用中表现不佳。</li></ul><hr /><p><strong><code>column = train_data.columns.tolist()[:39]</code>与 <code>columns = [col for col in train_data.columns]</code> 这两种获取列名的区别和优劣：</strong></p><ol type="1"><li><code>column = train_data.columns.tolist()[:39]</code>：<ul><li>这种方式将DataFrame的列名转换为一个Python列表。</li><li>优点：简单直接，获取指定数量的列名。</li><li>缺点：只能获取指定数量的列名，不适用于需要选择特定列或基于某些条件筛选列名的情况。</li></ul></li><li><code>columns = [col for col in train_data.columns]</code>：<ul><li>这种方式使用列表推导式将DataFrame的所有列名存储到一个列表中。</li><li>优点：可以获取DataFrame中的所有列名，提供了更大的灵活性。可以通过条件筛选、修改等方式来操作列名。</li><li>缺点：相对于第一种方式来说，代码稍微复杂一些。</li></ul></li></ol><p>所以，选择哪种方式取决于具体的需求：</p><ul><li>如果只需要获取特定数量的列名，且数量固定，可以使用<code>train_data.columns.tolist()[:39]</code>方式，简单且明确。</li><li>如果需要对列名进行更多的操作，如条件筛选、修改等，或者需要获取所有列名，例如<code>col for col in train_data.columns if col not in ['target']</code> 那么使用列表推导式会更灵活。</li></ul><h2 id="查看数据分布情况">4.3查看数据分布情况</h2><p>我们利用KDE分布对比特征变量在训练集和测试集中的分布情况。对比后发现：特征变量V5, V9, V11, V17, V22, V28在训练集和测试集中的分布差异较大，会影响模型的泛化能力，故删除这些特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># KDE分布</span><br>dist_cols = <span class="hljs-number">6</span><br>dist_rows = <span class="hljs-built_in">len</span>(test_data_scaler.columns)<br><br>plt.figure(figsize=(<span class="hljs-number">4</span>*dist_cols,<span class="hljs-number">4</span>*dist_rows))<br><br><br><span class="hljs-keyword">for</span> i, col <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(test_data_scaler.columns):<br>    ax=plt.subplot(dist_rows,dist_cols,i+<span class="hljs-number">1</span>)<br>    ax = sns.kdeplot(train_data_scaler[col], color=<span class="hljs-string">&quot;Red&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax = sns.kdeplot(test_data_scaler[col], color=<span class="hljs-string">&quot;Blue&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax.set_xlabel(col)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    ax = ax.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br> <br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-03特征工程/output_19_0.png" /> ​</p><h4 id="代码解释">代码解释：</h4><p><code>for i, col in enumerate(test_data_scaler.columns)</code>：迭代循环，遍历<code>test_data_scaler.columns</code>中的每一列，并使用<code>enumerate</code>函数同时将列的索引赋值给<code>i</code>，列名赋值给<code>col</code>。</p><p>查看特征'V5', 'V17', 'V28', 'V22', 'V11', 'V9'数据的数据分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">drop_col = <span class="hljs-number">6</span><br>drop_row = <span class="hljs-number">1</span><br><br>plt.figure(figsize=(<span class="hljs-number">5</span>*drop_col,<span class="hljs-number">5</span>*drop_row))<br><br><span class="hljs-keyword">for</span> i, col <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">&quot;V5&quot;</span>,<span class="hljs-string">&quot;V9&quot;</span>,<span class="hljs-string">&quot;V11&quot;</span>,<span class="hljs-string">&quot;V17&quot;</span>,<span class="hljs-string">&quot;V22&quot;</span>,<span class="hljs-string">&quot;V28&quot;</span>]):<br>    ax =plt.subplot(drop_row,drop_col,i+<span class="hljs-number">1</span>)<br>    ax = sns.kdeplot(train_data_scaler[col], color=<span class="hljs-string">&quot;Red&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax= sns.kdeplot(test_data_scaler[col], color=<span class="hljs-string">&quot;Blue&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax.set_xlabel(col)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    ax = ax.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-03特征工程/output_22_0.png" /> ​</p><p>这几个特征下，训练集的数据和测试集的数据分布不一致，会影响模型的泛化能力，故删除这些特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">data_train_scaler = train_data_scaler.drop([<span class="hljs-string">&#x27;V5&#x27;</span>,<span class="hljs-string">&#x27;V9&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>,<span class="hljs-string">&#x27;V17&#x27;</span>,<span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V28&#x27;</span>],axis=<span class="hljs-number">1</span>)<br>data_train_scaler.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V6</th><th>V7</th><th>V8</th><th>V10</th><th>V12</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>0</th><td>0.759139</td><td>0.729830</td><td>0.524488</td><td>0.680337</td><td>0.698964</td><td>0.427136</td><td>0.385874</td><td>0.613522</td><td>0.221743</td><td>0.698875</td><td>...</td><td>0.406834</td><td>0.641467</td><td>0.666159</td><td>0.679280</td><td>0.00000</td><td>0.000000</td><td>0.074074</td><td>0.000000</td><td>0.018401</td><td>0.175</td></tr><tr><th>1</th><td>0.821406</td><td>0.789631</td><td>0.557939</td><td>0.705130</td><td>0.664244</td><td>0.465152</td><td>0.385874</td><td>0.724232</td><td>0.373887</td><td>0.690502</td><td>...</td><td>0.371596</td><td>0.643552</td><td>0.748349</td><td>0.721619</td><td>0.37495</td><td>0.499949</td><td>0.755580</td><td>0.289702</td><td>0.437406</td><td>0.676</td></tr><tr><th>2</th><td>0.828377</td><td>0.808239</td><td>0.584987</td><td>0.674567</td><td>0.653210</td><td>0.495905</td><td>0.385874</td><td>0.733458</td><td>0.466415</td><td>0.699012</td><td>...</td><td>0.387480</td><td>0.676487</td><td>0.779472</td><td>0.610577</td><td>0.37495</td><td>0.499949</td><td>0.755580</td><td>0.429901</td><td>0.458673</td><td>0.633</td></tr><tr><th>3</th><td>0.785006</td><td>0.779830</td><td>0.592670</td><td>0.642601</td><td>0.718746</td><td>0.521712</td><td>0.425208</td><td>0.734467</td><td>0.350013</td><td>0.706972</td><td>...</td><td>0.390683</td><td>0.684269</td><td>0.779726</td><td>0.722084</td><td>0.37495</td><td>0.477220</td><td>0.755580</td><td>0.374841</td><td>0.530618</td><td>0.206</td></tr><tr><th>4</th><td>0.777416</td><td>0.818182</td><td>0.588988</td><td>0.649462</td><td>0.683488</td><td>0.541338</td><td>0.425208</td><td>0.721638</td><td>0.314675</td><td>0.736206</td><td>...</td><td>0.413107</td><td>0.776126</td><td>0.785950</td><td>0.693393</td><td>0.37495</td><td>0.462067</td><td>0.755580</td><td>0.296712</td><td>0.543288</td><td>0.384</td></tr></tbody></table><p>5 rows × 33 columns</p></div><h2 id="特征相关性">4.4特征相关性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">16</span>))  <br>column = train_data_scaler.columns.tolist()  <br>mcorr = train_data_scaler[column].corr(method=<span class="hljs-string">&quot;spearman&quot;</span>)  <br>mask = np.zeros_like(mcorr, dtype=np.<span class="hljs-built_in">bool</span>)  <br>mask[np.triu_indices_from(mask)] = <span class="hljs-literal">True</span>  <br>cmap = sns.diverging_palette(<span class="hljs-number">220</span>, <span class="hljs-number">10</span>, as_cmap=<span class="hljs-literal">True</span>)  <br>g = sns.heatmap(mcorr, mask=mask, cmap=cmap, square=<span class="hljs-literal">True</span>, annot=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">&#x27;0.2f&#x27;</span>)  <br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-03特征工程/output_26_0.png" /> ​</p><h2 id="特征降维">4.5特征降维</h2><h3 id="相关性初筛1">4.5.1相关性初筛1</h3><p>进行特征相关性初筛，计算相关性系数并筛选大于0.1的特征变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">mcorr=mcorr.<span class="hljs-built_in">abs</span>()<br>numerical_corr=mcorr[mcorr[<span class="hljs-string">&#x27;target&#x27;</span>]&gt;<span class="hljs-number">0.1</span>][<span class="hljs-string">&#x27;target&#x27;</span>]<br><span class="hljs-built_in">print</span>(numerical_corr.sort_values(ascending=<span class="hljs-literal">False</span>))<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">target    1.000000V0        0.712403V31       0.711636V1        0.682909V8        0.679469V27       0.657398V2        0.585850V16       0.545793V3        0.501622V4        0.478683V12       0.460300V10       0.448682V36       0.425991V37       0.376443V24       0.305526V5        0.286076V6        0.280195V20       0.278381V11       0.234551V15       0.221290V29       0.190109V7        0.185321V19       0.180111V18       0.149741V13       0.149199V17       0.126262V22       0.112743V30       0.101378Name: target, dtype: float64</code></pre><h4 id="代码详解-2">代码详解：</h4><ol type="1"><li><p>使用 <code>mcorr.abs()</code>对相关性矩阵 <code>mcorr</code> 中的各个元素取绝对值。</p></li><li><p><code>mcorr[mcorr['target']&gt;0.1]</code> 从 <code>mcorr</code> 中筛选出目标变量（<code>target</code>）相关性大于 0.1 的特征行，接着 <code>mcorr[mcorr['target']&gt;0.1]['target']</code>提取出 <code>target</code> 列。</p></li><li><p>对 <code>numerical_corr</code> 进行降序排序，<code>.sort_values(ascending=False)</code> 表示按照降序排列，即相关性系数较高的特征显示在前面。</p></li><li><p><code>numerical_corr.sort_values(ascending=False).index</code> 对 <code>numerical_corr</code> 进行降序排序，并提取排序后的索引，并将其赋值给 <code>index0</code>。</p></li><li><p>通过 <code>train_data_scaler[index0]</code> 获取 <code>train_data_scaler</code> 中与 <code>index0</code> 中特征名称索引对应的特征列，并使用 <code>.corr('spearman')</code> 计算这些特征之间的斯皮尔曼相关系数。</p></li></ol><h3 id="相关性初筛2">4.5.2相关性初筛2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">features_corr = numerical_corr.sort_values(ascending=<span class="hljs-literal">False</span>).reset_index()<br>features_corr.columns = [<span class="hljs-string">&#x27;features_and_target&#x27;</span>, <span class="hljs-string">&#x27;corr&#x27;</span>]<br>features_corr_select = features_corr[features_corr[<span class="hljs-string">&#x27;corr&#x27;</span>]&gt;<span class="hljs-number">0.3</span>] <span class="hljs-comment"># 筛选出大于相关性大于0.3的特征</span><br><span class="hljs-built_in">print</span>(features_corr_select)<br>select_features = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> features_corr_select[<span class="hljs-string">&#x27;features_and_target&#x27;</span>] <span class="hljs-keyword">if</span> col <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;target&#x27;</span>]]<br>new_train_data_corr_select = train_data_scaler[select_features+[<span class="hljs-string">&#x27;target&#x27;</span>]]<br>new_test_data_corr_select = test_data_scaler[select_features]<br></code></pre></td></tr></table></figure><pre><code class="hljs">   features_and_target      corr0               target  1.0000001                   V0  0.7124032                  V31  0.7116363                   V1  0.6829094                   V8  0.6794695                  V27  0.6573986                   V2  0.5858507                  V16  0.5457938                   V3  0.5016229                   V4  0.47868310                 V12  0.46030011                 V10  0.44868212                 V36  0.42599113                 V37  0.37644314                 V24  0.305526</code></pre><h2 id="多重共线性分析">4.6多重共线性分析</h2><p>多重共线性分析的原则是特征组之间的相关性系数较大，即每个特征变量与其他特征变量之间的相关性系数较大，故可能存在较大的共线性影响，这会导致模型估计不准确。因此，后续要使用PCA对数据进行处理，去除多重共线性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算多重共线性</span><br><span class="hljs-keyword">from</span> statsmodels.stats.outliers_influence <span class="hljs-keyword">import</span> variance_inflation_factor <span class="hljs-comment">#多重共线性方差膨胀因子</span><br><br><span class="hljs-comment">#多重共线性</span><br>new_numerical=[<span class="hljs-string">&#x27;V0&#x27;</span>, <span class="hljs-string">&#x27;V2&#x27;</span>, <span class="hljs-string">&#x27;V3&#x27;</span>, <span class="hljs-string">&#x27;V4&#x27;</span>, <span class="hljs-string">&#x27;V5&#x27;</span>, <span class="hljs-string">&#x27;V6&#x27;</span>, <span class="hljs-string">&#x27;V10&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>, <br>                         <span class="hljs-string">&#x27;V13&#x27;</span>, <span class="hljs-string">&#x27;V15&#x27;</span>, <span class="hljs-string">&#x27;V16&#x27;</span>, <span class="hljs-string">&#x27;V18&#x27;</span>, <span class="hljs-string">&#x27;V19&#x27;</span>, <span class="hljs-string">&#x27;V20&#x27;</span>, <span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V24&#x27;</span>,<span class="hljs-string">&#x27;V30&#x27;</span>, <span class="hljs-string">&#x27;V31&#x27;</span>, <span class="hljs-string">&#x27;V37&#x27;</span>]<br>X=np.matrix(train_data_scaler[new_numerical])<br>VIF_list=[variance_inflation_factor(X, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(X.shape[<span class="hljs-number">1</span>])]<br>VIF_list<br></code></pre></td></tr></table></figure><pre><code class="hljs">[216.73387180903222, 114.38118723828812, 27.863778129686356, 201.96436579080174, 78.93722825798903, 151.06983667656212, 14.519604941508451, 82.69750284665385, 28.479378440614585, 27.759176471505945, 526.6483470743831, 23.50166642638334, 19.920315849901424, 24.640481765008683, 11.816055964845381, 4.958208708452915, 37.09877416736591, 298.26442986612767, 47.854002539887034]</code></pre><p>说明：new_numerical的特征变量可以根据相关性矩阵看出并过滤筛选，剔除那些与其他特征高度相关的特征，然后，使用剩余的特征矩阵来计算每个特征的VIF值，以评估自变量之间的多重共线性程度。</p><h4 id="代码详解-3">代码详解：</h4><ol type="1"><li><p><code>new_numerical=[ ]</code>：定义了一个包含特征列名称的列表<code>new_numerical</code>，这些特征将被用于计算VIF。</p></li><li><p><code>X=np.matrix(train_data_scaler[new_numerical])</code>：将训练数据<code>train_data_scaler</code>中<code>new_numerical</code>列表中的特征列用 <code>np.matrix</code> 转换为二维矩阵<code>X</code>。该矩阵将作为VIF计算的输入。</p></li><li><p><code>VIF_list=[variance_inflation_factor(X, i) for i in range(X.shape[1])]</code>：使用列表推导式计算VIF列表。对于矩阵<code>X</code>的每一列（即特征），调用<code>variance_inflation_factor</code>函数来计算VIF，并将结果添加到<code>VIF_list</code>中。<code>range(X.shape[1])</code>生成了一个表示列索引的迭代器。（下方详解variance_inflation_factor）</p></li><li><p><code>VIF_list</code>：输出VIF列表，该列表包含了每个特征的方差膨胀因子。</p></li></ol><hr /><p><strong>variance_inflation_factor用法</strong></p><p><code>variance_inflation_factor</code> 是一个用于计算方差膨胀因子（Variance Inflation Factor，VIF）的函数。方差膨胀因子是用于检测多重共线性（multicollinearity）问题的一种统计指标。</p><p>多重共线性指的是在回归分析中，自变量之间存在高度线性相关性的情况。它会导致回归模型中的估计不稳定，使得对自变量的解释变得困难。方差膨胀因子通过衡量每个自变量对其他自变量的线性相关性来检测多重共线性。</p><p><code>variance_inflation_factor</code> 函数通常需要传入两个参数：</p><ol type="1"><li><code>X</code>：一个二维数组或数据帧，表示自变量矩阵。每一列代表一个自变量。</li><li><code>idx</code>：一个整数，表示要计算方差膨胀因子的自变量的索引。</li></ol><p>以下是 <code>variance_inflation_factor</code> 函数的用法示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> statsmodels.stats.outliers_influence <span class="hljs-keyword">import</span> variance_inflation_factor<br><br><span class="hljs-comment"># 假设 X 是自变量矩阵，其中每一列代表一个自变量</span><br>vif = variance_inflation_factor(X, idx)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Variance inflation factor for variable <span class="hljs-subst">&#123;idx&#125;</span>: <span class="hljs-subst">&#123;vif&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>这段代码计算自变量矩阵 <code>X</code> 中给定索引 <code>idx</code> 的自变量的方差膨胀因子，并将结果打印输出。</p><p>方差膨胀因子的常见阈值为 5 或 10。当方差膨胀因子超过这个阈值时，表示该自变量与其他自变量存在高度线性相关性，可能会导致多重共线性问题。一般而言，方差膨胀因子越大，说明自变量之间的相关性越高。</p><h2 id="pca处理">4.7PCA处理</h2><p>利用PCA方法去除数据的多重共线性，并进行降维。</p><p>在scikit-learn（sklearn）库中，PCA被实现<code>sklearn.decomposition.PCA</code>类，主要参数<code>n_components</code>指定降维后的特征数量或保留的信息量的比例。可以设置为一个整数来指定具体的特征数量，也可以设置为一个0到1之间的浮点数来表示保留的信息量比例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA   <span class="hljs-comment">#主成分分析法</span><br><br><span class="hljs-comment">#PCA方法降维</span><br><span class="hljs-comment">#保持90%的信息</span><br>pca = PCA(n_components=<span class="hljs-number">0.9</span>)<br>new_train_pca_90 = pca.fit_transform(train_data_scaler.iloc[:,<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>])<br>new_test_pca_90 = pca.transform(test_data_scaler)<br><br>new_train_pca_90 = pd.DataFrame(new_train_pca_90)<br>new_test_pca_90 = pd.DataFrame(new_test_pca_90)<br><br>new_train_pca_90[<span class="hljs-string">&#x27;target&#x27;</span>] = train_data_scaler[<span class="hljs-string">&#x27;target&#x27;</span>]<br><br><span class="hljs-comment"># 查看原数据信息并与PCA处理后的数据进行对比</span><br>display(new_train_pca_90.describe())<br>display(train_data_scaler.describe())<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2884.000000</td></tr><tr><th>mean</th><td>2.089242e-17</td><td>-1.012126e-16</td><td>1.057905e-17</td><td>-1.002894e-16</td><td>8.509402e-17</td><td>-5.249131e-17</td><td>5.271732e-17</td><td>6.668166e-17</td><td>-4.468205e-17</td><td>9.163379e-17</td><td>7.636149e-18</td><td>1.237075e-16</td><td>-5.053900e-18</td><td>-5.874257e-17</td><td>-2.122542e-17</td><td>1.230265e-16</td><td>0.127274</td></tr><tr><th>std</th><td>3.998976e-01</td><td>3.500240e-01</td><td>2.938631e-01</td><td>2.728023e-01</td><td>2.077128e-01</td><td>1.951842e-01</td><td>1.877104e-01</td><td>1.607670e-01</td><td>1.512707e-01</td><td>1.443772e-01</td><td>1.368790e-01</td><td>1.286192e-01</td><td>1.193301e-01</td><td>1.149758e-01</td><td>1.133507e-01</td><td>1.019259e-01</td><td>0.983462</td></tr><tr><th>min</th><td>-1.071795e+00</td><td>-9.429479e-01</td><td>-9.948314e-01</td><td>-7.103087e-01</td><td>-7.703987e-01</td><td>-5.340294e-01</td><td>-5.993766e-01</td><td>-5.870755e-01</td><td>-6.282818e-01</td><td>-4.902583e-01</td><td>-6.341045e-01</td><td>-5.906753e-01</td><td>-4.175153e-01</td><td>-4.310613e-01</td><td>-4.170535e-01</td><td>-3.601627e-01</td><td>-3.044000</td></tr><tr><th>25%</th><td>-2.804085e-01</td><td>-2.613727e-01</td><td>-2.090797e-01</td><td>-1.945196e-01</td><td>-1.315620e-01</td><td>-1.264097e-01</td><td>-1.236360e-01</td><td>-1.016452e-01</td><td>-9.662098e-02</td><td>-9.297088e-02</td><td>-8.202809e-02</td><td>-7.721868e-02</td><td>-7.139961e-02</td><td>-7.474073e-02</td><td>-7.709743e-02</td><td>-6.603914e-02</td><td>-0.348500</td></tr><tr><th>50%</th><td>-1.417104e-02</td><td>-1.277241e-02</td><td>2.112166e-02</td><td>-2.337401e-02</td><td>-5.122797e-03</td><td>-1.355336e-02</td><td>-1.747870e-04</td><td>-4.656359e-03</td><td>2.572054e-03</td><td>-1.479172e-03</td><td>7.286444e-03</td><td>-5.745946e-03</td><td>-4.140670e-03</td><td>1.054915e-03</td><td>-1.758387e-03</td><td>-7.533392e-04</td><td>0.313000</td></tr><tr><th>75%</th><td>2.287306e-01</td><td>2.317720e-01</td><td>2.069571e-01</td><td>1.657590e-01</td><td>1.281660e-01</td><td>9.993122e-02</td><td>1.272081e-01</td><td>9.657222e-02</td><td>1.002626e-01</td><td>9.059634e-02</td><td>8.833765e-02</td><td>7.148033e-02</td><td>6.786199e-02</td><td>7.574868e-02</td><td>7.116829e-02</td><td>6.357449e-02</td><td>0.794250</td></tr><tr><th>max</th><td>1.597730e+00</td><td>1.382802e+00</td><td>1.010250e+00</td><td>1.448007e+00</td><td>1.034061e+00</td><td>1.358962e+00</td><td>6.191589e-01</td><td>7.370089e-01</td><td>6.449125e-01</td><td>5.839586e-01</td><td>6.405187e-01</td><td>6.780732e-01</td><td>5.156118e-01</td><td>4.978126e-01</td><td>4.673189e-01</td><td>4.570870e-01</td><td>2.538000</td></tr></tbody></table></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>...</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2886.000000</td><td>2884.000000</td></tr><tr><th>mean</th><td>0.690633</td><td>0.735633</td><td>0.593844</td><td>0.606212</td><td>0.639787</td><td>0.607649</td><td>0.735477</td><td>0.741354</td><td>0.702053</td><td>0.821897</td><td>...</td><td>0.401631</td><td>0.634466</td><td>0.760495</td><td>0.632231</td><td>0.459302</td><td>0.484489</td><td>0.734944</td><td>0.336235</td><td>0.527608</td><td>0.127274</td></tr><tr><th>std</th><td>0.143740</td><td>0.133703</td><td>0.145844</td><td>0.151311</td><td>0.119504</td><td>0.193887</td><td>0.141896</td><td>0.137154</td><td>0.129098</td><td>0.108362</td><td>...</td><td>0.141594</td><td>0.124279</td><td>0.110938</td><td>0.139037</td><td>0.099799</td><td>0.101365</td><td>0.122840</td><td>0.123663</td><td>0.153192</td><td>0.983462</td></tr><tr><th>min</th><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>...</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>-3.044000</td></tr><tr><th>25%</th><td>0.626239</td><td>0.695703</td><td>0.497759</td><td>0.515087</td><td>0.586328</td><td>0.497566</td><td>0.659249</td><td>0.682314</td><td>0.653489</td><td>0.794789</td><td>...</td><td>0.300053</td><td>0.587132</td><td>0.722593</td><td>0.565757</td><td>0.409037</td><td>0.454490</td><td>0.685279</td><td>0.279792</td><td>0.427036</td><td>-0.348500</td></tr><tr><th>50%</th><td>0.727153</td><td>0.766335</td><td>0.609155</td><td>0.609855</td><td>0.652873</td><td>0.642456</td><td>0.767192</td><td>0.774189</td><td>0.728557</td><td>0.846181</td><td>...</td><td>0.385611</td><td>0.633894</td><td>0.782330</td><td>0.634770</td><td>0.454518</td><td>0.499949</td><td>0.755580</td><td>0.349860</td><td>0.519457</td><td>0.313000</td></tr><tr><th>75%</th><td>0.783922</td><td>0.812642</td><td>0.694422</td><td>0.714096</td><td>0.712152</td><td>0.759266</td><td>0.835690</td><td>0.837030</td><td>0.781029</td><td>0.846181</td><td>...</td><td>0.488121</td><td>0.694136</td><td>0.824949</td><td>0.714950</td><td>0.504261</td><td>0.511365</td><td>0.785260</td><td>0.414447</td><td>0.621870</td><td>0.794250</td></tr><tr><th>max</th><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>...</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>2.538000</td></tr></tbody></table><p>8 rows × 39 columns</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#PCA方法降维</span><br><span class="hljs-comment">#保留16个主成分</span><br>pca = PCA(n_components=<span class="hljs-number">16</span>)<br>new_train_pca_16 = pca.fit_transform(train_data_scaler.iloc[:,<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>])<br>new_test_pca_16 = pca.transform(test_data_scaler)<br>new_train_pca_16 = pd.DataFrame(new_train_pca_16)<br>new_test_pca_16 = pd.DataFrame(new_test_pca_16)<br>new_train_pca_16[<span class="hljs-string">&#x27;target&#x27;</span>] = train_data_scaler[<span class="hljs-string">&#x27;target&#x27;</span>]<br><br>display(new_train_pca_16.describe())<br>display(new_test_pca_16.describe())<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2.886000e+03</td><td>2884.000000</td></tr><tr><th>mean</th><td>-8.025530e-17</td><td>9.902951e-17</td><td>2.481268e-17</td><td>-9.296098e-17</td><td>6.399362e-17</td><td>-2.711122e-17</td><td>8.112207e-17</td><td>3.819036e-17</td><td>-6.028134e-17</td><td>7.289445e-17</td><td>1.754800e-17</td><td>1.437164e-16</td><td>-1.772471e-17</td><td>-4.583132e-17</td><td>-4.687240e-18</td><td>1.133413e-16</td><td>0.127274</td></tr><tr><th>std</th><td>3.998976e-01</td><td>3.500240e-01</td><td>2.938631e-01</td><td>2.728023e-01</td><td>2.077128e-01</td><td>1.951842e-01</td><td>1.877104e-01</td><td>1.607670e-01</td><td>1.512707e-01</td><td>1.443772e-01</td><td>1.368790e-01</td><td>1.286192e-01</td><td>1.193301e-01</td><td>1.149758e-01</td><td>1.133504e-01</td><td>1.019258e-01</td><td>0.983462</td></tr><tr><th>min</th><td>-1.071795e+00</td><td>-9.429479e-01</td><td>-9.948314e-01</td><td>-7.103086e-01</td><td>-7.703992e-01</td><td>-5.340298e-01</td><td>-5.993763e-01</td><td>-5.870643e-01</td><td>-6.282915e-01</td><td>-4.902772e-01</td><td>-6.340438e-01</td><td>-5.906787e-01</td><td>-4.175381e-01</td><td>-4.310506e-01</td><td>-4.168836e-01</td><td>-3.602406e-01</td><td>-3.044000</td></tr><tr><th>25%</th><td>-2.804085e-01</td><td>-2.613727e-01</td><td>-2.090798e-01</td><td>-1.945196e-01</td><td>-1.315621e-01</td><td>-1.264102e-01</td><td>-1.236360e-01</td><td>-1.016531e-01</td><td>-9.661879e-02</td><td>-9.296451e-02</td><td>-8.202614e-02</td><td>-7.723983e-02</td><td>-7.137032e-02</td><td>-7.476121e-02</td><td>-7.689358e-02</td><td>-6.605108e-02</td><td>-0.348500</td></tr><tr><th>50%</th><td>-1.417105e-02</td><td>-1.277241e-02</td><td>2.112167e-02</td><td>-2.337400e-02</td><td>-5.122561e-03</td><td>-1.355336e-02</td><td>-1.746698e-04</td><td>-4.655969e-03</td><td>2.574279e-03</td><td>-1.483695e-03</td><td>7.272187e-03</td><td>-5.778147e-03</td><td>-4.141567e-03</td><td>1.056716e-03</td><td>-1.924285e-03</td><td>-7.935672e-04</td><td>0.313000</td></tr><tr><th>75%</th><td>2.287306e-01</td><td>2.317720e-01</td><td>2.069571e-01</td><td>1.657590e-01</td><td>1.281662e-01</td><td>9.993117e-02</td><td>1.272076e-01</td><td>9.657352e-02</td><td>1.002620e-01</td><td>9.059130e-02</td><td>8.833726e-02</td><td>7.147819e-02</td><td>6.780737e-02</td><td>7.573818e-02</td><td>7.113472e-02</td><td>6.362983e-02</td><td>0.794250</td></tr><tr><th>max</th><td>1.597730e+00</td><td>1.382802e+00</td><td>1.010250e+00</td><td>1.448007e+00</td><td>1.034058e+00</td><td>1.358961e+00</td><td>6.191591e-01</td><td>7.370478e-01</td><td>6.449824e-01</td><td>5.839721e-01</td><td>6.405928e-01</td><td>6.781944e-01</td><td>5.156549e-01</td><td>4.978232e-01</td><td>4.677552e-01</td><td>4.569075e-01</td><td>2.538000</td></tr></tbody></table></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><th>count</th><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td></tr><tr><th>mean</th><td>0.381177</td><td>0.081992</td><td>0.281879</td><td>-0.197930</td><td>-0.100701</td><td>-0.142780</td><td>0.004071</td><td>-0.060480</td><td>-0.154322</td><td>0.086993</td><td>-0.100815</td><td>0.046543</td><td>0.019935</td><td>0.165712</td><td>-0.091402</td><td>0.098503</td></tr><tr><th>std</th><td>0.476428</td><td>0.401721</td><td>0.286971</td><td>0.469295</td><td>0.247697</td><td>0.240629</td><td>0.181197</td><td>0.182679</td><td>0.205765</td><td>0.194124</td><td>0.169021</td><td>0.150554</td><td>0.186972</td><td>0.133136</td><td>0.113115</td><td>0.156939</td></tr><tr><th>min</th><td>-0.669864</td><td>-0.811128</td><td>-0.867655</td><td>-1.464873</td><td>-0.835855</td><td>-0.885696</td><td>-0.598268</td><td>-1.178334</td><td>-1.263819</td><td>-0.551279</td><td>-0.907768</td><td>-0.552060</td><td>-0.647384</td><td>-0.249090</td><td>-0.530208</td><td>-0.404869</td></tr><tr><th>25%</th><td>0.038180</td><td>-0.212454</td><td>0.115846</td><td>-0.574960</td><td>-0.255649</td><td>-0.276799</td><td>-0.115316</td><td>-0.174018</td><td>-0.310445</td><td>-0.047362</td><td>-0.204719</td><td>-0.060321</td><td>-0.107933</td><td>0.071293</td><td>-0.168086</td><td>-0.011253</td></tr><tr><th>50%</th><td>0.287710</td><td>0.014673</td><td>0.282676</td><td>-0.087425</td><td>-0.125262</td><td>-0.150075</td><td>0.003478</td><td>-0.053806</td><td>-0.175642</td><td>0.107260</td><td>-0.107033</td><td>0.036827</td><td>0.034512</td><td>0.148576</td><td>-0.087650</td><td>0.084981</td></tr><tr><th>75%</th><td>0.684349</td><td>0.348803</td><td>0.478167</td><td>0.170079</td><td>0.031784</td><td>-0.028064</td><td>0.116061</td><td>0.062062</td><td>-0.015697</td><td>0.235243</td><td>0.002403</td><td>0.142344</td><td>0.149126</td><td>0.261064</td><td>-0.018204</td><td>0.207740</td></tr><tr><th>max</th><td>2.265144</td><td>1.727923</td><td>1.228726</td><td>1.300934</td><td>0.893993</td><td>1.232575</td><td>0.635610</td><td>0.468097</td><td>0.639576</td><td>0.758273</td><td>0.691010</td><td>0.793413</td><td>0.627588</td><td>0.665948</td><td>0.301437</td><td>0.631095</td></tr></tbody></table></div><h1 id="模型初步训练">5模型初步训练</h1><h2 id="切分数据集">切分数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split <span class="hljs-comment"># 切分数据</span><br><br><span class="hljs-comment">#采用 pca 保留16维特征的数据</span><br>new_train_pca_16 = new_train_pca_16.fillna(<span class="hljs-number">0</span>) <span class="hljs-comment"># 缺失值填充为0</span><br>train = new_train_pca_16[new_test_pca_16.columns] <span class="hljs-comment"># 特征</span><br>target = new_train_pca_16[<span class="hljs-string">&#x27;target&#x27;</span>] <span class="hljs-comment"># 标签</span><br><br><span class="hljs-comment"># 切分数据 训练数据80% 验证数据20%</span><br>train_data,test_data,train_target,test_target=train_test_split(train,target,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>train_data,test_data,train_target,test_target</code> 顺序一定不能错，依次为：训练集特征、测试集特征、训练集标签、测试集标签</p><h2 id="多元线性回归模型">5.1 多元线性回归模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression  <span class="hljs-comment">#线性回归</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error <span class="hljs-comment">#评价指标</span><br><br>clf = LinearRegression()<br>clf.fit(train_data, train_target)<br>test_pred = clf.predict(test_data)<br>score = mean_squared_error(test_target, test_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LinearRegression:   &quot;</span>, score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">LinearRegression:    0.27167848406515294</code></pre><h4 id="代码详解-4">代码详解：</h4><p><code>mean_squared_error</code>是一个用于计算均方误差（Mean Squared Error, MSE）的函数。它衡量了预测值与真实值之间的平均平方差。</p><p>函数语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mean_squared_error(y_true, y_pred, squared=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>y_true</code>：真实的目标变量值，也就是真实的标签值。</li><li><code>y_pred</code>：预测的目标变量值，也就是模型的预测结果。</li><li><code>squared</code>：可选参数，默认为<code>True</code>。如果设置为<code>False</code>，将返回均方根误差（RMSE），即平方根值。</li></ul><p>函数返回一个浮点数，表示计算得到的均方误差或均方根误差。</p><h2 id="k近邻回归">5.2 K近邻回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor  <span class="hljs-comment">#K近邻回归</span><br><br>clf = KNeighborsRegressor(n_neighbors=<span class="hljs-number">3</span>) <span class="hljs-comment"># 3个聚类</span><br>clf.fit(train_data, train_target)<br>score = mean_squared_error(test_target, clf.predict(test_data))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;KNeighborsRegressor:   &quot;</span>, score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">KNeighborsRegressor:    0.2677332937331796</code></pre><h2 id="决策树回归">5.3 决策树回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeRegressor     <span class="hljs-comment">#决策树回归</span><br><br>clf = DecisionTreeRegressor() <br>clf.fit(train_data, train_target)<br>score = mean_squared_error(test_target, clf.predict(test_data))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;DecisionTreeRegressor:   &quot;</span>, score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">DecisionTreeRegressor:    0.5939244757785467</code></pre><h2 id="随机森林回归">5.4 随机森林回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor <span class="hljs-comment">#随机森林回归</span><br><br>clf = RandomForestRegressor(n_estimators=<span class="hljs-number">200</span>) <span class="hljs-comment"># 200棵树模型</span><br>clf.fit(train_data, train_target)<br>score = mean_squared_error(test_target, clf.predict(test_data))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;RandomForestRegressor:   &quot;</span>, score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">RandomForestRegressor:    0.2512481316266003</code></pre>]]></content>
    
    
    <categories>
      
      <category>机器学习实战入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工业蒸汽预测-02数据探索</title>
    <link href="/2023/07/29/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-02%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/"/>
    <url>/2023/07/29/%E5%B7%A5%E4%B8%9A%E8%92%B8%E6%B1%BD%E9%A2%84%E6%B5%8B-02%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="导入数据探索的工具包">1导入数据探索的工具包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns <span class="hljs-comment"># 数据可视化。其中boxplot用于绘制箱形图</span><br><br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)<br> <br>%matplotlib inline<br></code></pre></td></tr></table></figure><h2 id="读取数据">2读取数据</h2><p>使用Pandas库<code>read_csv()</code>函数进行数据读取，由于读取的是文本文件(.txt)，需要设置分割符为‘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data_file = <span class="hljs-string">&quot;./data/zhengqi_train.txt&quot;</span><br>test_data_file =  <span class="hljs-string">&quot;./data/zhengqi_test.txt&quot;</span><br><br>train_data = pd.read_csv(train_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>test_data = pd.read_csv(test_data_file, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="查看数据信息">3查看数据信息</h2><h3 id="查看数据基本信息">3.1查看数据基本信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练集</span><br>train_data.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 2888 entries, 0 to 2887Data columns (total 39 columns): #   Column  Non-Null Count  Dtype  ---  ------  --------------  -----   0   V0      2888 non-null   float64 1   V1      2888 non-null   float64 2   V2      2888 non-null   float64 3   V3      2888 non-null   float64 4   V4      2888 non-null   float64 5   V5      2888 non-null   float64 6   V6      2888 non-null   float64 7   V7      2888 non-null   float64 8   V8      2888 non-null   float64 9   V9      2888 non-null   float64 10  V10     2888 non-null   float64 11  V11     2888 non-null   float64 12  V12     2888 non-null   float64 13  V13     2888 non-null   float64 14  V14     2888 non-null   float64 15  V15     2888 non-null   float64 16  V16     2888 non-null   float64 17  V17     2888 non-null   float64 18  V18     2888 non-null   float64 19  V19     2888 non-null   float64 20  V20     2888 non-null   float64 21  V21     2888 non-null   float64 22  V22     2888 non-null   float64 23  V23     2888 non-null   float64 24  V24     2888 non-null   float64 25  V25     2888 non-null   float64 26  V26     2888 non-null   float64 27  V27     2888 non-null   float64 28  V28     2888 non-null   float64 29  V29     2888 non-null   float64 30  V30     2888 non-null   float64 31  V31     2888 non-null   float64 32  V32     2888 non-null   float64 33  V33     2888 non-null   float64 34  V34     2888 non-null   float64 35  V35     2888 non-null   float64 36  V36     2888 non-null   float64 37  V37     2888 non-null   float64 38  target  2888 non-null   float64dtypes: float64(39)memory usage: 880.1 KB</code></pre><ol type="1"><li>此训练集数据共有2888个样本，数据中有V0-V37共计38个特征变量，变量类型都为数值类型，所有数据特征没有缺失值数据；</li><li>数据字段由于采用了脱敏处理，删除了特征数据的具体含义；</li><li>target字段为标签变量</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试集</span><br>test_data.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 1925 entries, 0 to 1924Data columns (total 38 columns): #   Column  Non-Null Count  Dtype  ---  ------  --------------  -----   0   V0      1925 non-null   float64 1   V1      1925 non-null   float64 2   V2      1925 non-null   float64 3   V3      1925 non-null   float64 4   V4      1925 non-null   float64 5   V5      1925 non-null   float64 6   V6      1925 non-null   float64 7   V7      1925 non-null   float64 8   V8      1925 non-null   float64 9   V9      1925 non-null   float64 10  V10     1925 non-null   float64 11  V11     1925 non-null   float64 12  V12     1925 non-null   float64 13  V13     1925 non-null   float64 14  V14     1925 non-null   float64 15  V15     1925 non-null   float64 16  V16     1925 non-null   float64 17  V17     1925 non-null   float64 18  V18     1925 non-null   float64 19  V19     1925 non-null   float64 20  V20     1925 non-null   float64 21  V21     1925 non-null   float64 22  V22     1925 non-null   float64 23  V23     1925 non-null   float64 24  V24     1925 non-null   float64 25  V25     1925 non-null   float64 26  V26     1925 non-null   float64 27  V27     1925 non-null   float64 28  V28     1925 non-null   float64 29  V29     1925 non-null   float64 30  V30     1925 non-null   float64 31  V31     1925 non-null   float64 32  V32     1925 non-null   float64 33  V33     1925 non-null   float64 34  V34     1925 non-null   float64 35  V35     1925 non-null   float64 36  V36     1925 non-null   float64 37  V37     1925 non-null   float64dtypes: float64(38)memory usage: 571.6 KB</code></pre><ol type="1"><li>测试集数据共有1925个样本，数据中有V0-V37共计38个特征变量，变量类型都为数值类型，无缺失值。</li><li>测试集中没有target字段（标签变量），需要我们预测并提交。</li></ol><h3 id="查看数据统计信息">3.2查看数据统计信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练集</span><br>train_data.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>count</th><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>...</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td><td>2888.000000</td></tr><tr><th>mean</th><td>0.123048</td><td>0.056068</td><td>0.289720</td><td>-0.067790</td><td>0.012921</td><td>-0.558565</td><td>0.182892</td><td>0.116155</td><td>0.177856</td><td>-0.169452</td><td>...</td><td>0.097648</td><td>0.055477</td><td>0.127791</td><td>0.020806</td><td>0.007801</td><td>0.006715</td><td>0.197764</td><td>0.030658</td><td>-0.130330</td><td>0.126353</td></tr><tr><th>std</th><td>0.928031</td><td>0.941515</td><td>0.911236</td><td>0.970298</td><td>0.888377</td><td>0.517957</td><td>0.918054</td><td>0.955116</td><td>0.895444</td><td>0.953813</td><td>...</td><td>1.061200</td><td>0.901934</td><td>0.873028</td><td>0.902584</td><td>1.006995</td><td>1.003291</td><td>0.985675</td><td>0.970812</td><td>1.017196</td><td>0.983966</td></tr><tr><th>min</th><td>-4.335000</td><td>-5.122000</td><td>-3.420000</td><td>-3.956000</td><td>-4.742000</td><td>-2.182000</td><td>-4.576000</td><td>-5.048000</td><td>-4.692000</td><td>-12.891000</td><td>...</td><td>-2.912000</td><td>-4.507000</td><td>-5.859000</td><td>-4.053000</td><td>-4.627000</td><td>-4.789000</td><td>-5.695000</td><td>-2.608000</td><td>-3.630000</td><td>-3.044000</td></tr><tr><th>25%</th><td>-0.297000</td><td>-0.226250</td><td>-0.313000</td><td>-0.652250</td><td>-0.385000</td><td>-0.853000</td><td>-0.310000</td><td>-0.295000</td><td>-0.159000</td><td>-0.390000</td><td>...</td><td>-0.664000</td><td>-0.283000</td><td>-0.170250</td><td>-0.407250</td><td>-0.499000</td><td>-0.290000</td><td>-0.202500</td><td>-0.413000</td><td>-0.798250</td><td>-0.350250</td></tr><tr><th>50%</th><td>0.359000</td><td>0.272500</td><td>0.386000</td><td>-0.044500</td><td>0.110000</td><td>-0.466000</td><td>0.388000</td><td>0.344000</td><td>0.362000</td><td>0.042000</td><td>...</td><td>-0.023000</td><td>0.053500</td><td>0.299500</td><td>0.039000</td><td>-0.040000</td><td>0.160000</td><td>0.364000</td><td>0.137000</td><td>-0.185500</td><td>0.313000</td></tr><tr><th>75%</th><td>0.726000</td><td>0.599000</td><td>0.918250</td><td>0.624000</td><td>0.550250</td><td>-0.154000</td><td>0.831250</td><td>0.782250</td><td>0.726000</td><td>0.042000</td><td>...</td><td>0.745250</td><td>0.488000</td><td>0.635000</td><td>0.557000</td><td>0.462000</td><td>0.273000</td><td>0.602000</td><td>0.644250</td><td>0.495250</td><td>0.793250</td></tr><tr><th>max</th><td>2.121000</td><td>1.918000</td><td>2.828000</td><td>2.457000</td><td>2.689000</td><td>0.489000</td><td>1.895000</td><td>1.918000</td><td>2.245000</td><td>1.335000</td><td>...</td><td>4.580000</td><td>2.689000</td><td>2.013000</td><td>2.395000</td><td>5.465000</td><td>5.110000</td><td>2.324000</td><td>5.238000</td><td>3.000000</td><td>2.538000</td></tr></tbody></table><p>8 rows × 39 columns</p></div><p>上面数据显示了数据的统计信息，例如样本数count，数据的平均值mean，标准差std，最小值min，最大值max等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试集</span><br>test_data.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V28</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th></tr></thead><tbody><tr><th>count</th><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>...</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td><td>1925.000000</td></tr><tr><th>mean</th><td>-0.184404</td><td>-0.083912</td><td>-0.434762</td><td>0.101671</td><td>-0.019172</td><td>0.838049</td><td>-0.274092</td><td>-0.173971</td><td>-0.266709</td><td>0.255114</td><td>...</td><td>-0.206871</td><td>-0.146463</td><td>-0.083215</td><td>-0.191729</td><td>-0.030782</td><td>-0.011433</td><td>-0.009985</td><td>-0.296895</td><td>-0.046270</td><td>0.195735</td></tr><tr><th>std</th><td>1.073333</td><td>1.076670</td><td>0.969541</td><td>1.034925</td><td>1.147286</td><td>0.963043</td><td>1.054119</td><td>1.040101</td><td>1.085916</td><td>1.014394</td><td>...</td><td>1.064140</td><td>0.880593</td><td>1.126414</td><td>1.138454</td><td>1.130228</td><td>0.989732</td><td>0.995213</td><td>0.946896</td><td>1.040854</td><td>0.940599</td></tr><tr><th>min</th><td>-4.814000</td><td>-5.488000</td><td>-4.283000</td><td>-3.276000</td><td>-4.921000</td><td>-1.168000</td><td>-5.649000</td><td>-5.625000</td><td>-6.059000</td><td>-6.784000</td><td>...</td><td>-2.435000</td><td>-2.413000</td><td>-4.507000</td><td>-7.698000</td><td>-4.057000</td><td>-4.627000</td><td>-4.789000</td><td>-7.477000</td><td>-2.608000</td><td>-3.346000</td></tr><tr><th>25%</th><td>-0.664000</td><td>-0.451000</td><td>-0.978000</td><td>-0.644000</td><td>-0.497000</td><td>0.122000</td><td>-0.732000</td><td>-0.509000</td><td>-0.775000</td><td>-0.390000</td><td>...</td><td>-0.453000</td><td>-0.818000</td><td>-0.339000</td><td>-0.476000</td><td>-0.472000</td><td>-0.460000</td><td>-0.290000</td><td>-0.349000</td><td>-0.593000</td><td>-0.432000</td></tr><tr><th>50%</th><td>0.065000</td><td>0.195000</td><td>-0.267000</td><td>0.220000</td><td>0.118000</td><td>0.437000</td><td>-0.082000</td><td>0.018000</td><td>-0.004000</td><td>0.401000</td><td>...</td><td>-0.445000</td><td>-0.199000</td><td>0.010000</td><td>0.100000</td><td>0.155000</td><td>-0.040000</td><td>0.160000</td><td>-0.270000</td><td>0.083000</td><td>0.152000</td></tr><tr><th>75%</th><td>0.549000</td><td>0.589000</td><td>0.278000</td><td>0.793000</td><td>0.610000</td><td>1.928000</td><td>0.457000</td><td>0.515000</td><td>0.482000</td><td>0.904000</td><td>...</td><td>-0.434000</td><td>0.468000</td><td>0.447000</td><td>0.471000</td><td>0.627000</td><td>0.419000</td><td>0.273000</td><td>0.364000</td><td>0.651000</td><td>0.797000</td></tr><tr><th>max</th><td>2.100000</td><td>2.120000</td><td>1.946000</td><td>2.603000</td><td>4.475000</td><td>3.176000</td><td>1.528000</td><td>1.394000</td><td>2.408000</td><td>1.766000</td><td>...</td><td>4.656000</td><td>3.022000</td><td>3.139000</td><td>1.428000</td><td>2.299000</td><td>5.465000</td><td>5.110000</td><td>1.671000</td><td>2.861000</td><td>3.021000</td></tr></tbody></table><p>8 rows × 38 columns</p></div><h3 id="查看数据字段信息">3.3查看数据字段信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train_data.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>0</th><td>0.566</td><td>0.016</td><td>-0.143</td><td>0.407</td><td>0.452</td><td>-0.901</td><td>-1.812</td><td>-2.360</td><td>-0.436</td><td>-2.114</td><td>...</td><td>0.136</td><td>0.109</td><td>-0.615</td><td>0.327</td><td>-4.627</td><td>-4.789</td><td>-5.101</td><td>-2.608</td><td>-3.508</td><td>0.175</td></tr><tr><th>1</th><td>0.968</td><td>0.437</td><td>0.066</td><td>0.566</td><td>0.194</td><td>-0.893</td><td>-1.566</td><td>-2.360</td><td>0.332</td><td>-2.114</td><td>...</td><td>-0.128</td><td>0.124</td><td>0.032</td><td>0.600</td><td>-0.843</td><td>0.160</td><td>0.364</td><td>-0.335</td><td>-0.730</td><td>0.676</td></tr><tr><th>2</th><td>1.013</td><td>0.568</td><td>0.235</td><td>0.370</td><td>0.112</td><td>-0.797</td><td>-1.367</td><td>-2.360</td><td>0.396</td><td>-2.114</td><td>...</td><td>-0.009</td><td>0.361</td><td>0.277</td><td>-0.116</td><td>-0.843</td><td>0.160</td><td>0.364</td><td>0.765</td><td>-0.589</td><td>0.633</td></tr><tr><th>3</th><td>0.733</td><td>0.368</td><td>0.283</td><td>0.165</td><td>0.599</td><td>-0.679</td><td>-1.200</td><td>-2.086</td><td>0.403</td><td>-2.114</td><td>...</td><td>0.015</td><td>0.417</td><td>0.279</td><td>0.603</td><td>-0.843</td><td>-0.065</td><td>0.364</td><td>0.333</td><td>-0.112</td><td>0.206</td></tr><tr><th>4</th><td>0.684</td><td>0.638</td><td>0.260</td><td>0.209</td><td>0.337</td><td>-0.454</td><td>-1.073</td><td>-2.086</td><td>0.314</td><td>-2.114</td><td>...</td><td>0.183</td><td>1.078</td><td>0.328</td><td>0.418</td><td>-0.843</td><td>-0.215</td><td>0.364</td><td>-0.280</td><td>-0.028</td><td>0.384</td></tr></tbody></table><p>5 rows × 39 columns</p></div><p>上面显示训练集前5条数据的基本信息，可以看到数据都是浮点型数据，数据都是数值型连续型特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">test_data.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>V9</th><th>...</th><th>V28</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th></tr></thead><tbody><tr><th>0</th><td>0.368</td><td>0.380</td><td>-0.225</td><td>-0.049</td><td>0.379</td><td>0.092</td><td>0.550</td><td>0.551</td><td>0.244</td><td>0.904</td><td>...</td><td>-0.449</td><td>0.047</td><td>0.057</td><td>-0.042</td><td>0.847</td><td>0.534</td><td>-0.009</td><td>-0.190</td><td>-0.567</td><td>0.388</td></tr><tr><th>1</th><td>0.148</td><td>0.489</td><td>-0.247</td><td>-0.049</td><td>0.122</td><td>-0.201</td><td>0.487</td><td>0.493</td><td>-0.127</td><td>0.904</td><td>...</td><td>-0.443</td><td>0.047</td><td>0.560</td><td>0.176</td><td>0.551</td><td>0.046</td><td>-0.220</td><td>0.008</td><td>-0.294</td><td>0.104</td></tr><tr><th>2</th><td>-0.166</td><td>-0.062</td><td>-0.311</td><td>0.046</td><td>-0.055</td><td>0.063</td><td>0.485</td><td>0.493</td><td>-0.227</td><td>0.904</td><td>...</td><td>-0.458</td><td>-0.398</td><td>0.101</td><td>0.199</td><td>0.634</td><td>0.017</td><td>-0.234</td><td>0.008</td><td>0.373</td><td>0.569</td></tr><tr><th>3</th><td>0.102</td><td>0.294</td><td>-0.259</td><td>0.051</td><td>-0.183</td><td>0.148</td><td>0.474</td><td>0.504</td><td>0.010</td><td>0.904</td><td>...</td><td>-0.456</td><td>-0.398</td><td>1.007</td><td>0.137</td><td>1.042</td><td>-0.040</td><td>-0.290</td><td>0.008</td><td>-0.666</td><td>0.391</td></tr><tr><th>4</th><td>0.300</td><td>0.428</td><td>0.208</td><td>0.051</td><td>-0.033</td><td>0.116</td><td>0.408</td><td>0.497</td><td>0.155</td><td>0.904</td><td>...</td><td>-0.458</td><td>-0.776</td><td>0.291</td><td>0.370</td><td>0.181</td><td>-0.040</td><td>-0.290</td><td>0.008</td><td>-0.140</td><td>-0.497</td></tr></tbody></table><p>5 rows × 38 columns</p></div><h2 id="可视化数据分布">4可视化数据分布</h2><h3 id="箱形图">4.1箱形图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先绘制训练集中特征变量V0的箱形图：</span><br>fig = plt.figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>))  <span class="hljs-comment"># 指定绘图对象宽度和高度</span><br>sns.boxplot(train_data[<span class="hljs-string">&#x27;V0&#x27;</span>],orient=<span class="hljs-string">&quot;v&quot;</span>, width=<span class="hljs-number">0.5</span>) <br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;AxesSubplot:&gt;</code></pre><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_20_1.png" /> ​</p><p>从图中可以看出有偏离值，许多数据点位于下四分位点以下。</p><h4 id="代码详解">代码详解：</h4><ol type="1"><li><p><code>fig = plt.figure(figsize=(4, 6))</code> 创建一个画布，并指定宽度为4，高度为6。<code>plt</code> 是 matplotlib 库的一个模块，用于绘制数据可视化图形。</p></li><li><p><code>sns.boxplot(train_data['V0'],orient="v", width=0.5)</code> 绘制箱形图。<code>sns</code> 是 seaborn 库的一个模块，用于数据可视化。<code>boxplot</code> 是用于绘制箱形图的函数。<code>train_data['V0']</code> 表示从训练集中获取特征变量 V0 的数据进行绘制。<code>orient="v"</code> 表示将箱形图垂直绘制，即以竖直方向为主轴。<code>width=0.5</code> 表示箱形图的宽度为0.5。</p></li></ol><p>箱形图是一种用于展示数据分布和离群值的图形。它由一个矩形框和两条线（即“须”上限、下限）组成。矩形框表示数据的四分位数范围（上下四分位数之间的距离），中间的线表示中位数，须表示数据的整体分布情况。箱形图可以帮助我们观察数据的偏态、集中趋势以及离群值等信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># V0-V37的箱形图：</span><br>column = train_data.columns.tolist()[:<span class="hljs-number">39</span>]  <span class="hljs-comment"># 列表头,共39列，V0-target</span><br>fig = plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">40</span>))  <span class="hljs-comment"># 指定绘图对象宽度和高度</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">38</span>):<br>    plt.subplot(<span class="hljs-number">13</span>, <span class="hljs-number">3</span>, i + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 13行3列子图</span><br>    sns.boxplot(train_data[column[i]], orient=<span class="hljs-string">&quot;h&quot;</span>, width=<span class="hljs-number">0.5</span>)  <span class="hljs-comment"># 箱式图</span><br>    plt.ylabel(column[i], fontsize=<span class="hljs-number">8</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_23_0.png" /> ​</p><p>从图中发现数据存在许多偏离较大的异常值，可以考虑移除。</p><h4 id="代码详解-1">代码详解：</h4><ol type="1"><li><p><code>column = train_data.columns.tolist()[:39]</code> 获取训练集数据中前39（包含）列（即V0到target）的列名，并将其存储在列表 <code>column</code> 中。<code>train_data.columns</code> 返回数据集的所有列名，<code>tolist()</code> 将其转换为列表，<code>[:39]</code> 表示取列表中的前39个元素。</p></li><li><p><code>fig = plt.figure(figsize=(20, 40))</code> 创建一个画布，并指定宽度为20，高度为40。</p></li><li><p><code>for i in range(38):</code> 循环遍历从0到37的整数，对应特征变量 V0 到 V37。</p></li><li><p><code>plt.subplot(13, 3, i + 1)</code> 创建一个子图，将画布分为13行3列的网格，选中当前子图(i+1)进行绘制。<code>i + 1</code> 表示子图的编号，从1开始。</p></li><li><p><code>sns.boxplot(train_data[column[i]], orient="h", width=0.5)</code> 绘制箱形图。<code>train_data[column[i]]</code> 表示从训练集中获取第i个特征变量的数据进行绘制。<code>orient="h"</code> 表示将箱形图水平绘制，即以水平方向为主轴。<code>width=0.5</code> 表示箱形图的宽度为0.5。</p></li><li><p><code>plt.ylabel(column[i], fontsize=8)</code> 在每个子图上添加y轴标签，标签内容为对应的特征变量名称 <code>column[i]</code>，并设置字体大小为8。</p></li><li><p><code>plt.show()</code> 展示绘制的箱形图。</p></li></ol><h3 id="直方图和q-q图">4.2直方图和Q-Q图</h3><p>Q-Q图是指数据的分位数和正态分布的分位数对比参照的图，如果数据符合正态分布，则所有的点都会落在直线上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看特征变量‘V0’的数据分布直方图，并绘制Q-Q图查看数据是否近似于正态分布</span><br><br>plt.figure(figsize=(<span class="hljs-number">5</span>,<span class="hljs-number">2.5</span>))<br><br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>sns.distplot(train_data[<span class="hljs-string">&#x27;V0&#x27;</span>],fit=stats.norm)<br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>res = stats.probplot(train_data[<span class="hljs-string">&#x27;V0&#x27;</span>], plot=plt)<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_28_0.png" /> ​</p><p>可以看到，训练集中特征变量V0的分布不是正态分布。</p><h4 id="代码详解-2">代码详解：</h4><ol type="1"><li><p><code>plt.figure(figsize=(10,5))</code> 创建一个宽度为10，高度为5的画布对象。<code>figsize=(10,5)</code> 指定了画布的尺寸。</p></li><li><p><code>ax=plt.subplot(1,2,1)</code> 创建一个子图对象，并指定它位于画布的第1行，第2列中。这里的 <code>(1,2,1)</code> 表示将画布分为1行2列的网格，并选中第1个位置的子图。</p></li><li><p><code>sns.distplot(train_data['V0'],fit=stats.norm)</code> 在第一个子图中绘制特征变量 'V0' 的直方图。<code>train_data['V0']</code> 表示从训练集中获取 'V0' 特征变量的数据进行绘制。<code>sns.distplot()</code> 是 seaborn 库中的函数，用于绘制直方图并拟合参数化的概率密度函数（默认为正态分布，通过 <code>fit=stats.norm</code> 指定，表示使用正态分布拟合）。</p></li><li><p><code>ax=plt.subplot(1,2,2)</code> 创建第二个子图，并指定它位于画布的第1行，第2列中。这里的 <code>(1,2,2)</code> 表示将画布分为1行2列的网格，并选中第2个位置的子图。</p></li><li><p><code>res = stats.probplot(train_data['V0'], plot=plt)</code> 在第二个子图中绘制特征变量 'V0' 的概率图。<code>stats.probplot()</code> 是 scipy 库（科学计算库）中的函数，用于绘制概率图。它可以判断数据是否符合某种理论分布（这里使用了默认的正态分布）。<code>plot=plt</code> 表示将概率图绘制在指定的子图上。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看所有数据的直方图和Q-Q图</span><br>train_cols = <span class="hljs-number">6</span> <span class="hljs-comment"># 画布列数</span><br>train_rows = <span class="hljs-built_in">len</span>(train_data.columns) <span class="hljs-comment"># 画布行数</span><br>plt.figure(figsize=(<span class="hljs-number">5</span>*train_cols,<span class="hljs-number">5</span>*train_rows))<br><br>i=<span class="hljs-number">0</span> <span class="hljs-comment"># 一次循环两个自增，所以初始为0</span><br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> train_data.columns:<br>    i+=<span class="hljs-number">1</span><br>    ax=plt.subplot(train_rows,train_cols,i)<br>    sns.distplot(train_data[col],fit=stats.norm)<br>    <br>    i+=<span class="hljs-number">1</span><br>    ax=plt.subplot(train_rows,train_cols,i)<br>    res = stats.probplot(train_data[col], plot=plt)<br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_31_0.png" /> ​</p><p>由上面的数据分布图信息可以看出，很多特征变量（如'V1','V9','V24','V28'等）的数据分布不是正态的，数据并不跟随对角线，后续可以使用数据变换对数据进行转换。</p><h4 id="代码解释">代码解释：</h4><p>简单的图可以通过<code>plt.figure(figsize=(10, 5))</code>直接指定画布的大小。</p><p>在展示多个子图时，直接指定画布大小可能会导致子图之间的重叠或缺乏足够的空间来显示所有子图。从而导致布局混乱或信息重叠。</p><p>使用<code>plt.figure(figsize=(5*train_cols, 5*train_rows))</code>的方式更加灵活，它会自动根据数据集中的特征变量数量来计算所需的行数和列数，并相应地调整画布的大小。这样可以确保每个子图都有足够的空间进行展示，并且整体布局更加均衡和清晰。</p><h3 id="kde图">4.3KDE图</h3><p>KDE(Kernel Density Estimation,核密度估计)可以理解为是对直方图的加窗平滑。可以查看并对比训练集和测试集中特征变量的分布情况，发现两个数据集中分布不一致的特征变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对比同一特征变量‘V0’下，训练集数据和测试集数据的分布情况，查看数据分布是否一致</span><br>plt.figure(figsize=(<span class="hljs-number">5</span>,<span class="hljs-number">2.5</span>),dpi=<span class="hljs-number">150</span>)<br>ax = sns.kdeplot(train_data[<span class="hljs-string">&#x27;V0&#x27;</span>], color=<span class="hljs-string">&quot;Red&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>ax = sns.kdeplot(test_data[<span class="hljs-string">&#x27;V0&#x27;</span>], color=<span class="hljs-string">&quot;Blue&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>ax.set_xlabel(<span class="hljs-string">&#x27;V0&#x27;</span>)<br>ax.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>ax = ax.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_35_0.png" /> ​</p><p>可以看到，V0在两个数据集中的分布基本一致。</p><h4 id="代码详解-3">代码详解：</h4><ol type="1"><li><p><code>plt.figure(figsize=(8,4), dpi=150)</code>：创建一个画布，指定尺寸为宽度8英寸，高度4英寸，dpi（每英寸像素点数）为150，数值越高质量越好，不指定有默认。</p></li><li><p><code>ax = sns.kdeplot(train_data['V0'], color="Red", shade=True)</code>：使用 Seaborn 库的 <code>kdeplot</code> 函数绘制训练数据集中特征变量 <code>'V0'</code> 的核密度估计曲线。<code>color="Red"</code> 指定曲线的颜色为红色，<code>shade=True</code> 表示曲线下方填充阴影以突出密度分布。</p></li><li><p><code>ax = sns.kdeplot(test_data['V0'], color="Blue", shade=True)</code>：类似地，使用 <code>kdeplot</code> 函数在同一图形上绘制测试数据集中特征变量 <code>'V0'</code> 的核密度估计曲线。这里设置曲线颜色为蓝色。</p></li><li><p><code>ax.set_xlabel('V0')</code>：设置 x 轴的标签为 <code>'V0'</code>。</p></li><li><p><code>ax.set_ylabel("Frequency")</code>：设置 y 轴的标签为 <code>'Frequency'</code>。</p></li><li><p><code>ax = ax.legend(["train","test"])</code>：添加图例。该语句首先通过 <code>ax.legend()</code> 方法在当前的轴对象 <code>ax</code> 上添加图例，然后使用 <code>["train", "test"]</code> 指定图例的标签。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看所有变量在训练集和测试集的KDE分布情况，分析并寻找出数据分布不一致的特征变量。</span><br>dist_cols = <span class="hljs-number">6</span><br>dist_rows = <span class="hljs-built_in">len</span>(test_data.columns)<br>plt.figure(figsize=(<span class="hljs-number">4</span>*dist_cols,<span class="hljs-number">4</span>*dist_rows))<br><br>i=<span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> test_data.columns:<br>    ax=plt.subplot(dist_rows,dist_cols,i)<br>    ax = sns.kdeplot(train_data[col], color=<span class="hljs-string">&quot;Red&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax = sns.kdeplot(test_data[col], color=<span class="hljs-string">&quot;Blue&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax.set_xlabel(col)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    ax = ax.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br>    <br>    i+=<span class="hljs-number">1</span><br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_38_0.png" /> ​</p><p>可以发现，特征变量V5,V9,V11,V17,V22,V28在训练集与测试集中的分布不一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看特征V5,V9,V11,V17,V22,V28数据的数据分布</span><br>drop_col = <span class="hljs-number">6</span><br>drop_row = <span class="hljs-number">1</span><br><br>plt.figure(figsize=(<span class="hljs-number">5</span>*drop_col,<span class="hljs-number">5</span>*drop_row))<br><br>i=<span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;V5&quot;</span>,<span class="hljs-string">&quot;V9&quot;</span>,<span class="hljs-string">&quot;V11&quot;</span>,<span class="hljs-string">&quot;V17&quot;</span>,<span class="hljs-string">&quot;V22&quot;</span>,<span class="hljs-string">&quot;V28&quot;</span>]:<br>    ax =plt.subplot(drop_row,drop_col,i)<br>    ax = sns.kdeplot(train_data[col], color=<span class="hljs-string">&quot;Red&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax = sns.kdeplot(test_data[col], color=<span class="hljs-string">&quot;Blue&quot;</span>, shade=<span class="hljs-literal">True</span>)<br>    ax.set_xlabel(col)<br>    ax.set_ylabel(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    ax = ax.legend([<span class="hljs-string">&quot;train&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>])<br>    <br>    i+=<span class="hljs-number">1</span><br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_40_0.png" /> ​</p><p>由上图的数据分布可以看到特征'V5','V9','V11','V17','V22','V28' 训练集数据与测试集数据分布不一致，会导致模型泛化能力差，采用删除此类特征方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">drop_columns = [<span class="hljs-string">&#x27;V5&#x27;</span>,<span class="hljs-string">&#x27;V9&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>,<span class="hljs-string">&#x27;V17&#x27;</span>,<span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V28&#x27;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#合并训练集和测试集数据，并可视化训练集和测试集数据特征分布图</span><br></code></pre></td></tr></table></figure><h3 id="线性回归关系图">4.4线性回归关系图</h3><p>线性回归关系图主要用于分析变量之间的线性回归关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看‘V0’与&#x27;target&#x27;变量的线性回归关系</span><br>fcols = <span class="hljs-number">2</span><br>frows = <span class="hljs-number">1</span><br>plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))<br><br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>sns.regplot(x=<span class="hljs-string">&#x27;V0&#x27;</span>, y=<span class="hljs-string">&#x27;target&#x27;</span>, data=train_data, ax=ax, <br>            scatter_kws=&#123;<span class="hljs-string">&#x27;marker&#x27;</span>:<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;alpha&#x27;</span>:<span class="hljs-number">0.3</span>&#125;,<br>            line_kws=&#123;<span class="hljs-string">&#x27;color&#x27;</span>:<span class="hljs-string">&#x27;k&#x27;</span>&#125;);<br>plt.xlabel(<span class="hljs-string">&#x27;V0&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;target&#x27;</span>)<br><br>ax=plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>sns.distplot(train_data[<span class="hljs-string">&#x27;V0&#x27;</span>].dropna())<br>plt.xlabel(<span class="hljs-string">&#x27;V0&#x27;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_45_0.png" /> ​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看所有特征变量与&#x27;target&#x27;变量的线性回归关系</span><br>fcols = <span class="hljs-number">6</span><br>frows = <span class="hljs-built_in">len</span>(test_data.columns)<br>plt.figure(figsize=(<span class="hljs-number">5</span>*fcols,<span class="hljs-number">4</span>*frows))<br><br>i=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> test_data.columns:<br>    i+=<span class="hljs-number">1</span><br>    ax=plt.subplot(frows,fcols,i)<br>    sns.regplot(x=col, y=<span class="hljs-string">&#x27;target&#x27;</span>, data=train_data, ax=ax, <br>                scatter_kws=&#123;<span class="hljs-string">&#x27;marker&#x27;</span>:<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;alpha&#x27;</span>:<span class="hljs-number">0.3</span>&#125;,<br>                line_kws=&#123;<span class="hljs-string">&#x27;color&#x27;</span>:<span class="hljs-string">&#x27;k&#x27;</span>&#125;);<br>    plt.xlabel(col)<br>    plt.ylabel(<span class="hljs-string">&#x27;target&#x27;</span>)<br>    <br>    i+=<span class="hljs-number">1</span><br>    ax=plt.subplot(frows,fcols,i)<br>    sns.distplot(train_data[col].dropna())<br>    plt.xlabel(col)<br>    <br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_46_0.png" /> ​</p><h4 id="代码解释-1">代码解释：</h4><p>散点图： 使用 Seaborn 库中的 <code>regplot</code> 函数来绘制自变量 <code>col</code> 与因变量 <code>'target'</code> 之间的散点图，并拟合一条线性回归线。</p><ul><li><code>x=col</code> 表示自变量的数据是 <code>col</code>，即当前循环遍历到的特征变量。</li><li><code>y='target'</code> 表示因变量的数据是 <code>'target'</code>，即目标变量。</li><li><code>data=train_data</code> 表示数据集是 <code>train_data</code>，即训练数据集。</li><li><code>ax=ax</code> 表示将子图对象 <code>ax</code> 分配给 <code>regplot</code> 函数来绘制子图。</li><li><code>scatter_kws=&#123;'marker':'.','s':3,'alpha':0.3&#125;</code> 设置散点图的样式参数。这里使用了小圆点作为散点图的标记，设置了透明度（<code>alpha</code>）、大小（<code>s</code>）和颜色（默认颜色）。</li><li><code>line_kws=&#123;'color':'k'&#125;</code> 设置回归线的样式参数。这里将回归线的颜色设置为黑色（<code>'k'</code> 是黑色的简写）。</li></ul><p>直方图： <code>sns.distplot(train_data[col].dropna())</code>绘制特征变量 <code>col</code>的直方图和核密度估计曲线。<code>dropna()</code>函数用于移除其中的缺失值（NaN值）。</p><h2 id="查看特征变量的相关性">5查看特征变量的相关性</h2><p>对特征变量的相关性进行分析，可以发现特征变量和目标变量及特征变量之间的关系，为在特征工程中提取特征做准备。</p><h3 id="计算相关性系数">5.1计算相关性系数</h3><p>在删除训练集和测试集中分布不一致的特征变量，如V5,V9,V11,V17,V22,V28之后，计算剩余特征变量及taret变量的相关性系数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pd.set_option (&#x27;display.max_columns&#x27;,10) # 显示最大列数，为10列，其他折叠起来</span><br><span class="hljs-comment"># pd.set_option(&#x27;display.max_rows&#x27;,10) # 显示最大行数，为10行，其他折叠起来</span><br><br>data_train1 = train_data.drop([<span class="hljs-string">&#x27;V5&#x27;</span>,<span class="hljs-string">&#x27;V9&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>,<span class="hljs-string">&#x27;V17&#x27;</span>,<span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V28&#x27;</span>],axis=<span class="hljs-number">1</span>)<br><br>train_corr = data_train1.corr()<br>train_corr<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V6</th><th>V7</th><th>V8</th><th>V10</th><th>V12</th><th>...</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th><th>target</th></tr></thead><tbody><tr><th>V0</th><td>1.000000</td><td>0.908607</td><td>0.463643</td><td>0.409576</td><td>0.781212</td><td>0.189267</td><td>0.141294</td><td>0.794013</td><td>0.298443</td><td>0.751830</td><td>...</td><td>0.302145</td><td>0.156968</td><td>0.675003</td><td>0.050951</td><td>0.056439</td><td>-0.019342</td><td>0.138933</td><td>0.231417</td><td>-0.494076</td><td>0.873212</td></tr><tr><th>V1</th><td>0.908607</td><td>1.000000</td><td>0.506514</td><td>0.383924</td><td>0.657790</td><td>0.276805</td><td>0.205023</td><td>0.874650</td><td>0.310120</td><td>0.656186</td><td>...</td><td>0.147096</td><td>0.175997</td><td>0.769745</td><td>0.085604</td><td>0.035129</td><td>-0.029115</td><td>0.146329</td><td>0.235299</td><td>-0.494043</td><td>0.871846</td></tr><tr><th>V2</th><td>0.463643</td><td>0.506514</td><td>1.000000</td><td>0.410148</td><td>0.057697</td><td>0.615938</td><td>0.477114</td><td>0.703431</td><td>0.346006</td><td>0.059941</td><td>...</td><td>-0.275764</td><td>0.175943</td><td>0.653764</td><td>0.033942</td><td>0.050309</td><td>-0.025620</td><td>0.043648</td><td>0.316462</td><td>-0.734956</td><td>0.638878</td></tr><tr><th>V3</th><td>0.409576</td><td>0.383924</td><td>0.410148</td><td>1.000000</td><td>0.315046</td><td>0.233896</td><td>0.197836</td><td>0.411946</td><td>0.321262</td><td>0.306397</td><td>...</td><td>0.117610</td><td>0.043966</td><td>0.421954</td><td>-0.092423</td><td>-0.007159</td><td>-0.031898</td><td>0.080034</td><td>0.324475</td><td>-0.229613</td><td>0.512074</td></tr><tr><th>V4</th><td>0.781212</td><td>0.657790</td><td>0.057697</td><td>0.315046</td><td>1.000000</td><td>-0.117529</td><td>-0.052370</td><td>0.449542</td><td>0.141129</td><td>0.927685</td><td>...</td><td>0.659093</td><td>0.022807</td><td>0.447016</td><td>-0.026186</td><td>0.062367</td><td>0.028659</td><td>0.100010</td><td>0.113609</td><td>-0.031054</td><td>0.603984</td></tr><tr><th>V6</th><td>0.189267</td><td>0.276805</td><td>0.615938</td><td>0.233896</td><td>-0.117529</td><td>1.000000</td><td>0.917502</td><td>0.468233</td><td>0.415660</td><td>-0.087312</td><td>...</td><td>-0.467980</td><td>0.188907</td><td>0.546535</td><td>0.144550</td><td>0.054210</td><td>-0.002914</td><td>0.044992</td><td>0.433804</td><td>-0.404817</td><td>0.370037</td></tr><tr><th>V7</th><td>0.141294</td><td>0.205023</td><td>0.477114</td><td>0.197836</td><td>-0.052370</td><td>0.917502</td><td>1.000000</td><td>0.389987</td><td>0.310982</td><td>-0.036791</td><td>...</td><td>-0.311363</td><td>0.170113</td><td>0.475254</td><td>0.122707</td><td>0.034508</td><td>-0.019103</td><td>0.111166</td><td>0.340479</td><td>-0.292285</td><td>0.287815</td></tr><tr><th>V8</th><td>0.794013</td><td>0.874650</td><td>0.703431</td><td>0.411946</td><td>0.449542</td><td>0.468233</td><td>0.389987</td><td>1.000000</td><td>0.419703</td><td>0.420557</td><td>...</td><td>-0.011091</td><td>0.150258</td><td>0.878072</td><td>0.038430</td><td>0.026843</td><td>-0.036297</td><td>0.179167</td><td>0.326586</td><td>-0.553121</td><td>0.831904</td></tr><tr><th>V10</th><td>0.298443</td><td>0.310120</td><td>0.346006</td><td>0.321262</td><td>0.141129</td><td>0.415660</td><td>0.310982</td><td>0.419703</td><td>1.000000</td><td>0.140462</td><td>...</td><td>-0.105042</td><td>-0.036705</td><td>0.560213</td><td>-0.093213</td><td>0.016739</td><td>-0.026994</td><td>0.026846</td><td>0.922190</td><td>-0.045851</td><td>0.394767</td></tr><tr><th>V12</th><td>0.751830</td><td>0.656186</td><td>0.059941</td><td>0.306397</td><td>0.927685</td><td>-0.087312</td><td>-0.036791</td><td>0.420557</td><td>0.140462</td><td>1.000000</td><td>...</td><td>0.666775</td><td>0.028866</td><td>0.441963</td><td>-0.007658</td><td>0.046674</td><td>0.010122</td><td>0.081963</td><td>0.112150</td><td>-0.054827</td><td>0.594189</td></tr><tr><th>V13</th><td>0.185144</td><td>0.157518</td><td>0.204762</td><td>-0.003636</td><td>0.075993</td><td>0.138367</td><td>0.110973</td><td>0.153299</td><td>-0.059553</td><td>0.098771</td><td>...</td><td>0.008235</td><td>0.027328</td><td>0.113743</td><td>0.130598</td><td>0.157513</td><td>0.116944</td><td>0.219906</td><td>-0.024751</td><td>-0.379714</td><td>0.203373</td></tr><tr><th>V14</th><td>-0.004144</td><td>-0.006268</td><td>-0.106282</td><td>-0.232677</td><td>0.023853</td><td>0.072911</td><td>0.163931</td><td>0.008138</td><td>-0.077543</td><td>0.020069</td><td>...</td><td>0.056814</td><td>-0.004057</td><td>0.010989</td><td>0.106581</td><td>0.073535</td><td>0.043218</td><td>0.233523</td><td>-0.086217</td><td>0.010553</td><td>0.008424</td></tr><tr><th>V15</th><td>0.314520</td><td>0.164702</td><td>-0.224573</td><td>0.143457</td><td>0.615704</td><td>-0.431542</td><td>-0.291272</td><td>0.018366</td><td>-0.046737</td><td>0.642081</td><td>...</td><td>0.951314</td><td>-0.111311</td><td>0.011768</td><td>-0.104618</td><td>0.050254</td><td>0.048602</td><td>0.100817</td><td>-0.051861</td><td>0.245635</td><td>0.154020</td></tr><tr><th>V16</th><td>0.347357</td><td>0.435606</td><td>0.782474</td><td>0.394517</td><td>0.023818</td><td>0.847119</td><td>0.752683</td><td>0.680031</td><td>0.546975</td><td>0.025736</td><td>...</td><td>-0.342210</td><td>0.154794</td><td>0.778538</td><td>0.041474</td><td>0.028878</td><td>-0.054775</td><td>0.082293</td><td>0.551880</td><td>-0.420053</td><td>0.536748</td></tr><tr><th>V18</th><td>0.148622</td><td>0.123862</td><td>0.132105</td><td>0.022868</td><td>0.136022</td><td>0.110570</td><td>0.098691</td><td>0.093682</td><td>-0.024693</td><td>0.119833</td><td>...</td><td>0.053958</td><td>0.470341</td><td>0.079718</td><td>0.411967</td><td>0.512139</td><td>0.365410</td><td>0.152088</td><td>0.019603</td><td>-0.181937</td><td>0.170721</td></tr><tr><th>V19</th><td>-0.100294</td><td>-0.092673</td><td>-0.161802</td><td>-0.246008</td><td>-0.205729</td><td>0.215290</td><td>0.158371</td><td>-0.144693</td><td>0.074903</td><td>-0.148319</td><td>...</td><td>-0.205409</td><td>0.100133</td><td>-0.131542</td><td>0.144018</td><td>-0.021517</td><td>-0.079753</td><td>-0.220737</td><td>0.087605</td><td>0.012115</td><td>-0.114976</td></tr><tr><th>V20</th><td>0.462493</td><td>0.459795</td><td>0.298385</td><td>0.289594</td><td>0.291309</td><td>0.136091</td><td>0.089399</td><td>0.412868</td><td>0.207612</td><td>0.271559</td><td>...</td><td>0.016233</td><td>0.086165</td><td>0.326863</td><td>0.050699</td><td>0.009358</td><td>-0.000979</td><td>0.048981</td><td>0.161315</td><td>-0.322006</td><td>0.444965</td></tr><tr><th>V21</th><td>-0.029285</td><td>-0.012911</td><td>-0.030932</td><td>0.114373</td><td>0.174025</td><td>-0.051806</td><td>-0.065300</td><td>-0.047839</td><td>0.082288</td><td>0.144371</td><td>...</td><td>0.157097</td><td>-0.077945</td><td>0.053025</td><td>-0.159128</td><td>-0.087561</td><td>-0.053707</td><td>-0.199398</td><td>0.047340</td><td>0.315470</td><td>-0.010063</td></tr><tr><th>V23</th><td>0.231136</td><td>0.222574</td><td>0.065509</td><td>0.081374</td><td>0.196530</td><td>0.069901</td><td>0.125180</td><td>0.174124</td><td>-0.066537</td><td>0.180049</td><td>...</td><td>0.116122</td><td>0.363963</td><td>0.129783</td><td>0.367086</td><td>0.183666</td><td>0.196681</td><td>0.635252</td><td>-0.035949</td><td>-0.187582</td><td>0.226331</td></tr><tr><th>V24</th><td>-0.324959</td><td>-0.233556</td><td>0.010225</td><td>-0.237326</td><td>-0.529866</td><td>0.072418</td><td>-0.030292</td><td>-0.136898</td><td>-0.029420</td><td>-0.550881</td><td>...</td><td>-0.642370</td><td>0.033532</td><td>-0.202097</td><td>0.060608</td><td>-0.134320</td><td>-0.095588</td><td>-0.243738</td><td>-0.041325</td><td>-0.137614</td><td>-0.264815</td></tr><tr><th>V25</th><td>-0.200706</td><td>-0.070627</td><td>0.481785</td><td>-0.100569</td><td>-0.444375</td><td>0.438610</td><td>0.316744</td><td>0.173320</td><td>0.079805</td><td>-0.448877</td><td>...</td><td>-0.575154</td><td>0.088238</td><td>0.201243</td><td>0.065501</td><td>-0.013312</td><td>-0.030747</td><td>-0.093948</td><td>0.069302</td><td>-0.246742</td><td>-0.019373</td></tr><tr><th>V26</th><td>-0.125140</td><td>-0.043012</td><td>0.035370</td><td>-0.027685</td><td>-0.080487</td><td>0.106055</td><td>0.160566</td><td>0.015724</td><td>0.072366</td><td>-0.124111</td><td>...</td><td>-0.133694</td><td>-0.057247</td><td>0.062879</td><td>-0.004545</td><td>-0.034596</td><td>0.051294</td><td>0.085576</td><td>0.064963</td><td>0.010880</td><td>-0.046724</td></tr><tr><th>V27</th><td>0.733198</td><td>0.824198</td><td>0.726250</td><td>0.392006</td><td>0.412083</td><td>0.474441</td><td>0.424185</td><td>0.901100</td><td>0.246085</td><td>0.374380</td><td>...</td><td>-0.032772</td><td>0.208074</td><td>0.790239</td><td>0.095127</td><td>0.030135</td><td>-0.036123</td><td>0.159884</td><td>0.226713</td><td>-0.617771</td><td>0.812585</td></tr><tr><th>V29</th><td>0.302145</td><td>0.147096</td><td>-0.275764</td><td>0.117610</td><td>0.659093</td><td>-0.467980</td><td>-0.311363</td><td>-0.011091</td><td>-0.105042</td><td>0.666775</td><td>...</td><td>1.000000</td><td>-0.122817</td><td>-0.004364</td><td>-0.110699</td><td>0.035272</td><td>0.035392</td><td>0.078588</td><td>-0.099309</td><td>0.285581</td><td>0.123329</td></tr><tr><th>V30</th><td>0.156968</td><td>0.175997</td><td>0.175943</td><td>0.043966</td><td>0.022807</td><td>0.188907</td><td>0.170113</td><td>0.150258</td><td>-0.036705</td><td>0.028866</td><td>...</td><td>-0.122817</td><td>1.000000</td><td>0.114318</td><td>0.695725</td><td>0.083693</td><td>-0.028573</td><td>-0.027987</td><td>0.006961</td><td>-0.256814</td><td>0.187311</td></tr><tr><th>V31</th><td>0.675003</td><td>0.769745</td><td>0.653764</td><td>0.421954</td><td>0.447016</td><td>0.546535</td><td>0.475254</td><td>0.878072</td><td>0.560213</td><td>0.441963</td><td>...</td><td>-0.004364</td><td>0.114318</td><td>1.000000</td><td>0.016782</td><td>0.016733</td><td>-0.047273</td><td>0.152314</td><td>0.510851</td><td>-0.357785</td><td>0.750297</td></tr><tr><th>V32</th><td>0.050951</td><td>0.085604</td><td>0.033942</td><td>-0.092423</td><td>-0.026186</td><td>0.144550</td><td>0.122707</td><td>0.038430</td><td>-0.093213</td><td>-0.007658</td><td>...</td><td>-0.110699</td><td>0.695725</td><td>0.016782</td><td>1.000000</td><td>0.105255</td><td>0.069300</td><td>0.016901</td><td>-0.054411</td><td>-0.162417</td><td>0.066606</td></tr><tr><th>V33</th><td>0.056439</td><td>0.035129</td><td>0.050309</td><td>-0.007159</td><td>0.062367</td><td>0.054210</td><td>0.034508</td><td>0.026843</td><td>0.016739</td><td>0.046674</td><td>...</td><td>0.035272</td><td>0.083693</td><td>0.016733</td><td>0.105255</td><td>1.000000</td><td>0.719126</td><td>0.167597</td><td>0.031586</td><td>-0.062715</td><td>0.077273</td></tr><tr><th>V34</th><td>-0.019342</td><td>-0.029115</td><td>-0.025620</td><td>-0.031898</td><td>0.028659</td><td>-0.002914</td><td>-0.019103</td><td>-0.036297</td><td>-0.026994</td><td>0.010122</td><td>...</td><td>0.035392</td><td>-0.028573</td><td>-0.047273</td><td>0.069300</td><td>0.719126</td><td>1.000000</td><td>0.233616</td><td>-0.019032</td><td>-0.006854</td><td>-0.006034</td></tr><tr><th>V35</th><td>0.138933</td><td>0.146329</td><td>0.043648</td><td>0.080034</td><td>0.100010</td><td>0.044992</td><td>0.111166</td><td>0.179167</td><td>0.026846</td><td>0.081963</td><td>...</td><td>0.078588</td><td>-0.027987</td><td>0.152314</td><td>0.016901</td><td>0.167597</td><td>0.233616</td><td>1.000000</td><td>0.025401</td><td>-0.077991</td><td>0.140294</td></tr><tr><th>V36</th><td>0.231417</td><td>0.235299</td><td>0.316462</td><td>0.324475</td><td>0.113609</td><td>0.433804</td><td>0.340479</td><td>0.326586</td><td>0.922190</td><td>0.112150</td><td>...</td><td>-0.099309</td><td>0.006961</td><td>0.510851</td><td>-0.054411</td><td>0.031586</td><td>-0.019032</td><td>0.025401</td><td>1.000000</td><td>-0.039478</td><td>0.319309</td></tr><tr><th>V37</th><td>-0.494076</td><td>-0.494043</td><td>-0.734956</td><td>-0.229613</td><td>-0.031054</td><td>-0.404817</td><td>-0.292285</td><td>-0.553121</td><td>-0.045851</td><td>-0.054827</td><td>...</td><td>0.285581</td><td>-0.256814</td><td>-0.357785</td><td>-0.162417</td><td>-0.062715</td><td>-0.006854</td><td>-0.077991</td><td>-0.039478</td><td>1.000000</td><td>-0.565795</td></tr><tr><th>target</th><td>0.873212</td><td>0.871846</td><td>0.638878</td><td>0.512074</td><td>0.603984</td><td>0.370037</td><td>0.287815</td><td>0.831904</td><td>0.394767</td><td>0.594189</td><td>...</td><td>0.123329</td><td>0.187311</td><td>0.750297</td><td>0.066606</td><td>0.077273</td><td>-0.006034</td><td>0.140294</td><td>0.319309</td><td>-0.565795</td><td>1.000000</td></tr></tbody></table><p>33 rows × 33 columns</p></div><h3 id="相关性热力图">5.2相关性热力图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画出相关性热力图</span><br>ax = plt.subplots(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">16</span>))<span class="hljs-comment">#调整画布大小</span><br><br>ax = sns.heatmap(train_corr, vmax=<span class="hljs-number">.8</span>, square=<span class="hljs-literal">True</span>, annot=<span class="hljs-literal">True</span>)<span class="hljs-comment">#画热力图   annot=True 显示系数</span><br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_52_0.png" /> ​</p><h4 id="代码解释-2">代码解释：</h4><p>使用Seaborn库中的<code>heatmap()</code>函数来绘制相关性热力图。</p><ul><li><code>ax = sns.heatmap(train_corr, vmax=.8, square=True, annot=True)</code> 在当前图像对象中绘制热力图。<code>train_corr</code>先前计算的相关系数矩阵。<code>vmax</code>参数用于设置颜色映射的最大值，即相关系数的范围。<code>square=True</code>将使得热力图的每个方块为正方形。<code>annot=True</code>表示在热力图中显示相关系数的数值。</li></ul><p><code>vmax</code>参数用于设置颜色映射的最大值，即相关系数的上限。通过将<code>vmax</code>设置为0.8，意味着相关系数的范围将被限制在0到0.8之间。任何具有相关系数大于0.8的值都将被映射为最浅的颜色。</p><p>通常，颜色映射是根据相关系数的值来定义的，例如，浅色可能表示正相关，深色可能表示负相关，中间色调可能表示无相关性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找出相关程度</span><br>data_train1 = train_data.drop([<span class="hljs-string">&#x27;V5&#x27;</span>,<span class="hljs-string">&#x27;V9&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>,<span class="hljs-string">&#x27;V17&#x27;</span>,<span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V28&#x27;</span>],axis=<span class="hljs-number">1</span>)<br><br>plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">16</span>))  <span class="hljs-comment"># 指定绘图对象宽度和高度</span><br>colnm = data_train1.columns.tolist()  <span class="hljs-comment"># 列表头</span><br>mcorr = data_train1[colnm].corr(method=<span class="hljs-string">&quot;spearman&quot;</span>)  <span class="hljs-comment"># 相关系数矩阵，即给出了任意两个变量之间的相关系数</span><br>mask = np.zeros_like(mcorr, dtype=np.<span class="hljs-built_in">bool</span>)  <span class="hljs-comment"># 构造与mcorr同维数矩阵 为bool型</span><br>mask[np.triu_indices_from(mask)] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 角分线右侧为True</span><br>cmap = sns.diverging_palette(<span class="hljs-number">220</span>, <span class="hljs-number">10</span>, as_cmap=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 返回matplotlib colormap对象</span><br>g = sns.heatmap(mcorr, mask=mask, cmap=cmap, square=<span class="hljs-literal">True</span>, annot=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">&#x27;0.2f&#x27;</span>)  <span class="hljs-comment"># 热力图（看两两相似度）</span><br>plt.show()<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_54_0.png" /> ​</p><p>上图为所有特征变量和target变量两两之间的相关系数，由此可以看出各个特征变量V0-V37之间的相关性以及特征变量V0-V37与target的相关性。</p><h4 id="代码详解-4">代码详解：</h4><ol type="1"><li><p><code>mcorr = data_train1[colnm].corr(method="spearman")</code>计算了给定变量列表<code>[colnm]</code>中两两变量之间的相关系数矩阵，使用Spearman秩相关系数方法，该方法更适用于非线性关系的数据，而且对异常值的影响较小。</p></li><li><p><code>np.zeros_like(mcorr, dtype=np.bool)</code>构建了一个与相关系数矩阵 <code>mcorr</code> 维度相同的布尔型矩阵 <code>mask</code>，并将其所有元素初始化为False。这个矩阵 <code>mask</code> 将用于在热力图中标记需要遮挡的区域。<code>np.zeros_like</code>用于创建一个与给定数组（或者与给定数组形状相同）具有相同形状的全零数组。</p></li><li><p><code>mask[np.triu_indices_from(mask)] = True</code>将对角线右上方的元素设为True，在热力图中这些区域将被遮挡起来，只显示对角线左下方的相关系数。</p></li></ol><ul><li><code>np.triu_indices_from()</code> 函数用于获取一个上三角矩阵的索引。</li><li><code>np.triu_indices_from(mask)</code>我们可以获取 mask 矩阵中上三角区域的所有元素的索引。然后，将这些索引对应的位置在 mask 矩阵中设置为 <code>True</code>，表示需要将相关系数矩阵中对应的元素掩盖起来。</li></ul><ol start="4" type="1"><li><code>cmap = sns.diverging_palette(220, 10, as_cmap=True)</code>利用Seaborn库中的<code>diverging_palette</code>函数创建了一个颜色映射(color map)对象 <code>cmap</code>，用于渲染热力图的颜色。</li></ol><ul><li><code>sns.diverging_palette()</code> 函数用于生成一个离散的、具有对比度的颜色调色板。它接受三个参数：<code>start</code>、<code>end</code> 和 <code>as_cmap</code>。</li><li><code>start</code> 和 <code>end</code> 是起始颜色和结束颜色的色调值（hue），取值范围为 [0, 360]。在这里，起始颜色的色调值为 220，结束颜色的色调值为 10。这意味着生成的调色板将从蓝绿色渐变到橙红色。</li><li><code>as_cmap=True</code> 表示将调色板转换为 colormap 对象，以便在绘图时使用。</li></ul><ol start="5" type="1"><li><code>g = sns.heatmap(mcorr, mask=mask, cmap=cmap, square=True, annot=True, fmt='0.2f')</code>生成热力图。其中，<code>mcorr</code>为相关系数矩阵，<code>mask</code>用于指定需要遮挡的区域，<code>cmap</code>为颜色映射对象，<code>square=True</code>表示将热力图显示为正方形，<code>annot=True</code>表示在热力图中显示相关系数的数值，<code>fmt='0.2f'</code>指定数值显示格式为保留两位小数。</li></ol><h3 id="根据相关系数筛选特征变量">5.3根据相关系数筛选特征变量</h3><p>以方便我们后续做特征工程及模型分析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先寻找K个与target变量最相关的特征变量</span><br>k = <span class="hljs-number">10</span> <span class="hljs-comment"># number of variables for heatmap</span><br>cols = train_corr.nlargest(k, <span class="hljs-string">&#x27;target&#x27;</span>)[<span class="hljs-string">&#x27;target&#x27;</span>].index <span class="hljs-comment"># 返回特征名</span><br><br>cm = np.corrcoef(train_data[cols].values.T)<br>hm = plt.subplots(figsize=(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>))<span class="hljs-comment">#调整画布大小</span><br><span class="hljs-comment">#hm1 = sns.heatmap(cm, cbar=True, annot=True, square=True) # 与hm结果相同，只是无标签.cbar=True 是在绘制相关性热力图时，添加了一个颜色条（color bar）来表示相关系数的范围。</span><br><span class="hljs-comment">#g = sns.heatmap(train_data[cols].corr(),annot=True,square=True,cmap=&quot;RdYlGn&quot;) # 与hm结果相同，只是配色不同. cmap=&quot;RdYlGn&quot; 指定颜色映射为 &quot;RdYlGn&quot;。</span><br>hm = sns.heatmap(train_data[cols].corr(),annot=<span class="hljs-literal">True</span>,square=<span class="hljs-literal">True</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/img/工业蒸汽预测-02数据探索/output_58_0.png" /> ​</p><h4 id="代码详解-5">代码详解：</h4><ol type="1"><li><code>train_corr.nlargest(k, 'target')['target'].index</code> 用于找到与目标变量相关性最高的k个特征变量，从<code>train_corr</code>中找到与<code>target</code>相关性最高的10个变量。</li></ol><ul><li><p><code>nlargest(n, columns, keep='first')</code>:<code>n</code>：要获取的最大值的数量。<code>columns</code>：指定要比较大小的列或列的列表。<code>keep</code>：（可选参数）设置用于处理重复值的策略。默认值为 'first'，表示保留第一个出现的最大值。还可以选择 'last'，表示保留最后一个出现的最大值。</p></li><li><p><code>train_corr.nlargest(k, 'target')</code> 返回了一个 DataFrame，其中包含了与目标变量 'target' 最相关的 K 个特征变量,返回整行。 <img src="/img/工业蒸汽预测-02数据探索/1.png" /></p></li><li><p><code>['target']</code> 从这个 DataFrame 中选择了名为 'target' 的列，并返回一个 Series 对象。 <img src="/img/工业蒸汽预测-02数据探索/2.png" /></p></li><li><p><code>.index</code> 调用了 Series 对象的 index 属性，用于获取该 Series 的索引。在这个上下文中，.index 返回了与目标变量最相关的 K 个特征变量所对应的列的索引。 <img src="/img/工业蒸汽预测-02数据探索/3.png" /></p></li></ul><ol start="2" type="1"><li><code>np.corrcoef(train_data[cols].values.T)</code> 计算<code>train_data</code>中<code>cols</code>所对应的特征变量之间的相关系数。</li></ol><ul><li><p><code>corrcoef(x, y=None, rowvar=True, bias=np._NoValue, ddof=np._NoValue)</code> 函数常用的是前三个参数，x和y分别是需要计算相关系数的两个随机变量，当rowvar为True(默认情况)时，每一行代表一个随机变量，否则每一列代表一个随机变量。所以需要用<code>.T</code>进行转置。</p></li><li><p><code>np.corrcoef(train_data[cols].values.T)</code>和<code>train_data[cols].corr()</code> 返回的数值都是一样的。最主要的区别是前者返回的类型是NumPy 数组，后者为 Pandas DataFrame</p></li></ul><ol start="3" type="1"><li><p><code>hm1 = sns.heatmap(cm, cbar=True, annot=True, square=True)</code> # cbar=True 添加颜色条（color bar）来表示相关系数的范围。</p></li><li><p><code>g = sns.heatmap(train_data[cols].corr(),annot=True,square=True,cmap="RdYlGn")</code> cmap="RdYlGn" 指定颜色映射为 "RdYlGn"。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 然后找出与arget变量的相关系数大于0.5的特征变量：</span><br>threshold = <span class="hljs-number">0.5</span><br><br>corrmat = train_data.corr()<br>top_corr_features = corrmat.index[<span class="hljs-built_in">abs</span>(corrmat[<span class="hljs-string">&quot;target&quot;</span>])&gt;threshold]<br>plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>))<br>g = sns.heatmap(train_data[top_corr_features].corr(),annot=<span class="hljs-literal">True</span>,cmap=<span class="hljs-string">&quot;RdYlGn&quot;</span>)<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_60_0.png" /> ​</p><h4 id="代码解释-3">代码解释：</h4><ol type="1"><li><p><code>corrmat["target"]</code>：从相关性矩阵 <code>corrmat</code> 中选择名为 "target" 的列，得到一个包含所有特征与目标变量的相关系数的 Series 对象。</p></li><li><p><code>abs(corrmat["target"]) &gt; threshold</code>：计算相关系数的绝对值，并将结果与阈值 <code>threshold</code> 进行比较，得到一个布尔类型的 Series 对象，表示哪些特征与目标变量的相关系数大于阈值。</p></li><li><p><code>corrmat.index[abs(corrmat["target"])&gt;threshold]</code>：根据上述布尔索引，从相关性矩阵的索引中选择相应的特征名。这将得到一个包含与目标变量的相关系数大于阈值的特征名的索引对象。<code>.index[]</code> 返回索引值。</p></li></ol><p>可以发现，与target变量的相关系数大于0.5的特征变量被直观地筛选出来。这一方法可以简单、直观地判断哪些特征变量线性相关，相关系数越大，就认为这些特征变量对target变量的线性影响越大。</p><p>说明：相关性选择主要用于判别线性相关对于target变量如果存在更复杂的函数形式的影响则建议使用树模型的特征重要性去选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用相关系数阈值移除相关特征：</span><br>threshold = <span class="hljs-number">0.5</span><br><br><span class="hljs-comment"># Absolute value correlation matrix</span><br>corr_matrix = data_train1.corr().<span class="hljs-built_in">abs</span>()<br>drop_col=corr_matrix[corr_matrix[<span class="hljs-string">&quot;target&quot;</span>]&lt;threshold].index<br><span class="hljs-comment">#data_all.drop(drop_col, axis=1, inplace=True)</span><br></code></pre></td></tr></table></figure><p>由于'V14', 'V21', 'V25', 'V26', 'V32', 'V33', 'V34'特征的相关系数值小于0.5，故认为这些特征与最终的预测target值不相关，删除这些特征变量；其可以发现一些不重要的特征并快速删除，方便快速分析重要特征。这里先不删除这些特征（注释的代码行用于删除特征），因为后续分析还会用到。</p><h3 id="box-cox变换">5.4Box-Cox变换</h3><p>由于线性回归是基于正态分布的，因此在进行统计分析时，需要转换数据使其符合正态分布。</p><p>Box-Cox 变换是一种常见的数据转换技术，用于将非正态分布的数据<strong>转换为近似正态分布</strong>的数据。这一变换可以使线性回归模型在满足线性、正态性、独立性及方差齐性的同时，又不丢失信息。在对数据做Box-Cox变换之后，可以在一定程度上减小不可观测的误差和预测变量的相关性，这有<strong>利于线性模型的拟合及分析出特征的相关性</strong>。</p><p>在做Box-Cox变换之前，需要对数据做归一化预处理。在归一化时，对数据进行合并操作可以使训练数据和测试数据一致。这种方式可以在线下分析建模中使用，而线上部署只需采用训练数据的归一化即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">drop_columns.clear()  <span class="hljs-comment"># 用于清空列表中的所有元素。</span><br>drop_columns = [<span class="hljs-string">&#x27;V5&#x27;</span>,<span class="hljs-string">&#x27;V9&#x27;</span>,<span class="hljs-string">&#x27;V11&#x27;</span>,<span class="hljs-string">&#x27;V17&#x27;</span>,<span class="hljs-string">&#x27;V22&#x27;</span>,<span class="hljs-string">&#x27;V28&#x27;</span>]<br><br><span class="hljs-comment"># 合并训练集和测试集的数据</span><br>train_x =  train_data.drop([<span class="hljs-string">&#x27;target&#x27;</span>], axis=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">#data_all=pd.concat([train_data,test_data],axis=0,ignore_index=True)</span><br>data_all = pd.concat([train_x,test_data]) <br><br><br>data_all.drop(drop_columns,axis=<span class="hljs-number">1</span>,inplace=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">#View data</span><br>data_all.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V6</th><th>V7</th><th>V8</th><th>V10</th><th>V12</th><th>...</th><th>V27</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th></tr></thead><tbody><tr><th>0</th><td>0.566</td><td>0.016</td><td>-0.143</td><td>0.407</td><td>0.452</td><td>-1.812</td><td>-2.360</td><td>-0.436</td><td>-0.940</td><td>-0.073</td><td>...</td><td>0.168</td><td>0.136</td><td>0.109</td><td>-0.615</td><td>0.327</td><td>-4.627</td><td>-4.789</td><td>-5.101</td><td>-2.608</td><td>-3.508</td></tr><tr><th>1</th><td>0.968</td><td>0.437</td><td>0.066</td><td>0.566</td><td>0.194</td><td>-1.566</td><td>-2.360</td><td>0.332</td><td>0.188</td><td>-0.134</td><td>...</td><td>0.338</td><td>-0.128</td><td>0.124</td><td>0.032</td><td>0.600</td><td>-0.843</td><td>0.160</td><td>0.364</td><td>-0.335</td><td>-0.730</td></tr><tr><th>2</th><td>1.013</td><td>0.568</td><td>0.235</td><td>0.370</td><td>0.112</td><td>-1.367</td><td>-2.360</td><td>0.396</td><td>0.874</td><td>-0.072</td><td>...</td><td>0.326</td><td>-0.009</td><td>0.361</td><td>0.277</td><td>-0.116</td><td>-0.843</td><td>0.160</td><td>0.364</td><td>0.765</td><td>-0.589</td></tr><tr><th>3</th><td>0.733</td><td>0.368</td><td>0.283</td><td>0.165</td><td>0.599</td><td>-1.200</td><td>-2.086</td><td>0.403</td><td>0.011</td><td>-0.014</td><td>...</td><td>0.277</td><td>0.015</td><td>0.417</td><td>0.279</td><td>0.603</td><td>-0.843</td><td>-0.065</td><td>0.364</td><td>0.333</td><td>-0.112</td></tr><tr><th>4</th><td>0.684</td><td>0.638</td><td>0.260</td><td>0.209</td><td>0.337</td><td>-1.073</td><td>-2.086</td><td>0.314</td><td>-0.251</td><td>0.199</td><td>...</td><td>0.332</td><td>0.183</td><td>1.078</td><td>0.328</td><td>0.418</td><td>-0.843</td><td>-0.215</td><td>0.364</td><td>-0.280</td><td>-0.028</td></tr></tbody></table><p>5 rows × 32 columns</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对合并后的每列数据进行归一化：</span><br>cols_numeric=<span class="hljs-built_in">list</span>(data_all.columns)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">scale_minmax</span>(<span class="hljs-params">col</span>):<br>    <span class="hljs-keyword">return</span> (col-col.<span class="hljs-built_in">min</span>())/(col.<span class="hljs-built_in">max</span>()-col.<span class="hljs-built_in">min</span>())<br><br>data_all[cols_numeric] = data_all[cols_numeric].apply(scale_minmax,axis=<span class="hljs-number">0</span>)<br>data_all[cols_numeric].describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>V0</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V6</th><th>V7</th><th>V8</th><th>V10</th><th>V12</th><th>...</th><th>V27</th><th>V29</th><th>V30</th><th>V31</th><th>V32</th><th>V33</th><th>V34</th><th>V35</th><th>V36</th><th>V37</th></tr></thead><tbody><tr><th>count</th><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>...</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td><td>4813.000000</td></tr><tr><th>mean</th><td>0.694172</td><td>0.721357</td><td>0.602300</td><td>0.603139</td><td>0.523743</td><td>0.748823</td><td>0.745740</td><td>0.715607</td><td>0.348518</td><td>0.578507</td><td>...</td><td>0.881401</td><td>0.388683</td><td>0.589459</td><td>0.792709</td><td>0.628824</td><td>0.458493</td><td>0.483790</td><td>0.762873</td><td>0.332385</td><td>0.545795</td></tr><tr><th>std</th><td>0.144198</td><td>0.131443</td><td>0.140628</td><td>0.152462</td><td>0.106430</td><td>0.132560</td><td>0.132577</td><td>0.118105</td><td>0.134882</td><td>0.105088</td><td>...</td><td>0.128221</td><td>0.133475</td><td>0.130786</td><td>0.102976</td><td>0.155003</td><td>0.099095</td><td>0.101020</td><td>0.102037</td><td>0.127456</td><td>0.150356</td></tr><tr><th>min</th><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>...</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td><td>0.000000</td></tr><tr><th>25%</th><td>0.626676</td><td>0.679416</td><td>0.514414</td><td>0.503888</td><td>0.478182</td><td>0.683324</td><td>0.696938</td><td>0.664934</td><td>0.284327</td><td>0.532892</td><td>...</td><td>0.888575</td><td>0.292445</td><td>0.550092</td><td>0.761816</td><td>0.562461</td><td>0.409037</td><td>0.454490</td><td>0.727273</td><td>0.270584</td><td>0.445647</td></tr><tr><th>50%</th><td>0.729488</td><td>0.752497</td><td>0.617072</td><td>0.614270</td><td>0.535866</td><td>0.774125</td><td>0.771974</td><td>0.742884</td><td>0.366469</td><td>0.591635</td><td>...</td><td>0.916015</td><td>0.375734</td><td>0.594428</td><td>0.815055</td><td>0.643056</td><td>0.454518</td><td>0.499949</td><td>0.800020</td><td>0.347056</td><td>0.539317</td></tr><tr><th>75%</th><td>0.790195</td><td>0.799553</td><td>0.700464</td><td>0.710474</td><td>0.585036</td><td>0.842259</td><td>0.836405</td><td>0.790835</td><td>0.432965</td><td>0.641971</td><td>...</td><td>0.932555</td><td>0.471837</td><td>0.650798</td><td>0.852229</td><td>0.719777</td><td>0.500000</td><td>0.511365</td><td>0.800020</td><td>0.414861</td><td>0.643061</td></tr><tr><th>max</th><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>...</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td><td>1.000000</td></tr></tbody></table><p>8 rows × 32 columns</p></div><h4 id="代码解释-4">代码解释：</h4><ol type="1"><li><code>cols_numeric=list(data_all.columns)</code><ul><li>将<code>data_all</code>中的所有列名保存在<code>cols_numeric</code>列表中。</li></ul></li><li><code>def scale_minmax(col):</code><ul><li>定义<code>scale_minmax</code>的函数，输入参数<code>col</code>表示数据的某一列。即使传入的是整个列，Pandas库的向量化操作会自动将这些操作应用到列中的每个元素上，从而实现对每个元素的归一化处理。</li></ul></li><li><code>return (col-col.min())/(col.max()-col.min())</code><ul><li>计算数据列<code>col</code>的归一化值。它用数据列中每个元素减去该列的最小值，然后除以该列的最大值与最小值之差，从而实现归一化处理。</li></ul></li><li><code>data_all[cols_numeric] = data_all[cols_numeric].apply(scale_minmax,axis=0)</code><ul><li>进行广播，将归一化处理的结果应用到<code>data_all</code>数据框的所有数值型列上。</li><li><code>data_all[cols_numeric]</code>表示选择<code>data_all</code>数据框中<code>cols_numeric</code>列表中的列。</li><li><code>.apply(scale_minmax, axis=0)</code>将<code>scale_minmax</code>函数应用到每列数据上，并指定<code>axis=0</code>以逐列进行操作。</li></ul></li></ol><p>也可以<strong>分开</strong>对训练数据和测试数据进行归一化处理，不过这种方式需要建立在训练数据和测试数据分布一致的前提下，建议在<strong>数据量大</strong>的情况下使用（数据量大，一般分布比较一致)，能加快归一化的速度。而数据量较小会存在分布差异较大的情况，此时，在数据分析和线下建模中应该将数据统一归一化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练集测试集分开归一化</span><br>train_data_process = train_data[cols_numeric]<br>train_data_process = train_data_process[cols_numeric].apply(scale_minmax,axis=<span class="hljs-number">0</span>)<br><br>test_data_process = test_data[cols_numeric]<br>test_data_process = test_data_process[cols_numeric].apply(scale_minmax,axis=<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Box-Cox变换（特征太多，分左右两部分绘制）</span><br>cols_numeric_left = cols_numeric[<span class="hljs-number">0</span>:<span class="hljs-number">13</span>]<br>cols_numeric_right = cols_numeric[<span class="hljs-number">13</span>:]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Check effect of Box-Cox transforms on distributions of continuous variables</span><br><br>train_data_process = pd.concat([train_data_process, train_data[<span class="hljs-string">&#x27;target&#x27;</span>]], axis=<span class="hljs-number">1</span>)<span class="hljs-comment"># 合并训练集</span><br><br>fcols = <span class="hljs-number">6</span><br>frows = <span class="hljs-built_in">len</span>(cols_numeric_left)<br>plt.figure(figsize=(<span class="hljs-number">4</span>*fcols,<span class="hljs-number">4</span>*frows)) <br>i=<span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> cols_numeric_left:<br>    dat = train_data_process[[var, <span class="hljs-string">&#x27;target&#x27;</span>]].dropna()<br>        <br>    <span class="hljs-comment">### 原数据直方图、Q-Q图、散点图    </span><br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    sns.distplot(dat[var] , fit=stats.norm);<br>    plt.title(var+<span class="hljs-string">&#x27; Original&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    _=stats.probplot(dat[var], plot=plt)<br>    plt.title(<span class="hljs-string">&#x27;skew=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stats.skew(dat[var]))) <span class="hljs-comment"># 下方有用法详解</span><br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    plt.plot(dat[var], dat[<span class="hljs-string">&#x27;target&#x27;</span>],<span class="hljs-string">&#x27;.&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    plt.title(<span class="hljs-string">&#x27;corr=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(dat[var], dat[<span class="hljs-string">&#x27;target&#x27;</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])) <span class="hljs-comment"># 下方有用法详解</span><br> <br>    <span class="hljs-comment">### Box-Cox变换，并绘制直方图、Q-Q图、散点图</span><br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    trans_var, lambda_var = stats.boxcox(dat[var].dropna()+<span class="hljs-number">1</span>)<br>    trans_var = scale_minmax(trans_var)      <br>    sns.distplot(trans_var , fit=stats.norm);<br>    plt.title(var+<span class="hljs-string">&#x27; Tramsformed&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    _=stats.probplot(trans_var, plot=plt)<br>    plt.title(<span class="hljs-string">&#x27;skew=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stats.skew(trans_var)))<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    plt.plot(trans_var, dat[<span class="hljs-string">&#x27;target&#x27;</span>],<span class="hljs-string">&#x27;.&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    plt.title(<span class="hljs-string">&#x27;corr=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(trans_var,dat[<span class="hljs-string">&#x27;target&#x27;</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><p>​<br /><img src="/img/工业蒸汽预测-02数据探索/output_73_0.png" /> ​</p><h4 id="代码详解-6">代码详解：</h4><ul><li><p><code>plt.title()</code>：这是Matplotlib库中的一个函数，用于设置当前子图的标题。它接受一个字符串作为参数，表示要设置的标题内容。</p></li><li><p><code>'skew=' + '&#123;:.4f&#125;'.format(stats.skew(dat[var]))</code>：这是一个字符串格式化操作，用于构造标题内容。其中包含了以下几个部分：</p><ul><li><code>'skew='</code>：这是一个固定的字符串，用于标识标题内容中的部分。</li><li><code>'&#123;:.4f&#125;'</code>：这是一个格式化字符串，表示将要显示的数值（即偏度值）的格式。<code>&#123;:.4f&#125;</code>中的<code>4</code>表示小数点后四位，<code>.f</code>表示浮点数。</li><li><code>format(stats.skew(dat[var]))</code>：这是一个格式化操作，用于将实际的数值（<code>stats.skew(dat[var])</code>）应用到格式化字符串中。</li></ul></li><li><p><code>stats.skew(dat[var])</code>：这是SciPy库中的<code>stats.skew()</code>函数，用于计算给定数据集（<code>dat[var]</code>）的偏度值。偏度是衡量数据分布偏斜程度的统计量，负值表示左偏（左侧的尾部更长），正值表示右偏（右侧的尾部更长），0表示对称分布。</p></li></ul><p><code>&#123;:.4f&#125;</code>是一种格式化字符串的方法，用于将浮点数进行格式化输出。</p><ol type="1"><li>具体用法：<ul><li><code>&#123;&#125;</code>：花括号内放置要格式化的值的占位符。</li><li><code>:</code> ：表示格式说明符的开始。</li><li><code>.4f</code>：表示使用浮点数格式化，并保留小数点后四位。</li></ul></li><li><code>:</code> 的用处：<ul><li>在格式说明符中，冒号（<code>:</code>）用来分隔格式说明符的各个部分。</li><li>在 <code>&#123;&#125;</code> 内的冒号后面，可以添加格式说明符，对应要格式化的值按照指定的格式输出。</li></ul></li><li>中间可以填哪些参数，表示什么：<ul><li>宽度参数：如 <code>&#123;:&lt;10&#125;</code> 表示左对齐并占用 10 个字符的宽度。</li><li>对齐参数：如 <code>&#123;:&gt;10&#125;</code> 表示右对齐并占用 10 个字符的宽度。</li><li>精度参数：如 <code>&#123;:.2f&#125;</code> 表示保留两位小数。</li><li>类型参数：如 <code>&#123;:s&#125;</code> 表示字符串类型，<code>&#123;:d&#125;</code> 表示整数类型，<code>&#123;:f&#125;</code> 表示浮点数类型等。</li></ul></li></ol><p>总结起来，冒号（<code>:</code>）在格式化字符串中的作用是分隔格式说明符的各个部分。精度参数和类型参数是冒号后面的部分，用于指定格式化的精度和类型。</p><p><code>[0][1]</code> 是用于获取 <code>np.corrcoef(dat[var],dat['target'])</code> 返回的相关系数矩阵中的特定元素的索引表示方式。</p><p><code>np.corrcoef(dat[var], dat['target'])</code> 用于计算 <code>dat[var]</code> 和 <code>dat['target']</code> 之间的相关系数矩阵。</p><ul><li>相关系数矩阵是一个二维矩阵，其中每个元素是两个变量之间的相关系数。例如： <img src="/img/工业蒸汽预测-02数据探索/4.png" /></li><li>在这种情况下，<code>[0][1]</code> 表示相关系数矩阵的第一行第二列的元素。其中，第一行对应于 <code>dat[var]</code> 与 <code>dat[var]</code>自身的相关系数，而第二列对应于 <code>dat[var]</code> 与 <code>dat['target']</code> 的相关系数。</li></ul><p>因此，<code>plt.title('corr='+'&#123;:.2f&#125;'.format(np.corrcoef(dat[var],dat['target'])[0][1]))</code> 中的 <code>[0][1]</code> 表示提取相关系数矩阵中与 <code>dat[var]</code> 与 <code>dat['target']</code> 相关系数对应的值，并将其格式化为小数点后两位的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Check effect of Box-Cox transforms on distributions of continuous variables</span><br><br>fcols = <span class="hljs-number">6</span><br>frows = <span class="hljs-built_in">len</span>(cols_numeric_right)<br>plt.figure(figsize=(<span class="hljs-number">4</span>*fcols,<span class="hljs-number">4</span>*frows))<br>i=<span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> cols_numeric_right:<br>    dat = train_data_process[[var, <span class="hljs-string">&#x27;target&#x27;</span>]].dropna() <br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    sns.distplot(dat[var] , fit=stats.norm);<br>    plt.title(var+<span class="hljs-string">&#x27; Original&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    _=stats.probplot(dat[var], plot=plt)<br>    plt.title(<span class="hljs-string">&#x27;skew=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stats.skew(dat[var])))<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    plt.plot(dat[var], dat[<span class="hljs-string">&#x27;target&#x27;</span>],<span class="hljs-string">&#x27;.&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    plt.title(<span class="hljs-string">&#x27;corr=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(dat[var], dat[<span class="hljs-string">&#x27;target&#x27;</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))<br> <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    trans_var, lambda_var = stats.boxcox(dat[var].dropna()+<span class="hljs-number">1</span>)<br>    trans_var = scale_minmax(trans_var)      <br>    sns.distplot(trans_var , fit=stats.norm);<br>    plt.title(var+<span class="hljs-string">&#x27; Tramsformed&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    _=stats.probplot(trans_var, plot=plt)<br>    plt.title(<span class="hljs-string">&#x27;skew=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stats.skew(trans_var)))<br>    plt.xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>        <br>    i+=<span class="hljs-number">1</span><br>    plt.subplot(frows,fcols,i)<br>    plt.plot(trans_var, dat[<span class="hljs-string">&#x27;target&#x27;</span>],<span class="hljs-string">&#x27;.&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    plt.title(<span class="hljs-string">&#x27;corr=&#x27;</span>+<span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.corrcoef(trans_var,dat[<span class="hljs-string">&#x27;target&#x27;</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><p><img src="/img/工业蒸汽预测-02数据探索/output_77_0.png" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习实战入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习07-强化学习</title>
    <link href="/2023/07/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A007-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A007-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="强化学习">强化学习</h1><p>强化学习是一种机器学习方法，它通过代理与环境的交互来学习如何做出最优决策。代理在不断尝试中获得奖励信号，并通过调整策略来最大化累积奖励。这种学习方式类似于人类通过试错来学习，帮助机器代理逐步提高在特定任务上的表现能力。</p><p>强化学习算法的思路非常简单，以游戏为例，如果在游戏中采取某种策略可以取得较高的得分，那么就进一步“强化”这种策略，以期继续取得较好的结果。这种策略与日常生活中的各种“绩效奖励”非常类似。</p><h1 id="离散状态空间">离散状态空间</h1><h2 id="示例火星探测器">示例：火星探测器</h2><p>探测器在火星执行探测任务，共有6个位置。在强化学习中，探测器的位置被称为状态，初始时，探测器位于状态4。 现在，位置1和位置6都有一些有趣的表面。科学家希望探测器对位置1进行采样，因为它比位置6更重要。但是位置1很远，所以我们通过奖励函数来反映状态的价值，在每个状态可以获得对应的奖励。状态1的奖励是100，状态6的奖励是40，其他状态的奖励都是0。在每一步中，探测器可以选择向左或向右移动。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721182005.png" /> 在每个位置，机器人都处于某种状态s，它可以选择一个动作a，并从而得到奖励R(s)，状态随动作变为新的状态s'。注意，奖励R(s)是与状态s相关，而不是下一个状态s'相关。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721182247.png" /> 例如，当探测器处于状态4，并采取了向左走的动作，状态4奖励为0，变为新的状态3。</p><p>强化学习四要素：<strong>状态、动作、奖励、下一个状态</strong></p><p>探测器在不同的位置可以走不同的路线，起点为位置4可以走4-3-2-1，也可以走4-5-6。较远的位置虽然奖励多，但是它所花费的时间和路程值得这些奖励吗？怎么知道一组特定的奖励比另一组不同的奖励更好还是更差?</p><p>我们用强化学习中的<strong>回报（Return）</strong> 来解决这件事。</p><h2 id="回报">回报</h2><p>基于折扣因子和奖励值，计算一系列动作下所获得的总效用值。折扣因子 <span class="math inline">\(\gamma\)</span> (Gamma)：取值范围在0到1之间，一般是一个非常接近1的数值。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721184441.png" /></p><p>得到的回报取决于奖励，而奖励取决于你采取的行动，因此回报取决于你采取的行动。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721185214.png" /></p><h2 id="策略">策略</h2><p>策略（policy）是指代理在特定状态下选择动作的方式或规则。策略定义了代理对于给定状态所做出的行为，就是一个从状态到行为的映射。我们可以通过策略来确定每个状态下的行为。</p><p>强化学习的目标是训练出一个策略函数，它以任意状态s为输入，并将其映射到采取的某个动作a。</p><p>例如可以有4种策略，以最后一种策略为例，右边是策略函数 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721194933.png" /></p><p>强化学习的目标是找到一个策略 <span class="math inline">\(\pi\)</span> ，告诉你在每个状态下采取什么行动以最大化回报。</p><h2 id="马尔可夫决策过程">马尔可夫决策过程</h2><p><strong>马尔可夫决策过程</strong>（Markov Decision Process, MDP），指未来仅取决于当前状态，而不取决于当前状态之前发生的任何事情。换句话说，在马尔可夫决策过程中，未来只取决于你现在所处的位置，而不取决于你是如何到达这里的。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721202150.png" /></p><p>根据目标当前状态 s，基于策略选择动作a，世界或环境会发生变化，然后观察基于世界状态，目标的状态s及得到的奖励R</p><h2 id="状态动作价值函数qsa">状态动作价值函数Q(s,a)</h2><p>状态动作价值函数 Q(s, a)（也称为 Q-value 函数）是在强化学习中用于评估在给定状态 s 下采取动作 a 的价值的函数。它表示了代理在特定状态下采取某个动作所能获得的预期累积回报。</p><p>具体而言，对于给定的状态动作对 (s, a)，Q(s, a) 表示从状态 s 开始，采取某一行动，之后一直按照最佳的策略行动，最终获得的预期累积回报。这个预期累积回报通常是通过累加未来奖励的折扣值来计算的。（至于为何能在获得最优策略前计算Q，后面会讲，会基于循环）。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721224150.png" /></p><p>例如： 计算Q（2，→），则为以状态2开始，采取向右的行动，到状态3，那后面最优策略是一直向左走，行动轨迹为2-3-2-1，所以计算Q为12.5。 Q（2，←）则为以状态2开始，采取某一行动为向左，行动轨迹为2-1，此时Q为50。</p><p>对每个状态，每个动作，都可计算得到Q。而且我们可以发现，Q(s,a)的最大值即为从状态s获得的最佳可能回报。因此当我们可以计算Q(s,a)，即可知道最佳的动作。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230721224959.png" /></p><p>如果你可以计算每一个状态每一个动作的Q(s,a)，然后找出最大的Q(s,a)，这个Q(s,a)中的a即为最佳的行动，所以该状态s的 <span class="math inline">\(\pi(s)=a\)</span> 。</p><p>因此，Q计算和策略相对应，如果能基于s和a计算Q函数，就能得到策略。</p><h2 id="贝尔曼方程">贝尔曼方程</h2><p>贝尔曼方程（Bellman equation）是强化学习中的关键方程，用来描述状态值函数或者状态动作值函数之间的递归关系。 <strong>贝尔曼方程</strong>：<span class="math inline">\(Q(s,a)=R(s)+\gamma\max_{a^{\prime}}Q(s^{\prime},a^{\prime})\)</span></p><p>贝尔曼方程通过将<strong>当前</strong>状态和动作的价值与<strong>下一个</strong>状态的价值联系起来，帮助我们计算最优策略。也就是说，贝尔曼方程告诉我们一个状态的价值如何与其后续状态的价值相关联。</p><p>贝尔曼方程的本质是，当前状态s的总回报包含两部分，一部分是马上得到的奖励R(s)，第二部分是 <span class="math inline">\(\gamma\)</span> 乘以下一状态s'的最佳总回报 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722101410.png" /> 例如从状态4开始，向左走： <span class="math display">\[\begin{aligned}&amp;Q(4,\leftarrow)\\&amp;=0+(0.5)0+(0.5)^20+(0.5)^3100\\&amp;=R(4)+(0.5)\begin{bmatrix}0+(0.5)0+(0.5)^2100\end{bmatrix}\\&amp;=R(4)+(0.5)\max_{a^{\prime}}Q(3,a^{\prime})\end{aligned}\]</span></p><p>实际上，贝尔曼方程告诉我们，在当前状态下采取某个动作的价值与下一个状态的价值之间存在一个关系。通过不断迭代更新这个关系，最终将能够找到最佳策略，即在每个状态下都选择可以获得最大预期回报的动作。 ## 随机马尔可夫决策</p><p>在随机马尔可夫过程中，执行动作a时，存在一定概率无法按照预期进行。以一个随机环境为例，我们向一个探测器发送左转指令，但由于未知的环境因素，左侧地面可能很滑，导致探测器滑向相反的方向，无法按照我们的指令执行。因此，我们获得的奖励也是随机的。</p><p>在随机强化学习问题中，目标的不是最大化回报，而是折扣奖励总和的平均值，即期望回报 <span class="math display">\[\begin{aligned}\text{Expected Return}&amp;=\text{Average}(R_1+\gamma R_2+\gamma^2R_3+\gamma^3R_4+\cdots)\\&amp;=\text{E}[R_1+\gamma R_2+\gamma^2R_3+\gamma^3R_4+\cdots]\end{aligned}\]</span></p><p>随机马尔可夫决策中，贝尔曼方程改为： <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722110235.png" /> 前面TensorFlow实例中，misstep_prob参数就表示失误概率。</p><h1 id="连续状态空间应用">连续状态空间应用</h1><p>例如在自动控制汽车、飞机中，状态s都是连续状态空间，包含x,y,z轴坐标，及各轴方向上速度、角速度等，这都是连续状态空间</p><h2 id="示例登月器">示例：登月器</h2><p>登月器的任务是在适当的时候启动火力推进，将其安全降落到着陆台上。</p><p><strong>状态：</strong> <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722112131.png" /> <span class="math inline">\(x\)</span> ：水平位置 <span class="math inline">\(y\)</span> ：垂直高度 <span class="math inline">\(\dot{x}\)</span> ：水平方向速度 <span class="math inline">\(\dot{y}\)</span> ：垂直方向速度 <span class="math inline">\(\theta\)</span> ：倾斜角，向左/右倾斜多少 <span class="math inline">\(\dot{\theta}\)</span> ：角速度 <span class="math inline">\(l\)</span> ：左脚落地 <span class="math inline">\(r\)</span> ：右脚落地</p><p><strong>动作：</strong> 什么都不做，向下加速，向左加速，向右加速</p><p><strong>奖励函数：</strong> <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722113031.png" /> 到达着陆台：100-140 靠近/远离着陆台的额外奖励 坠毁：-100 软着陆：+100 腿着陆：+10 启动主推进器：-0.3 启动侧推进器：-0.03</p><p><strong>目标</strong>是找到策略函数： <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722113530.png" /></p><h2 id="学习状态值函数强化学习中使用神经网络">学习状态值函数（强化学习中使用神经网络）</h2><p>关键思想是我们要训练一个神经网络来计算或近似S,a的状态动作值函数Q,然后上我们洗择好的动作</p><p>学习算法的核心是我们将训练一个神经网络，该网络输入当前状态和当前动作并计算或近似的Q 。 我们将状态和动作放在一起作为输入，这个12个数字的列表，8个数字用于状态，然后是个数字是动作的单热编码。这是我们对神经网络的输入，称之为X。神经网络的工作就是输出Q。</p><p>因为我们稍后会使用神经网络训练算法，所以我还将Q作为训练神经网络逼近的目标值Y。强化学习与监督学习不同，但我们要做的不是输入状态并让它来输出动作。我们要做的是输入一个状态动作对，让它尝试输出Q,并在强化学习算法中使用神经网络。</p><p><img src="/img/机器学习07-强化学习/Pasted%20image%2020230722183834.png" /> 如果您可以在隐藏层和上层中选择适当的参数来训练神经网络，以便为您提供对Q的良好估计，那么每当您在月球着陆器处于某种状态s时，您就可以使用神经网络计算Q。对于所有四个动作，都可以计算Q，Q(s,nothing),Q(s,left),Q(s,main),Q(s,right)，最后，哪个具有最高值，就选择那个相应的动作。 例如，如果在这四个值中，Q(s,main)最大，那么将启动着陆器的主推进器。</p><p>所以问题就变成了，如何训练一个神经网络来输出Q?</p><p>方法是使用贝尔曼方程来创建包含大量示例×和y的训练集，然后我们使用监督学习，就像神经网络时所学的一样。使用监督学习，利用神经网络学习从x到y的映射，即从状态动作对到目标值Q的映射。</p><p>但是，如何获得具有x和y值的训练集，可以在其上训练神经网络？</p><p>这是贝尔曼方程：<span class="math inline">\(Q(s,a)=R(s)+\gamma\max_{a^{\prime}}Q(s^{\prime},a^{\prime})\)</span> 。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722185112.png" />我们将等式右边的值为神经网络的输出y，等式左边即为输入x。神经网络的工作是输入x，即输入状态动作对，并尝试准确预测右边的值。</p><p>在监督学习中，我们训练一个神经网络来学习一个函数f，它取决于参数W和B（神经网络各个层的参数），神经网络的最左端输入X，最右端放一些接近目标值y的东西。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722185443.png" /> 问题是，我们如何才能为新网络提供一个具有x和y的训练集来学习？</p><p>我们将使用着陆器，并尝试在其中随机执行不同的操作。通过在月球着陆器中尝试做不同的动作，我们将会得到很多例子，这些例子说明我们何时处于哪种状态并采取了哪些动作，可能是一个好的动作，也可能是一个坏的动作。然后，由于处于该状态，我们获得了一些奖励R(s)，接着，我们进入了某个新状态S'。<span class="math inline">\((s,a,R(s),s^{\prime})\)</span> 我们称为元组。</p><p><img src="/img/机器学习07-强化学习/Pasted%20image%2020230722190456.png" /></p><p>例如，也许有一次处于某个状态 <span class="math inline">\(S^{(1)}\)</span>，采取了动作 <span class="math inline">\(a^{(1)}\)</span> ，得到了奖励 <span class="math inline">\(R(S^{(1)})\)</span> ，达到了个新状态 <span class="math inline">\(S^{\prime(1)}\)</span> ； 也许在不同的时间处于某个状态 <span class="math inline">\(S^{(2)}\)</span>，采取了动作 <span class="math inline">\(a^{(2)}\)</span> ，得到了奖励 <span class="math inline">\(R(S^{(2)})\)</span> ，达到了个新状态 <span class="math inline">\(S^{\prime(2)}\)</span> ；以此类推 。 也许你已经这样做了10,000次甚至超过10,000次。这10,000个元组都是训练示例x，y。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722191729.png" /> 元组中的前两个将用于计算x，后两个将用于计算y。 例如，<span class="math inline">\(x^1\)</span> 就是 <span class="math inline">\(x^{(1)}=(s^{(1)},a^{(1)})\)</span> ；<span class="math inline">\(y^1\)</span> 将使用贝尔曼方程的右侧计算。 贝尔曼方程表示，当您输入 <span class="math inline">\(s^{(1)},a^{(1)}\)</span> 时，希望 <span class="math inline">\(Q(s^{(1)},a^{(1)})=R(s^{(1)})+\gamma\max_{a^{\prime}}Q(s^{\prime(1)},a^{\prime})\)</span> 。<span class="math inline">\(y^1\)</span> 即等于 <span class="math inline">\(R(s^{(1)})+\gamma\max_{a^{\prime}}Q(s^{\prime(1)},a^{\prime})\)</span> 。注意，元组最后的两个元素提供了足够的信息来计算右侧，计算后这将是数字，比如12.5或17。 我们将数字保存为 <span class="math inline">\(y^1\)</span> 。这对 <span class="math inline">\(x^1,y^1\)</span> 成为了第一个训练示例。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722193800.png" /> 现在你可能想要知道 <span class="math inline">\(Q(s^{\prime(1)},a^{\prime})\)</span> 从哪里来，其实我们最初并不知道 <span class="math inline">\(Q(s^{\prime(1)},a^{\prime})\)</span> 是什么，但是当不知道Q函数是什么时，可以随机猜测一个初始值。刚开始这里的每一步Q都只是一些猜测，随着时间的推移，他们会变得更好，慢慢的逼近实际的Q函数值。</p><p>依此类推，直到你最终得到10,000个包含这些x,y对的训练示例。稍后，我们将采用这个训练集，其中x是具有12个特征的输入，而y只是数字。 我们将使用均方误差损失来训练一个新网络，以尝试将y预测为输入x的函数。</p><p>以上描述的只是我们将使用的算法的一部分，接下来看看它们是如何组合成一个学习Q函数的完整算法的。</p><p>首先，我们将采用我们的神经网络并随机初始化神经网络的所有参数。最初我们不知道Q函数是什么，我们只是完全随机的赋值。我们假设这个神经网络是我们对Q函数的初始随机猜测。这有点像你在训川练线性回归时随机初始化所有参数，然后使用梯度下降来改进参数。现在随机初始化没关系。重要的是算法是否可以慢慢改进参数以获得更好的估计。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722203836.png" /> 接下来，我们将重复执行以下操作；我们将对着陆器中采取动作，然后得到众多元组 <span class="math inline">\((s,a,R(s),s^{\prime})\)</span> ， 我们要做的是存储这些元组的10,000个最新示例。当你运行这个算法时，你会看到着陆器有很多步骤，可能有几十万个步骤。为了确保我们最终不会使用过多的计算机内存，通常的做法是只记住我们在 MDP中看到的10,000个最近的此类元组。这种仅存储最近示例的技术在强化学习算法中称为回放缓冲区。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722203905.png" /> 日前，我们只是让月球着陆器随机飞行，有时会坠毁，有时不会坠毁，并根据学习算法经验获取这些元组。</p><p>有时我们会训练神经网络，为了训练神经网络，下面是我们要做的。</p><p>我们将查看我们保存的这10,000个最近的元组，并创建一个包含10,000个示例的训练集。 训练集需要很多对x和y。对于我们的训练示例，x将是s来自元组的 <span class="math inline">\((s,a)\)</span> 这一部分。我们希望神经网络尝试预测的目标值是 <span class="math inline">\(\mathbf{y}=R(s)+\:\gamma\max_{a^{\prime}}Q(s^{\prime},a^{\prime})\)</span> 。我们如何获得Q的这个值？最初是我们随机初始化的这个神经网络，是一个猜测值。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722204559.png" /> 创建这10,000个训练示例后，我们将拥有训练示例 <span class="math inline">\(x^1\)</span> 、<span class="math inline">\(y^1\)</span> 到 <span class="math inline">\(x^{10,000}\)</span> 、<span class="math inline">\(y^{10,000}\)</span> 。我们将训练一个神经网络，我将把新的神经网络称为Qnew,这样 <span class="math inline">\(Q_{new}(s,a)\approx y\)</span> 。这正是训练那个神经网络 <span class="math inline">\(f_{W,B}(x)\approx y\)</span> 。现在，这个神经网络应该稍微更好地估计Q函数是什么，接着我们要做的是将Q设置为我们刚刚学习的新神经网络 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722210052.png" /> 事实证明，如果您从真正随机猜测Q函数开始运行此算法，然后使用Bellman方 Set-new.程反复尝试改进Q函数的估计值。,9然后通过反复执行此操作，采取大量操作，训川练模型，这将改进您对Q函数的猜 Set-new. Jw,BX)XU测.,9对于您训川练的下一个模型，您现在对什么是Q函数有了更好的估计。那么你训练的下一个模型会更好当您更新Q等于Qnew时。然后下次训练 <span class="math inline">\(Q(s^{\prime},a^{\prime})\)</span> 时，将是一个更好的估计值。</p><p>当你在每次迭代中运行这个算法时，<span class="math inline">\(Q(s^{\prime},a^{\prime})\)</span> 有望成为Q函数的更好估计，这样当你运行算法足够长的时间时，这个估计值会越来越接近真实值，这样你就可以用它来挑选，希望是好的动作或 MDP。</p><p>这个算法称为DQN算法（Deep Q-Network），因为使用深度学习和神经网络训练模型来学习Q函数。</p><h2 id="算法改进改进的神经网络架构">算法改进：改进的神经网络架构</h2><p>改进前，神将网络只能输出一个值，要分别计算4次Q，Q(s,nothing),Q(s,left),Q(s,main),Q(s,right)各一次 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722213200.png" /></p><p>改进后，神经网络可以同时输出四个值，会更加有效，且更方便选择最大值，可直接用于贝尔曼方程计算 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722213230.png" /></p><h2 id="算法改进epsilon-greedy-策略">算法改进：Epsilon Greedy 策略</h2><p>ε-greedy策略是一种在强化学习中常用的策略，用于在探索（exploration）和利用（exploitation）之间进行权衡。该策略基于一个参数ε，用来决定代理在<strong>选择动作时</strong>是进行<strong>随机探索</strong>还是根据当前已学习的知识做出<strong>最优动作</strong>的利用。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722215349.png" /></p><p>在强化学习中，ε-贪婪策略（方法2）是更常用的方法。在大多数情况下，我们选择使当前的Q(s, a)（神经网络训练出来的）最大化的动作a，即贪婪行动。只有在极少数情况下（偶尔）会随机选择动作，即探索行动。</p><p>方法1容易出现问题，因为由于随机初始化的原因，可能始终不会尝试一些动作，而这些动作可能会效果很好。为了解决这个问题，我们采用方法2，即使用ε-贪婪策略，对所有动作进行尝试。</p><p>当ε=0.05时，贪婪动作占95%，探索动作占5%。</p><p>通常，在学习刚开始时，我们将ε设置得较大，这样代理会频繁地选择随机动作，然后逐渐减小ε的值，因此随着时间的推移，代理不太可能随机采取行动，而更有可能根据Q函数来选择最优的动作。</p><p>在强化学习中，参数的选择非常关键，不合适的参数选择可能导致训练时间非常非常慢。</p><h2 id="算法改进小批量和软更新">算法改进：小批量和软更新</h2><p>小批量（mini-batches）可以提高算法运行速度，同样适用于监督学习，例如训练神经网络，或训练线性回归或逻辑回归模型。 软更新（soft updates）可以使强化学习更好的收敛</p><h3 id="小批量">小批量</h3><p>小批量是指在训练模型时，将训练数据划分为多个较小的批次进行模型参数的更新。相比于使用完整的训练集进行参数更新，小批量更新可以提高计算效率，并且有助于减少参数更新的方差。</p><p>当样本数量非常大时，例如有一亿个样本，如果梯度下降的每一步都需用全部样本计算平均值，那么算法会运行的很慢。使用小批量是每次梯度下降时，只关注一个batch的数据。使用小批量梯度下降的思想是不用再每次迭代中使用1亿个示例，而是选择一个较小的数，如1000，这将花费较少的时间。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722221956.png" /></p><p>小批量梯度下降很容易在迭代时向着错误的方向前进，不可靠且有点嘈杂。但会趋向于全局最小值，每次迭代的计算成本要低得多，因此小批量梯度下降可以提高算法运行速度。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722222116.png" /></p><p>在强化学习中同样可以应用mini-batch，如虽然缓冲存储区中有10000个样本元组，但每次训练神经网络模型时可以只选取1000个（一个batch）来进行训练</p><p><img src="/img/机器学习07-强化学习/Pasted%20image%2020230722223649.png" /></p><h3 id="软更新">软更新</h3><p>软更新是指在深度强化学习的策略网络和目标网络之间进行参数更新时，采用一种平滑的更新方式。</p><p>在软更新中，每次更新时只更新一小部分的策略网络参数，而不是完全替换目标网络的参数。这样可以缓解训练过程中目标网络参数的剧烈变化，使得网络更新更加稳定，更好的收敛。</p><p>软更新通常使用一个超参数τ来控制更新的幅度，即通过对新参数和旧参数进行加权平均来更新目标网络的参数。 <img src="/img/机器学习07-强化学习/Pasted%20image%2020230722223002.png" /></p><h1 id="强化学习发展现状">强化学习发展现状</h1><ul><li>强化学习在模拟状态实现要比真实状态实现容易很多</li><li>应用要比监督学习和无监督学习少很多</li><li>前景很大，是机器学习的支柱之一</li></ul><p><img src="/img/机器学习07-强化学习/Pasted%20image%2020230722223249.png" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习06-推荐系统</title>
    <link href="/2023/07/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A006-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/07/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A006-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="基于内容的推荐算法">基于内容的推荐算法</h1><p>假设您经营一家大型电影流媒体网站，用户使用一到五颗星对电影进行评级，请预测用户未看过的电影可能给出的评分。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230717185300.png" /> <span class="math inline">\(n_u\)</span> ：用户数量 <span class="math inline">\(n_m\)</span> ：电影数量 <span class="math inline">\(r(i,j)\)</span> = 1 ：第j个用户对 第i个电影做出评价 <span class="math inline">\(y^{(i,j)}\)</span> ：当 <span class="math inline">\(r(i,j)\)</span> = 1时，第j个用户对第i个电影的评分</p><p>假设每一部电影都有一个特征集X，n表示特征数量，<span class="math inline">\(x_1\)</span> 衡量一部电影为爱情片的程度，<span class="math inline">\(x_2\)</span> 衡量一部电影为动作片的程度，例如 <span class="math inline">\(x^{(1)}=\begin{bmatrix}0.9\\0\end{bmatrix}\)</span> <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230717202336.png" /> 我们可以把每一个用户的预测评价值当做线性回归问题。对于每个用户 j，需要学习参数 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> , 之后便可用 <span class="math inline">\(w · x^{(i)} + b\)</span> 预测用户 j 对电影 i 的评分。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230717202958.png" /></p><p>例如，预测用户 1 对电影 3 的评分，假设模型各参数为<span class="math inline">\(\mathbf{w}^{(1)}=\begin{bmatrix}5\\0\end{bmatrix} \quad b^{(1)}=0\quad\mathbf{x}^{(3)}=\begin{bmatrix}0.9\\0\end{bmatrix}\)</span> ，则有 <span class="math inline">\(\mathbf{w}^{(1)}\cdot\mathbf{x}^{(3)}+\mathbf{b}^{(1)}=4.95\)</span></p><p>一般的，用户j对电影i的评分为：<span class="math inline">\(\mathbf{w^{(j)}\cdot x^{(i)}+b^{(j)}}\)</span></p><h2 id="成本函数">成本函数</h2><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230717204317.png" /> 其中，<span class="math inline">\(\sum_{i:r(i,j)=1}\)</span> 表示仅对<span class="math inline">\(r(i,j)\)</span> = 1 的值求和。使用正则化后的代价函数为： <span class="math display">\[\min_{w^{(j)}b^{(j)}}{J}(w^{(j)},b^{(j)})=\frac{1}{2m^{(j)}}\sum_{i:r(i,j)=1}(w^{(j)}\cdot x^{(i)}+b^{(j)}-y^{(i,j)})^{2} +\frac{\lambda}{2m^{(j)}}\sum_{k=1}^{n}\left(w_{k}^{(j)}\right)^{2}\]</span> 为了使式子更简单，可以去掉 <span class="math inline">\(\frac{1}{2m^{(j)}}\)</span> 中的 <span class="math inline">\(m^{(j)}\)</span> ，去掉后值不变。</p><p>对所有的用户： <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230717210141.png" /></p><h1 id="预测电影特征">预测电影特征</h1><p>基于内容的推荐算法要求取得每部电影的特征值，然而这是很难的。对此，有另外一种算法无需取得特征值，而只要根据用户的爱好矩阵 便可预测出用户对电影的评分。</p><p>在之前的基于内容的推荐系统中，对于每一部电影，我们都掌握了可用的特征，比如衡量一部电影为爱情片的程度、动作片的程度，使用这些特征训练来出每一个用户的参数。相反地，如果我们拥有用户的参数，我们可以学习得出电影的特征。</p><p>假设拥有所有四个用户的参数，如下，进而我们可以求出电影的特征 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719165153.png" /></p><h2 id="成本函数-1">成本函数</h2><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719165851.png" /> 一部电影特征的成本函数： <span class="math display">\[J(x^{i})=\frac{1}{2}\sum_{j:r(i,j)=1}(w^{(j)}\cdot x^{(i)}+b^{(j)}-y^{(i,j)})^2+\frac{\lambda}{2}\sum_{k=1}^{n}\left(x_k^{(i)}\right)^2\]</span> 所有电影特征的成本函数： <span class="math display">\[J\left(x^{(1)},x^{(2)},...,x^{(n_m)}\right)=\frac12\sum_{i=1}^{n_m}\sum_{j:r(i,j)=1}\left(w^{(j)}\cdot x^{(j)}+b^{(j)}-y^{(i,j)}\right)^2+\frac\lambda2\sum_{i=1}^{n_m}\sum_{k=1}^n\left(x_k^{(i)}\right)^2\]</span></p><h1 id="协同过滤算法">协同过滤算法</h1><p>目前我们都是在假设已有用户参数的基础上来预测电影特征的，但是这些参数从哪里得到呢？我们将基于内容的推荐算法（学习w和b）和预测电影特征算法（学习x）结合在一起，这就是协同过滤算法 。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719171626.png" /></p><p>上面是逐列遍历矩阵中非零元素，下面试逐行遍历矩阵中非零元素 ## 成本函数 <span class="math display">\[\min_{b^{(1)},...,b^{(n_{u})}}J(w,b,x)=\frac{1}{2}\sum_{(i,j):r(i,j)=1}\left(w^{(j)}\cdot x^{(j)}+b^{(j)}-y^{(i,j)}\right)^{2}+\frac{\lambda}{2}\sum_{j=1}^{n_{u}}\sum_{k=1}^{n}\left(w_{k}^{(j)}\right)^{2}+\frac{\lambda}{2}\sum_{i=1}^{n_{m}}\sum_{k=1}^{n}\left(x_{k}^{(j)}\right)^{2}\]</span></p><h2 id="梯度下降">梯度下降</h2><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719173253.png" /></p><p>在协同过滤中，是因为有多个用户评价同一部电影，了解这部电影可能是什么样子，所以可以预测出电影特征。</p><h2 id="推广至二进制标签收藏喜欢和点击">推广至二进制标签：收藏、喜欢和点击</h2><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719181259.png" /></p><h1 id="均值归一化">均值归一化</h1><p>让我们来看下面的用户评分数据： <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719183211.png" /> 如果我们新增一个用户 <strong>Eve</strong>，并且 <strong>Eve</strong> 没有为任何电影评分，那么我们以什么为依据为<strong>Eve</strong>推荐电影呢？ 如果这个数据集上运行算法，会得到Eve的参数为<span class="math inline">\(w^{(5)}=\begin{bmatrix}0\\0\end{bmatrix}\quad b^{(5)}=0\)</span> ，预测结果都为0。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719183617.png" /> 因此，如果有一个尚未对任何内容进行评分的新用户，算法会认为他们会对所有电影都是零星评分，这样的预测并不是非常合理的。</p><p>因此，我们将使用<strong>均值归一化</strong>帮助该算法为尚未对任何电影进行评级的新用户更好地预测电影评级。</p><p>我们首先需要对结果矩阵进行均值归一化处理，将每一个用户对某一部电影的评分减去所有用户对该电影评分的平均值： <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719184019.png" /> 然后我们利用这个新的 矩阵来训练算法。 如果我们要用新训练出的算法来预测评分，则需要将平均值重新加回去，预测<span class="math inline">\(w^{(j)}\cdot x^{(i)}+b^{(j)}+\mu_i\)</span> 对于<strong>Eve</strong>，我们的新模型会认为她给每部电影的评分都是该电影的平均分。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230719184250.png" /></p><p>均值归一化使算法更快，更重要的是，当用户评价的电影很少甚至根本没有电影时，它可以让算法给出更好、更合理的预测。</p><h1 id="寻找相关特征">寻找相关特征</h1><p>当你浏览一些电影时，平台会给你推荐一些相似的电影，这是如何做到的？</p><p>使用算法学习出电影的特征 <span class="math inline">\(X^i\)</span> ，要是想要找出其他与 <span class="math inline">\(X^i\)</span> 相似的电影，即尝试找到具有特征 <span class="math inline">\(X^k\)</span> 的电影，并且 <span class="math inline">\(X^k\)</span> 类似于 <span class="math inline">\(X^i\)</span> 。我们用以下方法确定电影特征之间的相似程度： <span class="math display">\[\sum_{l=1}^n\left(x_l^{(k)}-x_l^{(i)}\right)^2\]</span> <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230720175911.png" /> # 协同过滤的局限性 1. 冷启动问题。如何解决 - 对很少有用户评价的新项目进行排名？ - 向对很少项目进行评分的新用户显示一些合理的内容？</p><ol start="2" type="1"><li>使用有关电影或用户的辅助信息：<ul><li>电影：类型、电影明星、工作室 ...</li><li>用户：人口统计数据（年龄、性别、地点）、偏好 ...</li></ul></li></ol><h1 id="基于内容的协同过滤">基于内容的协同过滤</h1><h2 id="协同过滤vs基于内容的协同过滤">协同过滤VS基于内容的协同过滤</h2><p>协同过滤： - 根据与你评分相近的用户的评分向你推荐商品</p><p>基于内容的协同过滤： - 根据用户和物品的特征向您推荐物品，找到合适的匹配</p><h2 id="用户和项目特性示例">用户和项目特性示例</h2><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230720183819.png" /></p><p>用户特征和电影特征的大小可能会有很大的差距。例如，用户特征可能会有1500个，而电影特征可能只会有50个。</p><h2 id="匹配用户和电影">匹配用户和电影</h2><p>之前我们用 <span class="math inline">\(w^{(j)}\cdot x^{(i)}+b^{(j)}\)</span> 来预测用户j对电影i的评分，在此，我们用 <span class="math inline">\(V_u^J\cdot V_m^i\)</span> 来预测用户j对电影i的评分。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230720184516.png" /> <span class="math inline">\(b\)</span> ：去掉b不会影响算法性能 <span class="math inline">\(V_u^J\)</span> ：代表向量，是根据用户j的特征 <span class="math inline">\(X_u^j\)</span> 计算的数字列表，下标u代表用户 <span class="math inline">\(V_m^i\)</span> ：代表向量，是根据电影i的特征 <span class="math inline">\(X_m^i\)</span> 计算的数字列表，下标m代表电影</p><p>例如，<span class="math inline">\(\mathbf{V_u}=\begin{bmatrix}4.9\\0.1\\\vdots\\3.0\end{bmatrix}\)</span> ，第一个数字代表用户对爱情电影的喜爱程度，第二个代表对动作电影的喜爱程度；<span class="math inline">\(\mathrm{Vm}=\begin{bmatrix}4.5\\0.2\\\vdots\\3.5\end{bmatrix}\)</span> ，第一个数字表示电影包含爱情片元素的程度，第二个表示包含动作片元素的程度。<span class="math inline">\(V_u\cdot V_m\)</span> 进行点积即可了解用户对该电影的喜爱程度。</p><p>点积需要<span class="math inline">\(V_u\)</span> 和 <span class="math inline">\(V_m\)</span> 有相同的维度，比如都需要有32个数字。但是，<span class="math inline">\(V_u\)</span> 和 <span class="math inline">\(V_m\)</span> 是根据用户特征<span class="math inline">\(X_u^j\)</span> 和电影特征<span class="math inline">\(X_m^i\)</span> 计算来的，用户特征和电影特征不一定有相同大小。</p><p>总而言之，在协同过滤中，我们有许多用户对不同的项目进行评分。在基于内容的过滤中，我们有用户的特征和项目的特征，我们想找到一种方法来找到用户和项目之间的良好匹配。</p><h2 id="基于内容过滤的深度学习方法">基于内容过滤的深度学习方法</h2><p>我们给定用户特征<span class="math inline">\(X_u^j\)</span> 和电影特征<span class="math inline">\(X_m^i\)</span> ，计算向量<span class="math inline">\(V_u\)</span> 和 <span class="math inline">\(V_m\)</span> 最好的办法是利用神经网络。</p><p>我们将用户特征<span class="math inline">\(X_u^j\)</span> 和电影特征<span class="math inline">\(X_m^i\)</span> 作为输入，将<span class="math inline">\(V_u\)</span> 和 <span class="math inline">\(V_m\)</span> 作为输出，最后计算<span class="math inline">\(V_u\cdot V_m\)</span> 。 <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230720201025.png" /> 需要注意的是，用户网络和电影网络输出层的神经元个数需要相同，中间的隐藏层可以不同。</p><p><span class="math inline">\(V_u\cdot V_m\)</span> 最终计算出的是1-5或0-5星的电影评级，如果我们有二进制标签，y表示用户喜欢或不喜欢某个项目，可以将sigmod函数应用于<span class="math inline">\(V_u\cdot V_m\)</span> 得出标签为1的概率。<span class="math inline">\(g(v_u\cdot v_m)\mathrm{~to~predict~the~probability~that~y^{(i,j)}~is~1}\)</span></p><p>我们也可以将用户网络和电影网络合成一个神经网路，最终直接计算出预测值： <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230720202033.png" /></p><p>现在，这个模型有很多参数，神经网络的每一层都有一组神经网络参数。那么如何训练用户网络和电影网络的所有参数？我们要做的是构建一个成本函数J。 <span class="math display">\[J=\sum_{(i,j):r(i,j)=1}\left(v_{u}^{(j)}\cdot v_{m}^{(i)}-y^{(i,j)}\right)^2+\text{NN regularization term}\]</span> 我们将神经网路算出来的参数 <span class="math inline">\(V_u\)</span> 和 <span class="math inline">\(V_m\)</span> 带入成本函数中的 <span class="math inline">\(v_{u}^{(j)}\)</span> 和<span class="math inline">\(v_{m}^{(i)}\)</span> ，来评价该模型的好坏，进而用梯度下降或其他优化算法来调整神经网络的参数，还可以添加神经网络的正则化项 <code>NN regularization term</code> 来防止过拟合。</p><p>当训练完这个神经网络后，也可以用它来寻找相似的电影：</p><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230720203458.png" /></p><p>目前该算法的一个局限性是，如果您有大量可能想要推荐的不同电影的大目录，那么运行它的计算成本可能非常高。</p><h2 id="从大型目录中推荐">从大型目录中推荐</h2><p>如果要推荐数百万、数千万甚至更多的电影时，如何使算法运行的更高效。 实现为两个步骤，称为检索和排名步骤。 在检索步骤中生成大量可能的项目候选列表，试图涵盖可能向用户推荐的许多可能的东西。如果候选列表中包含很多用户可能不太喜欢的项目，那么在排名步骤中将微调并选择最好的项目推荐给用户。</p><h3 id="检索">检索</h3><ul><li><p>生成大量可能的候选项目列表 （1）对于用户最近观看的 10 部电影中的每一部电影，查找 10 部最相似的电影 （2）对于观看次数最多的 3 个类型，查找排名前 10 的电影 （3）国内排名前20的电影</p></li><li><p>将检索到的项目合并到列表中，删除重复项和已观看/购买的项目</p></li></ul><p>检索步骤的目标是确保广泛的覆盖范围，以便有足够的电影至少有很多好电影</p><h3 id="排名">排名</h3><ul><li>获取检索到的列表，并使用模型进行排名（把用户特征向量和电影特征向量输入到神经网络中）</li><li>向用户显示排名的项目</li></ul><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230721105951.png" /> <img src="/img/机器学习06-推荐系统/Pasted%20image%2020230721110025.png" /></p><p>检索更多项目会带来更好的性能，但推荐速度会更慢。 要分析/优化权衡，请进行离线实验，看看检索其他项目是否会产生更相关的推荐。</p><p>但是通过单独的检索步骤和排名步骤，能使许多推荐系统能够提供快速和准确的结果。因为检索步骤试图剪掉很多不值得做的更详细的项目，然后排名步骤对用户实际可能喜欢的项目进行更仔细的预测。否则需要对所有的项目进行非常详细的预测。</p><h2 id="基于内容过滤的tensorflow实现">基于内容过滤的TensorFlow实现</h2><p><img src="/img/机器学习06-推荐系统/Pasted%20image%2020230721102308.png" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习05-无监督学习</title>
    <link href="/2023/07/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A005-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A005-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="聚类clustering">聚类（Clustering）</h1><p>聚类算法查看大量数据点并自动找到彼此相关或相似的数据点。</p><h2 id="k-means">K-means</h2><p>首先做的是随机初始化集群中心的位置，集群中心称为簇质心（Cluster centroids）。 <img src="/img/5无监督学习/Pasted%20image%2020230716102103.png" /></p><p>接着，重复做两件事，第一个是将点分配给簇质心，第二个是移动簇质心</p><p>第一步：遍历这些点中的每一个，并查看它是更接近红十字还是更接近蓝十字。然后把这些点分配给它更接近的簇质心。 <img src="/img/5无监督学习/Pasted%20image%2020230716102808.png" /></p><p>第二步：查看所有的红点并取它们的平均值。并将红十字移动到红点的平均位置，称为新的簇质心位置。蓝色同理。 <img src="/img/5无监督学习/Pasted%20image%2020230716102923.png" /></p><p>重复第一步：遍历每一个点并分配。 <img src="/img/5无监督学习/Pasted%20image%2020230716103250.png" /></p><p>接着重复第二步：移动簇质心。 <img src="/img/5无监督学习/Pasted%20image%2020230716103433.png" /></p><p>一直重复这两个步骤，直到簇质心的位置没有变化，此时K均值聚类算法已经收敛。 <img src="/img/5无监督学习/Pasted%20image%2020230716103559.png" /></p><h2 id="k-means算法">K-means算法</h2><p><strong>第一步：将点分配给簇质心</strong> <img src="/img/5无监督学习/Pasted%20image%2020230716123812.png" /> K:共K个聚类中心 <span class="math inline">\(\mu_{1},\mu_{2},\ldots,\mu_{K}\)</span> <span class="math inline">\(c^{(i)}\)</span> = 最接近<span class="math inline">\(x^{(i)}\)</span>的聚类中心点的索引(从1到K) 例如：点<span class="math inline">\(x^{(1)}\)</span> 离聚类中心 <span class="math inline">\(\mu_{1}\)</span> 最近，则<span class="math inline">\(c^{(i)}\)</span> = 1</p><p><strong>第二步：移动簇质心</strong> <img src="/img/5无监督学习/Pasted%20image%2020230716124031.png" /></p><p><span class="math inline">\(\mu_k\)</span> = 分配给群组k的点的平均值</p><h2 id="k-means的成本函数">K-means的成本函数</h2><p><span class="math inline">\(\mu_{C^{(i)}}\)</span> = 示例<span class="math inline">\(x^{(i)}\)</span>所在群组的聚类中心点 <span class="math display">\[J\big(c^{(1)},...,c^{(m)},\mu_1,...,\mu_K\big)=\frac{1}{m}\sum_{i=1}^{m}\big\Vert x^{(i)}-\mu_{c^{(i)}}\big\Vert^2\]</span> m表示训练样本的数量。</p><p><strong><span class="math inline">\(\mu_k\)</span> 和<span class="math inline">\(\mu_{C^{(i)}}\)</span> 区别：</strong> <span class="math inline">\(\mu_k\)</span>表示第k个群组的聚类中心点，即将该群组中所有分配给该群组的点<span class="math inline">\(x^{(i)}\)</span>的平均值作为新的聚类中心点。<span class="math inline">\(\mu_k\)</span>的计算方式是通过对属于第k个群组的所有数据点的均值来获得。</p><p>而<span class="math inline">\(\mu_{C^{(i)}}\)</span>表示示例<span class="math inline">\(x^{(i)}\)</span>所在群组的聚类中心点，是通过将<span class="math inline">\(x^{(i)}\)</span>分配给最近的聚类中心点得到的。<span class="math inline">\(\mu_{C^{(i)}}\)</span>和<span class="math inline">\(\mu_k\)</span>具有相同的含义，只是对应于不同的数据点。<span class="math inline">\(\mu_{C^{(i)}}\)</span>是根据每个数据点<span class="math inline">\(x^{(i)}\)</span>的分配结果得到的，而<span class="math inline">\(\mu_k\)</span>是根据整个群组的数据点求取均值得到的。</p><p>因此，<span class="math inline">\(\mu_{C^{(i)}}\)</span>和<span class="math inline">\(\mu_k\)</span>在K-means算法中都用于表示聚类中心点，只是对应于不同的数据点和群组。<span class="math inline">\(\mu_{C^{(i)}}\)</span>表示一个特定的数据点的聚类中心点，而<span class="math inline">\(\mu_k\)</span>表示整个群组的聚类中心点。</p><h2 id="如何初始化簇质心">如何初始化簇质心</h2><p>随机选择样本点作为初始簇质心 <img src="/img/5无监督学习/Pasted%20image%2020230716165659.png" /></p><p>只选择一次的话容易陷入局部最优 <img src="/img/5无监督学习/Pasted%20image%2020230716165753.png" /></p><p>多次选择样本点作 为簇质心，最终选择出成本函数最小的那一个 <img src="/img/5无监督学习/Pasted%20image%2020230716170122.png" /></p><h2 id="选择聚类数量k">选择聚类数量K</h2><p>Elbow method: <img src="/img/5无监督学习/Pasted%20image%2020230716171545.png" /></p><p>对于将T恤分成三个尺码，还是五个尺码，需要考虑成本和利润之间的关系，五个尺码可能挣得更多，但是成本更大。 <img src="/img/5无监督学习/Pasted%20image%2020230716171828.png" /></p><h1 id="异常检测anomaly-detection">异常检测（Anomaly detection）</h1><p>异常检测（Anomaly Detection）是一种用于识别和监测数据中异常、异常行为或异常模式的技术。它可以帮助我们在大量数据中自动发现那些与正常行为或模式不同的数据点。</p><p>检测制造的飞机发动机是否存在问题，为了简化问题，我们以发动机运行的温度、震动频率作为特征。当新引擎的参数落在中间一堆时，发动机正常，当落在外围时有很大概率存在问题。 <img src="/img/5无监督学习/Pasted%20image%2020230716173246.png" /></p><p>执行异常检测的最常见方法是通过密度估计的技术。 <img src="/img/5无监督学习/Pasted%20image%2020230716174016.png" /></p><h2 id="高斯分布">高斯分布</h2><p><img src="/img/5无监督学习/Pasted%20image%2020230716174647.png" /></p><p>对于只有一个特征时，将其应用于异常检测，就是要找到参数 <span class="math inline">\(\mu\)</span> 和 <span class="math inline">\(\sigma^2\)</span> 的合适取值 <img src="/img/5无监督学习/Pasted%20image%2020230716175138.png" /></p><h2 id="异常检测算法">异常检测算法</h2><p><img src="/img/5无监督学习/Pasted%20image%2020230716193942.png" /></p><p>共有m个样本，n个特征，对每一个特征求平均值 <span class="math inline">\(\mu\)</span> 和方差 <span class="math inline">\(\sigma^2\)</span> 。</p><p><span class="math inline">\(\mu_j\)</span> : 第j个特征的平均值 <span class="math inline">\(\sigma_j^2\)</span> : 第j个特征的方差 <span class="math inline">\(p(x)\)</span> : 假定每一个特征 <span class="math inline">\(x_{1}\)</span> 到 <span class="math inline">\(x_{n}\)</span> 均服从正态分布，则其模型的概率为： <span class="math display">\[\begin{aligned}p(x)&amp; =p(x_{1};\mu_{1},\sigma_{1}^{2})p(x_{2};\mu_{2},\sigma_{2}^{2})\cdotp\cdotp\cdotp p(x_{n};\mu_{n},\sigma_{n}^{2})  \\&amp;=\prod_{j=1}^{n}p(x_{j};\mu_{j},\sigma_{j}^{2}) \\&amp;=\prod_{j=1}^{n}\frac{1}{\sqrt{2\pi}\sigma_{j}}exp(-\frac{(x_{j}-\mu_{j})^{2}}{2\sigma_{j}^{2}})\end{aligned}\]</span></p><p>举例： 假定我们有两个特征，它们都服从于高斯分布，并且通过参数估计，我们知道了分布参数： <img src="/img/5无监督学习/Pasted%20image%2020230716202208.png" /> 将 <span class="math inline">\(p(x_1;\mu_1,\sigma_1^2)\)</span> 和 <span class="math inline">\(p(x_2;\mu_2,\sigma_2^2)\)</span> 相乘后会得到上图左下角的三维曲面图 <span class="math inline">\(p(x)\)</span>。当 <span class="math inline">\(p\left(x_{test}^{(1)}\right)\)</span> 小于 <span class="math inline">\(\mathbf{\varepsilon}\)</span> 时，有异常。</p><h2 id="算法评估">算法评估</h2><h3 id="实数计算">实数计算</h3><p><img src="/img/5无监督学习/Pasted%20image%2020230716221302.png" /></p><p>飞机发动机监测实例： 根据以往的数据，我们选择10000个正常的样本，20个异常样本。 <img src="/img/5无监督学习/Pasted%20image%2020230716220237.png" /></p><p>在训练集中用6000个正常样本训练模型； 交叉验证集中有2000个正常数据和10个异常数据，并把它们标记为0和1。在交叉验证集中评估模型准确率。</p><p>接着，改变超参数，训练集中训练模型，交叉验证集中评估模型。</p><p>最后选出一个最好的模型用在预测集中评估最终模型。</p><h3 id="算法评估-1">算法评估</h3><p>如果负面样本非常少，也可以不用预测集，只用训练集和交叉验证集。但这样的弊端是，模型可能在未知的数据上效果并不好。</p><p>由于异常样本是非常少的，所以整个数据集是非常偏斜的，我们不能单纯的用预测准确率来评估算法优劣，所以用我们之前的查准率（Precision）和召回率（Recall）计算出 F 值进行衡量异常检测算法了。</p><ul><li>真阳性、假阳性、真阴性、假阴性</li><li>查准率（Precision）与 召回率（Recall）</li><li>F1 Score</li></ul><h2 id="异常检测vs监督学习">异常检测VS监督学习</h2><p><img src="/img/5无监督学习/Pasted%20image%2020230716224601.png" /></p><p>异常检测，任何偏离正常的情况都被标记为异常，包括这在您的数据集中从未见过的一种全新的飞机发动机故障方式。</p><p>无监督适用于可能会出现从来没见过的例子的事情，而监督学习就适用于不会出现和以前完全不一样的例子的数据集</p><p>异常检测试图找到全新的正面示例，这些示例可能与您以前见过的任何东西都不一样。监督学习会查看您的正面示例并尝试确定未来示例是否与您已经看到的正面示例相似，</p><p>例子 <img src="/img/5无监督学习/Pasted%20image%2020230716224929.png" /></p><h2 id="选择特征">选择特征</h2><ol type="1"><li>将不符合高斯分布的特征转换成符合高斯分布的特征 <img src="/img/5无监督学习/Pasted%20image%2020230716230532.png" /></li><li>查看未能检测出来的异常，然后看看能否寻找出新的特征 <img src="/img/5无监督学习/Pasted%20image%2020230716230651.png" /></li></ol><h1 id="pca算法">PCA算法</h1><h2 id="降低特征数量">降低特征数量</h2><p>PCA是一种降维算法，用于获取具有大量特征、大量维度或高维度的数据，并将其简化为两个或三个特征，变成二维或三维数据，以便可以对其进行绘图和可视化，并更好地理解数据中有什么。</p><h3 id="示例">示例</h3><p>如果你有来自汽车的数据，并且汽车可以有很多特征。例如汽车的长度，汽车的宽度，汽车的高度，车轮的直径，以及其他特征。如果想要减少特征的数量以便将其可视化，如何使用PCA来做到这一点？</p><p><strong>示例1：</strong> 假设您有一个具有两个特征的数据集。特征 <span class="math inline">\(x_1\)</span> 是汽车的长度，特征<span class="math inline">\(x_2\)</span> 是汽车的宽度。 在大多数国家/地区，由于对汽车行驶道路宽度的限制，汽车宽度往往变化不大。你会发现数据集 <span class="math inline">\(x_1\)</span> 变化很大，而 <span class="math inline">\(x_2\)</span> 变化相对较小。 <img src="/img/5无监督学习/Pasted%20image%2020230721114957.png" /> 如果你想减少特征的数量，那么，你可以做的一件事就是只取 <span class="math inline">\(x_1\)</span> ，忽略 <span class="math inline">\(x_2\)</span> 。</p><p><strong>示例2：</strong> 假设我们有两个特征，即汽车的长度 <span class="math inline">\(x_1\)</span> 和高度 <span class="math inline">\(x_2\)</span>。这两个特征的变化范围都比较大。如果我们绘制这些数据点，可能会得到一个这样散点图。 <img src="/img/5无监督学习/Pasted%20image%2020230721120204.png" /></p><p>现在，如果我们想要减少特征的数量，我们应该选择什么呢？</p><p>我们不希望只选择长度 <span class="math inline">\(x_1\)</span> 而忽略高度 <span class="math inline">\(x_2\)</span>，也不希望只选择高度 <span class="math inline">\(x_2\)</span> 而忽略长度 <span class="math inline">\(x_1\)</span>。为了解决这个问题，PCA算法提出了一个思想：寻找一个新的轴，我们可以将其称为Z轴。请注意，这里的Z轴并不是在三维空间中突出显示的Z轴，而是长度和高度的组合，也是在这个二维平面中的。 <img src="/img/5无监督学习/Pasted%20image%2020230721120803.png" /></p><p>Z轴能够获得关于长度和高度的信息。Z轴上的值可以映射到 <span class="math inline">\(x_1\)</span> 轴和 <span class="math inline">\(x_2\)</span> 轴， <span class="math inline">\(x_1\)</span> 轴上的这个距离是多少，可以告诉我们汽车的长度是多少；<span class="math inline">\(x_2\)</span> 轴上的这个距离是多少，告诉我们汽车的高度是多少。</p><p><img src="/img/5无监督学习/Pasted%20image%2020230721121015.png" /></p><p>现在，我们只需要一个数字即可反映出汽车的长度和高度的特征。 重建可以知道原来的特征数据（近似的）是多少。这些新轴即为主成分。</p><p>通过PCA算法，我们能够将原始高维数据映射到低维空间，将数据的维度减少到我们所选择的新轴上，同时保留了关键的信息。这样做有助于简化问题、减少计算复杂性，并且仍然能够提供有关汽车尺寸的重要特征。</p><h2 id="pca代码实现scikit-learn">PCA代码实现(scikit-learn)</h2><p>2D to 1D <img src="/img/5无监督学习/Pasted%20image%2020230721131231.png" /></p><p>2D to 2D <img src="/img/5无监督学习/Pasted%20image%2020230721131323.png" /></p><h2 id="线性回归和pca区别">线性回归和PCA区别</h2><p>线性回归是求绿色线最小值 PCA求黄色线最小值 <img src="/img/5无监督学习/Pasted%20image%2020230721123113.png" /></p><h2 id="应用pca的建议">应用PCA的建议</h2><p><img src="/img/5无监督学习/Pasted%20image%2020230721131635.png" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习04-树模型</title>
    <link href="/2023/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A004-%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A004-%E6%A0%91%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="分类决策树">分类决策树</h1><p><img src="/img/4树模型/Pasted%20image%2020230715193726.png" /></p><ol type="1"><li>在每个节点上如何选择特征进行拆分？</li></ol><ul><li>选择要拆分的特征以尝试最大化纯度 <img src="/img/4树模型/Pasted%20image%2020230715170822.png" /></li></ul><ol start="2" type="1"><li>何时停止分支？ <img src="/img/4树模型/Pasted%20image%2020230715171547.png" /></li></ol><ul><li>分出类别</li><li>达到最大深度</li><li>当纯度低于阈值</li><li>节点的示例数量低于阈值</li></ul><h1 id="纯度">纯度</h1><p>熵（entropy）的定义，它是衡量一组数据不纯度（混乱程度）的指标。 熵越小，纯度越高</p><p><img src="/img/4树模型/Pasted%20image%2020230715172451.png" /></p><p>熵函数 <img src="/img/4树模型/Pasted%20image%2020230715172601.png" /> 在决策树构建的过程中，我们希望通过选择特征使得熵最小化，即寻找能够最大程度减少数据集的纯度。通过计算每个特征的熵，并对其进行比较，我们可以选择最佳的划分特征来构建决策树的节点。</p><h1 id="选择拆分信息增益">选择拆分信息增益</h1><p>在决策树中，熵的减少称为信息增益（information gain） 信息增益是决策树算法中用于选择最佳划分特征的指标之一。它表示通过使用某个特征对数据集进行划分所能获得的整体熵减少量。</p><p>在计算信息增益时，首先需要计算划分前的数据集的熵（也称为初始熵）。然后，对于每个候选划分特征，并计算每个划分子集的熵。最后，通过计算划分前的熵与所有划分子集熵的加权平均来计算信息增益。</p><p><img src="/img/4树模型/Pasted%20image%2020230715183454.png" /> 其中，初始熵是对整个数据集进行计算得到的熵，子集熵是对每个划分子集进行计算得到的熵，子集样本数是每个划分子集中的样本数量，总样本数是整个数据集的样本总数。</p><p>未分支前有5个猫，5个狗，因此初始熵熵 <span class="math inline">\(H(0.5)=1\)</span> 。 分支后加权平均的熵为上图红色方框，未分支前的熵减去分支后加权平均的熵即为信息增益。</p><p>具体计算公式如下：</p><p>信息增益 = 初始熵 - ∑(子集熵 * 子集样本数 / 总样本数) <img src="/img/4树模型/Pasted%20image%2020230715191714.png" /></p><p>信息增益表示通过使用某个特征划分数据集，分支后，<strong>整体熵相对于初始熵的减少量</strong>。我们希望选择具有<strong>最大</strong>信息增益的特征作为划分依据，因为它能够最大程度地<strong>减少数据集的不确定性（混乱程度）</strong>，提供更多有用的信息。</p><p>总结：熵代表混乱程度，熵越高，混乱程度越高；信息增益越大，熵减少的越大，说明从高熵减低到低熵，进而说明从高混乱程度到低混乱程度的变化。</p><h1 id="决策树步骤">决策树步骤</h1><p><img src="/img/4树模型/Pasted%20image%2020230715193336.png" /> 从根节点开始，将所有的示例放置在根节点上。 计算所有可能特征的信息增益，并选择具有最高信息增益的特征。 根据所选特征划分数据集，并创建决策树的左右分支。 不断重复划分过程，直到满足停止准则为止： - 当一个节点是100%属于某一类别时 - 当划分一个节点会导致树超过最大深度时 - 额外划分带来的信息增益低于阈值时。</p><h1 id="如何处理连续值特征">如何处理连续值特征</h1><p>在决策树中处理连续性数值的特征通常有两种方法：二元切分和多元切分。</p><ol type="1"><li><p>二元切分（Binary Splitting）：通过选择一个阈值来将连续性数值特征进行二元切分。对于给定的连续性特征，可以选择一个合适的阈值将数据集划分为两个子集。例如，如果特征是年龄，可以选择一个年龄阈值，将数据分为小于等于阈值和大于阈值的两个子集。然后，根据这个划分继续构建决策树。</p></li><li><p>多元切分（Multi-way Splitting）：与二元切分不同，多元切分将连续性数值特征划分为多个范围或区间。通过指定多个阈值或范围，将连续性特征划分为多个子集。例如，对于年龄特征，可以指定年龄范围(0-10岁, 11-20岁, 21-30岁, 等等)作为划分依据。然后，根据这个划分继续构建决策树。</p></li></ol><p>无论是二元切分还是多元切分，决策树都会根据划分结果计算信息增益或其他评估指标，选择最佳的划分。</p><p>在示例中增加一列体重特征： <img src="/img/4树模型/Pasted%20image%2020230715195850.png" /> 对于体重，我们选取不同的阈值来分割，然后计算对应的信息增益 <img src="/img/4树模型/Pasted%20image%2020230715200031.png" /> 当选择9时，信息增益最大，因此我们用是否大于9磅进行分支。</p><h1 id="回归决策树">回归决策树</h1><p>预测体重： <img src="/img/4树模型/Pasted%20image%2020230715201645.png" /></p><p><img src="/img/4树模型/Pasted%20image%2020230715201734.png" /></p><p><img src="/img/4树模型/Pasted%20image%2020230715201805.png" /> 方差 方差减小最大</p><h1 id="有放回抽样样本">有放回抽样样本</h1><p>共十个样本，五个猫 五个狗，有放回的抽取10次，组成一个新的训练集。 <img src="/img/4树模型/Pasted%20image%2020230715212515.png" /></p><h1 id="装袋决策树">装袋决策树</h1><p>有一个大小为m的训练集。</p><p>b等于1到B，我们将训练集放入袋子中，利用有放回抽样选出B次大小为m的新的训练集，我们在这些新的训练集中训练一个个决策树。 <img src="/img/4树模型/Pasted%20image%2020230715222743.png" /> 选出一个新的训练集，训练一个决策树；选出另外一个新的训练集，在训练一个决策树，就这样选出B个训练集，训练出B个决策树。 B则代表决策树的数量， 已经构建了一个包含B棵不同树的集合，然后让这些树对预测的结果进行投票。</p><p>当B远大于100时，算法的性能并不会有显著的增加，只会降低计算速度。</p><p>这种从袋子中选出新的训练集创建的决策树称为装袋决策时，所以B代表的是bag。</p><p>弊端是，这种抽取训练集的方法，会使许多树在根节点或者根节点附近的某些节点使用相同的特征进行分支。因此对算法进行改进，尝试随机化每个节点的特征选择，使数之间变得更加不同这就是随机森林。 # 随机森林</p><p>在每个节点上，在选择用于划分的特征时，如果有n个可用特征，则从中随机选择一个大小为k（k &lt; n）的特征子集，并只允许算法从该特征子集中进行选择，从中选择出具有最高信息增益的特征进行分支。 当n很大时，K值的典型选择是它的平方根 <span class="math inline">\({\mathrm{k=\sqrt{n}}}\)</span> 。</p><p>因此，这意味着训练集的任何微小变化都不太可能对整个随机森林算法的整体输出产生巨大影响。</p><h1 id="xgboost">XGBoost</h1><p>依然使用有放回的抽样方式，创建一个大小为m的新训练集。但不是以相等的（1/m）概率从所有示例中抽取，而是更有可能抽取那些先前训练树分类错误的示例。</p><p><strong>优势：</strong> 助推树的开源实现 快速高效的实现 可选择良好的默认拆分标准和何时停止拆分的标准 内置正则化，防止过拟合 机器学习竞赛（如Kaggle竞赛）中极具竞争力的算法 # 决策树VS神经网络 <img src="/img/4树模型/Pasted%20image%2020230716093526.png" /></p><ol type="1"><li><p>数据集的特征：决策树在处理具有离散特征和类别特征的数据集时表现较好，而神经网络在处理具有连续特征和大量样本的数据集时通常更有效。</p></li><li><p>数据集的大小：如果数据集非常大，神经网络通常能够通过深层次的学习来发现复杂的模式和关联，因此神经网络可能更适合用于大规模数据集。</p></li><li><p>解释性要求：决策树提供了较好的可解释性，可以根据节点分裂规则和特征重要性进行解释。而神经网络通常被认为是“黑盒”模型，其内部权重和参数难以解释。</p></li><li><p>预测性能需求：神经网络在某些高度复杂的问题上可能具有更强的预测性能，尤其是当数据集具有深层次的非线性关系时。集成树模型如随机森林和梯度提升树则在处理噪声和异常值方面表现较好。</p></li><li><p>训练效率：决策树通常更容易训练和调优，而神经网络需要更多的计算资源和时间来训练和优化。</p></li><li><p>预测速度：决策树是一种基于规则的模型，可以快速进行预测。相比之下，神经网络需要通过多层次的计算才能进行预测，因此在实时性要求较高的场景中可能不太适用。</p></li></ol><p>最终的选择应该根据具体问题的需求和数据集特征来决定。在某些情况下，使用决策树和集成树（如随机森林、梯度提升树）能够提供较好的性能和解释性；而在其他情况下，神经网络可能会更适合。还可以尝试将两种算法结合起来，如使用神经网络进行特征提取，然后使用决策树进行分类或回归。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习03-模型评估</title>
    <link href="/2023/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A003-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/"/>
    <url>/2023/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A003-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="模型选择">模型选择</h1><p>如何评估学习算法，自动选择模型？</p><p>模型选择&amp;交叉验证测试集的训练方法</p><p>因为d也是一个需要学习的参数，不断选择d的过程本质上和学习模型内参数w,b是一致的，而超参数d本就是靠在test集上测试找到的，而test集在这里就成为参数d的“训练集”，所以这样得出的d是过拟合的</p><p>简而言之 Training set 用来 选 w&amp;b, cross validation用来选 d , Test set 用来评估 模型 最终的 泛化误差 - 就是这个模型好不好</p><p>训练集：得到模型，得到每个模型的w，b 验证集:挑选模型，挑选某一个模型 测试集：评估挑选的模型的泛化能力</p><p>只有在你想出一个模型作为你的最终模型之后，才可以在测试集上对其进行评估，并且因为你没有使用测试集做出任何决定，这可以确保你的测试集是公平的而不是过度的对您的模型对新数据的泛化能力的乐观估计</p><p>选择几个模型进行训练，然后用交叉验证集对几个模型进行损失值评估，以此选出最好的模型，再通过测试集新数据评估该模型泛化误差</p><h1 id="偏差与方差">偏差与方差</h1><p>高偏差（欠拟合） 高方差（过拟合）</p><p>多项式最高次数与代价函数值图： <img src="/img/3模型评估/Pasted%20image%2020230713190145.png" /></p><p>多项式次数低，欠拟合，训练集成本函数值（<span class="math inline">\(J_{train}\)</span>）高，交叉验证集成本函数值（<span class="math inline">\(J_{cv}\)</span>）高。</p><p>多项式次数高，过拟合，<span class="math inline">\(J_{train}\)</span> 低，<span class="math inline">\(J_{cv}\)</span> 高。</p><p>一般在神经网路中才同时具有高偏差和高方差。</p><p>高偏差意味着在训练集上做的不好。高方差意味着在训练集和交叉验证集都不好。</p><h1 id="正则化如何影响方差和偏差">正则化如何影响方差和偏差</h1><p><img src="/img/3模型评估/Pasted%20image%2020230713203458.png" /></p><h1 id="正则化中-lambda-评估">正则化中 <span class="math inline">\(\lambda\)</span> 评估</h1><p><span class="math inline">\(\lambda\)</span> 与代价函数值图： <img src="/img/3模型评估/Pasted%20image%2020230713204607.png" /> <span class="math inline">\(\lambda\)</span> 小，过拟合，<span class="math inline">\(J_{train}\)</span> 低，<span class="math inline">\(J_{cv}\)</span> 高。 <span class="math inline">\(\lambda\)</span> 大，欠拟合，<span class="math inline">\(J_{train}\)</span> 高，<span class="math inline">\(J_{cv}\)</span> 高。</p><h1 id="性能评估的基准">性能评估的基准</h1><p><img src="/img/3模型评估/Pasted%20image%2020230714164315.png" /></p><p>评估基准：你希望算法能达到的性能是多少 - 人类水平的表现 - 竞争对手的算法，其他人以前已经实现的算法 - 以往的经验</p><h2 id="是否具有高方差偏差">是否具有高方差/偏差</h2><p><img src="/img/3模型评估/Pasted%20image%2020230714164706.png" /> 相互比较</p><h2 id="高偏差的学习曲线">高偏差的学习曲线</h2><p><img src="/img/3模型评估/Pasted%20image%2020230714170245.png" /> 具有高偏差欠拟合的模型，加训练数据量没法改善，从模型选择就有问题； 欠拟合对新数据不敏感</p><h2 id="高方差的学习曲线">高方差的学习曲线</h2><p><img src="/img/3模型评估/Pasted%20image%2020230714171220.png" /> 高方差过拟合加训练数据量可以改善； 过拟合对新数据特别敏感。</p><p>缺点是，使用训练集的不同大小的子集来训练这么多不同的模型在计算上非常昂贵，在实践中，并没有这样做。虽然如此，在脑海中形成训练集的视觉图像，有时可帮助思考学习算法在做什么，是否具有高偏差或高方差</p><h1 id="调试学习算法">调试学习算法</h1><p><img src="/img/3模型评估/Pasted%20image%2020230714173338.png" /></p><p>高方差：增加训练数据，简化模型（减少特征、增加<span class="math inline">\(\lambda\)</span>） 高偏差：强化模型（增加特征、增加多项式、降低<span class="math inline">\(\lambda\)</span>）</p><h1 id="误差分析">误差分析</h1><p>算法错误分类了100个样本，我们手动分析这一百个样本，并试图深入了解算法出错的地方，将它们分组为共同的主题或共同的属性或共同的特征。 <img src="/img/3模型评估/Pasted%20image%2020230714185413.png" /> 分析发现： 药品垃圾邮件21件 故意拼写错误3件 邮件路由错误7件 钓鱼邮件18件 图片5件 那我们将重心放在识别药品垃圾邮件和钓鱼邮件，而不是放在识别拼写错误这种净影响实际上非常小的问题上。</p><p>例如对于药品垃圾邮件，可以收集更多的关于药物垃圾邮件数据，而不是收集更多的所有数据，以便学习算法可以更好地识别这些药物垃圾邮件。</p><p>但是现在错误分析的一个局限性是它更容易解决人类擅长的问题。比如人们可以直接的分辨出是否为垃圾邮件，对于连人类都不擅长的任务，错误分析可能会更难一些，例如，如果试图预测人们会点击网站上的哪些链接。对于这种主观性较大的事件，可能无法预测人会点击什么。</p><h1 id="添加有帮助的数据">添加有帮助的数据</h1><p>采用现有的训练示例并对其进行修改、扭曲以创建另一个训练示例。 例如，计算机视觉常用合成数据进行增加训练样本。 <img src="/img/3模型评估/Pasted%20image%2020230714203623.png" /> 有时花更多时间采用以数据为中心的方法会更有成效，在这种方法中，专注于设计算法使用的数据，数据可以来源于收集、数据增强、数据合成。</p><p>可以用迁移学习的方法获取数据，关键在于从几乎不相关的任务中获取数据。</p><h1 id="迁移学习">迁移学习</h1><p>迁移学习可以使用其他任务中的数据应用于程序，核心思想是从一个任务学到的知识或模型应用于另一个相关任务上。通过迁移学习，可以在目标任务上利用源任务的经验和模型参数，从而加快目标任务的训练速度、提高预测性能。</p><p>迁移学习的基本假设是：不同的任务之间存在某种共享的特征表示或知识，这些特征和知识对于解决其他任务也是有用的。通过迁移学习，可以利用源任务的经验来帮助目标任务的学习，尤其在目标任务的数据较少或难以获取的情况下，迁移学习可以发挥重要作用。</p><p>假设要识别从0-9的手写识别，但是没有这么多用于训练的数据。 可以这样做， 假设您找到了一个非常大的数据集，其中包含一百万张猫、狗、汽车等一千个类别的图片，然后，您可以用这一百万张图片训练一个识别个个类别的神经网络，即训练算法将一百万张图像X作为输入，将1,000个不同的类别作为输出。 <img src="/img/3模型评估/Pasted%20image%2020230715085908.png" /> 这个神经网路共五层，四个隐藏层和一个输出层。各层的参数分别为<span class="math inline">\(\mathbf{W}^{[1]},\vec{\boldsymbol{b}}^{[1]}\)</span>、<span class="math inline">\(\mathbf{W}^{[2]},\vec{\boldsymbol{b}}^{[2]}\)</span>、<span class="math inline">\(\mathbf{W}^{[3]},\vec{\boldsymbol{b}}^{[3]}\)</span>、<span class="math inline">\(\mathbf{W}^{[4]},\vec{\boldsymbol{b}}^{[4]}\)</span>、<span class="math inline">\(\mathbf{W}^{[5]},\vec{\boldsymbol{b}}^{[5]}\)</span> 要应用迁移学习，您要做的是复制此神经网络，在其中插入参数<span class="math inline">\(\mathbf{W}^{[1]},\vec{\boldsymbol{b}}^{[1]}\)</span>、<span class="math inline">\(\mathbf{W}^{[2]},\vec{\boldsymbol{b}}^{[2]}\)</span>、<span class="math inline">\(\mathbf{W}^{[3]},\vec{\boldsymbol{b}}^{[3]}\)</span>、<span class="math inline">\(\mathbf{W}^{[4]},\vec{\boldsymbol{b}}^{[4]}\)</span> 但对于最后一层输出层，用0-9代替原来的一千个分类，然后用优化 算法，例如梯度下降或Adma算法仅更新 <span class="math inline">\(\mathbf{W}^{[5]},\vec{\boldsymbol{b}}^{[5]}\)</span> ；对于<span class="math inline">\(\mathbf{W}^{[1]},\vec{\boldsymbol{b}}^{[1]}\)</span>-<span class="math inline">\(\mathbf{W}^{[4]},\vec{\boldsymbol{b}}^{[4]}\)</span> 用原来的值 不更新。</p><p><img src="/img/3模型评估/Pasted%20image%2020230715091903.png" /></p><p>另一种策略是，更新所有的参数，但是<span class="math inline">\(\mathbf{W}^{[1]},\vec{\boldsymbol{b}}^{[1]}\)</span>、<span class="math inline">\(\mathbf{W}^{[2]},\vec{\boldsymbol{b}}^{[2]}\)</span>、<span class="math inline">\(\mathbf{W}^{[3]},\vec{\boldsymbol{b}}^{[3]}\)</span>、<span class="math inline">\(\mathbf{W}^{[4]},\vec{\boldsymbol{b}}^{[4]}\)</span> 使用上面训练过的值作为初始值，在此基础上进行更新。</p><p>如果有一个非常小的训练集，前一种策略较好，如果训练集稍微大一点，后一种策略较好。</p><p>迁移学习的两个步骤，首先在大型数据集上进行训练，即预训练；然后在较小的数据集上进一步调整参数，即微调。</p><p>我的理解： 预训练是用预训练的数据集找出一个大致的工作模板，第一步该干什么，第二步该干什么什么，最后得出结论。 微调是在已有的工作模板上直接按部就班，但是需要进行一些改动、优化，使之变得符合本项目的工作流程。</p><p>GPT: 预训练的目标是通过大规模数据集，使模型学习到一些通用的特征表示或知识。这个过程可以被看作是为模型提供一个“大致的工作模板”，其中包含了一些普遍适用的信息。预训练可以使用无监督学习方法，如自编码器或生成对抗网络，也可以使用有监督学习方法。预训练后的模型通常具有更好的初始特征表示能力。</p><p>微调则是在预训练模型的基础上，通过在目标领域的较小数据集上进行进一步训练来调整模型参数。微调过程中，可以根据具体任务的需求进行一些改动、优化或修正，以使模型更符合目标任务的工作流程。微调的目的是将预训练模型适应特定任务的特征和表现能力，提高模型在目标领域上的性能。</p><p>总结来说，预训练提供了一个初始的模板或特征表示，微调则是在此基础上进行调整和优化，以适应具体的任务需求和数据分布。这样的迁移学习方法可以减少对大量标注数据的依赖，提高模型的泛化性能。</p><h1 id="倾斜数据集的误差指标">倾斜数据集的误差指标</h1><p>如果正例与负例比例偏差很大，那么像准确度这种错误指标效果不佳。</p><p>假设正在训练一个二分类模型，检测患者是否患罕见疾病，在人群中只有0.5%发病率。</p><p>对于这种倾斜数据集的衡量常用准确率（Precisionn）和召回率（Recall）</p><p><img src="/img/3模型评估/Pasted%20image%2020230715114140.png" /> 高精度意味着如果患者被诊断患有这种罕见疾病，那么该患者可能确实患有这种疾病，并且这是一个准确的诊断。 高召回率意味着如果有患者患有这种罕见疾病，算法可能会正确识别出他们确实患有这种疾病。</p><p>预测的准确性和漏判的概率 Precision很高：说话靠谱；Recall很高：遗漏率很低。 当两者都较高时模型才有较好的效果。</p><p>因此，当有偏斜类或想要检测稀有类时，精确率和召回率可以判断算法是否做出了良好的预测或有用的预测。</p><h1 id="精确率与召回率的权衡">精确率与召回率的权衡</h1><p>当使用逻辑回归模型时，可更改阈值来权衡精确率和召回率 <img src="/img/3模型评估/Pasted%20image%2020230715120340.png" /> 当阈值提高到0.7，则说明当算法有70%及以上的信心认为样本患病时，才把该样本标记为患病。如果只有69%的信心时，则不标记患病，划分为未患病。</p><p>因此，通过提高阈值，可以提高精确度，但是会降低召回率。</p><p>如果治疗花费非常高、对患者伤害很大，则可能需要高精确度。反之，如果花费不是很高，伤害也小，但是不治疗会带来更糟糕的后果，则可能需要高召回率。</p><p>F1 Score，用于自动结合精确度和召回率，以帮助你选择最佳算法或最佳权衡两者。更强调的是这些值中较低的那个。数值较大的算法较好 <img src="/img/3模型评估/Pasted%20image%2020230715122058.png" /> 种结合P和R精度和召回率的方法，但它更强调这些值中较低的那个</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习02-多分类问题</title>
    <link href="/2023/07/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A002-%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    <url>/2023/07/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A002-%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="多分类问题">多分类问题</h1><h3 id="softmax回归">Softmax回归</h3><p>当有四种分类时： <img src="/img/2多分类问题/Pasted%20image%2020230712183238.png" /></p><p>普试： <img src="/img/2多分类问题/Pasted%20image%2020230712183725.png" /> <span class="math inline">\(a_{j}\)</span>被解释为给定输入特征x时模型对y等于j的概率。</p><h3 id="softmax回归的损失函数">Softmax回归的损失函数</h3><p><img src="/img/2多分类问题/Pasted%20image%2020230712185008.png" /> 损失函数衡量的是在一个训练样例上的表现如何，所以对于一个特定的训练样本，y只能取一个值。因此最终只能针对 <span class="math inline">\({a}_j\)</span> 的一个值计算 <span class="math inline">\({a}_j\)</span> 的负对数，即在该特定训练样本中y的实际值等于j的任何值。例如，当y等于2时，损失函数只计算 <span class="math inline">\(-\log a_{2}\)</span></p><h3 id="神经网络的softmax输出">神经网络的Softmax输出</h3><p><img src="/img/2多分类问题/Pasted%20image%2020230712191305.png" /> sigmod激活函数，激活值 <span class="math inline">\({a}_1\)</span> 仅是 <span class="math inline">\({z}_1\)</span> 的函数 ，<span class="math inline">\({a}_2\)</span> 也只是 <span class="math inline">\({z}_2\)</span> 的函数。但是对于softmax函数，每一个激活值都取决于Z的所有值。</p><h3 id="tensorflow实现">Tensorflow实现</h3><p>基本实现： <img src="/img/2多分类问题/Pasted%20image%2020230712192259.png" /></p><p>更好的实现：（P68） <img src="/img/2多分类问题/Pasted%20image%2020230712194825.png" /></p><p>目的在于减小计算误差。计算机是将数字转换为二进制计算数值的，会有误差。原来是先计算出a，再将a带入到损失函数中计算损失函数，这种利用中间值计算的损失函数具有误差。</p><p>现在softmax不再单独计算，在计算cost时将a嵌入损失韩素内部一起算了。并且输出层为 liner，这样输出层只会直接输出Z的值，不再带入softmax计算了。 完整代码： <img src="/img/2多分类问题/Pasted%20image%2020230712195606.png" alt="多分类优化代码" /></p><p>逻辑回归优化代码： <img src="/img/2多分类问题/Pasted%20image%2020230712195739.png" alt="逻辑回归优化代码" /></p><p>epochs 迭代次数。</p><h1 id="多标签分类问题">多标签分类问题</h1><p><img src="/img/2多分类问题/Pasted%20image%2020230712203304.png" /> 多标签分类问题是指对一个样本进行多个类别的分类，而不是将样本分到唯一的类别中。在多标签分类问题中，每个样本可以属于多个类别，类别之间是相互独立的。</p><p>举个例子，假设我们有一个图像识别任务，需要对图像进行多个标签的分类，比如识别图像中的汽车、公交车、行人。一张图像可能同时包含多个标签，比如既有人又有汽车。</p><p>训练三个单独的模型，分别识别有没有汽车、公交车、行人。 训练一个模型一次识别完。输出层有三个sigmod神经元，因此我们解决的是三个二分类问题。</p><p><img src="/img/2多分类问题/Pasted%20image%2020230712204335.png" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习01-神经网络</title>
    <link href="/2023/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A001-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A001-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="神经网路">神经网路</h2><p>什么是神经网络（Neural Networks）？最开始科学家想用算法去模拟大脑达到人工智能。通过一系列的实验发现，大脑是通过神经元进行工作的，神经元之间通过电信号传递信息。于是他们就开始模拟神经元的工作过程，用算法去模拟神经元，这就形成了神经网络。神经网络可以用来学习复杂的<strong>非线性假设模型</strong>。</p><p>为了构建神经网络模型，我们需要首先思考大脑中的神经网络是怎样的？</p><p>大脑中的神经元接受许多输入的信息，并进行一些计算和处理，计算后通过电脉冲发送给其他的神经元。上层神经元的输出又成为下层神经元的输入，下层神经元再次聚合来自其他神经元的输出作为该神经元的输入，然后将自己的输出发到其他神经元。这便是大脑中神经网络的工作原理。</p><p><img src="/img/1深度学习神经网络/Neurons_big1.jpg" /></p><p>我们将神经元简化如下：</p><p><img src="/img/1深度学习神经网络/Snipaste_2023-06-29_10-54-00.png" /> 每一个生物神经元都可以被认为是一个处理单元/神经核（<strong>processing unit</strong>/<strong>Nucleus</strong>），它含有许多输入/树突（<strong>input</strong>/<strong>Dendrite</strong>），并且有一个输出/轴突（<strong>output</strong>/<strong>Axon</strong>)。生物神经元会发送电脉冲，成为另一个神经元的输入。神经网络是大量神经元相互链接并通过电脉冲来交流的一个网络。</p><p>所有<strong>人工神经网络</strong>使用的是非常简化的生物神经元的数学模型。</p><p>我们用圆圈表示一个神经元，神经元所做的就是接受一个或多个输入，这些输入为数字，它进行一些计算后，输出一些数字，这些数字又作为下一层神经元的输入。我们构建人工神经网路时，通常同时模拟多个这样的神经元，而不是构建一个。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230708182836.png" /></p><h2 id="神经网络如何工作的">神经网络如何工作的？</h2><h3 id="案例一">案例一</h3><p>我们用需求案例来了解神经网路时如何工作的，这个案例中目标是想知道那些短袖可能成为畅销品，以来规划更好的库存水平和营销活动。收集的数据有：不同短袖的价格，以及是否是畅销品。</p><p><img src="/img/1深度学习神经网络/Pasted%20image%2020230709190636.png" /> 在此示例中，输入特征X是短袖的价格，如果应用逻辑回归sigmoid函数来拟合这些数据，那么预测输出则为<span class="math inline">\(\frac1{1+e^{-(wx+b)}}\)</span> <img src="assets/Pasted%20image%2020230709192135.png" /></p><p>在神经网络中，我们用a来表示算法的输出，a代表激活（activation），来源于神经科学的一个术语，指的是一个神经元向下游其他神经元发送多少高输出。</p><p>这个逻辑回归单元可看作大脑中单个神经元非常简化的数学模型。这个人工神经元所要做的就是，将价格X输入，然后利用sigmoid函数公式 <span class="math inline">\(\frac1{1+e^{-(wx+b)}}\)</span> 计算出输出值a，输出的则为这件短袖可能成为畅销品的概率。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709193702.png" /> 鉴于对单个神经元的描述，构建神经网络只需要将这些神经元并在一起，并将他们连接起来。</p><h3 id="案例二">案例二</h3><p>接下来我们看一个更复杂的需求预测案例，在该案例中我们用四个特征来预测短袖是否为畅销品。四个特征为价格（price）、运费（shipping cost）、营销手段（marketing）、材料质量（material）。我们假设短袖是否能成为畅销品取决于以下几个因素： 1. affordability - 对这件短袖人们是否<strong>可负担</strong>的起?支付能力 2. awareness - 潜在买家对这件短袖的<strong>认识程度</strong>如何？短袖是否知名 3. perceived quality - <strong>感知质量</strong>，人们是否有偏见或潜在偏见说这是一件高质量的短袖？ <img src="/img/1深度学习神经网络/Pasted%20image%2020230709200233.png" /></p><p><strong>首先</strong>，我们要创建一个人工神经元来估计这件短袖被人们认为是可负担的起的概率。支付能力主要是价格和运费的函数，因为一件短袖的支付总额是价格加上运费。所以在这里我们使用一个神经元，一个逻辑回归单元来输入价格和运费，并预测人们是否负担的起。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709212521.png" /></p><p><strong>接着</strong>，创建一个人工神经元来预测潜在买家对这件T恤衫的认识程度。短袖知名程度归因于营销手段。<strong>最后</strong>，要创建另一个神经元来估计人们是否认为这是高质量的短袖。这可能是短袖价格和材料质量的函数。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709213442.png" /></p><p>鉴于对可负担性（affordability）、认识程度（awareness）、感知质量（perceived quality）的预测，我们将这三个神经元的输出连接到右侧另一个神经元，然后该神经元输入这三个数字并输出可能成为畅销品的概率。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709213627.png" /> ==神经网络可看作逻辑回归，但是这个逻辑回归可以学习自身更好的特征，不需要手动设计，从而进行更准确的预测（神经网络=自动化特征工程+逻辑/线性回归)==</p><p>在神经网络术语中我们把，我们将把这三个神经元组合在一起，形成谓的<strong>层（layer）</strong>，层是一组神经元，它们将相同或相似的特征作为输入，然后一起输出一些数字，右边神经元也为层，所以层可以有一个或多个神经元。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709215546.png" /> 右边这一层也叫做<strong>输出层</strong>（output layer），因为最后一层输出的是整个神经网络的预测值。最左边输入的四个特征也叫<strong>输入层</strong>（input layer)。在输入层和输出层中间的所有层都叫<strong>隐藏层</strong>，在神经网络中输入层和输出层都有明确的数值，而中间的层并没有告诉确切的数值，是未知的。</p><p>我们还将 affordability、awareness、perceived quality 叫做激活（activations）。激活源于生物神经元，它指的是生物神经元向下游其他神经元发送的高输出值或发送许多电脉冲的程度。这些关于affordability、awareness和perceived quality的数字是该层中这三个神经元的激活。同样输出概率是右侧这个神经元的激活。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709220948.png" /></p><p>至此，我们手动选择了那个神经元需要那几个特征作为输入，但神经网络在实践中层中的每一个神经元都可以访问上一层的每一个特征，从输入层访问每个值。 <img src="/img/1深度学习神经网络/Pasted%20image%2020230709222537.png" /></p><p>你可以想象，如果试图预测短袖的可负担性，并且它知道价格、运费、营销和材料，你可能会忽略营销和材料，只注重于价格和运费。我们就可以通过适当地设置参数来找出那些特征与负担能力最相关，比如价格和运费权重较大，而营销和材料的权重较小。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习00-监督学习</title>
    <link href="/2023/07/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A000-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A000-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="线性回归模型linear-regression">线性回归模型（Linear Regression）</h1><h2 id="假设函数">假设函数</h2><p><span class="math display">\[f_{w,b}(x)=w_{1}x_{1}+w_{2}x_{2}+...+w_{n}x_{n}+b\]</span></p><p>如何确定模型中的参数取什么值? 用代价函数</p><h2 id="代价函数">代价函数</h2><p><a href="如何最简单、通俗地理解代价函数？.md">代价函数</a>（Cost Function）是用来衡量预测值与实际值之间的误差。它的目的是找到一组参数，使得预测值与实际值之间的误差最小（确定最优参数）。评价模型是否拟合的准确，值越小，拟合的越准确。</p><p><strong>线性回归的代价函数</strong>：最小二乘法。所谓“二乘”就是平方的意思。</p><p><span class="math display">\[J(w,b)=\frac{1}{2m}\sum_{i=1}^m\bigl(f_{w,b}\bigl(x^{(i)}\bigr)-y^{(i)}\bigr)^2\]</span></p><blockquote><p>此处1/2m中的2仅为了后续求导计算时，简化计算步骤</p></blockquote><p><strong>注意：</strong></p><p>代价函数中的 <span class="math display">\[(f_{w,b}\bigl(x^{(i)}\bigr)-y^{(i)}\bigr)^2\]</span> 部分叫损失函数（Loss Function）用L表示 <span class="math display">\[L=(f_{w,b}\bigl(x^{(i)}\bigr)-y^{(i)}\bigr)^2\]</span> 损失函数衡量的是你在一个训练样例上的表现如何，它是通过总结你随后获得的所有训练样列的损失；而代价函数衡量你在整个训练集上的表现。</p><p>因此，代价函数值是在损失函数值求和后除以训练量。</p><p>线性回归代价函数图：</p><p><img src="/img/机器学习/Snipaste_2023-06-09_11-22-50.png" /></p><p>代价函数图自变量为参数，因变量为代价函数值。有代价函数图了，如何自动到达代价函数图的最小值点，即模型拟合最优的点？</p><h2 id="梯度下降gradient-descent">梯度下降（Gradient descent ）</h2><p>从代价函数图中找到最小值所在的点。有没有一种算法可以自动地、快速求出使得代价函数最小的点呢？有，那就是<strong>梯度下降</strong></p><ul><li><p>梯度下降的工作是找到希望最小化代价函数J的参数w和b</p></li><li><p>如何快速到达最优点：从山顶一步一步走到山谷，先在原地转一圈，选最陡的地方走一步，在转一圈，在选最陡的一步。这一步一步就是多个梯度下降的步骤。</p></li><li><p>不同的w，b值决定你在那个位置</p></li><li><p>梯度下降算法 <span class="math display">\[\begin{aligned}w &amp;= w - \alpha \frac{\partial}{d\omega}J(\omega.b) \\b &amp;= b - \alpha \frac{\partial}{d\omega}J(\omega.b)\end{aligned}\]</span></p></li><li><p>梯度下降（Gradient descent ）同时更新w，b。同时更新目的在于，能够确保是在原点寻找最陡方向。赋值就像迈出了一步，先迈出左脚寻找最陡的地方和在原地寻找最陡的地方不一样。</p></li><li><p>α学习率决定你迈出的一步有多大</p></li><li><p>导数决定梯度下降方向，学习率决定步长</p></li></ul><p><img src="/img/机器学习/Snipaste_2023-06-12_19-02-10.png" /></p><p><strong>线性回归的梯度下降：</strong> <span class="math display">\[\begin{aligned}w&amp;=w-\alpha\frac{1}{m}\sum_{i=1}^{m}(f_{w,b}\big(x^{(i)}\big)-y^{(i)})x^{(i)}\\b &amp;=b-\alpha\frac{1}{m}\sum_{i=1}^{m}(f_{w,b}(x^{(i)})-y^{(i)})\end{aligned}\]</span></p><h2 id="多维特征">多维特征</h2><ul><li>矢量化使代码更简短 运行更高效</li></ul><h2 id="特征缩放feature-scaling">特征缩放（<strong>Feature Scaling</strong>）</h2><p>房价</p><p><span class="math display">\[pr i c e=w_{1}x_{1}+w_{2}x_{2}+b\]</span> <span class="math inline">\(x_{1}\)</span> : size（feet^2）range :300-2000 <span class="math inline">\(x_{2}\)</span> : # bedrooms range :0-5</p><p>当特征的可能值较大时，如房间大小(<span class="math inline">\(x_{1}\)</span>)，则其参数(<span class="math inline">\(w_{1}\)</span>)的合理值将相对较小 当特征的可能值较小时，如卧室数量(<span class="math inline">\(x_{2}\)</span>)，则其参数(<span class="math inline">\(w_{2}\)</span>)的合理值将相对较大</p><p><img src="/img/机器学习/Snipaste_2023-05-27_11-58-53.png" /></p><p>特征散点图如左上时，其代价函数在等高线图中的样子如右上所示，为椭圆形，梯度下降可能会在它最终找到全局最小值之前来回弹跳很长的时间。</p><p>所以当你有不同的特征，它们的取值范围非常不同时，它可能会导致梯度下降运行缓慢，但重新缩放不同的特征，使它们都具有可比较的取值范围，让梯度下降法运行得更快。</p><h3 id="如何实现特征缩放">如何实现特征缩放？</h3><p>将数据标准化、归一化</p><p><strong>平均值归一化方法（Mean normalization）</strong></p><p>如果要将该值映射到[-1,1]区间内，则需要计算特征的平均值<span class="math inline">\(X_{Mean}\)</span>，使用平均值归一化方法公式为</p><p><span class="math display">\[x=\frac{X-X_{Mean}}{X_{Max}-X_{Min}}\]</span></p><p><strong>Z-score标准化方法（Z-score Normalization）</strong></p><p>标准化法需要提前计算特征的均值<span class="math inline">\(X_{Mean}\)</span>和标准差<span class="math inline">\(\sigma\)</span>，标准化后的变量值围绕0上下波动，大于0说明高于平均水平，小于0说明低于平均水平。 <span class="math display">\[x={\frac{X-X_{M e a n}}{\sigma}}\]</span></p><h3 id="缩放的范围是否有固定的要求">缩放的范围是否有固定的要求？</h3><p><img src="/img/机器学习/Snipaste_2023-06-08_16-08-53.png" /></p><p>最好是-1到1，实在不行，最大是-3到3，最小是-0.3到0.3，都能接受。</p><p>基本意思是，保证各个特征的数量级一致，通过缩放尽量让所有特征的取值在差不多范围，在一个数量级以内的特征可以不考虑缩放，这样它们的变化对预测值的影响都是接近的。</p><h2 id="判断梯度下降是否收敛">判断梯度下降是否收敛？</h2><p>在运行梯度下降时，怎样才能知道梯度下降是否有效，是否正在找到全局最小值或接近它的值？为了能够选择更好的学习率。</p><p>判断梯度下降运行是否良好，用<strong>学习曲线</strong>（learning curve），横轴为梯度下降迭代次数，纵轴为代价函数J。</p><p><img src="/img/机器学习/Snipaste_2023-06-08_17-32-14.png" /> 当运行良好时，学习曲线是一直下降的，直到变平（即收敛)；当出现先下降后又上升的情况时，可能是学习率错误，或者程序错误。查看此学习曲线，您可以尝试发现梯度下降是否收敛。</p><p>另一种方法是<strong>自动收敛测试</strong>（Automatic convergence test） 令<span class="math inline">\(\epsilon\)</span> ”epsilon“等于一个非常小的数，如果代价J在一次迭代中减少的幅度小于这个数字epsilon,那么很可能位于学习曲线的平坦部分，可以宣布收敛。但是选择正确的阈值epsilon非常困难。</p><h2 id="如何设置学习率">如何设置学习率？</h2><p>当梯度下降函数运行有错误时，可能是学习率太大了或者程序有错误。</p><ul><li>学习率过大，调小学习率</li><li>程序有错误，查看公式是否写错，比如把减号写成加号</li></ul><p><strong>尝试不同的学习率并画对应的学习曲线</strong></p><p>……0.001，0.003，0.01，0.03，0.1，0.3，1 ……</p><p><img src="/img/机器学习/Snipaste_2023-06-08_17-54-18.png" /></p><p>在太小，太大的学习率之间调试。</p><h2 id="特征工程feature-engineering">特征工程（feature engineering）</h2><p>利用领域知识和现有数据，创造出新的特征，用于机器学习算法；可以手动（manual）或自动（automated）。</p><p>如果新特征是原始特征的次方，那么特征缩放会非常重要</p><p><img src="/img/机器学习/Snipaste_2023-06-08_18-10-02.png" /></p><h1 id="分类classification">分类（Classification）</h1><h2 id="逻辑回归logistic-regression">逻辑回归（logistic regression）</h2><h3 id="假设函数-1">假设函数</h3><p>首先介绍sigmoid函数，又称logistic函数</p><p><img src="/img/机器学习/Snipaste_2023-06-09_08-48-39.png" /></p><p><span class="math display">\[g(z)=\frac{1}{1+e^{-z}}\quad0&lt;g(z)&lt;1\]</span></p><p>当z取无限大时，函数趋向于1；当取无限小时，趋向于0。该函数表示结果输出为1的概率。</p><p>令 <span class="math display">\[\text{Z}=\overrightarrow{W}\cdot\overrightarrow{X}+b\]</span> 则逻辑回归的假设函数为 <span class="math display">\[f_{\overrightarrow{W},b}(\overrightarrow{X})=g(\vec{W}\cdot\vec{X}+b)=\frac{1}{1+e^{-(\overrightarrow{W}\cdot\overrightarrow{X}+b)}}\]</span></p><h3 id="代价函数-1">代价函数</h3><p>首先我们回顾一下之前学过的一个代价函数，线性回归的代价函数： <span class="math display">\[J(w,b)=\frac{1}{2m}\sum_{i=1}^m\bigl(f_{w,b}\bigl(x^{(i)}\bigr)-y^{(i)}\bigr)^2\]</span> 如果把此代价函数用在逻辑回归中会怎么样？我们看一下应用该代价函数的代价函数图：</p><p><img src="/img/机器学习/Snipaste_2023-06-12_17-13-32.png" /></p><p>我们发现，，此函数不是凸函数，如果用梯度下降的话，找到的是局部最优，不是整体最优。</p><pre><code class="hljs">凸函数有个很好的性质，只要能证明是凸函数，最终解一定是全局最优解，即局部最小值是全局最小值。</code></pre><p>因此，最小二乘法代价函数不适合逻辑回归。</p><p>我们定义<strong>逻辑回归的损失函数</strong>如下（后续说明为何定义该函数）:  $$L\left(f_{\overrightarrow{{{w}}},b}\left(\overrightarrow{{{x}}}^{(i)}\right),y^{(i)}\right)=\left\{\begin{array}{rl}{{-\log\left(f_{\overrightarrow{{{w}}},b}\left(\overrightarrow{{{x}}}^{(i)}\right)\right)}}&{{\mathrm{if~}y^{(i)}=1}}\\ {{-\log\left(1-f_{\overrightarrow{{{w}}},b}\left(\overrightarrow{{{x}}}^{(i)}\right)\right)}}&{{\mathrm{if~}y^{(i)}=0}}\end{array}\right. $$</p><p>因此，逻辑回归的代价函数如下：</p><p><span class="math display">\[J(\overrightarrow{W},b)=\frac{1}{m}\sum_{i=1}^{m}L\bigl(f_{\overrightarrow{W},b}\bigl(\overrightarrow{x}^{(i)}\bigr),y^{(i)}\bigr)\]</span></p><p>由于y的取值只能是0或1，所以<strong>简化</strong>后的损失函数及代价函数如下：  $$\begin{aligned}&L{\big(}f_{\overrightarrow{{{w}}},b}{\big(}\overrightarrow{{{x}}}^{(i)}{\big)},y^{(i)}{\big)}=-y^{(i)}\mathrm{log}{\Big(}f_{\overrightarrow{{{w}}},b}{\big(}\overrightarrow{{{x}}}^{(i)}{\big)}{\Big)}-{\big(}1-y^{(i)}\big){\mathrm{log}}{\Big(}1-f_{\overrightarrow{{{w}}},b}{\big(}\overrightarrow{{{x}}}^{(i)}{\big)}{\Big)} \\&J(\overrightarrow{w},b)=\frac{1}{m}\sum_{i=1}^{m}[L\big(f_{\overrightarrow{w},b}\big(\overrightarrow{x}^{(i)}\big),y^{(i)}\big)]\end{aligned}$$</p><p>那么为什么选择了这个函数作为代价函数呢？</p><p>这个特定的代价函数是使用称为<a href="https://zhuanlan.zhihu.com/p/148968222?utm_id=0">最大似然估计</a>的统计原理从统计中推导出来的。最大似然估计是一种常用的参数估计方法，它基于样本数据，通过寻找最有可能产生这些数据的参数值，来确定模型的参数。</p><h3 id="梯度下降">梯度下降</h3><p><strong>==逻辑回归的梯度下降==</strong> <span class="math display">\[\begin{aligned}w_{j}&amp;=w_{j}-\alpha\frac{1}{m}\sum_{i=1}^{m}(f_{w,b}\big(x^{(i)}\big)-y^{(i)})x_{j}^{(i)}\\b &amp;=b-\alpha\frac{1}{m}\sum_{i=1}^{m}(f_{w,b}(x^{(i)})-y^{(i)})\end{aligned}\]</span></p><p>注意：形式与线性回归一样，但是<span class="math inline">\(f_{w,b}(x)\)</span> 表达式不同。</p><h1 id="过拟合">过拟合</h1><h2 id="欠拟合过拟合">欠拟合、过拟合</h2><p><img src="/img/机器学习/Snipaste_2023-06-13_16-57-47.png" /></p><p>左图，欠拟合（underfit），也称作高偏差（High-bias），即对于当前数据集的拟合程度不够，欠拟合的特征是在训练集和测试集上的准确率都不好；</p><p>中图，拟合刚好的状态，具有泛化能力；</p><p>右图，过拟合（overfit），也称作高方差（High variance），过拟合对于当前训练数据拟合得太好了，以至于模型只在当前的训练集上表现很好，而在其他数据集上表现就不是那么好，所以过拟合的特征是在训练集上准确率很高而在测试集上表现一般。</p><h2 id="解决过拟合">解决过拟合</h2><p>方法： 1. 收集更多的数据 2. 减少特征数量 3. 正则化</p><h3 id="特征工程">特征工程</h3><h3 id="正则化">正则化</h3><p>将正则化应用在代价函数中，使用正则化来减小参数的大小</p><p><img src="/img/机器学习/Snipaste_2023-06-14_09-11-09.png" /></p><p>如何理解上式？</p><p>因为<span class="math inline">\(w_3^2\)</span>和<span class="math inline">\(w_4^2\)</span>前的系数非常大，要想使整个式子最小化，只能令<span class="math inline">\(w_3^2\)</span>和<span class="math inline">\(w_4^2\)</span> 非常小（<span class="math inline">\(\approx0\)</span>），<span class="math inline">\(w_3\)</span>和<span class="math inline">\(w_4\)</span> 即为惩罚项。 对于右图过拟合状态，此时<span class="math inline">\(w_3\)</span>和<span class="math inline">\(w_4\)</span> 权重衰减，这样就会降低高阶项对整个函数的影响，使得拟合的函数变得比较平滑。</p><p>如果有很多的特征，那如何选择惩罚项呢？</p><p>如果有非常多的特征，你可能不知道那些特征重要，以及需要惩罚的特征。通常实现正则化的方式是惩罚<strong>所有</strong>的特征。（==为什么惩罚有利特征==）</p><p>对于预测房价实例，比如有100个特征，正则化后的代价函数如下： <span class="math display">\[J(\vec{w},b)=\frac{1}{2m}\sum_{i=1}^{m}(f_{\vec{w},b}\big(\vec{x}^{(i)}\big)-y^{(i)}\big)^2+\frac{\lambda}{2m}\sum_{j=1}^{n}\omega_{j}^2\]</span> 把上式分为两部分，左边部分即为原始的代价函数，右边部分为正则化项。λ为超参数，通常会取一个较大的数。</p><p>为了最小化整个代价函数，当λ是固定的，那么就要减小<span class="math inline">\(w_1\)</span>到<span class="math inline">\(w_n\)</span>的值。加入正则项后，<span class="math inline">\(w_1\)</span>到<span class="math inline">\(w_n\)</span>均会减小，也就是使得权重衰减，这样就会降低高阶项对于整个函数的影响，使得估计函数变得比较平滑。</p><p>我们还将λ除以2m,这样这里的第一项和第二项都在2m上按比例缩放，会更改容易选择λ的值。按照惯例我们不会因为参数b太大而惩罚它，在实践中，做与不做几乎没有什么区别。</p><p>因此，总结一下这个修改后的代价函数： <img src="/img/机器学习/Snipaste_2023-06-14_09-37-48.png" /></p><p>我们想要最小化[原始代价函数即均方误差项+第二项即正则化项]</p><p>λ : 可以控制两个不同目标之间的取舍。</p><p>此函数有两个目的，目的一：最小化预测值与真实值之间的误差，更好的拟合训练集。目的二：试图减小<span class="math inline">\(w_j\)</span> ，使假设函数变得“简单”，防止过度拟合。</p><p><strong>两者相互平衡，从而达到一种相互制约的关系，最终找到一个平衡点，从而更好地拟合训练集并且具有良好的泛化能力。</strong></p><p>不同的λ值有什么影响？</p><p>使用线性回归的房价预测示例。</p><p>如果，λ等于0，那么正则项等于零，即根本没有使用正则化，会过度拟合。 <img src="/img/机器学习/Snipaste_2023-06-14_09-59-48.png" /></p><p>当λ非常非常大时，例如<span class="math inline">\(\lambda=10^{10}\)</span>,那么<span class="math inline">\(w_1到w_4\)</span>几乎等于0，只剩常数b项，此时会欠拟合。</p><p><img src="/img/机器学习/Snipaste_2023-06-14_10-00-42.png" /></p><p>线性回归的正则化方法： <img src="/img/机器学习/Snipaste_2023-06-14_10-13-49.png" /></p><p> $$\begin{aligned}& w_{j}=w_{j}-\alpha\left[\frac{1}{m}\sum_{i=1}^{m}\left[(f_{\vec{{{w}}},b}\big(\vec{x}^{(i)}\big)-y^{(i)}\big)x_{j}^{(i)}\right]+\frac{\lambda}{m}w_{j}\right]  \\&b=b-\alpha\frac{1}{m}\sum_{i=1}^m(f_{\vec{\mathbf{w}},b}(\vec{\mathbf{x}}^{(i)})-y^{(i)})\end{aligned}$$</p><p>逻辑回归的正则化方法： <img src="/img/机器学习/Snipaste_2023-06-14_10-18-04.png" /></p><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/75364861">吴恩达机器学习笔记（三）正则化</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java13-面向对象进阶-抽象类&amp;接口&amp;内部类</title>
    <link href="/2023/06/29/Java13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E6%8A%BD%E8%B1%A1%E7%B1%BB&amp;%E6%8E%A5%E5%8F%A3&amp;%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2023/06/29/Java13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E6%8A%BD%E8%B1%A1%E7%B1%BB&amp;%E6%8E%A5%E5%8F%A3&amp;%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-抽象类">第一章 抽象类</h1><h2 id="概述">1.1 概述</h2><h3 id="抽象类引入">1.1.1 抽象类引入</h3><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的定义即可，具体实现交给子类自己去实现。<strong>我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类</strong>。</p><ul><li><strong>抽象方法</strong> ： 没有方法体的方法。</li><li><strong>抽象类</strong>：包含抽象方法的类。</li></ul><h2 id="abstract使用格式">1.2 abstract使用格式</h2><p><strong>abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。</strong></p><h3 id="抽象方法定义格式">1.2.1 抽象方法定义格式</h3><p>使用<code>abstract</code> 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">abstract</span> 返回值类型 方法名 (参数列表);<br></code></pre></td></tr></table></figure><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h3 id="抽象类定义格式">1.2.2 抽象类定义格式</h3><p>如果一个类包含抽象方法，那么该类必须是抽象类。<strong>注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。</strong></p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> class 类名字 &#123; <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>；<br>&#125;<br></code></pre></td></tr></table></figure><p><em>抽象类不一定有抽象方法：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>    System.out.printin(<span class="hljs-string">&quot;跑步&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象类的使用">1.2.3 抽象类的使用</h3><p><strong>抽象类和抽象方法的注意事项</strong></p><ul><li>抽象类不能实例化</li><li>可以有构造方法</li><li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类 要么重写抽象类中的所有抽象方法 要么是抽象类</li></ul><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父类,抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br><span class="hljs-keyword">private</span> String id;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary)</span> &#123;<br><span class="hljs-built_in">this</span>.id = id;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.salary = salary;<br>&#125;<br><br><span class="hljs-comment">// 抽象方法</span><br><span class="hljs-comment">// 抽象方法必须要放在抽象类中</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义一个子类继承抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Manager</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Manager</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary)</span> &#123;<br><span class="hljs-built_in">super</span>(id, name, salary);<br>&#125;<br><span class="hljs-comment">// 2.重写父类的抽象方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;管理其他人&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个子类继承抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Cook</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Cook</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary)</span> &#123;<br><span class="hljs-built_in">super</span>(id, name, salary);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;厨师炒菜&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo10</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 创建抽象类,抽象类不能创建对象</span><br><span class="hljs-comment">// 假设抽象类让我们创建对象,里面的抽象方法没有方法体,无法执行.所以不让我们创建对象</span><br><span class="hljs-comment">//Employee e = new Employee();</span><br><span class="hljs-comment">//e.work();</span><br><br><span class="hljs-comment">// 3.创建子类</span><br><span class="hljs-type">Manager</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>();<br>m.work();<br><br><span class="hljs-type">Cook</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cook</span>(<span class="hljs-string">&quot;ap002&quot;</span>, <span class="hljs-string">&quot;库克&quot;</span>, <span class="hljs-number">1</span>);<br>c.work();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p><h2 id="抽象类的细节">1.3 抽象类的细节</h2><p>不需要背，只要当idea报错之后，知道如何修改即可。</p><ol type="1"><li><p>抽象类<strong>不能实例化（创建对象）</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p><blockquote><p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></blockquote></li><li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p><blockquote><p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p></blockquote></li><li><p>抽象类中，不一定有抽象方法，但是有抽象方法的类必定是抽象类。</p><blockquote><p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p></blockquote></li><li><p>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。</p><blockquote><p>理解：假设子类不重写所有抽象方法，则子类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p></blockquote></li><li><p>抽象类存在的意义是为了被子类继承。</p><blockquote><p>理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。</p></blockquote></li></ol><h2 id="抽象类存在的意义">1.4 抽象类存在的意义</h2><pre><code class="hljs">抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义。抽象类可以强制让子类，一定要按照规定的格式进行重写。</code></pre><h1 id="第二章-接口">第二章 接口</h1><h2 id="概述-1">2.1 概述</h2><p>[[接口.mp4]]</p><h2 id="接口的定义">2.2 接口的定义</h2><p>接口用关键字<code>interface</code>来定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口的定义格式：</span><br>interface 接口名称&#123;<br>    <span class="hljs-comment">// 抽象方法</span><br>&#125;<br><br><span class="hljs-comment">// 接口的声明：interface</span><br><span class="hljs-comment">// 接口名称：首字母大写，满足“驼峰模式”</span><br></code></pre></td></tr></table></figure><h2 id="接口的的实现">2.3 接口的的实现</h2><h3 id="实现接口的概述">2.3.1 实现接口的概述</h3><p>在Java中接口是被实现的，类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code>implements</code>关键字。</p><h3 id="实现接口的格式">2.3.2 实现接口的格式</h3><ul><li>接口和类的实现关系，可以单实现，也可以多实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名 implements 接口<span class="hljs-number">1</span>,接口<span class="hljs-number">2</span>,接口<span class="hljs-number">3.</span>..&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现类还可以在继承一个类的同时实现多个接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名 extends 父类 implements 接口<span class="hljs-number">1</span>,接口<span class="hljs-number">2</span>,接口<span class="hljs-number">3.</span>..&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类实现接口的要求和意义">2.3.3 类实现接口的要求和意义</h3><ol type="1"><li>必须重写实现的全部接口中所有抽象方法。</li><li>如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。</li><li><strong>意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。</strong></li></ol><h3 id="实例">2.3.4 实例</h3><p>编写带有接口和抽象类的标准劁avabean类</p><p>青蛙 属性：名字，年龄 行为：吃虫子，蛙泳 狗 属性：名字，年龄 行为：吃骨头，狗刨 兔子 属性：名字，年龄 行为：吃胡萝卜</p><p><strong>父类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;  <br>  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swim</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>青蛙：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Frog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Swim</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Frog</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Frog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(name, age);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;青蛙吃虫子&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;蛙泳&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>狗：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Swim</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(name, age);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;狗吃骨头&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;狗刨&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>兔子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rabbit</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rabbit</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(name, age);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃胡萝卜&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Frog</span> <span class="hljs-variable">frog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Frog</span>();  <br>  <br>        frog.eat();  <br>        frog.swim();  <br>        &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口成员特点">2.4 接口成员特点</h2><h3 id="成员变量">2.4.1 成员变量</h3><ul><li>只能是常量</li><li>默认修饰符：public static final</li></ul><h3 id="构造方法">2.4.2 构造方法</h3><ul><li>接口中无构造方法</li></ul><h3 id="成员方法">2.4.3 成员方法</h3><ul><li>只能是抽象方法</li><li>默认修饰符：public abstract</li></ul><blockquote><p>JDK7以前：接口中只能定义抽象方法。 JDK8的新特性：接口中可以定义有方法体的方法。 JDK9的新特性：接口中可以定义私有方法。</p></blockquote><h2 id="类和接口之间的关系">2.5 类和接口之间的关系</h2><h3 id="类和类的关系">2.5.1 类和类的关系</h3><p>继承关系，只能单继承，不能多继承，但是可以多层继承</p><h3 id="类和接口的关系">2.5.2 类和接口的关系</h3><p><strong>接口与类是实现关系</strong>，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p><p><strong>若多个接口中方法重名，只需要重写一次</strong></p><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter1</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter2</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method4</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntrImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Inter1</span>,Inter2&#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method1&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method2&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method3&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method4</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method4&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口和接口的关系">2.5.3 接口和接口的关系</h3><p><strong>接口与接口是继承关系</strong>，可以单继承，也可以多继承</p><p>接口继承接口就是把其他接口的抽象方法与本接口进行了合并，如果实现类实现了最下面的子接口，那么就需要重写所有的抽象方法。</p><p>代码举例：</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter1</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter2</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Inter1</span>,Inter2 &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntrImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Inter3</span> &#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method1&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method2&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;method3&quot;</span>);  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩展接口的细节">2.6 扩展：接口的细节</h2><ol type="1"><li>当两个接口中存在相同抽象方法的时候，该怎么办？</li></ol><blockquote><p>只要重写一次即可。此时重写的方法，既表示重写1接口的，也表示重写2接口的。</p></blockquote><ol start="2" type="1"><li>实现类能不能继承A类的时候，同时实现其他接口呢？</li></ol><blockquote><p>继承的父类，就好比是亲爸爸一样 实现的接口，就好比是干爹一样 可以继承一个类的同时，再实现多个接口，只不过，要把接口里面所有的抽象方法，全部实现。</p></blockquote><ol start="3" type="1"><li>实现类能不能继承一个抽象类的时候，同时实现其他接口呢？</li></ol><blockquote><p>实现类可以继承一个抽象类的同时，再实现其他多个接口，只不过要把里面所有的抽象方法全部重写。</p></blockquote><ol start="4" type="1"><li>实现类Zi，实现了一个接口，还继承了一个Fu类。假设在接口中有一个方法，父类中也有一个相同的方法。子类如何操作呢？</li></ol><blockquote><p>处理办法一：如果父类中的方法体，能满足当前业务的需求，在子类中可以不用重写。 处理办法二：如果父类中的方法体，不能满足当前业务的需求，需要在子类中重写。</p></blockquote><ol start="5" type="1"><li>如果一个接口中，有10个抽象方法，但是我在实现类中，只需要用其中一个，该怎么办?</li></ol><blockquote><p>可以在接口跟实现类中间，新建一个中间类（适配器类） 让这个适配器类去实现接口，对接口里面的所有的方法做空重写。 让子类继承这个适配器类，想要用到哪个方法，就重写哪个方法。 因为中间类没有什么实际的意义，所以一般会把中间类定义为抽象的，不让外界创建对象</p></blockquote><h1 id="第三章-内部类">第三章 内部类</h1><h2 id="概述-2">3.1 概述</h2><h3 id="什么是内部类">3.1.1 什么是内部类</h3><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<strong>内部类</strong>，B则称为<strong>外部类</strong>。可以把内部类理解成寄生，外部类理解成宿主。</p><h3 id="什么时候使用内部类">3.1.2 什么时候使用内部类</h3><p>一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用</p><ol type="1"><li>人里面有一颗心脏。</li><li>汽车内部有一个发动机。</li><li>为了实现更好的封装性。</li></ol><h2 id="内部类的分类">3.2 内部类的分类</h2><p>按定义的位置来分</p><ol type="1"><li><strong>成员内部内</strong>，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)</li><li><strong>静态内部类</strong>，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)</li><li><strong>局部内部类</strong>，类定义在方法内</li><li><strong>匿名内部类</strong>，没有名字的内部类，可以在方法中，也可以在类中方法外。</li></ol><h2 id="成员内部类">3.3 成员内部类</h2><p><strong>成员内部类特点</strong>：</p><ul><li>无static修饰的内部类，属于外部类对象的。</li><li>宿主：外部类对象。</li></ul><p><strong>内部类的使用格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.内部类。 <span class="hljs-comment">// 访问内部类的类型都是用 外部类.内部类</span><br></code></pre></td></tr></table></figure><p><strong>获取成员内部类对象的两种方式</strong>：</p><p>方式一：外部直接创建成员内部类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.内部类 变量 = <span class="hljs-keyword">new</span> 外部类（）.new 内部类（）;<br></code></pre></td></tr></table></figure><p>方式二：在外部类中定义一个方法提供内部类的对象</p><p><strong>案例演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式一：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//  宿主：外部类对象。</span><br>       <span class="hljs-comment">// Outer out = new Outer();</span><br>        <span class="hljs-comment">// 创建内部类对象。</span><br>        Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        oi.method();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-comment">// 成员内部类，属于外部类对象的。</span><br>    <span class="hljs-comment">// 拓展：成员内部类不能定义静态成员。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-comment">// 这里面的东西与类是完全一样的。</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;内部类中的方法被调用了&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//方式二：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>        System.out.println(o.getInstance());<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="成员内部类的细节">3.4 成员内部类的细节</h2><p>编写成员内部类的注意点：</p><ol type="1"><li>成员内部类可以被一些修饰符所修饰，比如： private，默认，protected，public，static等</li><li>在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。</li><li>创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。（请参见3.6节的内存图）</li></ol><p>详解：</p><pre><code class="hljs">内部类被private修饰，外界无法直接获取内部类的对象，只能通过3.3节中的方式二获取内部类的对象被其他权限修饰符修饰的内部类一般用3.3节中的方式一直接获取内部类的对象内部类被static修饰是成员内部类中的特殊情况，叫做静态内部类下面单独学习。内部类如果想要访问外部类的成员变量，外部类的变量必须用final修饰，JDK8以前必须手动写final，JDK8之后不需要手动写，JDK默认加上。</code></pre><h2 id="成员内部类面试题">3.5 成员内部类面试题</h2><p>请在?地方向上相应代码,以达到输出的内容</p><p>注意：内部类访问外部类对象的格式是：<strong>外部类名.this</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Outer.<span class="hljs-type">inner</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">inner</span>();<br>        oi.method();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<span class="hljs-comment">// 外部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><br>    <span class="hljs-comment">// 在成员位置定义一个类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">inner</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>            System.out.println(???);<span class="hljs-comment">// 10   答案：a</span><br>            System.out.println(???);<span class="hljs-comment">// 20答案：this.a</span><br>            System.out.println(???);<span class="hljs-comment">// 30答案：Outer.this.a</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="成员内部类内存图">3.6 成员内部类内存图</h2><p><img src="/img/13-Java面向对象进阶/1e1b693f95744a3482f23182edf90ac5.png" /></p><h2 id="静态内部类">3.7 静态内部类</h2><p><strong>静态内部类特点</strong>：</p><ul><li><p>静态内部类是一种特殊的成员内部类。</p></li><li><p>有static修饰，属于外部类本身的。</p></li><li><p>总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。</p></li><li><p><strong>拓展1</strong>:静态内部类可以直接访问外部类的静态成员。</p></li><li><p><strong>拓展2</strong>:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象。</p></li><li><p><strong>拓展3</strong>:静态内部类中没有银行的Outer.this。</p></li></ul><p><strong>内部类的使用格式</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">外部类.内部类。<br></code></pre></td></tr></table></figure><p><strong>静态内部类对象的创建格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.内部类  变量 = <span class="hljs-keyword">new</span>  外部类.内部类构造器;<br></code></pre></td></tr></table></figure><p><strong>调用方法的格式：</strong></p><ul><li>调用非静态方法的格式：先创建对象，用对象调用</li><li>调用静态方法的格式：外部类名.内部类名.方法名();</li></ul><p><strong>案例演示</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 外部类：Outer01</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer01</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-type">String</span> <span class="hljs-variable">sc_name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;程序员&quot;</span>;<br>    <span class="hljs-comment">// 内部类: Inner01</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner01</span>&#123;<br>        <span class="hljs-comment">// 这里面的东西与类是完全一样的。</span><br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Inner01</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showName</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-built_in">this</span>.name);<br>            <span class="hljs-comment">// 拓展:静态内部类可以直接访问外部类的静态成员。</span><br>            System.out.println(sc_name);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClassDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建静态内部类对象。</span><br>        <span class="hljs-comment">// 外部类.内部类  变量 = new  外部类.内部类构造器;</span><br>        Outer01.<span class="hljs-type">Inner01</span> <span class="hljs-variable">in</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer01</span>.Inner01(<span class="hljs-string">&quot;张三&quot;</span>);<br>        in.showName();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="局部内部类">3.8 局部内部类</h2><ul><li><strong>局部内部类</strong> ：定义在<strong>方法中</strong>的类。</li></ul><p>定义格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">class 外部类名 &#123;<br>数据类型 变量名;<br><br>修饰符 返回值类型 方法名(参数列表) &#123;<br><span class="hljs-comment">// …</span><br>class 内部类 &#123;<br><span class="hljs-comment">// 成员变量</span><br><span class="hljs-comment">// 成员方法</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匿名内部类">3.9 匿名内部类</h2><h3 id="概述-3">3.9.1 概述</h3><p><strong>匿名内部类</strong> ：是内部类的简化写法。他是一个隐含了名字的内部类。开发中，最常用到的内部类就是匿名内部类了。</p><h3 id="格式">3.9.2 格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名或者接口名() &#123;<br>     重写方法;<br>&#125;;<br></code></pre></td></tr></table></figure><p>包含了：</p><ul><li><p>继承或者实现关系</p></li><li><p>方法重写</p></li><li><p>创建对象</p></li></ul><p>所以从语法上来讲，这个整体其实是匿名内部类对象</p><h3 id="什么时候用到匿名内部类">3.9.2 什么时候用到匿名内部类</h3><p><strong>实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用</strong></p><p><strong>是为了简化代码</strong>。</p><p>之前我们使用接口时，似乎得做如下几步操作：</p><ol type="1"><li>定义子类</li><li>重写接口中的方法</li><li>创建子类对象</li><li>调用重写后的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swim</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 1. 定义接口的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Swim</span> &#123;<br>    <span class="hljs-comment">// 2. 重写抽象方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;狗刨式...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3. 创建实现类对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-comment">// 4. 调用方法</span><br>        s.swimming();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。</p><h3 id="匿名内部类前提和格式">3.9.3 匿名内部类前提和格式</h3><p>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p><p><strong>匿名内部类格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 父类名或者接口名()&#123;<br>    <span class="hljs-comment">// 方法重写</span><br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使用方式">3.9.4 使用方式</h3><p>以接口为例，匿名内部类的使用，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swim</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用匿名内部类</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;自由泳...&quot;</span>);<br>&#125;<br>&#125;.swimming();<br><br>        <span class="hljs-comment">// 接口 变量 = new 实现类(); // 多态,走子类的重写方法</span><br>        <span class="hljs-type">Swim</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;蛙泳...&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        s2.swimming();<br>        s2.swimming();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名内部类的特点">3.9.5 匿名内部类的特点</h3><ol type="1"><li>定义一个没有名字的内部类</li><li>这个类实现了父类，或者父类接口</li><li>匿名内部类会创建这个没有名字的类的对象</li></ol><h3 id="匿名内部类的使用场景">3.9.6 匿名内部类的使用场景</h3><p>通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swim</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 普通方式传入对象</span><br>        <span class="hljs-comment">// 创建实现类对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <br>        goSwimming(s);<br>        <span class="hljs-comment">// 匿名内部类使用场景:作为方法参数传递</span><br>        <span class="hljs-type">Swim</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;蝶泳...&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">// 传入匿名内部类</span><br>        goSwimming(s3);<br><br>        <span class="hljs-comment">// 完美方案: 一步到位</span><br>        goSwimming(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;大学生, 蛙泳...&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        goSwimming(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;小学生, 自由泳...&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义一个方法,模拟请一些人去游泳</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goSwimming</span><span class="hljs-params">(Swim s)</span> &#123;<br>        s.swimming();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java12-面向对象进阶-多态&amp;包&amp;final&amp;权限修饰符</title>
    <link href="/2023/06/29/Java12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E5%A4%9A%E6%80%81&amp;%E5%8C%85&amp;final&amp;%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2023/06/29/Java12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E5%A4%9A%E6%80%81&amp;%E5%8C%85&amp;final&amp;%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-多态">第一章 多态</h1><h2 id="多态的形式">1.1 多态的形式</h2><p><strong>多态是继封装、继承之后，面向对象的第三大特性。</strong></p><p><strong>多态是出现在继承或者实现关系中的</strong>。</p><p><strong>多态体现的格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型 对象名称 = 子类对象;<br></code></pre></td></tr></table></figure><p><strong>多态的前提</strong>： - 有继承或实现关系 - 有父类引用指向子类对象 - 有方法重写</p><p>有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。</p><p>有父类引用指向子类对象 , <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Fu f = new Zi ();<br>Fu : 父类引用<br><span class="hljs-section">=  ：指向</span><br>new Zi：子类对象<br></code></pre></td></tr></table></figure></p><h2 id="多态的使用场景">1.2 多态的使用场景</h2><p>如果没有多态，在下图中register方法只能传递学生对象，其他的Teacher和administrator对象是无法传递给register方法方法的，在这种情况下，只能定义三个不同的register方法分别接收学生，老师和管理员。</p><p><img src="/img/12-Java面向对象进阶/f2052316dfd544de8072059c376fc270.png" /></p><p>有了多态之后，方法的形参就可以定义为共同的父类Person。</p><p><strong>要注意的是：</strong></p><ul><li>当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。</li><li>当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象。</li><li>而且多态还可以根据传递的不同对象来调用不同类中的方法。</li></ul><p><img src="/img/12-Java面向对象进阶/ad501eaacded4b6b85bf109877e008d9.png" /></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">父类：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 空参构造</span><br>    <span class="hljs-comment">// 带全部参数的构造</span><br>    <span class="hljs-comment">// get和set方法</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;, &quot;</span> + age);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">子类<span class="hljs-number">1</span>：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Administrator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;管理员的信息为：&quot;</span> + getName() + <span class="hljs-string">&quot;, &quot;</span> + getAge());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">子类<span class="hljs-number">2</span>：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;学生的信息为：&quot;</span> + getName() + <span class="hljs-string">&quot;, &quot;</span> + getAge());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">子类<span class="hljs-number">3</span>：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;老师的信息为：&quot;</span> + getName() + <span class="hljs-string">&quot;, &quot;</span> + getAge());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">测试类：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建三个对象，并调用register方法</span><br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>        s.setAge(<span class="hljs-number">18</span>);<br><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        t.setName(<span class="hljs-string">&quot;王建国&quot;</span>);<br>        t.setAge(<span class="hljs-number">30</span>);<br><br>        <span class="hljs-type">Administrator</span> <span class="hljs-variable">admin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Administrator</span>();<br>        admin.setName(<span class="hljs-string">&quot;管理员&quot;</span>);<br>        admin.setAge(<span class="hljs-number">35</span>);<br><br>        register(s);<br>        register(t);<br>        register(admin);<br><br>    &#125;<br><br>    <span class="hljs-comment">//这个方法既能接收老师，又能接收学生，还能接收管理员</span><br>    <span class="hljs-comment">//只能把参数写成这三个类型的父类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Person p)</span>&#123;<br>        p.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多态的定义和前提">1.3 多态的定义和前提</h2><p><strong>多态</strong>： 同类型的对象，表现出的不同形态。</p><p>Student、Teacher、Administrator都是Person表现出的不同形态。</p><p><strong>前提【重点】</strong></p><ol type="1"><li><p>有继承或者实现关系</p></li><li><p>方法的重写【意义体现：不重写，无意义】</p></li><li><p>父类引用指向子类对象【格式体现】</p><blockquote><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p></blockquote></li></ol><h2 id="多态调用成员的特点">1.4 多态调用成员的特点</h2><p>调用成员变量时：编译看左边，运行看左边</p><p>调用成员方法时：编译看左边，运行看右边</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java">  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-comment">//创建对象（多态方式）  </span><br>        <span class="hljs-comment">//Fu f = new Zi();  </span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();  <br>        <span class="hljs-comment">//调用成员变量：编译看左边，运行也看左边  </span><br>        <span class="hljs-comment">//编译看左边：javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。  </span><br>        <span class="hljs-comment">//运行也看左边：java运行代码的时候，实际获取的就是左边父类中成员变量的值  </span><br>        System.out.println(a.name);<span class="hljs-comment">//动物  </span><br>  <br>        <span class="hljs-comment">//调用成员方法：编译看左边，运行看右边  </span><br>        <span class="hljs-comment">//编译看左边：javac编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，如果没有编译失败。  </span><br>        <span class="hljs-comment">//运行看右边：java运行代码的时候，实际上运行的是子类中的方法。  </span><br>        a.show();<span class="hljs-comment">///Dog --- show方法  </span><br>  <br>        <span class="hljs-comment">//理解：  </span><br>        <span class="hljs-comment">//Animal a = new Dog();  </span><br>        <span class="hljs-comment">//现在用a去调用变量和方法的？是的  </span><br>        <span class="hljs-comment">//而a是Animal类型的，所以默认都会从Animal这个类中去找  </span><br>  <br>        <span class="hljs-comment">//成员变量：在子类的对象中，会把父类的成员变量也继承下的。对象中存在两个name 一个父name  一个子name， Animal a = new Dog();现在是的a是父类类型，所以用父类的name</span><br>        <span class="hljs-comment">//成员方法：如果子类对方法进行了重写，那么在虚方法表中是会把父类的方法进行覆盖的，所以调用的是子类的方法。  </span><br>    &#125;  <br>&#125;  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;动物&quot;</span>;  <br>  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;Animal --- show方法&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;狗&quot;</span>;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Dog --- show方法&quot;</span>);  <br>    &#125;  <br>  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;猫&quot;</span>;  <br>  <br>   <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Cat --- show方法&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多态的弊端">1.5 多态的弊端</h2><p>我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时<strong>多态的写法就无法访问子类独有功能了</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>｛<br>        System.out.println(<span class="hljs-string">&quot;动物吃东西！&quot;</span>)<br>    ｝<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);  <br>    &#125;  <br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;抓老鼠&quot;</span>);  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        a.eat();<br>        a.catchMouse();<span class="hljs-comment">//编译报错，编译看左边，Animal没有这个方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用类型转换">1.6 引用类型转换</h2><h3 id="为什么要转型">1.6.1 为什么要转型</h3><p><strong>多态的写法就无法访问子类独有功能了。</strong></p><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做向下转型。</p><p>回顾基本数据类型转换</p><ul><li><p>自动转换: 范围小的赋值给范围大的.自动完成:double d = 5;</p></li><li><p>强制转换: 范围大的赋值给范围小的,强制转换:int i = (int)3.14</p><p>多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。</p></li></ul><h3 id="向上转型自动转换">1.6.2 向上转型（自动转换）</h3><ul><li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。 当父类引用指向一个子类对象时，便是向上转型。 使用格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型  变量名 = <span class="hljs-keyword">new</span> 子类类型();<br>如：<span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure><p>原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。所以子类范围小可以直接自动转型给父类类型的变量。</p><h3 id="向下转型强制转换">1.6.3 向下转型（强制转换）</h3><ul><li><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。 一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</li></ul><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 子类类型 变量名 = (子类类型) 父类变量名; 如:</span><br><span class="hljs-type">Aniaml</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>   <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span>(Cat) a;  <br></code></pre></td></tr></table></figure><h3 id="案例演示">1.6.4 案例演示</h3><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做向下转型。</p><p>转型演示，代码如下：</p><p>定义类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;  <br>&#125;  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;抓老鼠&quot;</span>);  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">watchHouse</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;看家&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>定义测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 向上转型  </span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();  <br>        a.eat(); <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br><br>        <span class="hljs-comment">// 向下转型  </span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a;       <br>        c.catchMouse(); <span class="hljs-comment">// 调用的是 Cat 的 catchMouse</span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="转型的异常">1.6.5 转型的异常</h3><p>转型的过程中，一不小心就会遇到这样的问题，请看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 向上转型  </span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();  <br>        a.eat();               <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br><br>        <span class="hljs-comment">// 向下转型  </span><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a;       <br>        d.watchHouse();        <span class="hljs-comment">// 调用的是 Dog 的 watchHouse 【运行报错】</span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码可以通过编译，但是运行时，却报出了 <code>ClassCastException</code> ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。</p><h3 id="instanceof关键字">1.6.6 instanceof关键字</h3><p>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">变量名 <span class="hljs-keyword">instanceof</span> 数据类型 <br>如果变量属于该数据类型或者其子类类型，返回<span class="hljs-literal">true</span>。<br>如果变量不属于该数据类型或者其子类类型，返回<span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p>所以，转换前，我们最好先做一个判断，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 向上转型  </span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();  <br>        a.eat();               <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br><br>        <span class="hljs-comment">// 向下转型  </span><br>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Cat)&#123;<br>            <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a;       <br>            c.catchMouse();        <span class="hljs-comment">// 调用的是 Cat 的 catchMouse</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Dog)&#123;<br>            <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a;       <br>            d.watchHouse();       <span class="hljs-comment">// 调用的是 Dog 的 watchHouse</span><br>        &#125;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="instanceof新特性">1.6.7 instanceof新特性</h3><p>JDK14的时候提出了新特性，把判断和强转合并成了一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//新特性</span><br><span class="hljs-comment">//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d</span><br><span class="hljs-comment">//如果不是，则不强转，结果直接是false</span><br><span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Dog d)&#123;<br>    d.lookHome();<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Cat c)&#123;<br>    c.catchMouse();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;没有这个类型，无法转换&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="综合练习">1.7 综合练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">需求：根据需求完成代码:<br><span class="hljs-number">1.</span>定义狗类<br>属性：<br>年龄，颜色<br>行为:<br>eat(String something)(something表示吃的东西)<br>看家lookHome方法(无参数)<br><span class="hljs-number">2.</span>定义猫类<br>属性：<br>年龄，颜色<br>行为:<br>eat(String something)方法(something表示吃的东西)<br>逮老鼠catchMouse方法(无参数)<br><span class="hljs-number">3.</span>定义Person类<span class="hljs-comment">//饲养员</span><br>属性：<br>姓名，年龄<br>行为：<br>keepPet(Dog dog,String something)方法<br>功能：喂养宠物狗，something表示喂养的东西<br>行为：<br>keepPet(Cat cat,String something)方法<br>功能：喂养宠物猫，something表示喂养的东西<br>生成空参有参构造，set和get方法  <br><span class="hljs-number">4.</span>定义测试类(完成以下打印效果):<br>keepPet(Dog dog,String somethind)方法打印内容如下：<br>年龄为<span class="hljs-number">30</span>岁的老王养了一只黑颜色的<span class="hljs-number">2</span>岁的狗<br><span class="hljs-number">2</span>岁的黑颜色的狗两只前腿死死的抱住骨头猛吃<br>keepPet(Cat cat,String somethind)方法打印内容如下：<br>年龄为<span class="hljs-number">25</span>岁的老李养了一只灰颜色的<span class="hljs-number">3</span>岁的猫<br><span class="hljs-number">3</span>岁的灰颜色的猫眯着眼睛侧着头吃鱼<br><span class="hljs-number">5.</span>思考：<br><span class="hljs-number">1.</span>Dog和Cat都是Animal的子类，以上案例中针对不同的动物，定义了不同的keepPet方法，过于繁琐，能否简化，并体会简化后的好处？<br><span class="hljs-number">2.</span>Dog和Cat虽然都是Animal的子类，但是都有其特有方法，能否想办法在keepPet中调用特有方法？<br></code></pre></td></tr></table></figure><p>画图分析：</p><p><img src="/img/12-Java面向对象进阶/c69b99aeed55418c8b6b81d6010e95cf.png" /></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动物类（父类）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String color;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String something)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;动物在吃&quot;</span> + something);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//猫类（子类）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String color)</span> &#123;<br>        <span class="hljs-built_in">super</span>(age, color);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String something)</span> &#123;<br>        System.out.println(getAge() + <span class="hljs-string">&quot;岁的&quot;</span> + getColor() + <span class="hljs-string">&quot;颜色的猫眯着眼睛侧着头吃&quot;</span> + something);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;猫抓老鼠&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//狗类（子类）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String color)</span> &#123;<br>        <span class="hljs-built_in">super</span>(age, color);<br>    &#125;<br><br>    <span class="hljs-comment">//行为</span><br>    <span class="hljs-comment">//eat(String something)(something表示吃的东西)</span><br>    <span class="hljs-comment">//看家lookHome方法(无参数)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String something)</span> &#123;<br>        System.out.println(getAge() + <span class="hljs-string">&quot;岁的&quot;</span> + getColor() + <span class="hljs-string">&quot;颜色的狗两只前腿死死的抱住&quot;</span> + something + <span class="hljs-string">&quot;猛吃&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lookHome</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狗在看家&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//饲养员类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">//饲养狗</span><br>   <span class="hljs-comment">/* public void keepPet(Dog dog, String something) &#123;</span><br><span class="hljs-comment">        System.out.println(&quot;年龄为&quot; + age + &quot;岁的&quot; + name + &quot;养了一只&quot; + dog.getColor() + &quot;颜色的&quot; + dog.getAge() + &quot;岁的狗&quot;);</span><br><span class="hljs-comment">        dog.eat(something);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    //饲养猫</span><br><span class="hljs-comment">    public void keepPet(Cat cat, String something) &#123;</span><br><span class="hljs-comment">        System.out.println(&quot;年龄为&quot; + age + &quot;岁的&quot; + name + &quot;养了一只&quot; + cat.getColor() + &quot;颜色的&quot; + cat.getAge() + &quot;岁的猫&quot;);</span><br><span class="hljs-comment">        cat.eat(something);</span><br><span class="hljs-comment">    &#125;*/</span><br><br><br>    <span class="hljs-comment">//想要一个方法，能接收所有的动物，包括猫，包括狗</span><br>    <span class="hljs-comment">//方法的形参：可以写这些类的父类 Animal</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keepPet</span><span class="hljs-params">(Animal a, String something)</span> &#123;<br>        <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Dog d)&#123;<br>            System.out.println(<span class="hljs-string">&quot;年龄为&quot;</span> + age + <span class="hljs-string">&quot;岁的&quot;</span> + name + <span class="hljs-string">&quot;养了一只&quot;</span> + a.getColor() + <span class="hljs-string">&quot;颜色的&quot;</span> + a.getAge() + <span class="hljs-string">&quot;岁的狗&quot;</span>);<br>            d.eat(something);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Cat c)&#123;<br>            System.out.println(<span class="hljs-string">&quot;年龄为&quot;</span> + age + <span class="hljs-string">&quot;岁的&quot;</span> + name + <span class="hljs-string">&quot;养了一只&quot;</span> + c.getColor() + <span class="hljs-string">&quot;颜色的&quot;</span> + c.getAge() + <span class="hljs-string">&quot;岁的猫&quot;</span>);<br>            c.eat(something);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;没有这种动物&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建对象并调用方法</span><br>       <span class="hljs-comment">/* Person p1 = new Person(&quot;老王&quot;,30);</span><br><span class="hljs-comment">        Dog d = new Dog(2,&quot;黑&quot;);</span><br><span class="hljs-comment">        p1.keepPet(d,&quot;骨头&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        Person p2 = new Person(&quot;老李&quot;,25);</span><br><span class="hljs-comment">        Cat c = new Cat(3,&quot;灰&quot;);</span><br><span class="hljs-comment">        p2.keepPet(c,&quot;鱼&quot;);*/</span><br><br><br>        <span class="hljs-comment">//创建饲养员的对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;老王&quot;</span>,<span class="hljs-number">30</span>);<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;黑&quot;</span>);<br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;灰&quot;</span>);<br>        p.keepPet(d,<span class="hljs-string">&quot;骨头&quot;</span>);<br>        p.keepPet(c,<span class="hljs-string">&quot;鱼&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二章-包">第二章 包</h1><h2 id="包">2.1 包</h2><pre><code class="hljs">包在操作系统中其实就是一个文件夹。**包是用来分门别类的管理技术，不同的技术类放在不同的包下**，方便管理和维护。</code></pre><p>在IDEA项目中，建包的操作如下：</p><p><img src="/img/12-Java面向对象进阶/f2295f3a8bac40e983c65f20604595b9.jpeg" /></p><p><strong>包名的命名规范</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">路径名.路径名.xxx.xxx<br><span class="hljs-comment">// 例如：com.itheima.oa</span><br></code></pre></td></tr></table></figure><ul><li>包名一般是公司域名的倒写。</li><li>包名必须用”.“连接。</li><li>包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。</li></ul><h2 id="导包">2.2 导包</h2><p>什么时候需要导包？</p><pre><code class="hljs">情况一：在使用Java中提供的非核心包中的类时情况二：使用自己写的其他包中的类时</code></pre><p>什么时候不需要导包？</p><pre><code class="hljs">情况一：在使用Java核心包（java.lang）中的类时情况二：在使用同一个包中的其他类时</code></pre><h2 id="使用不同包下的同名类怎么办">2.3 使用不同包下的同名类怎么办？</h2><p>假设demo1和demo2中都有一个Student该如何使用？ - 使用全类名的形式</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用全类名的形式即可。</span><br><span class="hljs-comment">//全类名：包名 + 类名</span><br><span class="hljs-comment">//拷贝全类名的快捷键：选中类名crtl + shift + alt + c 或者用鼠标点copy，再点击copy Reference</span><br>work.demo1.<span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">work</span>.demo1.Student();<br>work.demo2.<span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">work</span>.demo2.Student();<br></code></pre></td></tr></table></figure><h1 id="第三章-权限修饰符">第三章 权限修饰符</h1><h2 id="权限修饰符">3.1 权限修饰符</h2><p>权限修饰符：是用来控制一个成员能够被访问的范围的。 可以修饰成员变量，方法，构造方法，内部类。</p><pre><code class="hljs">在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和默认修饰符的作用。</code></pre><ul><li><p>public：公共的，所有地方都可以访问。</p></li><li><p>protected：本类 ，本包，其他包中的子类都可以访问。</p></li><li><p>默认（没有修饰符）：本类 ，本包可以访问。（注意：默认是空着不写，不是default）</p></li><li><p>private：私有的，当前类可以访问。</p></li></ul><p><code>public &gt; protected &gt; 默认 &gt; private</code></p><h2 id="不同权限的访问能力">3.2 不同权限的访问能力</h2><table><thead><tr class="header"><th></th><th>public</th><th>protected</th><th>默认</th><th>private</th></tr></thead><tbody><tr class="odd"><td>同一类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr class="even"><td>同一包中的类</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr class="odd"><td>不同包的子类</td><td>√</td><td>√</td><td></td><td></td></tr><tr class="even"><td>不同包中的无关类</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><p>可见，public具有最大权限。private则是最小权限。</p><p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p><ul><li>成员变量使用<code>private</code> ，隐藏细节。</li><li>构造方法使用<code>public</code> ，方便创建对象。</li><li>成员方法使用<code>public</code> ，方便调用方法。</li></ul><h1 id="第四章-final关键字">第四章 final关键字</h1><h2 id="概述">4.1 概述</h2><pre><code class="hljs">学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。</code></pre><p>如果有一个方法我不想别人去改写里面内容，该怎么办呢？</p><p>Java提供了<code>final</code> 关键字，表示修饰的内容不可变。</p><ul><li><strong>final</strong>： 不可改变，最终的含义。可以用于修饰类、方法和变量。<ul><li>类：被修饰的类，不能被继承。</li><li>方法：被修饰的方法，不能被重写。</li><li>变量：被修饰的变量，有且仅能被赋值一次。</li></ul></li></ul><h2 id="使用方式">4.2 使用方式</h2><h3 id="修饰类">4.2.1 修饰类</h3><p>final修饰的类，不能被继承。</p><p>格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> class 类名 &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br>&#125;<br><span class="hljs-comment">// class Zi extends Fu &#123;&#125; // 报错,不能继承final的类</span><br></code></pre></td></tr></table></figure><h3 id="修饰方法">4.2.2 修饰方法</h3><p>final修饰的方法，不能被重写。 格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">final</span> 返回值类型 方法名(参数列表)&#123;<br>    <span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show1</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Fu show1&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Fu show2&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-comment">//@Override</span><br><span class="hljs-comment">//public void show1() &#123;</span><br><span class="hljs-comment">//System.out.println(&quot;Zi show1&quot;);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Zi show2&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰变量">4.2.3 修饰变量</h3><p>实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性。</p><p>常量的命名规范： - 单个单词：全部大写 - 多个单词：全部大写，单词之间用下划线隔开</p><h4 id="局部变量">4.2.3.1 局部变量</h4><ol type="1"><li><p><strong>局部变量——基本类型</strong></p><p>基本类型的局部变量，被final修饰后，只能赋值一次，变量存储的==数据值==不能再更改。</p><p>代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 声明变量，使用final修饰</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> A;<br>        <span class="hljs-comment">// 第一次赋值 </span><br>        A = <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">// 第二次赋值</span><br>        A = <span class="hljs-number">20</span>; <span class="hljs-comment">// 报错,不可重新赋值</span><br><br>        <span class="hljs-comment">// 声明变量，直接赋值，使用final修饰</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">// 第二次赋值</span><br>        B = <span class="hljs-number">20</span>; <span class="hljs-comment">// 报错,不可重新赋值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意下面两种写法，哪种可以通过编译？</p><p>写法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">C</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    C = i;<br>    System.out.println(C);<br>&#125;<br></code></pre></td></tr></table></figure><p>写法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">C</span> <span class="hljs-operator">=</span> i;<br>    System.out.println(C);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据 <code>final</code> 的定义，写法1报错！写法2通过编译呢。因为每次循环，都是一次新的变量c。</p><ol start="2" type="1"><li><p><strong>局部变量——引用类型</strong></p><p>变量存储的==地址值==不能再更改，对象内部的属性值可以改变。</p><p>代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//创建对象 </span><br><span class="hljs-keyword">final</span> Student s <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(name:<span class="hljs-string">&quot;张三&quot;</span>,age:<span class="hljs-number">23</span>);<br><span class="hljs-comment">//S = new Student(); // 报错，地址值不能再更改</span><br>S.setName(<span class="hljs-string">&quot;李四&quot;</span>); <br>S.setAge(<span class="hljs-number">24</span>); <br>System.out.println(S.getName()+<span class="hljs-string">&quot;,&quot;</span>+S.getAge());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="成员变量">4.2.3.2 成员变量</h4><p>成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个：</p><ul><li>显示初始化(在定义成员变量的时候立马赋值)（常用）；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>构造方法初始化(在构造方法中赋值一次)（不常用）。</p><p><strong>注意：每个构造方法中都要赋值一次！</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> num2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.num2 = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//     this.num2 = 20;</span><br>    &#125;<br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.num2 = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//     this.num2 = 20;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第五章-代码块">第五章 代码块</h1><h2 id="代码块的分类">5.1 代码块的分类</h2><p>局部代码块，构造代码块，静态代码块</p><h2 id="局部代码块">5.2 局部代码块</h2><p>局部代码块的作用 提前结束变量的生命周期（已淘汰）</p><h2 id="构造代码块">5.3 构造代码块</h2><p>构造代码块的作用 抽取构造方法中的重复代码（不够灵活）</p><h2 id="静态代码块">5.4 静态代码块</h2><p>随着类的加载而加载的，并且只执行一次。</p><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span>&#123;<br> 语句<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>应用场景</strong></p><p>在程序刚开始时进行数据初始化</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java11-面向对象进阶-static-继承</title>
    <link href="/2023/06/29/Java11-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-static-%E7%BB%A7%E6%89%BF/"/>
    <url>/2023/06/29/Java11-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-static-%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-复习回顾">第一章 复习回顾</h1><h2 id="如何定义类">1.1 如何定义类</h2><p>类的定义格式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 class 类名 &#123;<br>    <span class="hljs-comment">// 1.成员变量（属性）</span><br>    <span class="hljs-comment">// 2.成员方法 (行为) </span><br>    <span class="hljs-comment">// 3.构造方法 （初始化类的对象数据的）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 1.成员变量</span><br>    <span class="hljs-keyword">public</span> String name ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> sex ; <span class="hljs-comment">// &#x27;男&#x27;  &#x27;女&#x27;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何通过类创建对象">1.2 如何通过类创建对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类名 对象名称 = <span class="hljs-keyword">new</span> 类名();<br></code></pre></td></tr></table></figure><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br></code></pre></td></tr></table></figure><h2 id="封装">1.3 封装</h2><h4 id="封装的步骤">1.3.1 封装的步骤</h4><p>1.使用 <code>private</code> 关键字来修饰成员变量。</p><p>2.使用<code>public</code>修饰getter和setter方法。</p><h2 id="构造方法">1.4 构造方法</h2><h3 id="构造方法的作用">1.4.1 构造方法的作用</h3><p>在创建对象的时候，给成员变量进行初始化。</p><p>初始化即赋值的意思。</p><h3 id="构造方法的格式">1.4.2 构造方法的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 类名(形参列表) &#123;<br>    <span class="hljs-comment">// 构造体代码，执行代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="this关键字的作用">1.5 this关键字的作用</h2><h3 id="this关键字的作用-1">1.5.1 this关键字的作用</h3><p>this代表所在类的当前对象的引用（地址值），即代表当前对象。</p><h3 id="this关键字的应用">1.5.2 this关键字的应用</h3><h4 id="用于普通的gettter与setter方法">1.5.2.1 用于普通的gettter与setter方法</h4><p>this出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>      <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">0</span> &amp;&amp; age &lt; <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;年龄非法！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="用于构造方法中">1.5.2.2 用于构造方法中</h4><p>this出现在构造方法中，代表构造方法正在初始化的那个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-comment">// 无参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;&#125; <br>    <br>    <span class="hljs-comment">// 有参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二章-static关键字">第二章 static关键字</h1><h2 id="概述">2.1 概述</h2><p>以前我们定义过如下类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> sex; <span class="hljs-comment">// &#x27;男&#x27;  &#x27;女&#x27;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 无参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">// 有参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String  a)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们已经知道面向对象中，存在类和对象的概念，我们在类中定义了一些成员变量，例如name,age,sex ,结果发现这些成员变量，每个对象都存在（因为每个对象都可以访问）。</p><p>而像name ,age , sex确实是每个学生对象都应该有的属性，应该属于每个对象。</p><p>所以Java中成员（变量和方法）等是存在所属性的，Java是通过static关键字来区分的。static关键字在Java开发非常的重要，对于理解面向对象非常关键。</p><p>关于 <code>static</code> 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是<strong>属于类</strong>的是放在静态区中，没有static修饰的成员变量和方法则是<strong>属于对象</strong>的。我们上面案例中的成员变量都是没有static修饰的，所以属于每个对象。</p><h2 id="定义格式和使用">2.2 定义格式和使用</h2><p>static是静态的意思。 static可以修饰成员变量或者修饰方法。</p><h3 id="静态变量及其访问">2.2.1 静态变量及其访问</h3><p>被static修饰的成员变量，叫做静态变量（也称为类变量）。</p><p><strong>特点：</strong> - 被所有的对象共享 - 不属于对象属于类 - 随着类的加载而加载的，优先于对象出现的</p><p><strong>定义格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">static</span> 数据类型 变量名 = 初始值；    <br></code></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">schoolName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A大学&quot;</span>； <span class="hljs-comment">// 属于类，只有一份。</span><br>    <span class="hljs-comment">// .....</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>静态变量的访问:</strong> <strong>调用方式：</strong> - 类名调用 - 对象名调用</p><p><strong>格式：类名.静态变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    System.out.println(Student.schoolName); <span class="hljs-comment">// A大学</span><br>    Student.schoolName = <span class="hljs-string">&quot;B大学&quot;</span>;<br>    System.out.println(Student.schoolName); <span class="hljs-comment">// B大学</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>static内存：</strong> 因为类只有一个，所以静态成员变量在内存区域中也只存在一份。</p><h3 id="实例变量及其访问">2.2.2 实例变量及其访问</h3><p>无static修饰的成员变量属于每个对象的， 这个成员变量叫<strong>实例变量</strong>，之前我们写成员变量就是实例成员变量。</p><p><strong>需要注意的是</strong>：实例成员变量属于每个对象，必须创建类的对象才可以访问。</p><p><strong>格式：对象.实例成员变量</strong></p><h3 id="静态方法及其访问">2.2.3 静态方法及其访问</h3><p>有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为<strong>类方法或者</strong>静态方法**。 直接用 类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。</p><p>与静态成员变量一样，静态方法也是直接通过<strong>类名.方法名称</strong>即可访问。</p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">schoolName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A大学&quot;</span>； <span class="hljs-comment">// 属于类，只有一份。</span><br>    <span class="hljs-comment">// .....</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我们都学习&quot;</span>);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong> - 多用在测试类和工具类中 - Javabean类中很少会用</p><p><strong>静态成员变量的访问:</strong> - 类名调用 - 对象名调用</p><p><strong>格式：类名.静态方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    Student.study();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例方法及其访问">2.2.4 实例方法及其访问</h3><p>无static修饰的成员方法属于每个对象的，这个成员方法也叫做<strong>实例方法</strong>。</p><p><strong>需要注意的是</strong>：实例方法是属于每个对象，必须创建类的对象才可以访问。</p><p><strong>格式：对象.实例方法</strong></p><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 实例变量</span><br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-comment">// 2.方法：行为</span><br>    <span class="hljs-comment">// 无 static修饰，实例方法。属于每个对象，必须创建对象调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;学生可以跑步&quot;</span>);<br>    &#125;<br><span class="hljs-comment">// 无 static修饰，实例方法</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;学生睡觉&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-comment">// 创建对象 </span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> ;<br>    stu.name = <span class="hljs-string">&quot;徐干&quot;</span>;<br>    <span class="hljs-comment">// Student.sleep();// 报错，必须用对象访问。</span><br>    stu.sleep();<br>    stu.run();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结">2.3 小结</h2><p>1.当 <code>static</code> 修饰成员变量或者成员方法时，该变量称为<strong>静态变量</strong>，该方法称为<strong>静态方法</strong>。该类的每个对象都<strong>共享</strong>同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。</p><p>2.无static修饰的成员变量或者成员方法，称为<strong>实例变量，实例方法</strong>，实例变量和实例方法必须创建类的对象，然后通过对象来访问。</p><p>3.static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。</p><p>4.无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。</p><ul><li>静态方法中没有this关键字</li><li>==静态方法中只能调用静态==。</li><li>非静态方法可以访问所有。</li><li>静态属于类（共享），非静态属于具体对象（私有） # 第三章 继承</li></ul><h2 id="概述-1">3.1 概述</h2><h3 id="引入">3.1.1 引入</h3><p>假如我们要定义如下类: 学生类和老师类，如下。</p><p><img src="/img/11-Java面向对象进阶-static-继承/216f22f2cf044d18b22fb6ad98bbd930.png" /></p><p>假如多个类中存在相同属性和行为时，我们可以将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要<strong>继承</strong>那一个类即可。如图所示：</p><p><img src="/img/11-Java面向对象进阶-static-继承/7cbf1824bb8a4c638cdf79d539357928.png" /> <img src="/img/11-Java面向对象进阶-static-继承/07480fc3765e4a5880abfebd7f00cb5f.png" /></p><p>其中，多个类可以称为<strong>子类</strong>，单独被继承的那一个类称为<strong>父类</strong>、<strong>超类（superclass)</strong> 或者<strong>基类</strong>。</p><p>子类可以直接用父类中的东西，继承就是类与类之间的父子关系。</p><h3 id="继承的含义">3.1.2 继承的含义</h3><p><strong>继承</strong>：就是子类继承父类的<strong>属性</strong>和<strong>行为</strong>，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的<strong>非私有</strong>的属性和行为。</p><h3 id="继承的好处">3.1.3 继承的好处</h3><ol type="1"><li>提高<strong>代码的复用性</strong>（减少代码冗余，相同代码重复利用）。</li><li>使类与类之间产生了关系。</li><li>子类可以在父类的基础上，增加其他的功能，使子类更强大。</li></ol><h3 id="什么时候用继承">3.1.3 什么时候用继承</h3><p>当类与类之间，存在<strong>相同</strong>（共性）的内容，并满足子类是父类中的<strong>一种</strong>，就可以考虑使用继承，来优化代码</p><h2 id="继承的格式">3.2 继承的格式</h2><p>通过 <code>extends</code> 关键字，可以声明一个子类继承另外一个父类，定义格式如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">class 父类 &#123;<br>...<br>&#125;<br><br>class 子类 extends 父类 &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>继承的特点:</strong> Java只支持<strong>单继承</strong>，不支持<strong>多继承</strong>，但支持<strong>多层继承</strong>。 单继承: 一个类只能继承一个父类，但是Java中的子类是更加强大的。 不支持多继承: 子类不能同时继承多个父类 多层继承：子类A继承父类B,父类B可以继承父类C。 每一个类都直接或者间接的继承于Object</p><p><img src="/img/11-Java面向对象进阶-static-继承/dd9132251212437c87da4f196f38718e.png" /></p><h2 id="继承案例">3.3 继承案例</h2><h3 id="案例">3.3.1 案例</h3><p>现在有四种动物：布偶猫、中国狸花猫、哈士奇、泰迪。 暂时不考虑属性，只要考虑行为。 请按照继承的思想特点进行继承体系的设计。</p><p>四种动物分别有以下的行为： 布偶猫：吃饭、喝水、抓老鼠 中国狸花猫：吃饭、喝水、抓老鼠 。 哈士奇：吃饭、喝水、看家、拆家 泰迪：吃饭、喝水、看家、蹭一蹭</p><h3 id="案例图解分析">3.3.2 案例图解分析</h3><p><img src="/img/11-Java面向对象进阶-static-继承/d4c5fcac3a3047278bb9d34d88fa35fd.png" /></p><h3 id="案例代码实现">3.3.3 案例代码实现</h3><p><strong>1.父类Animal类</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃饭&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;喝水&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>2.子类Cat类</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;抓老鼠&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>3.子类Dog类</strong></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">watchHome</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;看家&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>4.子类布偶猫类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ragdoll</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cat</span>&#123;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5.狸花猫类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LiHua</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cat</span>&#123;  <br>      <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>6.哈士奇类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Husky</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dog</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breakHome</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;拆家&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>7.泰迪类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teddy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dog</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">touch</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;蹭一蹭&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>8.测试类</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Ragdoll</span> <span class="hljs-variable">rd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ragdoll</span>();  <br>        rd.eat();  <br>        rd.drink();  <br>        rd.catchMouse();  <br>  <br>        <span class="hljs-type">Husky</span> <span class="hljs-variable">husky</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Husky</span>();  <br>        husky.eat();  <br>        husky.drink();  <br>        husky.watchHome();  <br>        husky.breakHome();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="小结-1">3.3.4 小结</h3><p>继承实际上是子类相同的属性和行为可以定义在父类中，子类特有的属性和行为由自己定义，这样就实现了相同属性和行为的重复利用，从而提高了代码复用。</p><h2 id="子类不能继承的内容">3.4 子类不能继承的内容</h2><h3 id="结论">3.4.1 结论</h3><p><img src="/img/11-Java面向对象进阶-static-继承/622d554279034a4f8990c2e2c3f7302b.png" /></p><p><strong>子类不能继承父类的构造方法。</strong> <strong>值得注意的是子类可以继承父类的私有成员（成员变量，方法)，只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。</strong></p><h2 id="继承后的特点成员变量">3.5 继承后的特点—成员变量</h2><h3 id="成员变量不重名">3.5.1 成员变量不重名</h3><p>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<strong>没有影响的</strong>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-comment">// Fu中的成员变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-comment">// Zi中的成员变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>  <br><span class="hljs-comment">// Zi中的成员方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 访问父类中的num</span><br>System.out.println(<span class="hljs-string">&quot;Fu num=&quot;</span>+num); <span class="hljs-comment">// 继承而来，所以直接访问。</span><br><span class="hljs-comment">// 访问子类中的num2</span><br>System.out.println(<span class="hljs-string">&quot;Zi num2=&quot;</span>+num2);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建子类对象</span><br><span class="hljs-type">Zi</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>(); <br>      <span class="hljs-comment">// 调用子类中的show方法</span><br>z.show();  <br>&#125;<br>&#125;<br><br>结果：<br><span class="hljs-type">Fu</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br><span class="hljs-type">Zi</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="成员变量重名">3.5.2 成员变量重名</h3><p>如果子类父类中出现<strong>重名</strong>的成员变量，这时的访问是<strong>有影响的</strong>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu1</span> &#123;<br><span class="hljs-comment">// Fu中的成员变量。</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu1</span> &#123;<br><span class="hljs-comment">// Zi中的成员变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;<br><br>System.out.println(<span class="hljs-string">&quot;num=&quot;</span> + num);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 创建子类对象</span><br><span class="hljs-type">Zi1</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi1</span>(); <br>      <span class="hljs-comment">// 调用子类中的show方法</span><br>z1.show(); <br>&#125;<br>&#125;<br>演示结果：<br>num = <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>就近原则</strong>，先在局部变量中寻找（int num = 7），没有去本类中寻找（int num = 6），最后去父类中寻找（int num = 5），逐级往上。</p><p>如果此时想访问父类成员变量，我们可以使用super关键字。</p><h3 id="super访问父类成员变量">3.5.3 super访问父类成员变量</h3><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用<code>super</code> 关键字，修饰父类成员变量，类似于 <code>this</code> 关键字。</p><p>需要注意的是：<strong>super代表的是父类对象的引用，this代表的是当前对象的引用(当前类中的成员变量，不在方法里 非局部)。</strong></p><p><img src="/img/11-Java面向对象进阶-static-继承/b4c9ec19b8794608aac6f0b16fc22baa.png" /></p><p><strong>使用格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">super</span>.父类成员变量名<br></code></pre></td></tr></table></figure><p>子类方法需要修改，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-comment">// Fu中的成员变量。</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-comment">// Zi中的成员变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <br>        <span class="hljs-comment">// 访问方法中的num</span><br>        System.out.println(<span class="hljs-string">&quot;method num=&quot;</span> + num);<br>        <span class="hljs-comment">// 访问子类中的num</span><br>        System.out.println(<span class="hljs-string">&quot;Zi num=&quot;</span> + <span class="hljs-built_in">this</span>.num);<br>        <span class="hljs-comment">// 访问父类中的num</span><br>        System.out.println(<span class="hljs-string">&quot;Fu num=&quot;</span> + <span class="hljs-built_in">super</span>.num);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 创建子类对象</span><br><span class="hljs-type">Zi1</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi1</span>(); <br>      <span class="hljs-comment">// 调用子类中的show方法</span><br>z1.show(); <br>&#125;<br>&#125;<br><br>演示结果：<br>method num=<span class="hljs-number">1</span><br>Zi num=<span class="hljs-number">6</span><br>Fu num=<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><blockquote><p>小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？可以在父类中提供公共的getXxx方法和setXxx方法。</p></blockquote><h2 id="继承后的特点成员方法">3.6 继承后的特点—成员方法</h2><p>当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？</p><h3 id="成员方法不重名">3.6.1 成员方法不重名</h3><p>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响的</strong>，<strong>就近原则</strong>。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Fu类中的show方法执行&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Zi类中的show2方法执行&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Zi</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();<br>     <span class="hljs-comment">//子类中没有show方法，但是可以找到父类方法去执行</span><br>z.show(); <br>z.show2();<br>&#125;<br>&#125;<br><br><br>结果：<br>Fu类中的show方法执行<br>Zi类中的show2方法执行<br></code></pre></td></tr></table></figure><h3 id="成员方法重名">3.6.2 成员方法重名</h3><p>如果子类父类中出现<strong>重名</strong>的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Fu show&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br><span class="hljs-comment">//子类重写了父类的show方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Zi show&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendsDemo05</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Zi</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();<br>     <span class="hljs-comment">// 子类中有show方法，只执行重写后的show方法</span><br>z.show();  <span class="hljs-comment">// Zi show</span><br><br>&#125;<br>&#125;<br><br>结果：<br>Zi show<br></code></pre></td></tr></table></figure><h2 id="方法重写">3.7 方法重写</h2><h3 id="概念">3.7.1 概念</h3><p><strong>方法重写</strong> ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>建立在子父类关系上，同个方法名同但是内容不同就是重写</strong>。</p><h3 id="使用场景与案例">3.7.2 使用场景与案例</h3><p>当父类的方法不能满足子类现在的需求，需要进行方法重写</p><p>子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方法（覆盖虚方法表中的方法）。</p><p>例如：我们定义了一个动物类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>  &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;动物跑的很快！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;动物都可以叫~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后定义一个猫类，猫可能认为父类cry()方法不能满足自己的需求</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;猫喵喵叫&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 创建子类对象</span><br>      <span class="hljs-type">Cat</span> <span class="hljs-variable">ddm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        <span class="hljs-comment">// 调用父类继承而来的方法</span><br>        ddm.run();<br>      <span class="hljs-comment">// 调用子类重写的方法</span><br>      ddm.cry();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="override重写注解">3.7.2 <span class="citation" data-cites="Override重写注解">@Override重写注解</span></h3><ul><li><p><span class="citation" data-cites="Override:注解">@Override:注解</span>，重写注解校验！</p></li><li><p>这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。</p></li><li><p>建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！</p><p>加上后的子类代码形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>     <span class="hljs-comment">// 声明不变，重新实现</span><br>    <span class="hljs-comment">// 方法名称与父类全部一样，只是方法体中的功能重写写了！</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;猫咪没有在叫&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="方法重写的本质">3.7.3 方法重写的本质</h3><p>如果发生了重写，则会覆盖，覆盖虚方法表中的方法。</p><p>B类继承C类方法： <img src="/img/11-Java面向对象进阶-static-继承/64667a9e3a924fbeb9f11ef31bfc589c.png" /></p><p>B类重写method2： <img src="/img/11-Java面向对象进阶-static-继承/0ba51ed75f0b4e90aedd47614d59a0f6.png" /></p><p>A类再次重写method2：</p><p><img src="/img/11-Java面向对象进阶-static-继承/c69ef5a5ee5f413ea782ca8d307a410a.png" /></p><h3 id="注意事项">3.7.4 注意事项</h3><ol type="1"><li>方法重写是发生在子父类之间的关系。</li><li>重写方法的名称、形参列表必须与父类中的一致。</li><li>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li><li>子类重写父类方法时，返回值类型子类必须小于等于父类</li><li>只有被添加到虚方法表中的方法才能被重写</li></ol><h2 id="继承后的特点构造方法">3.8 继承后的特点—构造方法</h2><h3 id="特点">3.8.1 特点</h3><ul><li>构造方法的名字是与类名一致的。所以子类无法继承父类构造方法的。</li><li>子类中所有的构造方法默认先访问父类中的无参构造，再执行自己。</li></ul><p><strong>为什么？</strong> - 构造方法的作用是初始化对象成员变量数据的。子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。 - ==子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化。==</p><p><strong>如何调用父类构造方法的？</strong> - 子类构造方法的第一行语句默认都是<code>super();</code>==不写也存在，且必须在第一行==。 - 如果想调用父类有参构造，必须手动写super进行调用</p><p><strong>继承后子类构方法器特点:子类所有构造方法的第一行都会默认先调用父类的无参构造方法</strong></p><h3 id="案例演示">3.8.2 案例演示</h3><p>按如下需求定义类:</p><ol type="1"><li>人类 成员变量: 姓名,年龄</li><li>学生类 成员变量: 姓名,年龄,成绩</li></ol><p>代码如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类无参&quot;</span>);<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <br>    <span class="hljs-built_in">this</span>.name = name;  <br>    <span class="hljs-built_in">this</span>.age = age;  <br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">//super(); // 调用父类无参,默认就存在，可以不写，必须再第一行  </span><br>    System.out.println(<span class="hljs-string">&quot;子类无参&quot;</span>);  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;  <br>    <span class="hljs-built_in">super</span>(name, age);  <span class="hljs-comment">// 调用父类有参构造  </span><br>    System.out.println(<span class="hljs-string">&quot;父类有参&quot;</span>);  <br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(); <span class="hljs-comment">//无参构造创建对象  </span><br>System.out.println(<span class="hljs-string">&quot;----------&quot;</span>);  <br>  <br><span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">23</span>);  <br>System.out.println(s2.name+<span class="hljs-string">&quot; &quot;</span>+ s2.age);<br>    &#125;<br>&#125;<br><br>输出结果：<br>父类无参<br>子类无参<br>----------<br>父类有参<br>zhangsan <span class="hljs-number">23</span><br></code></pre></td></tr></table></figure></p><p><strong>父类无参：</strong></p><p><img src="/img/11-Java面向对象进阶-static-继承/adb03faf41054ee8af43e112dbcea5b2.png" /></p><p><strong>父类有参：</strong></p><p><img src="/img/11-Java面向对象进阶-static-继承/821a536041a14c65bba450515cd78e51.png" /></p><h3 id="小结-2">3.8.3 小结</h3><ul><li>子类不能继承父类的构造方法，但是可以通过super调用</li><li>子类构造方法的第一行，有一个默认的super(0:</li><li>默认先访问父类中无参的构造方法，再执行自己。</li><li>如果想要方法文父类有参构造，必须手动书写。</li></ul><h2 id="super...和this...总结">3.9 super(...)和this(...)总结</h2><h3 id="总结">3.9.1 总结</h3><p>this : 理解为一个变量，表示当前方法调用者的地址值； super : 代表父类存储空间</p><h3 id="super和this的用法格式">3.9.2 super和this的用法格式</h3><p>访问成员变量格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.成员变量    --    本类的<br><span class="hljs-built_in">super</span>.成员变量    --    父类的<br><br></code></pre></td></tr></table></figure><p>访问成员方法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.成员方法名()  --    本类的    <br><span class="hljs-built_in">super</span>.成员方法名()   --    父类的<br></code></pre></td></tr></table></figure><p>访问构造方法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">super</span>(...) -- 调用父类的构造方法，根据参数匹配确认<br><span class="hljs-built_in">this</span>(...) -- 调用本类的其他构造方法，根据参数匹配确认<br></code></pre></td></tr></table></figure><h3 id="super....用法演示">3.9.3 super(....)用法演示</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;凤姐&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类无参&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name , <span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name ;<br>        <span class="hljs-built_in">this</span>.age = age ;<br>    &#125;<br><br>    <span class="hljs-comment">// getter/setter省略</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行</span><br>        System.out.println(<span class="hljs-string">&quot;子类无参&quot;</span>);<br>    &#125;<br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name ， <span class="hljs-type">int</span> age，<span class="hljs-type">double</span> score)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name ,age);<span class="hljs-comment">// 调用父类有参构造方法Person(String name , int age)初始化name和age</span><br>        <span class="hljs-built_in">this</span>.score = score;    <br>        System.out.println(<span class="hljs-string">&quot;子类有参&quot;</span>);<br>     &#125;<br>      <span class="hljs-comment">// getter/setter省略</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 调用子类有参数构造方法</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>，<span class="hljs-number">20</span>，<span class="hljs-number">99</span>);<br>        System.out.println(s2.getScore()); <span class="hljs-comment">// 99</span><br>        System.out.println(s2.getName()); <span class="hljs-comment">// 输出 张三</span><br>        System.out.println(s2.getAge()); <span class="hljs-comment">// 输出 20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p><p>super(..)是根据参数去确定调用父类哪个构造方法的。</p><h3 id="super...案例图解">3.9.4 super(...)案例图解</h3><p><strong>父类空间优先于子类对象产生</strong></p><p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造七调用时，一定先调用父类的构造方法。理解图解如下：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fN0EXS8c-1682256310760)(./附件/13.jpg)]</p><h3 id="this...用法演示">3.9.5 this(...)用法演示</h3><p>this(...) * 默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。 * 为了借用其他构造方法的功能。 * 一般给一些数据赋默认值时会用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age ;<br>    <span class="hljs-keyword">private</span> String school ;<br><br><span class="hljs-comment">//需求：学校默认为xxx大学</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//调用本类其他构造方法</span><br><span class="hljs-comment">//虚拟机不会在添加super（）</span><br>        <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;xxx大学&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, <span class="hljs-type">char</span> sex)</span> &#123;<br>    <span class="hljs-comment">//不会在添加super();</span><br>        <span class="hljs-built_in">this</span>.name = name ;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.school = school;<br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>注意： - this（）必须写在第一行 - 虚拟机不会在添加super（）</p><h3 id="小结-3">3.9.6 小结</h3><ul><li><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p></li><li><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p></li><li><p><strong>super(..)和this(...)是根据参数去确定调用父类哪个构造方法的。</strong></p></li><li><p>super(..)可以调用父类构造方法初始化继承自父类的成员变量的数据。</p></li><li><p>this(..)可以调用本类中的其他构造方法。</p></li></ul><h2 id="练习">4. 练习</h2><p>写一个继承结构下的标准Javabean</p><p><strong>需求：</strong> 1.经理 成员变量：工号，姓名，工资，管理奖金 成员方法：工作（管理其他人），吃饭（吃米饭）</p><p>2.厨师 成员变量：工号，姓名，工资 成员方法：工作（炒菜），吃饭（吃米饭）</p><p><strong>代码示例：</strong></p><p><strong>父类Worker</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> extent4;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> &#123;  <br>    <span class="hljs-keyword">private</span> String id;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.id = id;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.salary = salary;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> id;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(String id)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.id = id;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSalary</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> salary;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSalary</span><span class="hljs-params">(<span class="hljs-type">double</span> salary)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.salary = salary;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;工作&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃米饭&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>子类Manger</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> extent4;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Worker</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> bonus;  <br>  <br>  <br>    <span class="hljs-comment">//空参构造  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Manager</span><span class="hljs-params">()</span> &#123;  <br>  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 带全部参数的构造（父类和子类所有的成员变量）  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Manager</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary, <span class="hljs-type">double</span> bonus)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(id, name, salary);  <br>        <span class="hljs-built_in">this</span>.bonus = bonus;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-comment">// 只用写子类的get&amp;set  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getBonus</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> bonus;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBonus</span><span class="hljs-params">(<span class="hljs-type">double</span> bonus)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.bonus = bonus;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;管理其他人&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>子类Cook</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> extent4;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Worker</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cook</span><span class="hljs-params">()</span> &#123;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cook</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(id, name, salary);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;炒菜&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> extent4;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Manager</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>(<span class="hljs-string">&quot;00a&quot;</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">8888</span>, <span class="hljs-number">6666</span>);  <br>        System.out.println(manager.getId() + <span class="hljs-string">&quot;, &quot;</span> + manager.getName() + <span class="hljs-string">&quot;, &quot;</span> + manager.getSalary() + <span class="hljs-string">&quot;, &quot;</span> + manager.getBonus());  <br>        manager.job();  <br>        manager.eat();  <br>  <br>  <br>        <span class="hljs-type">Cook</span> <span class="hljs-variable">cook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cook</span>();  <br>        cook.setId(<span class="hljs-string">&quot;002&quot;</span>);  <br>        cook.setName(<span class="hljs-string">&quot;lisi&quot;</span>);  <br>        cook.setSalary(<span class="hljs-number">6666</span>);  <br>        System.out.println(cook.getId() + <span class="hljs-string">&quot;, &quot;</span> + cook.getName() + <span class="hljs-string">&quot;, &quot;</span> + cook.getSalary());  <br>        cook.job();  <br>        cook.eat();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java10-集合ArrayList</title>
    <link href="/2023/06/29/Java10-%E9%9B%86%E5%90%88ArrayList/"/>
    <url>/2023/06/29/Java10-%E9%9B%86%E5%90%88ArrayList/</url>
    
    <content type="html"><![CDATA[<h2 id="arraylist">1.ArrayList</h2><h3 id="集合和数组的优势对比">集合和数组的优势对比：</h3><ol type="1"><li>长度可变</li><li>添加数据的时候不需要考虑索引，默认将数据添加到末尾</li></ol><h3 id="arraylist类概述">1.1 ArrayList类概述</h3><ul><li><p>什么是集合</p><p>提供一种存储空间==可变==的存储模型，存储的数据容量可以发生改变</p></li><li><p>ArrayList集合的特点</p><p>长度可以变化，只能存储引用数据类型。</p></li><li><p>泛型的使用</p><p>用于<em>约束</em>集合中存储元素的<em>数据类型</em></p></li></ul><h3 id="arraylist类常用方法">1.2 ArrayList类常用方法</h3><h4 id="构造方法">1.2.1 构造方法</h4><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public ArrayList()</td><td>创建一个空的集合对象</td></tr></tbody></table><p>格式：<code>ArrayList&lt;E&gt; array = new ArrayList&lt;E&gt;();</code></p><h4 id="成员方法">1.2.2 成员方法</h4><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public boolean add(要添加的元素)</td><td>将指定的元素追加到此集合的末尾</td></tr><tr class="even"><td>public boolean remove(要删除的元素)</td><td>删除指定元素,返回值表示是否删除成功</td></tr><tr class="odd"><td>public E remove(int index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr class="even"><td>public E set(int index,E element)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr class="odd"><td>public E get(int index)</td><td>返回指定索引处的元素</td></tr><tr class="even"><td>public int size()</td><td>返回集合中的元素的个数</td></tr></tbody></table><h4 id="示例代码">1.2.3 示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayListDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建集合</span><br>        ArrayList&lt;String&gt; array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>        <span class="hljs-comment">//添加元素</span><br>        array.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        array.add(<span class="hljs-string">&quot;world&quot;</span>);<br>        array.add(<span class="hljs-string">&quot;java&quot;</span>);<br><br>        <span class="hljs-comment">//public boolean remove(Object o)：删除指定的元素，返回删除是否成功</span><br>        array.remove(<span class="hljs-string">&quot;world&quot;</span>)); <span class="hljs-comment">// true</span><br>        array.remove(<span class="hljs-string">&quot;javaee&quot;</span>));<span class="hljs-comment">// false</span><br><br>        <span class="hljs-comment">//public E remove(int index)：删除指定索引处的元素，返回被删除的元素</span><br>        array.remove(<span class="hljs-number">1</span>); <span class="hljs-comment">// world</span><br><br>        <span class="hljs-comment">//IndexOutOfBoundsException</span><br>        array.remove(<span class="hljs-number">3</span>); <span class="hljs-comment">//IndexOutOfBoundsException</span><br><br>        <span class="hljs-comment">//public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素</span><br>        array.set(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;javaee&quot;</span>); <span class="hljs-comment">//返回world。把1索引的值改成javaee</span><br><br>        <span class="hljs-comment">//IndexOutOfBoundsException</span><br>        array.set(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;javaee&quot;</span>);<span class="hljs-comment">// IndexOutOfBoundsException</span><br><br>        <span class="hljs-comment">//public E get(int index)：返回指定索引处的元素</span><br>        array.get(<span class="hljs-number">0</span>); <br>        array.get(<span class="hljs-number">1</span>);<br>        array.get(<span class="hljs-number">2</span>);<br>        <br><br>        <span class="hljs-comment">//public int size()：返回集合中的元素的个数</span><br>        array.size();<br><br>        <span class="hljs-comment">//输出集合</span><br>        System.out.println(<span class="hljs-string">&quot;array:&quot;</span> + array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="arraylist遍历">1.3 ArrayList遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//遍历</span><br><span class="hljs-comment">//快捷键: list.fori 正向遍历</span><br><span class="hljs-comment">//list.forr 倒着遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>        System.out.println(list.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基本数据类型对应的包装类">1.4 基本数据类型对应的包装类</h3><p>byte Byte shot Short char Char int Interger long Long float Float double Double boolean Boolean</p><h3 id="添加对象">1.5 添加对象</h3><p>需求：</p><p>1，main方法中定义一个集合，存入三个用户对象。</p><p>用户属性为：id，username，password</p><p>2，要求：定义一个方法，根据id查找对应的学生信息。</p><p>如果存在，返回索引</p><p>如果不存在，返回-1</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayListDemo6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*需求：</span><br><span class="hljs-comment">        1，main方法中定义一个集合，存入三个用户对象。</span><br><span class="hljs-comment">        用户属性为：id，username，password</span><br><span class="hljs-comment">        2，要求：定义一个方法，根据id查找对应的学生信息。</span><br><span class="hljs-comment">        如果存在，返回索引</span><br><span class="hljs-comment">        如果不存在，返回-1*/</span><br><br><br>        <span class="hljs-comment">//1.创建集合对象</span><br>        ArrayList&lt;User&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">//2.创建用户对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;heima001&quot;</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;heima002&quot;</span>, <span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;heima003&quot;</span>, <span class="hljs-string">&quot;wangwu&quot;</span>, <span class="hljs-string">&quot;1234qwer&quot;</span>);<br><br>        <span class="hljs-comment">//3.把用户对象添加到集合当中</span><br>        list.add(u1);<br>        list.add(u2);<br>        list.add(u3);<br><br>        <span class="hljs-comment">//4.调用方法，通过id获取对应的索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> getIndex(list, <span class="hljs-string">&quot;heima001&quot;</span>);<br><br>        System.out.println(index);<br><br>    &#125;<br><br><br>    <span class="hljs-comment">//1.我要干嘛？  根据id查找对应的学生信息</span><br>    <span class="hljs-comment">//2.我干这件事情需要什么才能完成？   集合 id</span><br>    <span class="hljs-comment">//3.方法的调用处是否需要继续使用方法的结果？</span><br>    <span class="hljs-comment">//要用必须返回，不要用可以返回也可以不返回</span><br>    <span class="hljs-comment">//明确说明需要有返回值 int</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIndex</span><span class="hljs-params">(ArrayList&lt;User&gt; list, String id)</span> &#123;<br>        <span class="hljs-comment">//遍历集合得到每一个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> u.getId();<br>            <span class="hljs-keyword">if</span>(uid.equals(id))&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//因为只有当集合里面所有的元素都比较完了，才能断定id是不存在的。</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="判断用户的是否存在">1.6 判断用户的是否存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayListDemo5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">/* 需求：</span><br><span class="hljs-comment">        1，main方法中定义一个集合，存入三个用户对象。</span><br><span class="hljs-comment">        用户属性为：id，username，password</span><br><span class="hljs-comment">        2，要求：定义一个方法，根据id查找对应的学生信息。</span><br><span class="hljs-comment">        如果存在，返回true</span><br><span class="hljs-comment">        如果不存在，返回false*/</span><br><br>        <span class="hljs-comment">//1.定义集合</span><br>        ArrayList&lt;User&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">//2.创建对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;heima001&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;heima002&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;12345678&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;heima003&quot;</span>,<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-string">&quot;1234qwer&quot;</span>);<br><br>        <span class="hljs-comment">//3.把用户对象添加到集合当中</span><br>        list.add(u1);<br>        list.add(u2);<br>        list.add(u3);<br><br>        <span class="hljs-comment">//4.调用方法，查询id是否存在</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> contains(list, <span class="hljs-string">&quot;heima001&quot;</span>);<br>        System.out.println(result);<br><br>    &#125;<br><br>    <span class="hljs-comment">//定义在测试类中的方法需要加static</span><br>    <span class="hljs-comment">//1.我要干嘛？ 我要根据id查询学生是否存在</span><br>    <span class="hljs-comment">//2.我干这件事情，需要什么才能完成？ 集合 id</span><br>    <span class="hljs-comment">//3.方法的调用处是否需要使用方法的结果？</span><br>    <span class="hljs-comment">//如果要用，必须返回，如果不用，可以返回也可以不返回</span><br>    <span class="hljs-comment">//但是本题明确说明需要返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(ArrayList&lt;User&gt; list, String id)</span>&#123;<br>        <span class="hljs-comment">//循环遍历集合，得到集合里面的每一个元素</span><br>        <span class="hljs-comment">//再进行判断</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-comment">//i 索引  list.get(i); 元素</span><br>            <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-comment">//判断id是否存在，我是拿着谁跟谁比较</span><br>            <span class="hljs-comment">//需要把用户对象里面的id拿出来再进行比较。</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> u.getId();<br>            <span class="hljs-keyword">if</span>(id.equals(uid))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//return 关键字：作用就是结束方法。</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//只有当集合里面所有的元素全部比较完毕才能认为是不存在的。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java09-字符串</title>
    <link href="/2023/06/29/Java09-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/06/29/Java09-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="string类">1.String类</h2><h3 id="string类概述">1.1String类概述</h3><pre><code class="hljs">String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！</code></pre><h3 id="string类的特点">1.2String类的特点</h3><ul><li>字符串不可变，它们的值在创建后不能被更改</li><li>虽然 String 的值是不可变的，但是它们可以被共享</li><li>字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )</li></ul><h3 id="string类的构造方法">1.3String类的构造方法</h3><ul><li><p>常用的构造方法</p><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public String()</td><td>创建一个空白字符串对象，不含有任何内容</td></tr><tr class="even"><td>public String(char[] chs)</td><td>根据字符数组的内容，来创建字符串对象</td></tr><tr class="odd"><td>public String(byte[] bys)</td><td>根据字节数组的内容，来创建字符串对象</td></tr><tr class="even"><td>String s = “abc”;</td><td>直接赋值的方式创建字符串对象，内容就是abc</td></tr></tbody></table></li></ul><h3 id="创建字符串对象两种方式的区别">1.4创建字符串对象两种方式的区别</h3><ul><li><p>通过构造方法创建 通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同</p></li><li><p>直接赋值方式创建 当使用双引号直接赋值时，系统会检查该字符串在串池中是否存在。 不存在：创建新的 存在：复用</p></li></ul><p>String是个引用类型,有它的属性和方法,继承obj,只不过重写了返回的对象是他自己,也就是字符组。</p><p>赋值：在串池里面，new出来的：在堆里面 串池也是堆内存中开辟的一个空间</p><h3 id="字符串的比较">1.5字符串的比较</h3><h4 id="号的作用">1.5.1 <code>==</code> 号的作用</h4><ul><li>比较基本数据类型：比较的是具体的值</li><li>比较引用数据类型：比较的是对象地址值</li></ul><h4 id="equals方法的作用">1.5.2equals方法的作用</h4><ul><li>方法介绍</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> s1.equals(s2)     比较两个字符串内容是否完全相同、区分大小写<br>           equalsIgnoreCase        忽略大小写<br></code></pre></td></tr></table></figure><ul><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//构造方法的方式得到对象</span><br>        <span class="hljs-type">char</span>[] chs = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs);<br><br>        <span class="hljs-comment">//直接赋值的方式得到对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><br>        <span class="hljs-comment">//比较字符串对象地址是否相同</span><br>        System.out.println(s1 == s2);<br>        System.out.println(s1 == s3);<br>        System.out.println(s3 == s4);<br>        System.out.println(<span class="hljs-string">&quot;--------&quot;</span>);<br><br>        <span class="hljs-comment">//比较字符串内容是否相同</span><br>        System.out.println(s1.equals(s2));<br>        System.out.println(s1.equals(s3));<br>        System.out.println(s3.equals(s4));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="遍历字符串案例">1.6遍历字符串案例</h3><p>. charAt(索引)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符串直接遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//两个方法：</span><br>        <span class="hljs-comment">//charAt()：会根据索引获取对应的字符</span><br>        <span class="hljs-comment">//length(): 会返回字符串的长度</span><br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str.charAt(i);<br>            System.out.println(c);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="统计字符次数案例">1.7统计字符次数案例</h3><h4 id="案例需求">1.7.1案例需求</h4><pre><code class="hljs">键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数(不考虑其他字符)</code></pre><h4 id="代码实现">1.7.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 统计个数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//键盘录入一个字符串，统计大写，小写，数字出现的次数</span><br><br><br>        <span class="hljs-comment">//1.键盘录入一个字符串</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入一个字符串&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.next();<br><br><br>        <span class="hljs-comment">//2.统计 --- 计数器count</span><br>        <span class="hljs-comment">//此时我要统计的有3样东西，所以要定义3个计数器分别进行统计</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bigCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">smallCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numberCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//得到这个字符串里面每一个字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str.charAt(i);<br>            <span class="hljs-comment">//对c进行判断</span><br>            <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>                smallCount++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)&#123;<br>                bigCount++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                numberCount++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//3.当循环结束之后，三个变量记录的就是对应的个数</span><br>        System.out.println(<span class="hljs-string">&quot;大写字符有:&quot;</span> + bigCount + <span class="hljs-string">&quot;个&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;小写字符有:&quot;</span> + smallCount + <span class="hljs-string">&quot;个&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;数字字符有:&quot;</span> + numberCount + <span class="hljs-string">&quot;个&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="金额转换">1.8 金额转换</h3><h4 id="案例需求-1">1.8.1 案例需求</h4><pre><code class="hljs">把2135变成：零佰零拾零万贰仟壹佰叁拾伍元 把789变成：零佰零拾零万零仟柒佰捌拾玖元</code></pre><h4 id="代码实现-1">1.8.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.键盘录入一个金额</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> money;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;请录入一个金额&quot;</span>);<br>            money = sc.nextInt();<br>            <span class="hljs-keyword">if</span> (money &gt;= <span class="hljs-number">0</span> &amp;&amp; money &lt;= <span class="hljs-number">9999999</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;金额无效&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//定义一个变量用来表示钱的大写</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">moneyStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">//2.得到money里面的每一位数字,再转成中文</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-comment">//2135</span><br>            <span class="hljs-comment">//从右往左获取数据，因为右侧是数据的个位</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">ge</span> <span class="hljs-operator">=</span> money % <span class="hljs-number">10</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">capitalNumber</span> <span class="hljs-operator">=</span> getCapitalNumber(ge);<br>            <span class="hljs-comment">//把转换之后的大写拼接到moneyStr当中</span><br>            moneyStr = capitalNumber + moneyStr;<br>            <span class="hljs-comment">//第一次循环 ： &quot;伍&quot; + &quot;&quot; = &quot;伍&quot;</span><br>            <span class="hljs-comment">//第二次循环 ： &quot;叁&quot; + &quot;伍&quot; = &quot;叁伍&quot;</span><br>            <span class="hljs-comment">//去掉刚刚获取的数据</span><br>            money = money / <span class="hljs-number">10</span>;<br><br>            <span class="hljs-comment">//如果数字上的每一位全部获取到了，那么money记录的就是0，此时循环结束</span><br>            <span class="hljs-keyword">if</span> (money == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//3.在前面补0，补齐7位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span> - moneyStr.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            moneyStr = <span class="hljs-string">&quot;零&quot;</span> + moneyStr;<br>        &#125;<br>        System.out.println(moneyStr);<span class="hljs-comment">//零零零贰壹叁伍</span><br><br>        <span class="hljs-comment">//4.插入单位</span><br>        <span class="hljs-comment">//定义一个数组表示单位</span><br>        String[] arr = &#123;<span class="hljs-string">&quot;佰&quot;</span>,<span class="hljs-string">&quot;拾&quot;</span>,<span class="hljs-string">&quot;万&quot;</span>,<span class="hljs-string">&quot;仟&quot;</span>,<span class="hljs-string">&quot;佰&quot;</span>,<span class="hljs-string">&quot;拾&quot;</span>,<span class="hljs-string">&quot;元&quot;</span>&#125;;<br>        <span class="hljs-comment">//               零    零   零   贰   壹   叁   伍</span><br><br>        <span class="hljs-comment">//遍历moneyStr，依次得到 零    零   零   贰   壹   叁   伍</span><br>        <span class="hljs-comment">//然后把arr的单位插入进去</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; moneyStr.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> moneyStr.charAt(i);<br>            <span class="hljs-comment">//把大写数字和单位拼接到result当中</span><br>            result = result + c + arr[i];<br>        &#125;<br><br>        <span class="hljs-comment">//5.打印最终结果</span><br>        System.out.println(result);<br><br>    &#125;<br><br><br>    <span class="hljs-comment">//定义一个方法把数字变成大写的中文</span><br>    <span class="hljs-comment">//1 -- 壹</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getCapitalNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-comment">//定义数组，让数字跟大写的中文产生一个对应关系</span><br>        String[] arr = &#123;<span class="hljs-string">&quot;零&quot;</span>, <span class="hljs-string">&quot;壹&quot;</span>, <span class="hljs-string">&quot;贰&quot;</span>, <span class="hljs-string">&quot;叁&quot;</span>, <span class="hljs-string">&quot;肆&quot;</span>, <span class="hljs-string">&quot;伍&quot;</span>, <span class="hljs-string">&quot;陆&quot;</span>, <span class="hljs-string">&quot;柒&quot;</span>, <span class="hljs-string">&quot;捌&quot;</span>, <span class="hljs-string">&quot;玖&quot;</span>&#125;;<br>        <span class="hljs-comment">//返回结果</span><br>        <span class="hljs-keyword">return</span> arr[number];<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="手机号屏蔽">1.9 手机号屏蔽</h3><p>需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽</p><p>最终效果为：<code>131****9468</code></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 手机号屏蔽</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test8</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽</span><br><span class="hljs-comment">        最终效果为：131****9468*/</span><br><br>        <span class="hljs-comment">//1.键盘录入一个手机号码</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入手机号码&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">phoneNumber</span> <span class="hljs-operator">=</span> sc.next();<span class="hljs-comment">//13112349408</span><br><br>        <span class="hljs-comment">//2.截取手机号码中的前三位</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">star</span> <span class="hljs-operator">=</span> phoneNumber.substring(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">//3.截取手机号码中的最后四位</span><br>        <span class="hljs-comment">//此时我用substring方法，是用1个参数的，还是两个参数的？1个参数的会更好</span><br>        <span class="hljs-comment">//因为现在我要截取到最后，所以建议使用1个参数的。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> phoneNumber.substring(<span class="hljs-number">7</span>);<br><br>        <span class="hljs-comment">//4.拼接</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> star + <span class="hljs-string">&quot;****&quot;</span> + end;<br><br>        System.out.println(result);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="敏感词替换">1.10 敏感词替换</h3><p>需求1：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 敏感词替换</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.定义一个变量表示骂人的话</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">talk</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TMD&quot;</span>;<br><br><br>        <span class="hljs-comment">//2.把这句话中的敏感词进行替换</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> talk.replace(<span class="hljs-string">&quot;TMD&quot;</span>, <span class="hljs-string">&quot;***&quot;</span>);<br><br>        <span class="hljs-comment">//3.打印</span><br>        System.out.println(talk);<br>        System.out.println(result);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>需求2：如果要替换的敏感词比较多怎么办？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 多个敏感词替换</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test10</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//实际开发中，敏感词会有很多很多</span><br><br>        <span class="hljs-comment">//1.先键盘录入要说的话</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入要说的话&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">talk</span> <span class="hljs-operator">=</span> sc.next();<span class="hljs-comment">//TMD,GDX,ctmd,ZZ</span><br><br>        <span class="hljs-comment">//2.定义一个数组用来存多个敏感词</span><br>        String[] arr = &#123;<span class="hljs-string">&quot;TMD&quot;</span>,<span class="hljs-string">&quot;GDX&quot;</span>,<span class="hljs-string">&quot;ctmd&quot;</span>,<span class="hljs-string">&quot;ZZ&quot;</span>,<span class="hljs-string">&quot;lj&quot;</span>,<span class="hljs-string">&quot;FW&quot;</span>,<span class="hljs-string">&quot;nt&quot;</span>&#125;;<br><br>        <span class="hljs-comment">//3.把说的话中所有的敏感词都替换为***</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">//i 索引</span><br>            <span class="hljs-comment">//arr[i] 元素 --- 敏感词</span><br>            talk = talk.replace(arr[i],<span class="hljs-string">&quot;***&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//4.打印结果</span><br>        System.out.println(talk);<span class="hljs-comment">//***,***,***,***</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="身份证信息查看">1.11 身份证信息查看</h3><pre><code class="hljs">身份证的每一位都是有固定的含义：</code></pre><ul><li>1、2位：省份</li><li>3、4位：城市</li><li>5、6位：区县</li><li>7-14位：出生年、月、日</li><li>15、16位：所在地派出所</li><li>17位：性别（奇数男性，偶数女性）</li><li>18位：个人信息码（随机产生）</li></ul><p>要求打印内容方式如下：</p><pre><code class="hljs">人物信息为：出生年月日：XXXX年X月X日性别为：男/女</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDemo11</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.定义一个字符串记录身份证号码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;321281202001011234&quot;</span>;<br><br>        <span class="hljs-comment">//2.获取出生年月日</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> id.substring(<span class="hljs-number">6</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> id.substring(<span class="hljs-number">10</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> id.substring(<span class="hljs-number">12</span>, <span class="hljs-number">14</span>);<br><br><br>        System.out.println(<span class="hljs-string">&quot;人物信息为：&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;出生年月日:&quot;</span> + year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + day + <span class="hljs-string">&quot;日&quot;</span>);<br><br>        <span class="hljs-comment">//3.获取性别</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> id.charAt(<span class="hljs-number">16</span>);<span class="hljs-comment">//&#x27;3&#x27;  ---&gt; 3</span><br>        <span class="hljs-comment">//利用ASCII码表进行转换</span><br>        <span class="hljs-comment">//&#x27;0&#x27; ---&gt;  48</span><br>        <span class="hljs-comment">//&#x27;1&#x27; ---&gt;  49</span><br>        <span class="hljs-comment">//&#x27;2&#x27; ---&gt;  50</span><br>        <span class="hljs-comment">//&#x27;3&#x27; ---&gt;  51</span><br>        <span class="hljs-comment">//&#x27;4&#x27; ---&gt;  52</span><br>        <span class="hljs-comment">//&#x27;5&#x27; ---&gt;  53</span><br>        <span class="hljs-comment">//&#x27;6&#x27; ---&gt;  54</span><br>        <span class="hljs-comment">//&#x27;7&#x27; ---&gt;  55</span><br>        <span class="hljs-comment">//&#x27;8&#x27; ---&gt;  56</span><br>        <span class="hljs-comment">//&#x27;9&#x27; ---&gt;  57</span><br><br>       <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> gender - <span class="hljs-number">48</span>;<br>        <span class="hljs-keyword">if</span>(num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;性别为:女&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;性别为:男&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stringbuilder">2.StringBuilder</h2><p>StringBuilder 可以看成是一个容器，创建之后里面的内容是可变的。</p><p>当我们在拼接字符串和反转字符串的时候会使用到</p><h3 id="构造方法">2.1 构造方法</h3><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public StringBuilder()</td><td>创建一个空白可变字符串对象，不含有任何内容</td></tr><tr class="even"><td>public StringBuilder(String str)</td><td>根据字符串的内容，来创建可变字符串对象.初始化存在str</td></tr></tbody></table><h3 id="常用方法">2.2 常用方法</h3><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public StringBuilder append(任意类型)</td><td>添加数据，并返回对象本身</td></tr><tr class="even"><td>public StringBuilder reverse()</td><td>反转容器中的内容</td></tr><tr class="odd"><td>public int length（）</td><td>返回长度（字符出现的个数）</td></tr><tr class="even"><td>public String toString()</td><td>把StringBuilder转换为String</td></tr></tbody></table><h3 id="基本使用">2.3 基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilderDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//0.创建对象</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><br>        <span class="hljs-comment">//1.添加元素</span><br>        <span class="hljs-comment">/*sb.append(1);</span><br><span class="hljs-comment">        sb.append(2.3);</span><br><span class="hljs-comment">        sb.append(true);</span><br><span class="hljs-comment">        System.out.println(sb);//结果 abc12.3true</span><br><span class="hljs-comment">        */</span><br>        <br>        <span class="hljs-comment">//2.反转</span><br>        sb.reverse();<br>System.out.println(sb);<span class="hljs-comment">//结果 cba</span><br>        <span class="hljs-comment">//3.获取长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> sb.length();<br>        System.out.println(len);<span class="hljs-comment">//结果 3</span><br><br><span class="hljs-comment">//4.把StringBuilder变回String</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br><br>        <span class="hljs-comment">//打印</span><br>        <span class="hljs-comment">//普及：</span><br>        <span class="hljs-comment">//因为StringBuilder是Java已经写好的类</span><br>        <span class="hljs-comment">//java在底层对他做了一些特殊处理。</span><br>        <span class="hljs-comment">//打印对象不是地址值而是属性值。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链式编程">2.4 链式编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilderDemo4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.创建对象</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-comment">//2.添加字符串</span><br>        sb.append(<span class="hljs-string">&quot;aaa&quot;</span>).append(<span class="hljs-string">&quot;bbb&quot;</span>).append(<span class="hljs-string">&quot;ccc&quot;</span>).append(<span class="hljs-string">&quot;ddd&quot;</span>);<br><br>        System.out.println(sb);<span class="hljs-comment">//aaabbbcccddd</span><br><br>        <span class="hljs-comment">//3.再把StringBuilder变回字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br>        System.out.println(str);<span class="hljs-comment">//aaabbbcccddd</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stringjoiner">3. StringJoiner</h2><ul><li>StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。</li><li>作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。</li><li>JDK8出现的</li></ul><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public StringJoiner（间隔符号）</td><td>指定拼接的间隔符号</td></tr><tr class="even"><td>public StringJoiner（间隔符号，开始符号，结束符号）</td><td>指定拼接的间隔符号，开始符号，结束符号</td></tr></tbody></table><table><thead><tr class="header"><th>方法名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>public StringJoiner add(任意类型)</td><td>添加数据，并返回对象本身</td></tr><tr class="even"><td>public int length（）</td><td>返回长度（字符出现的个数）</td></tr><tr class="odd"><td>public String toString()</td><td>把StringBuilder转换为String</td></tr></tbody></table><p>基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建一个对象，并指定中间的间隔符号</span><br><span class="hljs-type">StringJoiner</span> <span class="hljs-variable">sj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;---&quot;</span>);<br><span class="hljs-comment">//2.添加元素</span><br>sj.add(<span class="hljs-string">&quot;aaa&quot;</span>).add(<span class="hljs-string">&quot;bbb&quot;</span>).add(<span class="hljs-string">&quot;ccc&quot;</span>);<br><span class="hljs-comment">//3.打印结果</span><br>System.out.println(sj);<span class="hljs-comment">//aaa---bbb---ccc</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建对象</span><br><span class="hljs-type">StringJoiner</span> <span class="hljs-variable">sj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;, &quot;</span>,<span class="hljs-string">&quot;[&quot;</span>,<span class="hljs-string">&quot;]&quot;</span>);<br><span class="hljs-comment">//2.添加元素</span><br>sj.add(<span class="hljs-string">&quot;aaa&quot;</span>).add(<span class="hljs-string">&quot;bbb&quot;</span>).add(<span class="hljs-string">&quot;ccc&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> sj.length();<br>System.out.println(len);<span class="hljs-comment">//15</span><br><span class="hljs-comment">//3.打印</span><br>System.out.println(sj);<span class="hljs-comment">//[aaa, bbb, ccc]</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sj.toString();<br>System.out.println(str);<span class="hljs-comment">//[aaa, bbb, ccc]</span><br></code></pre></td></tr></table></figure><h2 id="关于字符串的底层原理">关于字符串的底层原理：</h2><ol type="1"><li><p>字符串存储的内存原理</p><p>String s = “abc”；直接赋值</p><p>特点：</p><p>此时字符串abc是存在字符串常量池中的。</p><p>先检查字符串常量池中有没有字符串abc，如果有，不会创建新的，而是直接复用。如果没有abc，才会创建一个新的。</p><p>所以，直接赋值的方式，代码简单，而且节约内存。</p></li><li><p>new出来的字符串</p><p>看到new关键字，一定是在堆里面开辟了一个小空间。</p><p>String s1 = new String（“abc”）；</p><p>String s2 = “abc”；</p><p>s1记录的是new出来的，在堆里面的地址值。</p><p>s2是直接赋值的，所以记录的是字符串常量池中的地址值。</p></li><li><p><code>==</code>号比较的到底是什么？</p><p>如果比较的是基本数据类型：比的是具体的数值是否相等。</p><p>如果比较的是引用数据类型：比的是地址值是否相等。</p><p>结论：<code>==</code>只能用于比较基本数据类型。不能比较引用数据类型。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java08-面向对象</title>
    <link href="/2023/06/29/Java08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/06/29/Java08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="类和对象">1. 类和对象</h2><h3 id="类和对象的理解">1.1 类和对象的理解</h3><p>客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。</p><ul><li>类<ul><li>类的理解<ul><li>类是对现实生活中一类具有共同属性和行为的事物的抽象</li><li>类是对象的数据类型，类是具有相同属性和行为的一组对象的集合</li><li>简单理解：类就是对现实事物的一种描述</li></ul></li><li>类的组成<ul><li>属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）</li><li>行为：指事物能执行的操作，例如：手机事物（打电话，发短信）</li></ul></li></ul></li><li>类和对象的关系<ul><li>类：类是对现实生活中一类具有共同属性和行为的事物的抽象</li><li>对象：是能够看得到摸的着的真实存在的实体</li><li>简单理解：<strong>类是对事物的一种描述，对象则为具体存在的事物</strong></li></ul></li></ul><h3 id="类的定义">1.2 类的定义</h3><p>类的组成是由属性和行为两部分组成</p><ul><li>属性：在类中通过成员变量来体现（类中方法外的变量）</li><li>行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）</li></ul><p>类的定义步骤：</p><p>①定义类 类名首字母建议大写，需要见名知意，驼峰模式。 一个Java文件中可以定义多个class类，且只能一个类是public修饰，而且public修饰的类名必须成为代码文件名。 实际开发中建议还是一个文件定义一个class类。</p><p>②编写类的成员变量 修饰符 数据类型 变量名称 = 初始化值；</p><p>③编写类的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 类名 &#123;<br><span class="hljs-comment">// 成员变量</span><br>变量<span class="hljs-number">1</span>的数据类型 变量<span class="hljs-number">1</span>；<br>变量<span class="hljs-number">2</span>的数据类型 变量<span class="hljs-number">2</span>;<br>…<br><span class="hljs-comment">// 成员方法</span><br>方法<span class="hljs-number">1</span>;<br>方法<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    手机类：</span><br><span class="hljs-comment">        类名：</span><br><span class="hljs-comment">        手机(Phone)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        成员变量：</span><br><span class="hljs-comment">        品牌(brand)</span><br><span class="hljs-comment">        价格(price)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        成员方法：</span><br><span class="hljs-comment">        打电话(call)</span><br><span class="hljs-comment">        发短信(sendMessage)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br>    <span class="hljs-comment">//成员变量</span><br>    String brand;<br>    <span class="hljs-type">int</span> price;<br><br>    <span class="hljs-comment">//成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>定义类的补充注意事项</p><ul><li><p>用来描述一类事物的类，专业叫做：Javabean类。 在javabean类中，是不写main方法的。</p></li><li><p>在以前，编写main方法的类，叫做测试类。 我们可以在测试类中创建javabean类的对象并进行赋值调用。</p></li></ul><p>定义类技巧 - 属性多为名词 - 动词多为行为 ### 1.3 对象的使用</p><ul><li>创建对象的格式：<ul><li>类名 对象名 = new 类名();</li></ul></li><li>调用成员的格式：<ul><li>对象名.成员变量</li><li>对象名.成员方法();</li></ul></li><li>示例代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建对象</span><br><span class="hljs-comment">        格式：类名 对象名 = new 类名();</span><br><span class="hljs-comment">        范例：Phone p = new Phone();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    使用对象</span><br><span class="hljs-comment">        1：使用成员变量</span><br><span class="hljs-comment">            格式：对象名.变量名</span><br><span class="hljs-comment">            范例：p.brand</span><br><span class="hljs-comment">        2：使用成员方法</span><br><span class="hljs-comment">            格式：对象名.方法名()</span><br><span class="hljs-comment">            范例：p.call()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建对象</span><br>        <span class="hljs-type">Phone</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br><br>        <span class="hljs-comment">//使用成员变量</span><br>        System.out.println(p.brand);<br>        System.out.println(p.price);<br><br>        p.brand = <span class="hljs-string">&quot;小米&quot;</span>;<br>        p.price = <span class="hljs-number">2999</span>;<br><br>        System.out.println(p.brand);<br>        System.out.println(p.price);<br><br>        <span class="hljs-comment">//使用成员方法</span><br>        p.call();<br>        p.sendMessage();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="对象内存图">2. 对象内存图</h2><h3 id="单个对象内存图">2.1 单个对象内存图</h3><p>1.加载class文件 2.申明局部变量 3.在堆内存中开辟一个空间 4.默认初始化 5.显示初始化 6.构造方法初始化 7.将堆内存中的地址值赋值给左边的局部变量</p><ul><li>成员变量使用过程</li></ul><p><img src="/img/08-Java面向对象/a988fe806c874853b9932cd82f4f0ace.png" /></p><ul><li>成员方法调用过程</li></ul><p><img src="/img/08-Java面向对象/9452a4e92a064994a789cf8933907fee.png" /></p><h3 id="多个对象内存图">2.2 多个对象内存图</h3><ul><li>成员变量使用过程</li></ul><p><img src="/img/08-Java面向对象/3fc24a8afebb4205b22c3ab626fac3e1.png" /></p><ul><li>成员方法调用过程</li></ul><p><img src="/img/08-Java面向对象/42357759542a4e1e928a5e259b3bbec0.png" /></p><ul><li><p>总结：</p><p>多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份</p></li></ul><h2 id="成员变量和局部变量">3. 成员变量和局部变量</h2><h3 id="成员变量和局部变量的区别">3.1 成员变量和局部变量的区别</h3><table><thead><tr class="header"><th>区别</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr class="odd"><td>类中位置不同</td><td>类中方法外</td><td>方法内部或方法声明上</td></tr><tr class="even"><td>初始化值不同</td><td>有默认初始化值</td><td>没有默认初始化值，必须先定义，赋值才能使用</td></tr><tr class="odd"><td>内存中位置不同</td><td>堆内存</td><td>栈内存</td></tr><tr class="even"><td>生命周期不同</td><td>随着对象的存在而存在，随着对象的消失而消失</td><td>随着方法的调用而存在，醉着方法的调用完毕而消失</td></tr><tr class="odd"><td>作用域</td><td>整个类中有效</td><td>当前方法中有效</td></tr></tbody></table><h2 id="封装">4. 封装</h2><p>黑马程序员Java P83</p><h3 id="封装思想">4.1 封装思想</h3><ol type="1"><li><p>封装概述 是面向对象三大特征之一（封装，继承，多态） 有选择的暴露</p><p><strong>对象代表什么，就得封装对应的数据，并提供数据对应的行为</strong> （java bean类）</p></li><li><p>封装代码实现 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 成员变量private，提供对应的getXxx()/setXxx()方法</p></li></ol><h3 id="private关键字">4.2 private关键字</h3><p>private是一个权限修饰符，可以用来修饰成员（成员变量，成员方法）</p><ul><li><p>被private修饰的成员，只能在本类进行访问，不能在其他类直接调用(如测试类). 如果需要被其他类使用，提供相应的操作:</p><ul><li>提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰</li><li>提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰</li></ul></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    学生类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//成员变量</span><br>    String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//提供get/set方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>        <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">0</span> || a&gt;<span class="hljs-number">120</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;你给的年龄有误&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            age = a;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-comment">//成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;,&quot;</span> + age);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    学生测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-comment">//给成员变量赋值</span><br>        s.name = <span class="hljs-string">&quot;林青霞&quot;</span>;<br>        s.setAge(<span class="hljs-number">30</span>);<br>        <span class="hljs-comment">//调用show方法</span><br>        s.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="this关键字">4.3 this关键字</h3><ul><li>==this==修饰的变量用于==指代成员变量==，其主要作用是（区分局部变量和成员变量的重名问题）<ul><li>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量</li><li>方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量</li><li>不写this的话就是就近原则</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;,&quot;</span> + age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>this的内存原理 黑马P89 this的本质:所在方法调用者的地址值</li></ul><h2 id="构造方法">5. 构造方法</h2><h3 id="构造方法概述">5.1 构造方法概述</h3><p>构造方法是一种特殊的方法,也叫作构造器、构造函数。</p><ul><li><p>作用： 创造对象的时候，由虚拟机自动调用构造方法，给成员变量进行初始化(即赋值)的。完成对象数据的初始化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();  <span class="hljs-comment">//空参的构造方法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">new为创建对象</span><br><span class="hljs-comment">空参构造先把对象创建出来,Student为自己创建的方法</span><br><span class="hljs-comment">后续在用   </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p></li><li><p>种类 无参数构造方法：初始化的对象时，成员变量的数据均采用默认值。 有参数构造方法：在初始化对象的时候，同时可以为对象进行赋值。</p></li><li><p>格式：</p><p>public class 类名{ 修饰符 类名( 参数 ) { 方法体; } }</p></li><li><p>示例代码：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;无参构造方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;,&quot;</span> + age);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<span class="hljs-comment">// 无参构造方法</span><br>        s.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造方法的注意事项">5.2 构造方法的注意事项</h3><ul><li><p>构造方法的定义 如果没有定义构造方法，系统将给出一个默认的无参数构造方法 如果定义了构造方法，系统将不再提供默认的构造方法 如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法</p></li><li><p>构造方法的重载 带参构造方法和无参数构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载</p></li><li><p>推荐的使用方式 无论是否使用，==都写==无参和带全部参数的构造方法</p></li><li><p>重要功能！</p></li></ul><p>可以使用带参构造，为成员变量进行初始化</p><ul><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    学生类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;,&quot;</span> + age);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s1.show();<br><br>        <span class="hljs-comment">//public Student(String name)</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;林青霞&quot;</span>);<br>        s2.show();<br><br>        <span class="hljs-comment">//public Student(int age)</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">30</span>);<br>        s3.show();<br><br>        <span class="hljs-comment">//public Student(String name,int age)</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;林青霞&quot;</span>,<span class="hljs-number">30</span>);<br>        s4.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="标准javabean类制作">5.3 标准JavaBean类制作</h3><p>① 类名需要见名知意</p><p>② 成员变量使用private修饰</p><p>③ 提供至少两个构造方法</p><ul><li>无参构造方法</li><li>带全部参数的构造方法</li></ul><p>④ 成员方法</p><ul><li>提供每一个成员变量对应的setXxx()/getXxx()</li><li>如果还有其他行为，也需要写上</li></ul><h3 id="例1">5.4 例1</h3><p>需求：</p><pre><code class="hljs">定义标准学生类，要求分别使用空参和有参构造方法创建对象，空参创建的对象通过setXxx赋值，有参创建的对象直接赋值，并通过show方法展示数据。 </code></pre><ul><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//成员变量</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">//成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;,&quot;</span> + age);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建对象并为其成员变量赋值的两种方式</span><br><span class="hljs-comment">        1:无参构造方法创建对象后使用setXxx()赋值</span><br><span class="hljs-comment">        2:使用带参构造方法直接创建带有属性值的对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//无参构造方法创建对象后使用setXxx()赋值</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s1.setName(<span class="hljs-string">&quot;林青霞&quot;</span>);<br>        s1.setAge(<span class="hljs-number">30</span>);<br>        s1.show();<br><br>        <span class="hljs-comment">//使用带参构造方法直接创建带有属性值的对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;林青霞&quot;</span>,<span class="hljs-number">30</span>);<br>        s2.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例2">5.4 例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-comment">//1.私有化全部的成员变量</span><br>    <span class="hljs-comment">//2.空参构造</span><br>    <span class="hljs-comment">//3.带全部参数的构造</span><br>    <span class="hljs-comment">//4.针对于每一个私有化的成员变量都要提供其对应的get和set方法</span><br>    <span class="hljs-comment">//5.如果当前事物还有其他行为，那么也要写出来，比如学生的吃饭，睡觉等行为</span><br><br>    <span class="hljs-keyword">private</span> String username;<span class="hljs-comment">//用户名</span><br>    <span class="hljs-keyword">private</span> String password;<span class="hljs-comment">//密码</span><br>    <span class="hljs-keyword">private</span> String email;<span class="hljs-comment">//邮箱</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> gender;<span class="hljs-comment">//性别</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄</span><br><br>    <span class="hljs-comment">//空参构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">//带全部参数的构造</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String username, String password, String email, <span class="hljs-type">char</span> gender, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.password = password;<br>        <span class="hljs-built_in">this</span>.email = email;<br>        <span class="hljs-built_in">this</span>.gender = gender;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">//get和set</span><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;<br>        <span class="hljs-built_in">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPassword</span><span class="hljs-params">(String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getEmail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> email;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEmail</span><span class="hljs-params">(String email)</span> &#123;<br>        <span class="hljs-built_in">this</span>.email = email;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getGender</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> gender;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGender</span><span class="hljs-params">(<span class="hljs-type">char</span> gender)</span> &#123;<br>        <span class="hljs-built_in">this</span>.gender = gender;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(username + <span class="hljs-string">&quot;在吃饭&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//写一个标准的javabean类</span><br>        <span class="hljs-comment">//咱们在课后只要能把这个标准的javabean能自己写出来，那么就表示今天的知识点就ok了</span><br><br><br>        <span class="hljs-comment">//利用空参构造创建对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-comment">//如果利用空参创建对象，还想赋值只能用set方法赋值</span><br>        u1.setUsername(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        u1.setPassword(<span class="hljs-string">&quot;1234qwer&quot;</span>);<br>        u1.setEmail(<span class="hljs-string">&quot;zjl256904767@outlook.com&quot;</span>);<br>        u1.setGender(<span class="hljs-string">&#x27;男&#x27;</span>);<br>        u1.setAge(<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//获取属性的值并打印</span><br>        System.out.println(u1.getUsername() + <span class="hljs-string">&quot;, &quot;</span> + u1.getPassword()<br>                + <span class="hljs-string">&quot;, &quot;</span> + u1.getEmail() + <span class="hljs-string">&quot;, &quot;</span> + u1.getGender() + <span class="hljs-string">&quot;, &quot;</span> + u1.getAge());<br>        u1.eat();<br><br>        System.out.println(<span class="hljs-string">&quot;=============================&quot;</span>);<br><br>        <span class="hljs-comment">//简单的办法</span><br>        <span class="hljs-comment">//利用带全部参数的构造来创建对象</span><br>        <span class="hljs-comment">//快捷键:ctrl + p</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;12345678&quot;</span>,<span class="hljs-string">&quot;lisi@outlook.com&quot;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-number">24</span>);<br>        System.out.println(u2.getUsername() + <span class="hljs-string">&quot;, &quot;</span> + u2.getPassword()<br>                + <span class="hljs-string">&quot;, &quot;</span> + u2.getEmail() + <span class="hljs-string">&quot;, &quot;</span> + u2.getGender() + <span class="hljs-string">&quot;, &quot;</span> + u2.getAge());<br>        u2.eat();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="基本数据类型与引用数据类型">6.基本数据类型与引用数据类型</h2><p>从内存的角度去解释： 基本数据类型：数据值是存储在自己的空间中 引用数据类型：数据值是存储在其他空间中， 自己空间中存储的是地址值。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java07-方法</title>
    <link href="/2023/06/29/Java07-%E6%96%B9%E6%B3%95/"/>
    <url>/2023/06/29/Java07-%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="方法概述">1. 方法概述</h2><h3 id="方法的概念">1.1 方法的概念</h3><p>方法（method）是程序中最小的执行单元</p><p>注意： * 方法必须先创建才可以使用，该过程即为方法定义（把一些代码打包在一起） * 方法定义后并不是直接运行，需要手动使用才执行，该过程即为方法调用</p><h2 id="方法的定义和调用">2. 方法的定义和调用</h2><h3 id="无参数方法定义和调用">2.1 无参数方法定义和调用</h3><ul><li><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> 方法名 (  ) &#123;<br><span class="hljs-comment">// 方法体;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">方法名();<br></code></pre></td></tr></table></figure></li><li><p>注意： 方法必须先定义，后调用，否则程序将报错 方法定义要写在main方法外面，类的里面</p></li></ul><h3 id="有参数方法定义和调用">2.2 有参数方法定义和调用</h3><ul><li><p>定义格式： 参数：数据类型 变量名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> 方法名 (参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span>, 参数<span class="hljs-number">3.</span>..) &#123;<br>方法体;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">方法名(参数)；<br><br>方法名(参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>)；<br></code></pre></td></tr></table></figure></li></ul><p>注意： - 方法定义时，参数中的数据类型与变量名都不能缺少 - 方法定义时，多个参数之间使用逗号( ，)分隔 * 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配</p><h3 id="形参和实参">2.3 形参和实参</h3><ol type="1"><li>形参：方法定义中的参数</li></ol><p>等同于变量定义格式，例如：int number</p><ol start="2" type="1"><li>实参：方法调用中的参数</li></ol><p>等同于使用变量或常量，例如： 10 number</p><h3 id="带返回值方法定义和调用">2.4 带返回值方法定义和调用</h3><ul><li><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 返回值类型 方法名 ( 参数 ) &#123; <br>  方法体<br>   <span class="hljs-keyword">return</span> 返回值 ;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接调用</span><br>方法名 ( 实参 ) ;<br><br><span class="hljs-comment">//赋值调用</span><br>数据类型 变量名 = 方法名 ( 实参 ) ;<br><br><span class="hljs-comment">//输出调用</span><br>sout(方法名 ( 实参 ))<br></code></pre></td></tr></table></figure></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">isEvenNumber ( <span class="hljs-number">5</span> ) ;<br><span class="hljs-type">boolean</span>  <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span>  isEvenNumber ( <span class="hljs-number">5</span> ); <br></code></pre></td></tr></table></figure></li></ul><p>注意： - 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错 - 方法的返回值通常会使用变量接收，否则该返回值将无意义</p><h3 id="方法定义的小技巧">2.5==方法定义的小技巧==</h3><ol start="0" type="1"><li>需要==重复==用到的模块定义为方法</li><li>我要干什么？ （方法体）</li><li>我干这件事情需要什么才能完成？ （形参）</li><li>方法的调用处是否需要继续使用方法的结果 （返回值） ## 3. 方法的注意事项</li></ol><h3 id="方法的注意事项">3.1 方法的注意事项</h3><ul><li><p>方法不能嵌套定义</p><p>示例代码：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodOne</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodTwo</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// 这里会引发编译错误!!!</span><br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据</p><p>示例代码：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodTwo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//return 100; 编译错误，因为没有具体返回值类型</span><br>        <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//System.out.println(100); return语句后面不能跟数据或代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>return语句下面，不能编写代码，因为永远执行不到，属于无效的代码 方法没有返回值：可以省路不写。如果书写，表示结束方法 方法有返回值：必须要写。表示结束方法和返回结果</p></li></ul><h3 id="方法的通用格式">3.2 方法的通用格式</h3><ul><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 返回值类型 方法名(参数) &#123;<br>   方法体; <br>   <span class="hljs-keyword">return</span> 数据 ;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>解释：</p></li></ul><p>public static 修饰符，目前先记住这个格式</p><p>返回值类型 方法操作完毕之后返回的数据的数据类型</p><p>如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return</p><p>方法名 调用方法时候使用的标识</p><p>参数 由数据类型和变量名组成，多个参数之间用逗号隔开</p><p>方法体 完成功能的代码块</p><p>return 如果方法操作完毕，有数据返回，用于把数据返回给调用者</p><ul><li><p>定义方法时，要做到两个明确</p><ul><li>明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型</li><li>明确参数：主要是明确参数的类型和数量</li></ul></li><li><p>调用方法时的注意：</p><ul><li>void类型的方法，直接调用即可</li><li>非void类型的方法，推荐用变量接收调用</li></ul></li></ul><h2 id="方法重载">4. 方法重载</h2><h3 id="方法重载-1">4.1 方法重载</h3><ul><li><p>方法重载概念</p><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载</p><ul><li>多个方法在==同一类中==</li><li>多个方法具有==相同的方法名==</li><li>多个方法的==参数不相同==，类型不同、数量不同 或 顺序不同(不建议)</li></ul></li><li><p>简单记：同一个类中，方法名相同，参数（形参）不同的方法。 与返回值无关。只有三个条件，不看其他条件。</p></li></ul><p><strong>注意：</strong> * 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式 * 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载</p><ul><li><p>正确范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>    <span class="hljs-comment">//方法体</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span> &#123;<br>    <span class="hljs-comment">//方法体</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>    <span class="hljs-comment">//方法体</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-comment">//方法体</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>错误范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>    <span class="hljs-comment">//方法体</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123; <span class="hljs-comment">/*错误原因：重载与返回值无关*/</span><br>    <span class="hljs-comment">//方法体</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>        <span class="hljs-comment">//方法体</span><br>    &#125;<br>&#125; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span> &#123; <span class="hljs-comment">/*错误原因：这是两个类的两个fn方法*/</span><br>        <span class="hljs-comment">//方法体</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="方法重载练习">6.2 方法重载练习</h3><ul><li><p>需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long）</p></li><li><p>思路：</p><ul><li>①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数</li><li>②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数</li><li>③定义所有的重载方法，两个byte类型与两个short类型参数</li><li>④完成方法的调用，测试运行结果</li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//调用方法</span><br>        System.out.println(compare(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>        System.out.println(compare((<span class="hljs-type">byte</span>) <span class="hljs-number">10</span>, (<span class="hljs-type">byte</span>) <span class="hljs-number">20</span>));<br>        System.out.println(compare((<span class="hljs-type">short</span>) <span class="hljs-number">10</span>, (<span class="hljs-type">short</span>) <span class="hljs-number">20</span>));<br>        System.out.println(compare(<span class="hljs-number">10L</span>, <span class="hljs-number">20L</span>));<br>    &#125;<br><br>    <span class="hljs-comment">//int</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;int&quot;</span>);<br>        <span class="hljs-keyword">return</span> a == b;<br>    &#125;<br><br>    <span class="hljs-comment">//byte</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">byte</span> a, <span class="hljs-type">byte</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;byte&quot;</span>);<br>        <span class="hljs-keyword">return</span> a == b;<br>    &#125;<br><br>    <span class="hljs-comment">//short</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">short</span> a, <span class="hljs-type">short</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;short&quot;</span>);<br>        <span class="hljs-keyword">return</span> a == b;<br>    &#125;<br><br>    <span class="hljs-comment">//long</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;long&quot;</span>);<br>        <span class="hljs-keyword">return</span> a == b;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="数组遍历">7.3 数组遍历</h3><ul><li><p>需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55]</p></li><li><p>思路：</p><ul><li><p>①因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”);</p><p>System.out.println(“内容”); 输出内容并换行</p><p>System.out.print(“内容”); 输出内容不换行</p><p>System.out.println(); 起到换行的作用</p></li><li><p>②定义一个数组，用静态初始化完成数组元素初始化</p></li><li><p>③定义一个方法，用数组遍历通用格式对数组进行遍历</p></li><li><p>④用新的输出语句修改遍历操作</p></li><li><p>⑤调用遍历方法</p></li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">/*  //先打印数据，再进行换行</span><br><span class="hljs-comment">        System.out.println(&quot;aaa&quot;);</span><br><span class="hljs-comment">        //只打印不换行</span><br><span class="hljs-comment">        System.out.print(&quot;bbb&quot;);</span><br><span class="hljs-comment">        System.out.print(&quot;ddd&quot;);</span><br><span class="hljs-comment">        //不打印任何内容，只换行</span><br><span class="hljs-comment">        System.out.println();</span><br><span class="hljs-comment">        System.out.print(&quot;cc&quot;);*/</span><br>        <span class="hljs-comment">//设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55]</span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        printArr(arr);<br>    &#125;<br>    <span class="hljs-comment">//1.我要遍历数组</span><br>    <span class="hljs-comment">//2.需要什么？  数组</span><br>    <span class="hljs-comment">//3.调用处是否需要使用方法的结果。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArr</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;[&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i == arr.length - <span class="hljs-number">1</span>)&#123;<br>                System.out.println(arr[i] + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                System.out.print(arr[i] + <span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="数组最大值">7.4 数组最大值</h3><ul><li><p>需求：设计一个方法用于获取数组中元素的最大值</p></li><li><p>思路：</p><ul><li>①定义一个数组，用静态初始化完成数组元素初始化</li><li>②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了</li><li>③调用获取最大值方法，用变量接收返回结果</li><li>④把结果输出在控制台</li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodTest02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//定义一个数组，用静态初始化完成数组元素初始化</span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">45</span>, <span class="hljs-number">98</span>, <span class="hljs-number">73</span>, <span class="hljs-number">60</span>&#125;;<br><br>        <span class="hljs-comment">//调用获取最大值方法，用变量接收返回结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> getMax(arr);<br><br>        <span class="hljs-comment">//把结果输出在控制台</span><br>        System.out.println(<span class="hljs-string">&quot;number:&quot;</span> + number);<br>    &#125;<br><br>    <span class="hljs-comment">//定义一个方法，用来获取数组中的最大值</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        两个明确：</span><br><span class="hljs-comment">            返回值类型：int</span><br><span class="hljs-comment">            参数：int[] arr</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>; x&lt;arr.length; x++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[x] &gt; max) &#123;<br>                max = arr[x];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="获取索引">7.6 获取索引</h3><p>需求：</p><pre><code class="hljs">定义一个方法获取数字，在数组中的索引位置，将结果返回给调用处，如果有重复的，只要获取第一个即可。</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.demo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//定义一个方法获取数字，在数组中的索引位置，将结果返回给调用处</span><br>        <span class="hljs-comment">//如果有重复的，只要获取第一个即可</span><br><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> contains(arr, <span class="hljs-number">3</span>);<br>        System.out.println(index);<br>    &#125;<br><br>    <span class="hljs-comment">//1. 我要干嘛？判断数组中的某一个数是否存在</span><br>    <span class="hljs-comment">//2. 需要什么？数组 数字</span><br>    <span class="hljs-comment">//3. 调用处是否需要继续使用？返回</span><br>    <span class="hljs-comment">//获取number在arr中的位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-comment">//遍历arr得到每一个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">//拿着每一个元素跟number比较</span><br>            <span class="hljs-keyword">if</span>(arr[i] == number)&#123;<br>                <span class="hljs-comment">//如果相等，表示找到了</span><br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//当循环结束之后，如果还不能返回索引，表示数组中不存在该数据</span><br>        <span class="hljs-comment">//可以返回-1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java06-数组</title>
    <link href="/2023/06/29/Java06-%E6%95%B0%E7%BB%84/"/>
    <url>/2023/06/29/Java06-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数组">1.数组</h1><h3 id="概念">概念：</h3><p>指的是一种容器，可以同来存储==同种数据类型==的多个值。</p><p>但是数组容器在存储数据的时候，需要结合隐式转换考虑。</p><p><strong>建议：</strong> 容器的类，和存储的数据类型保持一致。</p><h1 id="数组的定义">2.数组的定义</h1><h3 id="格式一">格式一：</h3><p>(常用) 数据类型 [ ] 数组名</p><p>比如：<code>int [ ] array</code></p><h3 id="格式二">格式二：</h3><p>数据类型 数组名 []</p><p>比如：<code>int array []</code></p><h1 id="数组的静态初始化">3.数组的静态初始化</h1><h3 id="完整格式">完整格式：</h3><p>数据类型 [] 数组名 = new 数据类型[]{元素1，元素2，元素3，元素4...};</p><p>比如：<code>int[] arr = new int[]&#123;11,22,33&#125;;</code></p><h3 id="简化格式">简化格式 :</h3><p>数据类型[] 数组名 = {元素1，元素2，元素3，元素4...};</p><p>比如：<code>int[] array = &#123;1,2,3,4,5&#125;;</code></p><h3 id="注意点">注意点：</h3><ul><li>等号前后的数据类型必须保持一致。</li><li>数组一旦创建之后，长度不能发生变化。</li></ul><h1 id="地址值">4.地址值</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>System.out.println(arr);<span class="hljs-comment">//[I@6d03e736</span><br><br><span class="hljs-type">double</span>[] arr2 = &#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>&#125;;<br>System.out.println(arr2);<span class="hljs-comment">//[D@568db2f2</span><br></code></pre></td></tr></table></figure><p>打印数组的时候，实际出现的是数组的==地址值==。</p><p>数组的地址值：就表示数组在内存中的位置。</p><p>以<code>[I@6d03e736</code>为例：</p><p><code>[</code>：表示现在打印的是一个数组。</p><p>I：表示现在打印的数组是int类型的。</p><p>@：仅仅是一个间隔符号而已。</p><p>6d03e736：就是数组在内存中真正的地址值。（十六进制的）</p><p>习惯性把<code>[I@6d03e736</code> 这个整体称之为数组的地址值。</p><h1 id="数组元素访问">5.数组元素访问</h1><h3 id="格式">格式：</h3><p>数组名[索引];</p><h3 id="作用">作用：</h3><ul><li><p>获取数组中对应索引上的值</p></li><li><p>修改数组中对应索引上的值</p><p>一旦修改之后，原来的值就会被覆盖了。</p></li></ul><p><strong>例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <br>       <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>       <span class="hljs-comment">//需求1：获取arr数组中，3索引上的值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">3</span>];<br>        System.out.println(number);<br>        System.out.println(arr[<span class="hljs-number">3</span>]);<br><br>       <span class="hljs-comment">//需求2：将arr数组中，3索引上的值修改为10</span><br>            arr[<span class="hljs-number">3</span>] = <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;修改之后为:&quot;</span> + arr[<span class="hljs-number">3</span>]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组的遍历">6.数组的遍历</h1><p>遍历：把数组里面所有的内容一个一个全部取出来。</p><p>数组的长度：数组名.length;</p><p>通用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>    <span class="hljs-comment">//在循环的过程中，i依次表示数组中的每一个索引</span><br>    sout(arr[i]);<span class="hljs-comment">//就可以把数组里面的每一个元素都获取出来，并打印在控制台上了。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>附：</strong> idea快速遍历数组 数组名.fori</p><h1 id="数组的动态初始化">7.数组的动态初始化</h1><p>只指定长度，无初始值</p><h3 id="格式-1">格式：</h3><p>数据类型[] 数组名 = new 数据类型[数组的长度];</p><h3 id="例">例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个数组，存3个人的年龄，年龄未知</span><br><span class="hljs-type">int</span>[] agesArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h3 id="数组的默认初始化值">数组的默认初始化值：</h3><p>整数类型：0</p><p>小数类型：0.0</p><p>布尔类型：false</p><p>字符类型：'000'</p><p>引用类型：null</p><h1 id="数组两种初始化方式的区别">8.数组两种初始化方式的区别</h1><p>静态初始化：<code>int[] arr = &#123;1,2,3,4,5&#125;;</code></p><p>动态初始化：<code>int[] arr = new int[5];</code></p><p>静态初始化：手动指定数组的元素，系统会根据元素的个数，计算出数组的长度。</p><p>动态初始化：手动指定数组长度，由系统给出默认初始化值。</p><h3 id="使用场景">使用场景：</h3><p>只明确元素个数，但是不明确具体的数据，推荐使用动态初始化。</p><p>已经明确了要操作的所有数据，推荐使用静态初始化。</p><h3 id="举例">举例：</h3><ul><li><p>使用数组来存储键盘录入的5个整数。</p><p><code>int[] arr = new int[5];</code></p></li><li><p>将全班的学生成绩存入数组中，已知学生成绩为：66,77,88,99,100</p><p><code>int[] arr = &#123;66,77,88,99,100&#125;;</code></p></li></ul><h1 id="二维数组">9.二维数组</h1><h2 id="静态初始化">静态初始化</h2><h3 id="格式-2">格式：</h3><p><code>数据类型[][] 数组名=new 据类型[][] &#123;&#123;元素1，元素2&#125;,&#123;元素1，元素2&#125;&#125;</code> 比如：<code>int[][] array = new int[][]&#123;&#123;11,22&#125;,&#123;33,44&#125;&#125;</code></p><h3 id="简化格式-1">简化格式：</h3><p><code>数据类型[][] 数组名=&#123;&#123;元素1，元素2&#125;,&#123;元素1，元素2&#125;&#125;</code></p><h2 id="获取元素">获取元素</h2><h3 id="格式-3">格式</h3><p><code>arr[i][j]</code></p><h2 id="二维数组的遍历">二维数组的遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">arr.fori<br>  arr[i].fori<br>    <span class="hljs-title function_">sout</span><span class="hljs-params">(arr[i][j])</span><br></code></pre></td></tr></table></figure><h2 id="动态初始化">动态初始化</h2><h3 id="格式-4">格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">`数据类型[][] 数组名=<span class="hljs-keyword">new</span> 数据类型[m][n]`<br><span class="hljs-comment">// m表示这个二维数组，可以存放多少个一维数组 </span><br><span class="hljs-comment">//n表示每一个一维数组，可以存放多少个元素</span><br></code></pre></td></tr></table></figure><h2 id="二维数组地址值">二维数组地址值</h2><p><img src="/img/06-Java数组/85e10cf54f6a41e695ad103f5defcdd3.png" /> <img src="/img/06-Java数组/9d5945949af649db9f30f4101b5b2b38.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java05-高级循环(forr while)</title>
    <link href="/2023/06/29/Java05-%E9%AB%98%E7%BA%A7%E5%BE%AA%E7%8E%AF-for-while/"/>
    <url>/2023/06/29/Java05-%E9%AB%98%E7%BA%A7%E5%BE%AA%E7%8E%AF-for-while/</url>
    
    <content type="html"><![CDATA[<h2 id="无限循环">1.无限循环</h2><h3 id="概念">概念：</h3><pre><code class="hljs">又叫死循环。循环一直停不下来。</code></pre><h3 id="for格式">for格式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(;;)&#123;<br>    System.out.println(<span class="hljs-string">&quot;循环执行一直在打印内容&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><p>初始化语句可以空着不写，表示循环之前不定义任何的控制变量。</p><p>条件判断语句可以空着不写，如果不写，默认表示true，循环一直进行。</p><p>条件控制语句可以空着不写，表示每次循环体执行完毕后，控制变量不做任何变化。</p><h3 id="while格式">while格式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;循环执行一直在打印内容&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><pre><code class="hljs">小括号里面就不能省略了，true一定要写出来，否则代码会报错。</code></pre><h3 id="do...while格式">do...while格式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;循环执行一直在打印内容&quot;</span>);<br>&#125;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>解释：</p><pre><code class="hljs">小括号里面就不能省略了，true一定要写出来，否则代码会报错。</code></pre><h3 id="无限循环的注意事项">无限循环的注意事项：</h3><ul><li>最为常用的格式：while</li><li>无限循环下面不能再写其他代码了，因为永远执行不到。</li></ul><h2 id="条件控制语句">2.条件控制语句</h2><ul><li>break</li><li>continue</li></ul><h3 id="break">break:</h3><pre><code class="hljs">不能单独存在的。可以用在switch和循环中，表示结束，跳出的意思。</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.吃1~5号包子</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    System.out.println(<span class="hljs-string">&quot;在吃第&quot;</span> + i + <span class="hljs-string">&quot;个包子&quot;</span>);<br>    <span class="hljs-comment">//2.吃完第三个的时候就不吃了</span><br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-keyword">break</span>;<span class="hljs-comment">//结束整个循环。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="continue">continue:</h3><pre><code class="hljs">不能单独存在的。只能存在于循环当中。表示：跳过本次循环，继续执行下次循环。</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.吃1~5号包子</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-comment">//2.第3个包子有虫子就跳过，继续吃下面的包子</span><br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-comment">//跳过本次循环（本次循环中，下面的代码就不执行了），继续执行下次循环。</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;在吃第&quot;</span> + i + <span class="hljs-string">&quot;个包子&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="random">3. Random</h2><p>Random跟Scanner一样，也是Java提前写好的类，我们不需要关心是如何实现的，只要直接使用就可以了。</p><h3 id="使用步骤">使用步骤：</h3><ol type="1"><li>导包</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-comment">// 导包的动作必须出现在类定义的上边。</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>创建对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span> ();<br><span class="hljs-comment">// 上面这个格式里面，只有r是变量名，可以变，其他的都不允许变。</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>生成随机数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> r.nextInt(随机数的范围);<br><span class="hljs-comment">// 上面这个格式里面，只有number是变量名，可以变，其他的都不允许变。</span><br><span class="hljs-comment">// 随机数范围的特点：从0开始，不包含指定值。比如：参数为10，生成的范围[0,10)</span><br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.导包</span><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//2.创建对象</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-comment">//3.生成随机数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">100</span>);<span class="hljs-comment">//包左不包右，包头不包尾</span><br>        <span class="hljs-comment">//0 ~ 99</span><br>        System.out.println(number);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="逢七过">4. 逢七过</h2><p>需求：</p><pre><code class="hljs">朋友聚会的时候可能会玩一个游戏：逢7过 游戏规则：从任意一个数字开始报数，当你要报的数字是包含7或者是7的倍数时都要说过：过使用程序在控制台打印出1-100之间的满足逢七必过规则的数据 </code></pre><p>举例：</p><pre><code class="hljs">1 2 3 4 5 6 过 8 9 10 11 12 13 过 15 16 过 18 ...</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*朋友聚会的时候可能会玩一个游戏：逢7过</span><br><span class="hljs-comment">        游戏规则：从任意一个数字开始报数，当你要报的数字是包含7或者是7的倍数时都要说过：过</span><br><span class="hljs-comment">        需求：使用程序在控制台打印出1-100之间的满足逢七必过规则的数据*/</span><br><span class="hljs-comment">//分析：</span><br><span class="hljs-comment">//个位7  十位7   7倍数</span><br><span class="hljs-comment">//1 2 3 4 5 6 过 8 9 10 11 12 13 过 15 16 过 18 19 20 过....</span><br><span class="hljs-comment">//69 过 过 过 过 过 过... 80</span><br><span class="hljs-comment">//1.得到1~100之间的每一个数字</span><br><span class="hljs-comment">//开始：1</span><br><span class="hljs-comment">//结束：100</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>    <span class="hljs-comment">//2.判断每一个数字，如果符合规则，就打印过，如果不符合规则就打印真实的数字</span><br>    <span class="hljs-keyword">if</span>(i % <span class="hljs-number">10</span> == <span class="hljs-number">7</span> || i / <span class="hljs-number">10</span> % <span class="hljs-number">10</span> == <span class="hljs-number">7</span>  ||  i % <span class="hljs-number">7</span> == <span class="hljs-number">0</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;过&quot;</span>);<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="平方根">5. 平方根</h2><p>需求：</p><pre><code class="hljs">键盘录入一个大于等于2的整数 x ，计算并返回 x 的 平方根 。结果只保留整数部分 ，小数部分将被舍去 。</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*需求：键盘录入一个大于等于2的整数 x ，计算并返回 x 的 平方根 。</span><br><span class="hljs-comment">        结果只保留整数部分 ，小数部分将被舍去 。*/</span><br><br><br><span class="hljs-comment">//分析：</span><br><span class="hljs-comment">//平方根   16的平方根4</span><br><span class="hljs-comment">//         4的平方根2</span><br><br><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// 1 * 1 = 1 &lt; 10</span><br><span class="hljs-comment">// 2 * 2 = 4 &lt; 10</span><br><span class="hljs-comment">// 3 * 3 = 9 &lt; 10</span><br><span class="hljs-comment">// 4 * 4 = 16 &gt; 10</span><br><span class="hljs-comment">//推断：10的平方根是在3~4之间。</span><br><br><br><span class="hljs-comment">// 20</span><br><span class="hljs-comment">// 1 * 1 = 1 &lt; 20</span><br><span class="hljs-comment">// 2 * 2 = 4 &lt; 20</span><br><span class="hljs-comment">// 3 * 3 = 9 &lt; 20</span><br><span class="hljs-comment">// 4 * 4 = 16 &lt; 20</span><br><span class="hljs-comment">// 5 * 5 = 25 &gt; 20</span><br><span class="hljs-comment">//推断：20的平方根是在4~5之间。</span><br><br><br><span class="hljs-comment">//在代码当中</span><br><span class="hljs-comment">//从1开始循环，拿着数字的平方跟原来的数字进行比较</span><br><span class="hljs-comment">//如果小于的，那么继续往后判断</span><br><span class="hljs-comment">//如果相等，那么当前数字就是平方根</span><br><span class="hljs-comment">//如果大于的，那么前一个数字就是平方跟的整数部分</span><br><br><br><span class="hljs-comment">//1.键盘录入一个整数</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入一个整数&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> sc.nextInt();<br><span class="hljs-comment">//2.从1开始循环判断</span><br><span class="hljs-comment">//开始：1 结束: number</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= number; i++) &#123;<br>    <span class="hljs-comment">//用i * i 再跟number进行比较</span><br>    <span class="hljs-keyword">if</span>(i * i == number)&#123;<br>        System.out.println(i + <span class="hljs-string">&quot;就是&quot;</span> + number + <span class="hljs-string">&quot;的平方根&quot;</span>);<br>        <span class="hljs-comment">//一旦找到了，循环就可以停止了，后面的数字就不需要再找了，提高代码的运行效率。</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i * i &gt; number)&#123;<br>        System.out.println((i - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;就是&quot;</span> + number + <span class="hljs-string">&quot;平方根的整数部分&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断是否为质数">6.判断是否为质数</h2><p>需求：</p><pre><code class="hljs">键盘录入一个正整数 x ，判断该整数是否为一个质数。 </code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//需求：键盘录入一个正整数 x ，判断该整数是否为一个质数。</span><br><br><span class="hljs-comment">//质数：</span><br><span class="hljs-comment">//如果一个整数只能被1和本身整除，那么这个数就是质数。否则这个数叫做合数</span><br><span class="hljs-comment">//7 = 1 * 7 质数</span><br><span class="hljs-comment">//8 = 1 * 8  2 * 4 合数</span><br><br><br><span class="hljs-comment">//分析：</span><br><span class="hljs-comment">//1.键盘录入一个正整数</span><br><span class="hljs-comment">//number</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入一个正整数&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> sc.nextInt();<span class="hljs-comment">//9</span><br><br><span class="hljs-comment">//定义一个变量，表示标记</span><br><span class="hljs-comment">//标记着number是否为一个质数</span><br><span class="hljs-comment">//true： 是一个质数</span><br><span class="hljs-comment">//false : 不是一个质数</span><br><br><span class="hljs-comment">//表示最初就认为number是一个质数</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><br><span class="hljs-comment">//2.判断</span><br><span class="hljs-comment">//写一个循环，从2开始判断，一直判断到number-1为止</span><br><span class="hljs-comment">//看这个范围之内，有没有数字可以被number整除</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; number; i++) &#123;<br>    <span class="hljs-comment">//i 依次表示这个范围之内的每一个数字</span><br>    <span class="hljs-comment">//看number是否能被i整除就可以了</span><br>    <span class="hljs-keyword">if</span>(number % i == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 9 % 2 = 1</span><br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//System.out.println(number + &quot;不是一个质数&quot;);</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-comment">/*else&#123;</span><br><span class="hljs-comment">                System.out.println(number + &quot;是一个质数&quot;);</span><br><span class="hljs-comment">            &#125;*/</span><br>&#125;<br><br><span class="hljs-comment">//只有当这个循环结束了，表示这个范围之内所有的数字都判断完毕了</span><br><span class="hljs-comment">//此时才能断定number是一个质数</span><br><span class="hljs-keyword">if</span>(flag)&#123;<br>    System.out.println(number + <span class="hljs-string">&quot;是一个质数&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    System.out.println(number + <span class="hljs-string">&quot;不是一个质数&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="猜数字小游戏">7. 猜数字小游戏</h2><p>需求：</p><pre><code class="hljs">程序自动生成一个1-100之间的随机数，在代码中使用键盘录入去猜出这个数字是多少？</code></pre><p>要求：</p><pre><code class="hljs">使用循环猜，一直猜中为止。</code></pre><p>思路分析：</p><ol type="1"><li>生成一个1-100之间的随机数</li><li>使用键盘录入去猜出这个数字是多少</li><li>把反复猜的代码写在循环中</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.生成一个1-100之间的随机数</span><br><span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">100</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">// 0 ~ 99 + 1 --- 1 ~ 100</span><br>System.out.println(number);<br><br><span class="hljs-comment">//2.使用键盘录入去猜出这个数字是多少？</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;请输入一个整数&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">guessNumber</span> <span class="hljs-operator">=</span> sc.nextInt();<br>    <span class="hljs-comment">//3.比较</span><br>    <span class="hljs-keyword">if</span>(guessNumber &gt; number)&#123;<br>        System.out.println(<span class="hljs-string">&quot;您猜的数字大了&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(guessNumber &lt; number)&#123;<br>        System.out.println(<span class="hljs-string">&quot;您猜的数字小了&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;恭喜你，猜中了&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java04-判断和循环</title>
    <link href="/2023/06/29/Java04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/"/>
    <url>/2023/06/29/Java04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-流程控制语句">第一章 流程控制语句</h2><p>在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。</p><h3 id="流程控制语句分类">1.1 流程控制语句分类</h3><pre><code class="hljs">顺序结构判断和选择结构(if, switch)循环结构(for, while, do…while)</code></pre><h3 id="顺序结构">1.2 顺序结构</h3><p>顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。</p><p>顺序结构执行流程图：</p><p><img src="/img/04-Java判断和循环/7ededb84db2e49cd8c0887a2f4873189.png" /></p><h2 id="第二章-判断语句if语句">第二章 判断语句：if语句</h2><h3 id="if语句格式1">2.1 if语句格式1</h3><p>格式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (关系表达式) &#123;<br>    语句体;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>执行流程：</p><p>①首先计算关系表达式的值</p><p>②如果关系表达式的值为true就执行语句体</p><p>③如果关系表达式的值为false就不执行语句体</p><p>④继续执行后面的语句内容</p><p><img src="/img/04-Java判断和循环/678e041956b54723a24ead3103ac6b28.png" /> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IfDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;开始&quot;</span>);<br><span class="hljs-comment">//定义两个变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-comment">//需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b</span><br><span class="hljs-keyword">if</span>(a == b) &#123;<br>System.out.println(<span class="hljs-string">&quot;a等于b&quot;</span>);<br>&#125;<br><span class="hljs-comment">//需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c</span><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span>(a == c) &#123;<br>System.out.println(<span class="hljs-string">&quot;a等于c&quot;</span>);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if语句格式2">2.2 if语句格式2</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (关系表达式) &#123;<br>    语句体<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    语句体<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式的值</p><p>②如果关系表达式的值为true就执行语句体1</p><p>③如果关系表达式的值为false就执行语句体2</p><p>④继续执行后面的语句内容</p><p><img src="/img/04-Java判断和循环/39c52aa5d50049e48513a724a5aceb87.png" /></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IfDemo02</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;开始&quot;</span>);<br><span class="hljs-comment">//定义两个变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-comment">//需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b</span><br><span class="hljs-keyword">if</span>(a &gt; b) &#123;<br>System.out.println(<span class="hljs-string">&quot;a的值大于b&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;a的值不大于b&quot;</span>);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if语句格式3">2.3 if语句格式3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">格式：<br><span class="hljs-keyword">if</span> (关系表达式<span class="hljs-number">1</span>) &#123;<br>    语句体<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (关系表达式<span class="hljs-number">2</span>) &#123;<br>    语句体<span class="hljs-number">2</span>;<br>&#125; <br>…<br><span class="hljs-keyword">else</span> &#123;<br>    语句体n+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式1的值</p><p>②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值</p><p>③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值</p><p>④…</p><p>⑤如果没有任何关系表达式为true，就执行语句体n+1。</p><p><img src="/img/04-Java判断和循环/273c4ba80bbb4f51a924fb7b81f1d75c.png" /></p><h2 id="第三章-switch语句">第三章 switch语句</h2><h3 id="格式">3.1 格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (表达式) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>语句体<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>语句体<span class="hljs-number">2</span>;<br><span class="hljs-keyword">break</span>;<br>...<br><span class="hljs-keyword">default</span>:<br>语句体n+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="执行流程">3.2 <strong>执行流程：</strong></h3><ul><li>首先计算出表达式的值</li><li>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。</li><li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。</li></ul><h4 id="练习运动计划">练习：运动计划</h4><ul><li><p>需求：键盘录入星期数，显示今天的减肥活动。</p><p>周一：跑步</p><p>周二：游泳</p><p>周三：慢走</p><p>周四：动感单车</p><p>周五：拳击</p><p>周六：爬山</p><p>周日：好好吃一顿</p></li><li><p>代码示例：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwitchDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.键盘录入一个整数表示星期</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入一个整数表示星期&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">week</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-comment">//2.书写一个switch语句去跟week进行匹配</span><br>        <span class="hljs-keyword">switch</span> (week)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                System.out.println(<span class="hljs-string">&quot;跑步&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                System.out.println(<span class="hljs-string">&quot;游泳&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                System.out.println(<span class="hljs-string">&quot;慢走&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                System.out.println(<span class="hljs-string">&quot;动感单车&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                System.out.println(<span class="hljs-string">&quot;拳击&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                System.out.println(<span class="hljs-string">&quot;爬山&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>                System.out.println(<span class="hljs-string">&quot;好好吃一顿&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                System.out.println(<span class="hljs-string">&quot;输入错误，没有这个星期&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="switch的扩展知识">3.3 switch的扩展知识：</h3><ul><li><p>default的位置和省略情况</p><p>default可以放在任意位置，也可以省略</p></li><li><p>case穿透</p><p>不写break会引发case穿透现象</p></li><li><p>switch在JDK12的新特性</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">switch</span> (number) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> -&gt; System.out.println(<span class="hljs-string">&quot;一&quot;</span>);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> -&gt; System.out.println(<span class="hljs-string">&quot;二&quot;</span>);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span> -&gt; System.out.println(<span class="hljs-string">&quot;三&quot;</span>);<br>    <span class="hljs-keyword">default</span> -&gt; System.out.println(<span class="hljs-string">&quot;其他&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>switch和if第三种格式各自的使用场景</li></ul><p>当我们需要对一个范围进行判断的时候，用if的第三种格式</p><p>当我们把有限个数据列举出来，选择其中一个执行的时候，用switch语句</p><p>比如：</p><p>小明的考试成绩，如果用switch，那么需要写100个case，太麻烦了，所以用if简单。</p><p>如果是星期，月份，客服电话中0~9的功能选择就可以用switch</p><h2 id="第四章-循环结构">第四章 循环结构</h2><h3 id="for循环结构掌握">4.1 for循环结构（掌握）</h3><p>循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环。</p><h4 id="for循环格式">4.1.1 for循环格式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (初始化语句;条件判断语句;条件控制语句) &#123;<br>循环体语句;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>格式解释：</strong></p><ul><li>初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样</li><li>条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去</li><li>循环体语句： 用于表示循环反复执行的内容，简单说就是循环反复执行的事情</li><li>条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去</li></ul><p><strong>执行流程：</strong></p><p>①执行初始化语句</p><p>②执行条件判断语句，看其结果是true还是false</p><pre><code class="hljs">         如果是false，循环结束         如果是true，继续执行</code></pre><p>③执行循环体语句</p><p>④执行条件控制语句</p><p>⑤回到②继续</p><p><strong>for循环书写技巧：</strong></p><ul><li>确定循环的开始条件</li><li>确定循环的结束条件</li><li>确定循环要重复执行的代码</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.确定循环的开始条件</span><br><span class="hljs-comment">//2.确定循环的结束条件</span><br><span class="hljs-comment">//3.确定要重复执行的代码</span><br><br><span class="hljs-comment">//需求：打印5次HelloWorld</span><br><span class="hljs-comment">//开始条件：1</span><br><span class="hljs-comment">//结束条件：5</span><br><span class="hljs-comment">//重复代码：打印语句</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="while循环">4.2 while循环</h3><h4 id="格式-1">4.2.1 格式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化语句;<br><span class="hljs-keyword">while</span>(条件判断语句)&#123;<br>循环体;<br>条件控制语句;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="实例打印5次helloworld">实例：打印5次HelloWorld</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i &lt;= <span class="hljs-number">5</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>    i++;<br>&#125;<br>System.out.println(i);<br></code></pre></td></tr></table></figure><h3 id="do...while循环">4.3 do...while循环</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化语句;<br><span class="hljs-keyword">do</span>&#123;<br>    循环体;<br>    条件控制语句;<br>&#125;<span class="hljs-keyword">while</span>(条件判断语句);<br></code></pre></td></tr></table></figure><p>特点：</p><pre><code class="hljs">先执行，再判断。</code></pre><h3 id="三种格式的区别">4.4 三种格式的区别：</h3><pre><code class="hljs">for和while循环，是先判断，再执行。do...while是先执行，再判断。当知道循环次数或者循环范围的时候，用for循环。当不知道循环次数，也不知道循环范围，但是知道循环的结束条件时，用while循环。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java03-运算符</title>
    <link href="/2023/06/29/Java03-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2023/06/29/Java03-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="运算符和表达式">1.运算符和表达式</h1><h3 id="运算符">运算符：</h3><pre><code class="hljs">就是对常量或者变量进行操作的符号。比如： +  -  *  / </code></pre><h3 id="表达式">表达式：</h3><pre><code class="hljs">用运算符把常量或者变量连接起来的，符合Java语法的式子就是表达式。比如：a + b 这个整体就是表达式。而其中+是算术运算符的一种，所以这个表达式也称之为算术表达式。</code></pre><h1 id="算术运算符">2.算术运算符</h1><p>分类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">+ - * / %<br></code></pre></td></tr></table></figure><p>运算特点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">+ - * :跟数学中一样.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">/：<br><span class="hljs-number">1.</span>整数相除结果只能得到整除，如果结果想要是小数，必须要有小数参数。<br><span class="hljs-number">2.</span>小数直接参与运算，得到的结果有可能是不精确的。<br>案例：<br>System.out.println( <span class="hljs-number">10</span> / <span class="hljs-number">3</span>);<span class="hljs-comment">//3</span><br>System.out.println(<span class="hljs-number">10.0</span> / <span class="hljs-number">3</span>);<span class="hljs-comment">//3.3333333333333335</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">%：取模、取余。<br>   做的也是除法运算，只不过获取的是余数而已。<br>案例：<br>System.out.println(<span class="hljs-number">10</span> % <span class="hljs-number">2</span>);<span class="hljs-comment">//0</span><br>System.out.println(<span class="hljs-number">10</span> % <span class="hljs-number">3</span>);<span class="hljs-comment">//1</span><br>应用场景：<br><span class="hljs-comment">//可以利用取模来判断一个数是奇数还是偶数</span><br>System.out.println(<span class="hljs-number">15</span> % <span class="hljs-number">2</span>);<span class="hljs-comment">//1  奇数</span><br></code></pre></td></tr></table></figure><h3 id="练习数值拆分">练习：数值拆分</h3><p>需求：键盘录入一个三位数，将其拆分为个位、十位、百位后，打印在控制台</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.键盘录入一个三位数</span><br><span class="hljs-comment">//导包 --- 创建对象 --- 接收数据</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入一个三位数&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> sc.nextInt();<span class="hljs-comment">//123</span><br><br><span class="hljs-comment">//2.获取这个三位数的个位、十位、百位并打印出来</span><br><span class="hljs-comment">//公式：</span><br><span class="hljs-comment">//针对于任意的一个数而言</span><br><span class="hljs-comment">//个位： 数字 % 10</span><br><span class="hljs-type">int</span> <span class="hljs-variable">ones</span> <span class="hljs-operator">=</span> number % <span class="hljs-number">10</span>;<br><span class="hljs-comment">//十位： 数字 / 10 % 10</span><br><span class="hljs-type">int</span> <span class="hljs-variable">tens</span> <span class="hljs-operator">=</span> number / <span class="hljs-number">10</span> % <span class="hljs-number">10</span>;<br><span class="hljs-comment">//百位： 数字 / 100 % 10</span><br><span class="hljs-type">int</span> <span class="hljs-variable">hundreds</span> <span class="hljs-operator">=</span> number / <span class="hljs-number">100</span>  % <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//输出结果</span><br>System.out.println(ones);<br>System.out.println(tens);<br>System.out.println(hundreds);<br></code></pre></td></tr></table></figure><p>公式：</p><p>获取任意一个数上每一位数。</p><p>个位：数字 % 10</p><p>十位：数字 / 10 % 10</p><p>百位：数字 / 100 % 10</p><p>千位：数字 / 1000 % 10</p><p>以此类推</p><h1 id="隐式转换">3.隐式转换</h1><h3 id="概念">概念：</h3><p>也叫自动类型提升。</p><p>就是把一个取值范围小的数据或者变量，赋值给另一个取值范围大的变量。此时不需要我们额外写代码单独实现，是程序自动帮我们完成的。</p><p>简单记忆：就是小的给大的，可以直接给。</p><h3 id="两种提升规则">两种提升规则：</h3><ul><li>取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算。</li><li>byte、short、char三种类型的数据在运算的时候，都会直接先提升为int，然后再进行运算。</li></ul><h3 id="取值范围从小到大的关系">取值范围从小到大的关系：</h3><pre><code class="hljs">byte \&lt;short \&lt;int \&lt;long \&lt;float \&lt;double</code></pre><h1 id="强制转换">4.强制转换</h1><h3 id="概念-1">概念：</h3><p>如果要把一个取值范围大的数据或者变量赋值给另一个取值范围小的变量。是不允许直接操作。如果一定要这么干，就需要加入强制转换。</p><h3 id="书写格式">书写格式：</h3><pre><code class="hljs">目标数据类型 变量名 = （目标数据类型）被强转的数据；</code></pre><p>简单理解：要转成什么类型的，那么就在小括号中写什么类型就可以了。</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatorDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">12.3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) a;<br>        System.out.println(b);<span class="hljs-comment">//12</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意点：</p><pre><code class="hljs">强制转换有可能会导致数据发生错误。（数据的精度丢失）</code></pre><h1 id="字符串的操作">5.字符串的+操作</h1><h3 id="核心技巧">核心技巧：</h3><ul><li>当+操作中出现字符串时，此时就是字符串的连接符，会将前后的数据进行拼接，并产生一个新的字符串。</li><li>当连续进行+操作时，从左到右逐个执行的。</li></ul><h1 id="字符串相加的练习">6.字符串相加的练习：</h1><p>案例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结果："1abc1"</p><p>解释：</p><pre><code class="hljs">第一步： 1 + &quot;abc&quot;。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串&quot;1abc&quot;第二步：  &quot;1abc&quot; + 1。这个过程中，有字符串参与的，所以做的也是拼接操作，产生一个新的字符串&quot;1abc1&quot;</code></pre><p>案例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结果：“3abc21”</p><p>解释：</p><pre><code class="hljs">第一步：1 + 2 。在这个过程中，没有字符串参与的，所以做的是加法运算，结果为3。第二步：3 + &quot;abc&quot;。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串&quot;3abc&quot;。第三步：&quot;3abc&quot; + 2。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串&quot;3abc2&quot;。第四步：&quot;3abc2&quot; + 1。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串“3abc21”</code></pre><h1 id="字符的操作">8.字符的+操作</h1><h3 id="规则">规则：</h3><pre><code class="hljs">当+操作中出现了**字符**，会拿着字符到计算机内置的ASCII码表中去查对应的数字，然后再进行计算。</code></pre><h3 id="案例">案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> c + <span class="hljs-number">0</span>;<br>System.out.println(result);<span class="hljs-comment">//97</span><br></code></pre></td></tr></table></figure><p>ASCII码表中：</p><pre><code class="hljs">&#39;a&#39;   -----    97&#39;A&#39;   -----    65</code></pre><h1 id="算术运算符的总结">9.算术运算符的总结</h1><p>分类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">+ - * / %  这些操作跟小学数学几乎是一模一样的。<br></code></pre></td></tr></table></figure><p>注意点：</p><ul><li>/ 和 % 的区别：他们两个都是做除法运算，/取结果的商。% 取结果的余数。</li><li>整数操作只能得到整数，如果想要得到小数，必须有浮点数参与运算。</li></ul><p>算术运算符的高级用法：</p><p>是以+为例进行的讲解，其余减法，乘法，除法的运算规则也是一样的。</p><p>特例：字符串只有+操作，没有其他操作。</p><h1 id="自增自减运算符">10.自增自减运算符</h1><h3 id="分类">分类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">++  自增运算符<br>--  自减运算符<br></code></pre></td></tr></table></figure><p>++：就是把变量里面的值+1</p><p>--：就是把变量里面的值-1</p><h3 id="使用方式">使用方式：</h3><ul><li>放在变量的前面，我们叫做先++。 比如：++a</li><li>放在变量的后面，我们叫做后++。 比如：a++</li></ul><h3 id="注意点">注意点：</h3><pre><code class="hljs">不管是先++，还是后++。单独写在一行的时候，运算结果是一模一样的。</code></pre><h3 id="案例-1">案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//++</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>a++;<span class="hljs-comment">//就是让变量a里面的值 + 1</span><br>System.out.println(a);<span class="hljs-comment">//11</span><br>++a;<span class="hljs-comment">//就是让变量a里面的值 + 1</span><br>System.out.println(a);<span class="hljs-comment">//12</span><br></code></pre></td></tr></table></figure><h3 id="自增自减运算符的应用场景">自增自减运算符的应用场景：</h3><p>某些情况下，变量需要进行加1或者减1的时候使用。</p><p>比如：过生日多一岁，就用到了自增运算符。</p><p>比如：购物商场中，选择商品数量，也用到了自增或者自减运算符。</p><p>比如：统计很多数据中，有多少个数据满足要求，也用到了自增运算符。</p><h1 id="赋值运算符">11.赋值运算符</h1><p>最为常用的： =</p><p>运算过程：就是把等号右边的结果赋值给左边的变量</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatorDemo6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.最为简单的赋值运算符用法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-comment">//就是把10赋值给变量a</span><br>        System.out.println(a);<br><br>        <span class="hljs-comment">//2.如果等号右边需要进行计算。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<span class="hljs-comment">//先计算等号右边的，把计算的结果赋值给左边的变量</span><br>        System.out.println(c);<br><br>        <span class="hljs-comment">//3.特殊的用法</span><br>        a = a + <span class="hljs-number">10</span>;<span class="hljs-comment">//先计算等号右边的，把计算的结果赋值给左边的变量</span><br>        System.out.println(a);<span class="hljs-comment">//20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="扩展赋值运算符">12.扩展赋值运算符</h1><h3 id="分类-1">分类：</h3><pre><code class="hljs">+=、-=、*=、/=、%=</code></pre><h3 id="运算规则">运算规则：</h3><pre><code class="hljs">就是把左边跟右边进行运算，把最终的结果赋值给左边，对右边没有任何影响。</code></pre><h3 id="案例-2">案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatorDemo7</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//扩展赋值运算符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        a += b;<span class="hljs-comment">//把左边和右边相加，再把最终的结果赋值给左边，对右边没有任何影响</span><br>        <span class="hljs-comment">// 相当于 a = a + b;</span><br>        System.out.println(a);<span class="hljs-comment">//30</span><br>        System.out.println(b);<span class="hljs-comment">//20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意点-1">注意点：</h3><p>扩展的赋值运算符中隐层还包含了一个强制转换。</p><p>以+=为例。</p><p>a += b ;实际上相当于 a = (byte)(a + b);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatorDemo8</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-comment">//a += b;</span><br>        a = (<span class="hljs-type">byte</span>)(a + b);<br>        System.out.println(a);<span class="hljs-comment">//30</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="关系运算符">13.关系运算符</h1><p>又叫比较运算符，其实就是拿着左边跟右边进行了判断而已。</p><h3 id="分类-2">分类：</h3><table><thead><tr class="header"><th>符号</th><th>解释</th></tr></thead><tbody><tr class="odd"><td>==</td><td>就是判断左边跟右边是否相等，如果成立就是true，如果不成立就是false</td></tr><tr class="even"><td>!=</td><td>就是判断左边跟右边是否不相等，如果成立就是true，如果不成立就是false</td></tr><tr class="odd"><td>&gt;</td><td>就是判断左边是否大于右边，如果成立就是true，如果不成立就是false</td></tr><tr class="even"><td>&gt;=</td><td>就是判断左边是否大于等于右边，如果成立就是true，如果不成立就是false</td></tr><tr class="odd"><td>&lt;</td><td>就是判断左边是否小于右边，如果成立就是true，如果不成立就是false</td></tr><tr class="even"><td>&lt;=</td><td>就是判断左边是否小于等于右边，如果成立就是true，如果不成立就是false</td></tr></tbody></table><h3 id="注意点-2">注意点：</h3><ul><li>关系运算符最终的结果一定是布尔类型的。要么是true，要么是false</li><li>在写==的时候，千万不要写成=</li></ul><h1 id="逻辑运算符">14.逻辑运算符</h1><h3 id="和-的使用">&amp; 和 | 的使用：</h3><p>&amp;：逻辑与（而且）</p><pre><code class="hljs">两边都为真，结果才是真，只要有一个为假，那么结果就是假。</code></pre><p>|：逻辑或（或者）</p><pre><code class="hljs">两边都为假，结果才是假，只要有一个为真，那么结果就是真。</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// &amp;  //两边都是真，结果才是真。</span><br>System.out.println(<span class="hljs-literal">true</span> &amp; <span class="hljs-literal">true</span>);<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-literal">false</span> &amp; <span class="hljs-literal">false</span>);<span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-literal">true</span> &amp; <span class="hljs-literal">false</span>);<span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-literal">false</span> &amp; <span class="hljs-literal">true</span>);<span class="hljs-comment">//false</span><br><br>System.out.println(<span class="hljs-string">&quot;===================================&quot;</span>);<br><br><span class="hljs-comment">// | 或  //两边都是假，结果才是假，如果有一个为真，那么结果就是真。</span><br>System.out.println(<span class="hljs-literal">true</span> | <span class="hljs-literal">true</span>);<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-literal">false</span> | <span class="hljs-literal">false</span>);<span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-literal">true</span> | <span class="hljs-literal">false</span>);<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-literal">false</span> | <span class="hljs-literal">true</span>);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>使用技巧：</p><pre><code class="hljs">当两种条件只要满足其中一个的时候，可以使用或</code></pre><h3 id="异或的使用">^（异或）的使用：</h3><pre><code class="hljs">在以后用的不多，了解一下即可。</code></pre><p>计算规则：如果两边相同，结果为false，如果两边不同，结果为true</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//^   //左右不相同，结果才是true，左右相同结果就是false</span><br>System.out.println(<span class="hljs-literal">true</span> ^ <span class="hljs-literal">true</span>);<span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-literal">false</span> ^ <span class="hljs-literal">false</span>);<span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-literal">true</span> ^ <span class="hljs-literal">false</span>);<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-literal">false</span> ^ <span class="hljs-literal">true</span>);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h3 id="取反的使用">!（取反）的使用：</h3><pre><code class="hljs">是取反，也叫做非。</code></pre><p>计算规则：false取反就是true，true取反就是false</p><p>温馨提示：<strong>取反最多只用一个。</strong></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(!<span class="hljs-literal">false</span>);<span class="hljs-comment">//true</span><br>System.out.println(!<span class="hljs-literal">true</span>);<span class="hljs-comment">//false</span><br><br>System.out.println(!!<span class="hljs-literal">false</span>);<span class="hljs-comment">//注意点：取反最多只用一个。</span><br></code></pre></td></tr></table></figure><h1 id="短路逻辑运算符">15.短路逻辑运算符</h1><p>分类： &amp;&amp; ||</p><h3 id="section">&amp;&amp;：</h3><pre><code class="hljs">运算结果跟&amp;是一模一样的，只不过具有短路效果。</code></pre><h3 id="section-1">||：</h3><pre><code class="hljs">运算结果跟|是一模一样的。只不过具有短路效果。</code></pre><h3 id="逻辑核心">逻辑核心：</h3><pre><code class="hljs">当左边不能确定整个表达式的结果，右边才会执行。当左边能确定整个表达式的结果，那么右边就不会执行了。从而提高了代码的运行效率。</code></pre><h3 id="举例">举例：</h3><ul><li><p>用户登录案例</p><p>用户名正确 &amp; 密码正确</p><p>如果使用一个&amp;，不管用户名是否正确都会去验证密码。</p></li></ul><p>思考：</p><pre><code class="hljs">如果用户名输入正确了，那么我们再判断密码是否正确，是符合业务逻辑的。但是如果用户名输入错误了，那么现在还有必要去比较密码吗？没有不要了。如果使用一个&amp;，那么左边和右边不管什么情况下，都会执行。用户名正确  &amp;&amp;  密码正确如果用户名输入正确了，那么才会验证密码是否输入正确。如果用户名输入错误了，那么就不会再去验证密码是否正确，最终的结果直接为false。从而提高了程序运行的效率。</code></pre><h3 id="总结">总结：</h3><pre><code class="hljs">&amp;&amp; 和 &amp; 、||和|的运行结果都是一模一样的。但是短路逻辑运算符可以提高程序的运行效率。</code></pre><h3 id="建议">建议：</h3><pre><code class="hljs">最为常用： &amp;&amp;   ||   ！</code></pre><h1 id="三元运算符">16.三元运算符</h1><p>又叫做：三元表达式或者问号冒号表达式。</p><h3 id="格式">格式：</h3><pre><code class="hljs">关系表达式 ？ 表达式1 ：表达式2 ；</code></pre><h3 id="计算规则">计算规则：</h3><ul><li>计算关系表达式的值。</li><li>如果关系表达式的值为真，那么执行表达式1。</li><li>如果关系表达式的值为假，那么执行表达式2。</li></ul><h3 id="注意点-3">注意点：</h3><pre><code class="hljs">三元运算符的最终结果一定要被使用，要么赋值给一个变量，要么直接打印出来。</code></pre><h3 id="案例-3">案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatorDemo12</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//需求：求两个数的较大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        <span class="hljs-comment">//格式：关系表达式 ？ 表达式1 ： 表达式2 ；</span><br>        <span class="hljs-comment">//注意点：</span><br>        <span class="hljs-comment">//三元运算符的最终结果一定要被使用。</span><br>        <span class="hljs-comment">//要么赋值给一个变量，要么直接输出。</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span>  a &gt; b ? a : b ;<br>        System.out.println(max);<br><br><br>        System.out.println(a &gt; b ? a : b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java02-基础概念</title>
    <link href="/2023/06/29/Java02-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/06/29/Java02-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="java基础概念">Java基础概念</h1><h2 id="注释">1. 注释</h2><p>注释是对代码的解释和说明文字。</p><p>Java中的注释分为三种：</p><ul><li>单行注释：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是单行注释文字</span><br></code></pre></td></tr></table></figure><ul><li>多行注释：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">*/</span><br>注意：多行注释不能嵌套使用。<br></code></pre></td></tr></table></figure><ul><li>文档注释：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">这是多行注释文字</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="使用的技巧">使用的技巧</h3><pre><code class="hljs">如果我们要对代码进行解释，那么就可以使用注释。当注释的内容比较少，一行就写完了，可以用单行注释。如果注释的内容比较多，需要写在多行，那么可以使用多行注释。</code></pre><h3 id="注意">注意：</h3><pre><code class="hljs">注释的内容不会参与编译和运行的，仅仅是对代码的解释说明而已。所以，不管在注释当中写什么内容，都不会影响代码运行的结果。</code></pre><h2 id="关键字">2. 关键字</h2><h3 id="概念">2.1 概念</h3><pre><code class="hljs">被Java赋予了特定含义的英文单词。当我们在代码中写了关键字之后，程序在运行的时候，就知道要做什么事情了。</code></pre><table><thead><tr class="header"><th><strong>abstract</strong></th><th><strong>assert</strong></th><th><strong>boolean</strong></th><th><strong>break</strong></th><th><strong>byte</strong></th></tr></thead><tbody><tr class="odd"><td><strong>case</strong></td><td><strong>catch</strong></td><td><strong>char</strong></td><td><strong>class</strong></td><td><strong>const</strong></td></tr><tr class="even"><td><strong>continue</strong></td><td><strong>default</strong></td><td><strong>do</strong></td><td><strong>double</strong></td><td><strong>else</strong></td></tr><tr class="odd"><td><strong>enum</strong></td><td><strong>extends</strong></td><td><strong>final</strong></td><td><strong>finally</strong></td><td><strong>float</strong></td></tr><tr class="even"><td><strong>for</strong></td><td><strong>goto</strong></td><td><strong>if</strong></td><td><strong>implements</strong></td><td><strong>import</strong></td></tr><tr class="odd"><td><strong>instanceof</strong></td><td><strong>int</strong></td><td><strong>interface</strong></td><td><strong>long</strong></td><td><strong>native</strong></td></tr><tr class="even"><td><strong>new</strong></td><td><strong>package</strong></td><td><strong>private</strong></td><td><strong>protected</strong></td><td><strong>public</strong></td></tr><tr class="odd"><td><strong>return</strong></td><td><strong>strictfp</strong></td><td><strong>short</strong></td><td><strong>static</strong></td><td><strong>super</strong></td></tr><tr class="even"><td><strong>switch</strong></td><td><strong>synchronized</strong></td><td><strong>this</strong></td><td><strong>throw</strong></td><td><strong>throws</strong></td></tr><tr class="odd"><td><strong>transient</strong></td><td><strong>try</strong></td><td><strong>void</strong></td><td><strong>volatile</strong></td><td><strong>while</strong></td></tr></tbody></table><h3 id="第一个关键字class">2.2 第一个关键字class</h3><pre><code class="hljs">表示定义一个类 创建一个类。</code></pre><p>类：Java项目最基本的组成单元，一个完整的Java项目有可能会有成千上万个类来组成的。</p><p>class后面跟随的就是这个类的名字，简称：类名。</p><p>在类名后面会有一对大括号，表示这个类的内容。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>解释：class表示定义类。</p><pre><code class="hljs">类名：HelloWorldHelloWorld后面的大括号表示这个类的范围。</code></pre><h2 id="字面量">3. 字面量</h2><p>作用：告诉程序员，数据在程序中的书写格式。</p><table><thead><tr class="header"><th><strong>字面量类型</strong></th><th><strong>说明</strong></th><th><strong>程序中的写法</strong></th></tr></thead><tbody><tr class="odd"><td>整数</td><td>不带小数的数字</td><td>666，-88</td></tr><tr class="even"><td>小数</td><td>带小数的数字</td><td>13.14，-5.21</td></tr><tr class="odd"><td>字符</td><td>必须使用单引号，有且仅能一个字符</td><td>‘A’，‘0’， ‘我’</td></tr><tr class="even"><td>字符串</td><td>必须使用双引号，内容可有可无</td><td>“HelloWorld”，“程序员”</td></tr><tr class="odd"><td>布尔值</td><td>布尔值，表示真假，只有两个值：true，false</td><td>true 、false</td></tr><tr class="even"><td>空值</td><td>一个特殊的值，空值</td><td>值是：null</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-number">10</span>); <span class="hljs-comment">// 输出一个整数</span><br>        System.out.println(<span class="hljs-number">5.5</span>); <span class="hljs-comment">// 输出一个小数</span><br>        System.out.println(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// 输出一个字符</span><br>        System.out.println(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 输出boolean值true</span><br>        System.out.println(<span class="hljs-string">&quot;程序员&quot;</span>); <span class="hljs-comment">// 输出字符串</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区分技巧">区分技巧</h3><ol type="1"><li>不带小数点的数字都是整数类型的字面量。</li><li>只要带了小数点，那么就是小数类型的字面量。</li><li>只要用双引号引起来的，不管里面的内容是什么，不管里面有没有内容，都是字符串类型的字面量。</li><li>字符类型的字面量必须用单引号引起来，不管内容是什么，但是个数有且只能有一个。</li><li>字符类型的字面量只有两个值，true、false。</li><li>空类型的字面量只有一个值，null。</li></ol><h2 id="变量">4. 变量</h2><h3 id="什么是变量">4.1 什么是变量？</h3><pre><code class="hljs">变量就在程序中临时存储数据的容器。但是这个容器中只能存一个值。</code></pre><h3 id="变量的定义格式">4.2 变量的定义格式</h3><pre><code class="hljs">数据类型 变量名 = 数据值；</code></pre><h4 id="格式详解">4.2.1 格式详解</h4><pre><code class="hljs">数据类型：限定了变量当中能存储什么类型的数据。如果要存10，那么数据类型就需要写整数类型。如果要存10.0，那么数据类型就需要写小数类型。变量名：其实就是这个容器的名字。当以后想要使用变量里面的数据时，直接使用变量名就可以了。数据值：真正存储在容器中的数据。分号：表示语句的结束，就跟以前写作文时候的句号是一样的。</code></pre><h4 id="常用的数据类型">4.2.2 常用的数据类型</h4><pre><code class="hljs">整数：int小数：（浮点数）double其他数据类型稍后讲解</code></pre><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableDemo</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">//定义一个整数类型的变量</span><br><span class="hljs-comment">//数据类型 变量名 = 数据值;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>System.out.println(a);<span class="hljs-comment">//16</span><br><br><span class="hljs-comment">//定义一个小数类型的变量</span><br><span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10.1</span>;<br>System.out.println(b);<span class="hljs-comment">//10.1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="变量的注意事项">4.2.3 变量的注意事项</h4><ul><li>变量名不能重复</li><li>在一条语句中，可以定义多个变量。但是这种方式影响代码的阅读，所以了解一下即可。</li><li>变量在使用之前必须要赋值。</li></ul><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableDemo2</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">//1.变量名不允许重复</span><br><span class="hljs-comment">//int a = 10;</span><br><span class="hljs-comment">//int a = 20;</span><br><span class="hljs-comment">//System.out.println(a);</span><br><br><span class="hljs-comment">//2.一条语句可以定义多个变量</span><br><span class="hljs-comment">//了解。</span><br><span class="hljs-comment">//int a = 10, b = 20, c = 20,d = 20;</span><br><span class="hljs-comment">//System.out.println(a);//?</span><br><span class="hljs-comment">//System.out.println(b);//?</span><br><br><br><span class="hljs-comment">//3.变量在使用之前必须要赋值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>System.out.println(a);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="变量的练习">4.3 变量的练习</h3><pre><code class="hljs">需求：说出公交车到终点站之后，车上一共有多少乘客？        一开始没有乘客。       第一站：上去一位乘客，没有下来乘客。       第二站：上去两位乘客，下来一位乘客。       第三站：上去两位乘客，下来一位乘客。       第四站：没有上去乘客，下来一位乘客。       第五站：上去一位乘客，没有下来乘客。       问：到了终点站之后，车上一共多少乘客？代码解析：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableBus</span>&#123;<br><span class="hljs-comment">//主入口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">//一开始没有乘客。</span><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//第一站：上去一位乘客</span><br><span class="hljs-comment">//在原有的基础上 + 1</span><br>count = count + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//System.out.println(count);</span><br><span class="hljs-comment">//第二站：上去两位乘客，下来一位乘客</span><br>count = count + <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; <br><span class="hljs-comment">//第三站：上去两位乘客，下来一位乘客</span><br>count = count + <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br><span class="hljs-comment">//第四站：下来一位乘客</span><br>count = count - <span class="hljs-number">1</span>;<br><span class="hljs-comment">//第五站：上去一位乘客</span><br>count = count + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//请问：到了终点站，车上一共几位乘客。</span><br>System.out.println(count);<span class="hljs-comment">//3</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据类型">5. 数据类型</h2><h3 id="java语言数据类型的分类">5.1 Java语言数据类型的分类</h3><ul><li>基本数据类型</li><li>引用数据类型（面向对象的时候再深入学习）</li></ul><h3 id="基本数据类型的四类八种">5.2 基本数据类型的四类八种</h3><table><thead><tr class="header"><th style="text-align: center;">数据类型</th><th style="text-align: center;">关键字</th><th style="text-align: center;">内存占用</th><th style="text-align: center;">取值范围</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">整数</td><td style="text-align: center;">byte</td><td style="text-align: center;">1</td><td style="text-align: center;">负的2的7次方 ~ 2的7次方-1(-128~127)</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">short</td><td style="text-align: center;">2</td><td style="text-align: center;">负的2的15次方 ~ 2的15次方-1(-32768~32767)</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">int</td><td style="text-align: center;">4</td><td style="text-align: center;">负的2的31次方 ~ 2的31次方-1</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">long</td><td style="text-align: center;">8</td><td style="text-align: center;">负的2的63次方 ~ 2的63次方-1</td></tr><tr class="odd"><td style="text-align: center;">浮点数</td><td style="text-align: center;">float</td><td style="text-align: center;">4</td><td style="text-align: center;">1.401298e<sup>-45</sup> ~ 3.402823e<sup>+38</sup></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">double</td><td style="text-align: center;">8</td><td style="text-align: center;">4.9000000e<sup>-324</sup> ~ 1.797693e<sup>+308</sup></td></tr><tr class="odd"><td style="text-align: center;">字符</td><td style="text-align: center;">char</td><td style="text-align: center;">2</td><td style="text-align: center;">0-65535</td></tr><tr class="even"><td style="text-align: center;">布尔</td><td style="text-align: center;">boolean</td><td style="text-align: center;">1</td><td style="text-align: center;">true，false</td></tr></tbody></table><h4 id="说明">说明</h4><pre><code class="hljs">e^+38^表示是乘以10的38次方，同样，e^-45^表示乘以10的负45次方。在java中整数默认是int类型，浮点数默认是double类型。</code></pre><h4 id="需要记忆以下几点">需要记忆以下几点</h4><p>byte类型的取值范围：</p><pre><code class="hljs">-128 ~ 127</code></pre><p>int类型的大概取值范围：</p><pre><code class="hljs">-21亿多  ~ 21亿多</code></pre><p>整数类型和小数类型的取值范围大小关系：</p><pre><code class="hljs">double &gt; float &gt; long &gt; int &gt; short &gt; byte</code></pre><p>最为常用的数据类型选择：</p><ul><li><p>在定义变量的时候，要根据实际的情况来选择不同类型的变量。</p><p>比如：人的年龄，可以选择byte类型。</p><p>比如：地球的年龄，可以选择long类型。</p></li><li><p>如果整数类型中，不太确定范围，那么默认使用int类型。</p></li><li><p>如果小数类型中，不太确定范围，那么默认使用double类型。</p></li><li><p>如果要定义字符类型的变量，那么使用char</p></li><li><p>如果要定义布尔类型的变量，那么使用boolean</p></li></ul><h3 id="定义8种基本数据类型变量">5.3 定义8种基本数据类型变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableDemo3</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//1.定义byte类型的变量</span><br>        <span class="hljs-comment">//数据类型 变量名 = 数据值;</span><br>        <span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(a);<br><br>        <span class="hljs-comment">//2.定义short类型的变量</span><br>        <span class="hljs-type">short</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        System.out.println(b);<br><br>        <span class="hljs-comment">//3.定义int类型的变量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>        System.out.println(c);<br><br>        <span class="hljs-comment">//4.定义long类型的变量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">123456789123456789L</span>;<br>        System.out.println(d);<br><br>        <span class="hljs-comment">//5.定义float类型的变量</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-number">10.1F</span>;<br>        System.out.println(e);<br><br>        <span class="hljs-comment">//6.定义double类型的变量</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">20.3</span>;<br>        System.out.println(f);<br><br>        <span class="hljs-comment">//7.定义char类型的变量</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>        System.out.println(g);<br><br>        <span class="hljs-comment">//8.定义boolean类型的变量</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        System.out.println(h);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意-1"><strong>注意</strong></h4><ul><li>如果要定义 一个整数类型的变量，不知道选择哪种数据类型了，默认使用int。</li><li>如果要定义 一个小数类型的变量，不知道选择哪种数据类型了，默认使用double。</li><li>如果要定义一个long类型的变量，那么在数据值的后面需要加上L后缀。（大小写都可以，建议大写。）</li><li>如果要定义一个float类型的变量，那么在数据值的后面需要加上F后缀。（大小写都可以）</li></ul><h2 id="标识符">6. 标识符</h2><p>业内大多数程序员都在遵守阿里巴巴的命名规则。</p><h3 id="硬性要求">6.1 硬性要求：</h3><pre><code class="hljs">必须要这么做，否则代码会报错。</code></pre><ul><li>必须由数字、字母、下划线_、美元符号$组成。</li><li>数字不能开头</li><li>不能是关键字</li><li>区分大小写的。</li></ul><h3 id="软性建议">6.2 软性建议：</h3><pre><code class="hljs">如果不这么做，代码不会报错，但是会让代码显不规范。</code></pre><h3 id="小驼峰命名法">6.2.1 小驼峰命名法</h3><p>适用于变量名和方法名</p><ul><li><p>如果是一个单词，那么全部小写，比如：name</p></li><li><p>如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge</p></li></ul><h3 id="大驼峰命名法">6.2.2 大驼峰命名法</h3><p>适用于类名</p><ul><li><p>如果是一个单词，那么首字母大写。比如：Demo、Test。</p></li><li><p>如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld</p></li></ul><p><strong>不管起什么名字，都要做到见名知意。</strong></p><h3 id="阿里巴巴命名规范细节">阿里巴巴命名规范细节：</h3><ol type="1"><li><p>尽量不要用拼音。但是一些国际通用的拼音可视为英文单词。</p><p>正确：alibaba、hangzhou、nanjing</p><p>错误：jiage、dazhe</p></li><li><p>平时在给变量名、方法名、类名起名字的时候，不要使用下划线或美元符号。</p><p>错误：_name</p><p>正确：name</p></li></ol><h2 id="键盘录入">7. 键盘录入</h2><pre><code class="hljs">键盘录入的实际功能Java已经帮我们写好了，不需要我们自己再实现了，而Java写好的功能都放在了Scanner这个类中，所以，我们只要直接使用Scanner这个类就可以了。</code></pre><p>使用步骤：</p><p>第一步：</p><pre><code class="hljs">导包：其实就是表示先找到Scanner这个类在哪。</code></pre><p>第二步：</p><pre><code class="hljs">创建对象：其实就表示申明一下，我准备开始用Scanner这个类了。</code></pre><p>第三步：</p><pre><code class="hljs">接收数据：也是真正干活的代码。</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//导包，其实就是先找到Scanner这个类在哪</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScannerDemo1</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">//2.创建对象，其实就是申明一下，我准备开始用Scanner这个类了。</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//3.接收数据</span><br><span class="hljs-comment">//当程序运行之后，我们在键盘输入的数据就会被变量i给接收了</span><br>System.out.println(<span class="hljs-string">&quot;请输入一个数字&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sc.nextInt();<br>System.out.println(i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java01-Java入门</title>
    <link href="/2023/06/27/Java01-Java%E5%85%A5%E9%97%A8/"/>
    <url>/2023/06/27/Java01-Java%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="java概述">1. Java概述</h2><h3 id="java是什么">1.1 Java是什么？</h3><p>语言：人与人交流沟通的表达方式</p><p>计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言</p><p>我们想要让计算机做一些事情，那么就可以通过Java语言告诉计算机就可以了</p><h3 id="下载和安装">1.2 下载和安装</h3><h4 id="下载">1.2.1 下载</h4><p>通过官方网站获取JDK <a href="http://www.oracle.com/">http://www.oracle.com</a></p><p><strong>注意</strong>：针对不同的操作系统，需要下载对应版本的JDK。</p><h4 id="安装">1.2.2 安装</h4><p>傻瓜式安装，下一步即可。默认的安装路径是在<code>C:\Program Files</code>下。</p><p>建议：</p><ul><li>安装在除C盘以外的盘内，在这里插入代码片安装路径不要有中文，不要有空格等一些特殊的符号。</li><li>以后跟开发相关的所有软件建议都安装在同一个文件夹中，方便管理。</li></ul><h4 id="jdk的安装目录介绍">1.2.3 JDK的安装目录介绍</h4><table><thead><tr class="header"><th>目录名称</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>bin</td><td>该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。</td></tr><tr class="even"><td>conf</td><td>该路径下存放了JDK的相关配置文件。</td></tr><tr class="odd"><td>include</td><td>该路径下存放了一些平台特定的头文件。</td></tr><tr class="even"><td>jmods</td><td>该路径下存放了JDK的各种模块。</td></tr><tr class="odd"><td>legal</td><td>该路径下存放了JDK各模块的授权文档。</td></tr><tr class="even"><td>lib</td><td>该路径下存放了JDK工具的一些补充JAR包。</td></tr></tbody></table><h3 id="helloworld小案例">1.3 HelloWorld小案例</h3><p>HelloWorld案例是指在计算机屏幕上输出“HelloWorld”这行文字。各种计算机语言都习惯使用该案例作为第一个演示案例。</p><h4 id="java程序开发运行流程">1.3.1 Java程序开发运行流程</h4><p>开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。</p><h4 id="helloworld案例的编写">1.3.2 HelloWorld案例的编写</h4><ol type="1"><li><p>新建文本文档文件，修改名称为HelloWorld.java。</p><p><strong>注意</strong>：后缀名为java的才是java文件。</p></li><li><p>用记事本打开HelloWorld.java文件，输写程序内容。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><p>保存</p></li><li><p>编译文件。编译后会产生一个class文件。</p><p>java文件：程序员自己编写的代码。</p><p>class文件：交给计算机执行的文件。</p></li><li><p>运行代码</p><p><strong>注意</strong>：运行的是编译之后的class文件。</p></li></ol><blockquote><p>用到两个命令：</p><p>javac + 文件名 + 后缀名 （就是编译java文件）</p><p>java + 文件名（运行编译之后的class文件）</p></blockquote><h3 id="helloworld案例常见问题">1.4 HelloWorld案例常见问题</h3><p>1、非法字符问题。Java中的符号都是英文格式的。</p><p>2、大小写问题。Java语言对大小写敏感（区分大小写）。</p><p>3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。</p><p>4、编译命令后的java文件名需要带文件后缀.java</p><p>5、运行命令后的class文件名（类名）不带文件后缀.class</p><h3 id="环境变量">1.5 环境变量</h3><h4 id="为什么配置环境变量">1.5.1 为什么配置环境变量</h4><pre><code class="hljs">开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在bin目录下使用，而我们想要在任意目录下都能使用，所以就要配置环境变量。</code></pre><p>注意：现在从官网上下载的最新版本的JDK安装时会自动配置javac、java命令的路径到Path环境变量中去 ，所以javac、java可以直接使用。</p><h4 id="配置方式">1.5.2 配置方式</h4><p>以前下载的老版本的JDK是没有自动配置的，而且自动配置的也只包含了4个工具而已，所以我们需要删掉已经配置完毕的，再次重新配置Path环境变量。</p><p><img src="/img/01-Java入门/18bc9fbdd5d44dcca776d761afabc52f.png" /></p><p>① <strong>JAVA_HOME</strong>：告诉操作系统JDK安装在了哪个位置</p><p>② <strong>Path</strong>：告诉操作系统JDK提供的javac(编译)、java(执行)命令安装到了哪个位置</p><h3 id="java语言的发展">1.6 Java语言的发展</h3><p>三个版本：</p><ul><li>Java5.0：这是Java的第一个大版本更新。</li><li>Java8.0：这个是目前绝大数公司正在使用的版本。这个版本最为稳定。</li></ul><h3 id="java的三大平台">1.7 Java的三大平台</h3><p>JavaSE、JavaME、JavaEE</p><h4 id="javase">1.7.1 JavaSE</h4><p>是其他两个版本的基础。</p><h4 id="javame">1.7.2 JavaME</h4><p>Java语言的小型版，用于嵌入式消费类电子设备或者小型移动设备的开发。</p><p>其中最为主要的还是小型移动设备的开发（手机）。渐渐的没落了，已经被安卓和IOS给替代了。</p><p>但是，安卓也是可以用Java来开发的。</p><h4 id="javaee">1.7.3 JavaEE</h4><p>用于Web方向的网站开发。（主要从事后台服务器的开发）</p><h3 id="java的主要特性">1.8 Java的主要特性</h3><ul><li>面向对象</li><li>安全性</li><li>多线程</li><li>简单易用</li><li>开源</li><li>跨平台</li></ul><h4 id="java语言跨平台的原理">1.8.1 Java语言跨平台的原理</h4><ul><li>操作系统本身其实是不认识Java语言的。</li><li>但是针对于不同的操作系统，Java提供了不同的虚拟机。</li></ul><p>虚拟机会把Java语言翻译成操作系统能看得懂的语言。</p><p><img src="/img/01-Java入门/a009ce99cf0841e89f9c731e67b07b80.png" /></p><h3 id="jre和jdk">1.9 JRE和JDK</h3><p><img src="/img/01-Java入门/5a5bce2705344fb29c0a39ceaf57573d.png" /></p><p>JVM（Java Virtual Machine) : Java虚拟机</p><p>JRE（Java Runtime Environment) : Java运行环境，包含了JVM和Java的核心类库（Java API）</p><p>JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具</p><p>总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
